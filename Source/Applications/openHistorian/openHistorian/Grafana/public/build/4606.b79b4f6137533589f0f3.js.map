{"version":3,"file":"4606.b79b4f6137533589f0f3.js","mappings":"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","sources":["webpack://grafana/./packages/grafana-ui/src/components/VizTooltip/VizTooltipColorIndicator.tsx","webpack://grafana/./packages/grafana-ui/src/components/VizTooltip/VizTooltipRow.tsx","webpack://grafana/./public/app/core/components/GraphNG/GraphNG.tsx","webpack://grafana/./packages/grafana-data/src/transformations/transformers/nulls/nullToUndefThreshold.ts","webpack://grafana/./public/app/core/components/GraphNG/utils.ts","webpack://grafana/./public/app/core/components/TimelineChart/TimelineChart.tsx","webpack://grafana/./public/app/plugins/panel/state-timeline/StateTimelineTooltip2.tsx"],"sourcesContent":["import { css, cx } from '@emotion/css';\n\nimport { FALLBACK_COLOR, GrafanaTheme2 } from '@grafana/data';\nimport { LineStyle } from '@grafana/schema';\n\nimport { useStyles2 } from '../../themes';\nimport { SeriesIcon } from '../VizLegend/SeriesIcon';\n\nimport { ColorIndicator, DEFAULT_COLOR_INDICATOR } from './types';\nimport { getColorIndicatorClass } from './utils';\n\nexport enum ColorIndicatorPosition {\n  Leading,\n  Trailing,\n}\n\ninterface Props {\n  color?: string;\n  colorIndicator?: ColorIndicator;\n  position?: ColorIndicatorPosition;\n  lineStyle?: LineStyle;\n}\n\nexport type ColorIndicatorStyles = ReturnType<typeof getStyles>;\n\nexport const VizTooltipColorIndicator = ({\n  color = FALLBACK_COLOR,\n  colorIndicator = DEFAULT_COLOR_INDICATOR,\n  position = ColorIndicatorPosition.Leading,\n  lineStyle,\n}: Props) => {\n  const styles = useStyles2(getStyles);\n\n  if (colorIndicator === ColorIndicator.series) {\n    return (\n      <SeriesIcon\n        color={color}\n        lineStyle={lineStyle}\n        className={position === ColorIndicatorPosition.Leading ? styles.leading : styles.trailing}\n      />\n    );\n  }\n\n  return (\n    <span\n      style={{ backgroundColor: color }}\n      className={cx(\n        position === ColorIndicatorPosition.Leading ? styles.leading : styles.trailing,\n        getColorIndicatorClass(colorIndicator, styles)\n      )}\n    />\n  );\n};\n\n// @TODO Update classes/add svgs\nconst getStyles = (theme: GrafanaTheme2) => ({\n  leading: css({\n    marginRight: theme.spacing(0.5),\n  }),\n  trailing: css({\n    marginLeft: theme.spacing(0.5),\n  }),\n  value: css({\n    width: '12px',\n    height: '12px',\n    borderRadius: theme.shape.radius.default,\n    fontWeight: 500,\n    minWidth: '12px',\n  }),\n  hexagon: css({}),\n  pie_1_4: css({}),\n  pie_2_4: css({}),\n  pie_3_4: css({}),\n  marker_sm: css({\n    width: '4px',\n    height: '4px',\n    borderRadius: theme.shape.radius.circle,\n    minWidth: '4px',\n  }),\n  marker_md: css({\n    width: '8px',\n    height: '8px',\n    borderRadius: theme.shape.radius.circle,\n    minWidth: '8px',\n  }),\n  marker_lg: css({\n    width: '12px',\n    height: '12px',\n    borderRadius: theme.shape.radius.circle,\n    minWidth: '12px',\n  }),\n});\n","import { css, cx } from '@emotion/css';\nimport { CSSProperties, ReactNode, useEffect, useRef, useState } from 'react';\nimport * as React from 'react';\n\nimport { GrafanaTheme2 } from '@grafana/data';\n\nimport { useStyles2 } from '../../themes';\nimport { InlineToast } from '../InlineToast/InlineToast';\nimport { Tooltip } from '../Tooltip';\n\nimport { ColorIndicatorPosition, VizTooltipColorIndicator } from './VizTooltipColorIndicator';\nimport { ColorPlacement, VizTooltipItem } from './types';\n\ninterface VizTooltipRowProps extends Omit<VizTooltipItem, 'value'> {\n  value: string | number | null | ReactNode;\n  justify?: string;\n  isActive?: boolean; // for series list\n  marginRight?: string;\n  isPinned: boolean;\n  showValueScroll?: boolean;\n}\n\nenum LabelValueTypes {\n  label = 'label',\n  value = 'value',\n}\n\nconst SUCCESSFULLY_COPIED_TEXT = 'Copied to clipboard';\nconst SHOW_SUCCESS_DURATION = 2 * 1000;\nconst HORIZONTAL_PX_PER_CHAR = 7;\n\nexport const VizTooltipRow = ({\n  label,\n  value,\n  color,\n  colorIndicator,\n  colorPlacement = ColorPlacement.first,\n  justify = 'flex-start',\n  isActive = false,\n  marginRight = '0px',\n  isPinned,\n  lineStyle,\n  showValueScroll,\n}: VizTooltipRowProps) => {\n  const styles = useStyles2(getStyles, justify, marginRight);\n\n  const innerValueScrollStyle: CSSProperties = showValueScroll\n    ? {\n        maxHeight: 55,\n        whiteSpace: 'wrap',\n        wordBreak: 'break-word',\n        overflowY: 'auto',\n      }\n    : {\n        whiteSpace: 'wrap',\n        wordBreak: 'break-word',\n      };\n\n  const [showLabelTooltip, setShowLabelTooltip] = useState(false);\n\n  const [copiedText, setCopiedText] = useState<Record<string, string> | null>(null);\n  const [showCopySuccess, setShowCopySuccess] = useState(false);\n\n  const labelRef = useRef<null | HTMLDivElement>(null);\n  const valueRef = useRef<null | HTMLDivElement>(null);\n\n  useEffect(() => {\n    let timeoutId: ReturnType<typeof setTimeout>;\n\n    if (showCopySuccess) {\n      timeoutId = setTimeout(() => {\n        setShowCopySuccess(false);\n      }, SHOW_SUCCESS_DURATION);\n    }\n\n    return () => {\n      window.clearTimeout(timeoutId);\n    };\n  }, [showCopySuccess]);\n\n  const copyToClipboard = async (text: string, type: LabelValueTypes) => {\n    if (!(navigator?.clipboard && window.isSecureContext)) {\n      fallbackCopyToClipboard(text, type);\n      return;\n    }\n\n    try {\n      await navigator.clipboard.writeText(text);\n      setCopiedText({ [`${type}`]: text });\n      setShowCopySuccess(true);\n    } catch (error) {\n      setCopiedText(null);\n    }\n  };\n\n  const fallbackCopyToClipboard = (text: string, type: LabelValueTypes) => {\n    // Use a fallback method for browsers/contexts that don't support the Clipboard API.\n    const textarea = document.createElement('textarea');\n    labelRef.current?.appendChild(textarea);\n    textarea.value = text;\n    textarea.focus();\n    textarea.select();\n    try {\n      const successful = document.execCommand('copy');\n      if (successful) {\n        setCopiedText({ [`${type}`]: text });\n        setShowCopySuccess(true);\n      }\n    } catch (err) {\n      console.error('Unable to copy to clipboard', err);\n    }\n\n    textarea.remove();\n  };\n\n  const onMouseEnterLabel = (event: React.MouseEvent<HTMLDivElement>) => {\n    if (event.currentTarget.offsetWidth < event.currentTarget.scrollWidth) {\n      setShowLabelTooltip(true);\n    }\n  };\n\n  const onMouseLeaveLabel = () => setShowLabelTooltip(false);\n\n  // if label is > 50% window width, try to put label/value pairs on new lines\n  if (label.length * HORIZONTAL_PX_PER_CHAR > window.innerWidth / 2) {\n    label = label.replaceAll('{', '{\\n  ').replaceAll('}', '\\n}').replaceAll(', ', ',\\n  ');\n  }\n\n  return (\n    <div className={styles.contentWrapper}>\n      {(color || label) && (\n        <div className={styles.valueWrapper}>\n          {color && colorPlacement === ColorPlacement.first && (\n            <VizTooltipColorIndicator color={color} colorIndicator={colorIndicator} lineStyle={lineStyle} />\n          )}\n          {!isPinned ? (\n            <div className={cx(styles.label, isActive && styles.activeSeries)}>{label}</div>\n          ) : (\n            <>\n              <Tooltip content={label} interactive={false} show={showLabelTooltip}>\n                <>\n                  {showCopySuccess && copiedText?.label && (\n                    <InlineToast placement=\"top\" referenceElement={labelRef.current}>\n                      {SUCCESSFULLY_COPIED_TEXT}\n                    </InlineToast>\n                  )}\n                  {/* eslint-disable-next-line jsx-a11y/click-events-have-key-events,jsx-a11y/no-static-element-interactions */}\n                  <div\n                    className={cx(styles.label, isActive && styles.activeSeries, navigator?.clipboard && styles.copy)}\n                    onMouseEnter={onMouseEnterLabel}\n                    onMouseLeave={onMouseLeaveLabel}\n                    onClick={() => copyToClipboard(label, LabelValueTypes.label)}\n                    ref={labelRef}\n                  >\n                    {label}\n                  </div>\n                </>\n              </Tooltip>\n            </>\n          )}\n        </div>\n      )}\n\n      <div className={styles.valueWrapper}>\n        {color && colorPlacement === ColorPlacement.leading && (\n          <VizTooltipColorIndicator\n            color={color}\n            colorIndicator={colorIndicator}\n            position={ColorIndicatorPosition.Leading}\n            lineStyle={lineStyle}\n          />\n        )}\n\n        {!isPinned ? (\n          <div className={cx(styles.value, isActive)} style={innerValueScrollStyle}>\n            {value}\n          </div>\n        ) : (\n          <>\n            {showCopySuccess && copiedText?.value && (\n              <InlineToast placement=\"top\" referenceElement={valueRef.current}>\n                {SUCCESSFULLY_COPIED_TEXT}\n              </InlineToast>\n            )}\n            {/* eslint-disable-next-line jsx-a11y/click-events-have-key-events,jsx-a11y/no-static-element-interactions */}\n            <div\n              className={cx(styles.value, isActive, navigator?.clipboard && styles.copy)}\n              style={innerValueScrollStyle}\n              onClick={() => copyToClipboard(value ? value.toString() : '', LabelValueTypes.value)}\n              ref={valueRef}\n            >\n              {value}\n            </div>\n          </>\n        )}\n\n        {color && colorPlacement === ColorPlacement.trailing && (\n          <VizTooltipColorIndicator\n            color={color}\n            colorIndicator={colorIndicator}\n            position={ColorIndicatorPosition.Trailing}\n            lineStyle={lineStyle}\n          />\n        )}\n      </div>\n    </div>\n  );\n};\n\nconst getStyles = (theme: GrafanaTheme2, justify: string, marginRight: string) => ({\n  contentWrapper: css({\n    display: 'flex',\n    alignItems: 'start',\n    justifyContent: justify,\n    marginRight: marginRight,\n  }),\n  label: css({\n    color: theme.colors.text.secondary,\n    fontWeight: 400,\n    textOverflow: 'ellipsis',\n    overflow: 'hidden',\n    marginRight: theme.spacing(2),\n  }),\n  value: css({\n    fontWeight: 500,\n    textOverflow: 'ellipsis',\n    overflow: 'hidden',\n  }),\n  valueWrapper: css({\n    display: 'flex',\n    alignItems: 'center',\n  }),\n  activeSeries: css({\n    fontWeight: theme.typography.fontWeightBold,\n    color: theme.colors.text.maxContrast,\n  }),\n  copy: css({\n    cursor: 'pointer',\n  }),\n});\n","import { Component } from 'react';\nimport * as React from 'react';\nimport uPlot, { AlignedData } from 'uplot';\n\nimport {\n  DataFrame,\n  DataLinkPostProcessor,\n  Field,\n  FieldMatcherID,\n  fieldMatchers,\n  FieldType,\n  getLinksSupplier,\n  InterpolateFunction,\n  TimeRange,\n  TimeZone,\n} from '@grafana/data';\nimport { DashboardCursorSync, VizLegendOptions } from '@grafana/schema';\nimport { Themeable2, VizLayout } from '@grafana/ui';\nimport { UPlotChart } from '@grafana/ui/src/components/uPlot/Plot';\nimport { AxisProps } from '@grafana/ui/src/components/uPlot/config/UPlotAxisBuilder';\nimport { Renderers, UPlotConfigBuilder } from '@grafana/ui/src/components/uPlot/config/UPlotConfigBuilder';\nimport { ScaleProps } from '@grafana/ui/src/components/uPlot/config/UPlotScaleBuilder';\nimport { pluginLog } from '@grafana/ui/src/components/uPlot/utils';\n\nimport { GraphNGLegendEvent, XYFieldMatchers } from './types';\nimport { preparePlotFrame as defaultPreparePlotFrame } from './utils';\n\n/**\n * @internal -- not a public API\n */\nexport type PropDiffFn<T extends any = any> = (prev: T, next: T) => boolean;\n\nexport interface GraphNGProps extends Themeable2 {\n  frames: DataFrame[];\n  structureRev?: number; // a number that will change when the frames[] structure changes\n  width: number;\n  height: number;\n  timeRange: TimeRange;\n  timeZone: TimeZone[] | TimeZone;\n  legend: VizLegendOptions;\n  fields?: XYFieldMatchers; // default will assume timeseries data\n  renderers?: Renderers;\n  tweakScale?: (opts: ScaleProps, forField: Field) => ScaleProps;\n  tweakAxis?: (opts: AxisProps, forField: Field) => AxisProps;\n  onLegendClick?: (event: GraphNGLegendEvent) => void;\n  children?: (builder: UPlotConfigBuilder, alignedFrame: DataFrame) => React.ReactNode;\n  prepConfig: (alignedFrame: DataFrame, allFrames: DataFrame[], getTimeRange: () => TimeRange) => UPlotConfigBuilder;\n  propsToDiff?: Array<string | PropDiffFn>;\n  preparePlotFrame?: (frames: DataFrame[], dimFields: XYFieldMatchers) => DataFrame | null;\n  renderLegend: (config: UPlotConfigBuilder) => React.ReactElement | null;\n  replaceVariables: InterpolateFunction;\n  dataLinkPostProcessor?: DataLinkPostProcessor;\n  cursorSync?: DashboardCursorSync;\n\n  /**\n   * needed for propsToDiff to re-init the plot & config\n   * this is a generic approach to plot re-init, without having to specify which panel-level options\n   * should cause invalidation. we can drop this in favor of something like panelOptionsRev that gets passed in\n   * similar to structureRev. then we can drop propsToDiff entirely.\n   */\n  options?: Record<string, any>;\n}\n\nfunction sameProps(prevProps: any, nextProps: any, propsToDiff: Array<string | PropDiffFn> = []) {\n  for (const propName of propsToDiff) {\n    if (typeof propName === 'function') {\n      if (!propName(prevProps, nextProps)) {\n        return false;\n      }\n    } else if (nextProps[propName] !== prevProps[propName]) {\n      return false;\n    }\n  }\n\n  return true;\n}\n\n/**\n * @internal -- not a public API\n */\nexport interface GraphNGState {\n  alignedFrame: DataFrame;\n  alignedData?: AlignedData;\n  config?: UPlotConfigBuilder;\n}\n\nconst defaultMatchers = {\n  x: fieldMatchers.get(FieldMatcherID.firstTimeField).get({}),\n  y: fieldMatchers.get(FieldMatcherID.byTypes).get(new Set([FieldType.number, FieldType.enum])),\n};\n\n/**\n * \"Time as X\" core component, expects ascending x\n */\nexport class GraphNG extends Component<GraphNGProps, GraphNGState> {\n  private plotInstance: React.RefObject<uPlot>;\n\n  constructor(props: GraphNGProps) {\n    super(props);\n    let state = this.prepState(props);\n    state.alignedData = state.config!.prepData!([state.alignedFrame]) as AlignedData;\n    this.state = state;\n    this.plotInstance = React.createRef();\n  }\n\n  getTimeRange = () => this.props.timeRange;\n\n  prepState(props: GraphNGProps, withConfig = true) {\n    let state: GraphNGState = null as any;\n\n    const { frames, fields = defaultMatchers, preparePlotFrame, replaceVariables, dataLinkPostProcessor } = props;\n\n    const preparePlotFrameFn = preparePlotFrame ?? defaultPreparePlotFrame;\n\n    const withLinks = frames.some((frame) => frame.fields.some((field) => (field.config.links?.length ?? 0) > 0));\n\n    const alignedFrame = preparePlotFrameFn(\n      frames,\n      {\n        ...fields,\n        // if there are data links, keep all fields during join so they're index-matched\n        y: withLinks ? () => true : fields.y,\n      },\n      props.timeRange\n    );\n\n    pluginLog('GraphNG', false, 'data aligned', alignedFrame);\n\n    if (alignedFrame) {\n      let alignedFrameFinal = alignedFrame;\n\n      if (withLinks) {\n        const timeZone = Array.isArray(this.props.timeZone) ? this.props.timeZone[0] : this.props.timeZone;\n\n        // for links gen we need to use original frames but with the aligned/joined data values\n        let linkFrames = frames.map((frame, frameIdx) => ({\n          ...frame,\n          fields: alignedFrame.fields.filter(\n            (field, fieldIdx) => fieldIdx === 0 || field.state?.origin?.frameIndex === frameIdx\n          ),\n          length: alignedFrame.length,\n        }));\n\n        linkFrames.forEach((linkFrame, frameIndex) => {\n          linkFrame.fields.forEach((field) => {\n            field.getLinks = getLinksSupplier(\n              linkFrame,\n              field,\n              {\n                ...field.state?.scopedVars,\n                __dataContext: {\n                  value: {\n                    data: linkFrames,\n                    field: field,\n                    frame: linkFrame,\n                    frameIndex,\n                  },\n                },\n              },\n              replaceVariables,\n              timeZone,\n              dataLinkPostProcessor\n            );\n          });\n        });\n\n        // filter join field and fields.y\n        alignedFrameFinal = {\n          ...alignedFrame,\n          fields: alignedFrame.fields.filter((field, i) => i === 0 || fields.y(field, alignedFrame, [alignedFrame])),\n        };\n      }\n\n      let config = this.state?.config;\n\n      if (withConfig) {\n        config = props.prepConfig(alignedFrameFinal, this.props.frames, this.getTimeRange);\n        pluginLog('GraphNG', false, 'config prepared', config);\n      }\n\n      state = {\n        alignedFrame: alignedFrameFinal,\n        config,\n      };\n\n      pluginLog('GraphNG', false, 'data prepared', state.alignedData);\n    }\n\n    return state;\n  }\n\n  componentDidUpdate(prevProps: GraphNGProps) {\n    const { frames, structureRev, timeZone, cursorSync, propsToDiff } = this.props;\n\n    const propsChanged = !sameProps(prevProps, this.props, propsToDiff);\n\n    if (\n      frames !== prevProps.frames ||\n      propsChanged ||\n      timeZone !== prevProps.timeZone ||\n      cursorSync !== prevProps.cursorSync\n    ) {\n      let newState = this.prepState(this.props, false);\n\n      if (newState) {\n        const shouldReconfig =\n          this.state.config === undefined ||\n          timeZone !== prevProps.timeZone ||\n          cursorSync !== prevProps.cursorSync ||\n          structureRev !== prevProps.structureRev ||\n          !structureRev ||\n          propsChanged;\n\n        if (shouldReconfig) {\n          newState.config = this.props.prepConfig(newState.alignedFrame, this.props.frames, this.getTimeRange);\n          pluginLog('GraphNG', false, 'config recreated', newState.config);\n        }\n\n        newState.alignedData = newState.config!.prepData!([newState.alignedFrame]) as AlignedData;\n\n        this.setState(newState);\n      }\n    }\n  }\n\n  render() {\n    const { width, height, children, renderLegend } = this.props;\n    const { config, alignedFrame, alignedData } = this.state;\n\n    if (!config) {\n      return null;\n    }\n\n    return (\n      <VizLayout width={width} height={height} legend={renderLegend(config)}>\n        {(vizWidth: number, vizHeight: number) => (\n          <UPlotChart\n            config={config}\n            data={alignedData!}\n            width={vizWidth}\n            height={vizHeight}\n            plotRef={(u) => ((this.plotInstance as React.MutableRefObject<uPlot>).current = u)}\n          >\n            {children ? children(config, alignedFrame) : null}\n          </UPlotChart>\n        )}\n      </VizLayout>\n    );\n  }\n}\n","// mutates all nulls -> undefineds in the fieldValues array for value-less refValues ranges below maxThreshold\n// refValues is typically a time array and maxThreshold is the allowable distance between in time\nexport function nullToUndefThreshold(refValues: number[], fieldValues: unknown[], maxThreshold: number) {\n  let prevRef;\n  let nullIdx;\n\n  for (let i = 0; i < fieldValues.length; i++) {\n    let fieldVal = fieldValues[i];\n\n    if (fieldVal == null) {\n      if (nullIdx == null && prevRef != null) {\n        nullIdx = i;\n      }\n    } else {\n      if (nullIdx != null && prevRef != null) {\n        if (refValues[i] - prevRef < maxThreshold) {\n          while (nullIdx < i) {\n            fieldValues[nullIdx++] = undefined;\n          }\n        }\n\n        nullIdx = null;\n      }\n\n      prevRef = refValues[i];\n    }\n  }\n\n  return fieldValues;\n}\n","import { DataFrame, Field, FieldType, outerJoinDataFrames, TimeRange } from '@grafana/data';\nimport { NULL_EXPAND, NULL_REMOVE, NULL_RETAIN } from '@grafana/data/src/transformations/transformers/joinDataFrames';\nimport { applyNullInsertThreshold } from '@grafana/data/src/transformations/transformers/nulls/nullInsertThreshold';\nimport { nullToUndefThreshold } from '@grafana/data/src/transformations/transformers/nulls/nullToUndefThreshold';\nimport { GraphDrawStyle } from '@grafana/schema';\n\nimport { XYFieldMatchers } from './types';\n\nfunction isVisibleBarField(f: Field) {\n  return (\n    f.type === FieldType.number && f.config.custom?.drawStyle === GraphDrawStyle.Bars && !f.config.custom?.hideFrom?.viz\n  );\n}\n\nexport function getRefField(frame: DataFrame, refFieldName?: string | null) {\n  return frame.fields.find((field) => {\n    // note: getFieldDisplayName() would require full DF[]\n    return refFieldName != null ? field.name === refFieldName : field.type === FieldType.time;\n  });\n}\n\n// will mutate the DataFrame's fields' values\nfunction applySpanNullsThresholds(frame: DataFrame, refFieldName?: string | null) {\n  const refField = getRefField(frame, refFieldName);\n\n  let refValues = refField?.values;\n\n  for (let i = 0; i < frame.fields.length; i++) {\n    let field = frame.fields[i];\n\n    if (field === refField || isVisibleBarField(field)) {\n      continue;\n    }\n\n    let spanNulls = field.config.custom?.spanNulls;\n\n    if (typeof spanNulls === 'number') {\n      if (spanNulls !== -1 && refValues) {\n        field.values = nullToUndefThreshold(refValues, field.values, spanNulls);\n      }\n    }\n  }\n\n  return frame;\n}\n\nexport function preparePlotFrame(frames: DataFrame[], dimFields: XYFieldMatchers, timeRange?: TimeRange | null) {\n  let xField: Field;\n  loop: for (let frame of frames) {\n    for (let field of frame.fields) {\n      if (dimFields.x(field, frame, frames)) {\n        xField = field;\n        break loop;\n      }\n    }\n  }\n\n  // apply null insertions at interval\n  frames = frames.map((frame) => {\n    if (!xField?.state?.nullThresholdApplied) {\n      return applyNullInsertThreshold({\n        frame,\n        refFieldName: xField.name,\n        refFieldPseudoMin: timeRange?.from.valueOf(),\n        refFieldPseudoMax: timeRange?.to.valueOf(),\n      });\n    } else {\n      return frame;\n    }\n  });\n\n  let numBarSeries = frames.reduce(\n    (acc, frame) => acc + frame.fields.reduce((acc, field) => acc + (isVisibleBarField(field) ? 1 : 0), 0),\n    0\n  );\n\n  // to make bar widths of all series uniform (equal to narrowest bar series), find smallest distance between x points\n  let minXDelta = Infinity;\n\n  if (numBarSeries > 1) {\n    frames.forEach((frame) => {\n      if (!frame.fields.some(isVisibleBarField)) {\n        return;\n      }\n\n      const xVals = xField.values;\n\n      for (let i = 0; i < xVals.length; i++) {\n        if (i > 0) {\n          minXDelta = Math.min(minXDelta, xVals[i] - xVals[i - 1]);\n        }\n      }\n    });\n  }\n\n  let alignedFrame = outerJoinDataFrames({\n    frames,\n    joinBy: dimFields.x,\n    keep: dimFields.y,\n    keepOriginIndices: true,\n\n    // the join transformer force-deletes our state.displayName cache unless keepDisplayNames: true\n    // https://github.com/grafana/grafana/pull/31121\n    // https://github.com/grafana/grafana/pull/71806\n    keepDisplayNames: true,\n\n    // prevent minesweeper-expansion of nulls (gaps) when joining bars\n    // since bar width is determined from the minimum distance between non-undefined values\n    // (this strategy will still retain any original pre-join nulls, though)\n    nullMode: (field) => {\n      if (isVisibleBarField(field)) {\n        return NULL_RETAIN;\n      }\n\n      let spanNulls = field.config.custom?.spanNulls;\n      return spanNulls === true ? NULL_REMOVE : spanNulls === -1 ? NULL_RETAIN : NULL_EXPAND;\n    },\n  });\n\n  if (alignedFrame) {\n    alignedFrame = applySpanNullsThresholds(alignedFrame, xField!.name);\n\n    // append 2 null vals at minXDelta to bar series\n    if (minXDelta !== Infinity) {\n      alignedFrame.fields.forEach((f, fi) => {\n        let vals = f.values;\n\n        if (fi === 0) {\n          let lastVal = vals[vals.length - 1];\n          vals.push(lastVal + minXDelta, lastVal + 2 * minXDelta);\n        } else if (isVisibleBarField(f)) {\n          vals.push(null, null);\n        } else {\n          vals.push(undefined, undefined);\n        }\n      });\n\n      alignedFrame.length += 2;\n    }\n\n    return alignedFrame;\n  }\n\n  return null;\n}\n","import { Component } from 'react';\n\nimport { DataFrame, FALLBACK_COLOR, FieldType, TimeRange } from '@grafana/data';\nimport { VisibilityMode, TimelineValueAlignment, TooltipDisplayMode, VizTooltipOptions } from '@grafana/schema';\nimport { UPlotConfigBuilder, VizLayout, VizLegend, VizLegendItem } from '@grafana/ui';\n\nimport { GraphNG, GraphNGProps } from '../GraphNG/GraphNG';\n\nimport { preparePlotConfigBuilder, TimelineMode } from './utils';\n\n/**\n * @alpha\n */\nexport interface TimelineProps extends Omit<GraphNGProps, 'prepConfig' | 'propsToDiff' | 'renderLegend'> {\n  mode: TimelineMode;\n  rowHeight?: number;\n  showValue: VisibilityMode;\n  alignValue?: TimelineValueAlignment;\n  colWidth?: number;\n  legendItems?: VizLegendItem[];\n  tooltip?: VizTooltipOptions;\n  // Whenever `paginationRev` changes, the graph will be fully re-configured/rendered.\n  paginationRev?: string;\n}\n\nconst propsToDiff = ['rowHeight', 'colWidth', 'showValue', 'mergeValues', 'alignValue', 'tooltip', 'paginationRev'];\n\nexport class TimelineChart extends Component<TimelineProps> {\n  getValueColor = (frameIdx: number, fieldIdx: number, value: unknown) => {\n    const field = this.props.frames[frameIdx]?.fields[fieldIdx];\n\n    if (field?.display) {\n      const disp = field.display(value); // will apply color modes\n      if (disp.color) {\n        return disp.color;\n      }\n    }\n\n    return FALLBACK_COLOR;\n  };\n\n  prepConfig = (alignedFrame: DataFrame, allFrames: DataFrame[], getTimeRange: () => TimeRange) => {\n    return preparePlotConfigBuilder({\n      frame: alignedFrame,\n      getTimeRange,\n      allFrames: this.props.frames,\n      ...this.props,\n\n      // Ensure timezones is passed as an array\n      timeZones: Array.isArray(this.props.timeZone) ? this.props.timeZone : [this.props.timeZone],\n\n      // When there is only one row, use the full space\n      rowHeight: alignedFrame.fields.length > 2 ? this.props.rowHeight : 1,\n      getValueColor: this.getValueColor,\n\n      hoverMulti: this.props.tooltip?.mode === TooltipDisplayMode.Multi,\n    });\n  };\n\n  renderLegend = (config: UPlotConfigBuilder) => {\n    const { legend, legendItems } = this.props;\n\n    if (!config || !legendItems || !legend || legend.showLegend === false) {\n      return null;\n    }\n\n    return (\n      <VizLayout.Legend placement={legend.placement}>\n        <VizLegend placement={legend.placement} items={legendItems} displayMode={legend.displayMode} readonly />\n      </VizLayout.Legend>\n    );\n  };\n\n  render() {\n    return (\n      <GraphNG\n        {...this.props}\n        fields={{\n          x: (f) => f.type === FieldType.time,\n          y: (f) =>\n            f.type === FieldType.number ||\n            f.type === FieldType.boolean ||\n            f.type === FieldType.string ||\n            f.type === FieldType.enum,\n        }}\n        prepConfig={this.prepConfig}\n        propsToDiff={propsToDiff}\n        renderLegend={this.renderLegend}\n      />\n    );\n  }\n}\n","import { ReactNode } from 'react';\n\nimport { FieldType, TimeRange } from '@grafana/data';\nimport { SortOrder } from '@grafana/schema/dist/esm/common/common.gen';\nimport { TooltipDisplayMode } from '@grafana/ui';\nimport { VizTooltipContent } from '@grafana/ui/src/components/VizTooltip/VizTooltipContent';\nimport { VizTooltipFooter } from '@grafana/ui/src/components/VizTooltip/VizTooltipFooter';\nimport { VizTooltipHeader } from '@grafana/ui/src/components/VizTooltip/VizTooltipHeader';\nimport { VizTooltipWrapper } from '@grafana/ui/src/components/VizTooltip/VizTooltipWrapper';\nimport { VizTooltipItem } from '@grafana/ui/src/components/VizTooltip/types';\nimport { getContentItems } from '@grafana/ui/src/components/VizTooltip/utils';\nimport { findNextStateIndex, fmtDuration } from 'app/core/components/TimelineChart/utils';\n\nimport { getDataLinks, getFieldActions } from '../status-history/utils';\nimport { TimeSeriesTooltipProps } from '../timeseries/TimeSeriesTooltip';\nimport { isTooltipScrollable } from '../timeseries/utils';\n\ninterface StateTimelineTooltip2Props extends TimeSeriesTooltipProps {\n  timeRange: TimeRange;\n  withDuration: boolean;\n}\n\nexport const StateTimelineTooltip2 = ({\n  series,\n  dataIdxs,\n  seriesIdx,\n  mode = TooltipDisplayMode.Single,\n  sortOrder = SortOrder.None,\n  isPinned,\n  annotate,\n  timeRange,\n  withDuration,\n  maxHeight,\n  replaceVariables,\n}: StateTimelineTooltip2Props) => {\n  const xField = series.fields[0];\n\n  const dataIdx = seriesIdx != null ? dataIdxs[seriesIdx] : dataIdxs.find((idx) => idx != null);\n\n  const xVal = xField.display!(xField.values[dataIdx!]).text;\n\n  mode = isPinned ? TooltipDisplayMode.Single : mode;\n\n  const contentItems = getContentItems(series.fields, xField, dataIdxs, seriesIdx, mode, sortOrder);\n\n  // append duration in single mode\n  if (withDuration && mode === TooltipDisplayMode.Single) {\n    const field = series.fields[seriesIdx!];\n    const nextStateIdx = findNextStateIndex(field, dataIdx!);\n    let nextStateTs;\n    if (nextStateIdx) {\n      nextStateTs = xField.values[nextStateIdx!];\n    }\n\n    const stateTs = xField.values[dataIdx!];\n    let duration: string;\n\n    if (nextStateTs) {\n      duration = nextStateTs && fmtDuration(nextStateTs - stateTs);\n    } else {\n      const to = timeRange.to.valueOf();\n      duration = fmtDuration(to - stateTs);\n    }\n\n    contentItems.push({ label: 'Duration', value: duration });\n  }\n\n  let footer: ReactNode;\n\n  if (isPinned && seriesIdx != null) {\n    const field = series.fields[seriesIdx];\n    const dataIdx = dataIdxs[seriesIdx]!;\n    const links = getDataLinks(field, dataIdx);\n    const actions = getFieldActions(series, field, replaceVariables!, dataIdx);\n\n    footer = <VizTooltipFooter dataLinks={links} annotate={annotate} actions={actions} />;\n  }\n\n  const headerItem: VizTooltipItem = {\n    label: xField.type === FieldType.time ? '' : (xField.state?.displayName ?? xField.name),\n    value: xVal,\n  };\n\n  return (\n    <VizTooltipWrapper>\n      <VizTooltipHeader item={headerItem} isPinned={isPinned} />\n      <VizTooltipContent\n        items={contentItems}\n        isPinned={isPinned}\n        scrollable={isTooltipScrollable({ mode, maxHeight })}\n        maxHeight={maxHeight}\n      />\n      {footer}\n    </VizTooltipWrapper>\n  );\n};\n"],"names":["ColorIndicatorPosition","VizTooltipColorIndicator","color","colorIndicator","position","lineStyle","styles","getStyles","SeriesIcon","theme","LabelValueTypes","SUCCESSFULLY_COPIED_TEXT","SHOW_SUCCESS_DURATION","HORIZONTAL_PX_PER_CHAR","VizTooltipRow","label","value","colorPlacement","justify","isActive","marginRight","isPinned","showValueScroll","innerValueScrollStyle","showLabelTooltip","setShowLabelTooltip","copiedText","setCopiedText","showCopySuccess","setShowCopySuccess","labelRef","valueRef","timeoutId","copyToClipboard","text","type","fallbackCopyToClipboard","textarea","err","onMouseEnterLabel","event","onMouseLeaveLabel","Tooltip","InlineToast","sameProps","prevProps","nextProps","propsToDiff","propName","defaultMatchers","GraphNG","props","state","withConfig","frames","fields","preparePlotFrame","replaceVariables","dataLinkPostProcessor","preparePlotFrameFn","withLinks","frame","field","alignedFrame","alignedFrameFinal","timeZone","linkFrames","frameIdx","fieldIdx","linkFrame","frameIndex","i","config","structureRev","cursorSync","propsChanged","newState","width","height","children","renderLegend","alignedData","vizWidth","vizHeight","u","nullToUndefThreshold","refValues","fieldValues","maxThreshold","prevRef","nullIdx","isVisibleBarField","f","getRefField","refFieldName","applySpanNullsThresholds","refField","spanNulls","dimFields","timeRange","xField","loop","numBarSeries","acc","minXDelta","xVals","fi","vals","lastVal","TimelineChart","disp","allFrames","getTimeRange","legend","legendItems","StateTimelineTooltip2","series","dataIdxs","seriesIdx","mode","sortOrder","annotate","withDuration","maxHeight","dataIdx","idx","xVal","contentItems","nextStateIdx","nextStateTs","stateTs","duration","to","footer","links","actions","headerItem"],"sourceRoot":""}