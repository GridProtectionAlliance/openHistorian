{"version":3,"sources":["webpack:///./public/app/plugins/datasource/elasticsearch/language_provider.ts","webpack:///./public/app/plugins/datasource/elasticsearch/query_def.ts","webpack:///./public/app/plugins/datasource/elasticsearch/elastic_response.ts","webpack:///./public/app/plugins/datasource/elasticsearch/index_pattern.ts","webpack:///./public/app/plugins/datasource/elasticsearch/query_builder.ts","webpack:///./public/app/plugins/datasource/elasticsearch/datasource.ts","webpack:///./public/app/plugins/datasource/elasticsearch/bucket_agg.ts","webpack:///./public/app/plugins/datasource/elasticsearch/metric_agg.ts","webpack:///./public/app/plugins/datasource/elasticsearch/pipeline_variables.ts","webpack:///./public/app/plugins/datasource/elasticsearch/query_ctrl.ts","webpack:///./public/app/plugins/datasource/elasticsearch/configuration/ElasticDetails.tsx","webpack:///./public/app/plugins/datasource/elasticsearch/configuration/LogsConfig.tsx","webpack:///./public/app/plugins/datasource/elasticsearch/configuration/DataLink.tsx","webpack:///./public/app/plugins/datasource/elasticsearch/configuration/DataLinks.tsx","webpack:///./public/app/plugins/datasource/elasticsearch/module.ts","webpack:///./public/app/plugins/datasource/elasticsearch/configuration/ConfigEditor.tsx","webpack:///./public/app/core/components/Select/DataSourcePicker.tsx","webpack:///./public/app/plugins/datasource/prometheus/promql.ts"],"names":["ElasticsearchLanguageProvider","datasource","initialValues","Object","assign","queries","datasourceType","map","query","isLogsQuery","prometheusLabels","elasticsearchLuceneLabels","keyOperatorValue","push","substring","length","join","getElasticsearchQuery","promQuery","labels","tokens","Prism","tokenize","grammar","nameLabelValue","prop","getNameLabelValue","Token","token","type","labelKey","labelValue","labelOperator","contentTokens","content","currentToken","currentStr","extractPrometheusLabels","expr","refId","LanguageProvider","metricAggTypes","text","value","requiresField","supportsInlineScript","supportsMissing","isPipelineAgg","minVersion","supportsMultipleBucketPaths","bucketAggTypes","orderByOptions","orderOptions","sizeOptions","extendedStats","intervalOptions","movingAvgModelOptions","pipelineOptions","moving_avg","default","undefined","derivative","cumulative_sum","bucket_script","movingAvgModelSettings","simple","linear","ewma","holt","holt_winters","isCheckbox","getMetricAggTypes","esVersion","_","filter","f","metricType","po","isPipelineAggWithMultipleBucketPaths","find","t","getAncestors","target","metric","metrics","id","initialAncestors","reduce","acc","includedInField","field","includes","includedInVariables","pipelineVariables","some","pv","pipelineAgg","getMovingAvgSettings","model","filtered","filteredResult","each","setting","describeMetric","def","findMetricById","hasMetricOfType","m","ElasticResponse","targets","response","processResponseToSeries","seriesList","i","responses","error","getErrorFromElasticResponse","hits","processHits","aggregations","tmpSeriesList","table","TableModel","processBuckets","trimDatapoints","nameSeries","y","rows","data","this","esAgg","props","bucket","newSeries","hide","datapoints","buckets","doc_count","key","percentiles","values","percentileName","statName","meta","stats","std_deviation_bounds_upper","std_deviation_bounds","upper","std_deviation_bounds_lower","lower","metricId","normalized_value","aggDef","columns","keys","propKey","addColumn","filterable","addMetricValue","metricName","isArray","propValues","getMetricName","settings","script","aggs","depth","aggId","maxDepth","bucketAggs","processMetrics","processAggregationDocs","nameIndex","clone","key_as_string","metricDef","queryDef","series","metricTypeCount","alias","replace","match","g1","g2","group","indexOf","agg","appliedAgg","name","propName","trim","uniq","getSeriesName","hit","doc","hitsTotal","total","_id","_type","_index","_source","fields","histogram","trimEdges","points","slice","err","result","JSON","stringify","root_cause","reason","message","$$config","config","processResponseToDataFrames","logMessageField","logLevelField","isLogsRequest","dataFrame","n","flattenHits","propNames","docs","createEmptyDataFrame","timeField","add","addPreferredVisualisationType","toDataFrame","flattened","flatten","sort","MutableDataFrame","addField","FieldType","time","string","parse","v","fieldNames","s","preferredVisualisationType","intervalMap","Hourly","startOf","amount","Daily","Weekly","Monthly","Yearly","IndexPattern","pattern","interval","dateLocale","toUtc","locale","format","from","to","intervalInfo","start","dateTime","utc","endEpoch","valueOf","indexList","ElasticQueryBuilder","options","gte","lte","queryNode","metricRef","terms","size","parseInt","orderBy","order","isNaN","min_doc_count","missing","extended_bounds","min","max","offset","filterObj","filters","label","query_string","analyze_wildcard","unmapped_type","script_fields","adhocFilters","condition","queryCondition","operator","bool","must","match_phrase","must_not","lt","range","gt","regexp","queryString","j","nestedAggs","getRangeFilter","addAdhocFilters","documentQuery","getDateHistogramAgg","getHistogramAgg","getFiltersAgg","buildTermsAgg","precision","aggField","metricAgg","buckets_path","test","hasOwnProperty","keyname","querystring","build","ELASTIC_META_FIELDS","ElasticDatasource","instanceSettings","templateSrv","getTemplateSrv","timeSrv","getTimeSrv","basicAuth","withCredentials","url","index","database","settingsData","jsonData","indexPattern","timeInterval","maxConcurrentShardRequests","queryBuilder","dataLinks","languageProvider","method","headers","Authorization","getBackendSrv","datasourceRequest","catch","originMeta","importQueries","timeRange","getIndexList","requestAllIndices","then","results","request","getIndexForToday","maxTraversals","listLen","Math","status","annotation","timeEndField","tagsField","textField","dateRanges","rangeStart","rangeEnd","should","minimum_should_match","header","search_type","ignore_unavailable","payload","angular","toJson","post","res","list","getFieldFromSource","source","fieldName","split","fieldValue","console","log","isString","isNumber","event","tags","timeEnd","titleField","title","scopedVars","expandedQueries","getFields","dateFields","searchType","timeFrom","timeTo","queryHeader","cloneDeep","sentTargets","getAdhocFilters","queryObj","getLogsQuery","esQuery","getQueryHeader","Promise","resolve","toString","getMultiSearchUrl","er","getLogs","enhanceDataFrame","getTimeSeries","configuredEsVersion","get","typeMap","float","double","integer","long","date","date_nanos","scaled_float","nested","shouldAddField","obj","isMetadataField","fieldNameParts","getFieldsRecursively","subObj","isObject","properties","concat","pop","indexName","mappings","typeName","getTermsQuery","fromJson","getTerms","variableExists","bucketAgg","objectContainsTemplate","isPrimitive","Array","item","DataSourceApi","link","dataLinkConfig","dataLink","datasourceUid","internal","links","ElasticBucketAggCtrl","$scope","uiSegmentSrv","$rootScope","getBucketAggTypes","getOrderOptions","getSizeOptions","onAppEvent","CoreEvents","elasticQueryUpdated","validateModel","init","onChangeInternal","onChange","onTypeChanged","showOptions","isFirst","bucketAggCount","settingsLinkText","memo","substr","defaultTo","addFiltersQuery","removeFiltersQuery","without","toggleOptions","getOrderByOptions","metricRefs","getFieldsInternal","$fieldType","getIntervalOptions","transformToSegments","addBucketAgg","lastBucket","addIndex","val","splice","fake","removeBucketAgg","createDefaultMetric","coreModule","directive","templateUrl","controller","restrict","scope","ElasticMetricAggCtrl","metricAggs","pipelineAggOptions","modelSettingsValues","updatePipelineAggOptions","ancestors","isSingle","variablesLinkText","RegExp","opt","precisionThreshold","precision_threshold","percents","movingAvgModelTypes","modelSettings","updateMovingAvgModelSettings","inlineScript","inline","toggleVariables","showVariables","modelSettingsKeys","onChangeClearInternal","minimize","onTypeChange","addMetricAgg","removeMetricAgg","metricBeingRemoved","metricsToRemove","newMetricAggs","toggleShowMetric","newVariable","ElasticPipelineVariablesCtrl","variables","remove","ElasticQueryCtrl","$injector","refresh","queryUpdated","jsonStr","metricFindQuery","handleQueryError","bind","newJsonTargetMetrics","newJsonRawQuery","rawQueryOld","targetMetricsOld","appEvent","QueryCtrl","Select","LegacyForms","Input","FormField","indexPatternTypes","example","esVersions","ElasticDetails","className","labelWidth","inputWidth","changeHandler","placeholder","required","inputEl","intervalHandler","jsonDataChangeHandler","option","version","defaultMaxConcurrentShardRequests","getMaxConcurrenShardRequestOrDefault","aria-label","validationEvents","EventsWithValidation","onBlur","regexValidation","tooltip","currentTarget","newInterval","startsWith","newDatabase","LogsConfig","Switch","getStyles","stylesFactory","firstRow","css","nameField","regexField","row","DataLink","onDelete","suggestions","styles","useState","showInternalLink","setShowInternalLink","previousUid","usePrevious","useEffect","useInternalLink","variant","icon","onClick","preventDefault","newValue","checked","DataSourceSection","datasources","getDatasourceSrv","getExternal","ds","tracing","uid","selectedDatasource","d","DataSourcePicker","current","theme","infoText","spacing","md","colors","textWeak","sm","DataLinks","useTheme","newField","newDataLinks","DataLinkBuiltInVars","valueRaw","documentation","origin","VariableOrigin","Value","ElasticAnnotationsQueryCtrl","plugin","DataSourcePlugin","setQueryCtrl","setConfigEditor","onOptionsChange","defaultUrl","dataSourceConfig","showAccessOptions","sigV4AuthToggleEnabled","sigV4AuthEnabled","setAnnotationQueryCtrl","autoFocus","hideTextValue","openMenuOnFocus","showLoading","invalid","imgUrl","info","logos","small","loading","hideText","selectors","components","container","isMulti","isClearable","backspaceRemovesValue","maxMenuHeight","menuPlacement","noOptionsMessage","getOptionLabel","o","isUnsignedPluginSignature","signature","align","justify","PureComponent","defaultProps","RATE_RANGES","sortText","FUNCTIONS","insertText","detail","tokenizer","comment","lookbehind","inside","punctuation","greedy","function","number"],"mappings":"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","file":"elasticsearchPlugin.591ee81e63053ad31983.js","sourcesContent":["import { ElasticsearchQuery } from './types';\nimport { DataQuery, LanguageProvider } from '@grafana/data';\n\nimport { ElasticDatasource } from './datasource';\n\nimport { PromQuery } from '../prometheus/types';\n\nimport Prism, { Token } from 'prismjs';\nimport grammar from '../prometheus/promql';\n\nfunction getNameLabelValue(promQuery: string, tokens: any): string {\n  let nameLabelValue = '';\n  for (let prop in tokens) {\n    if (typeof tokens[prop] === 'string') {\n      nameLabelValue = tokens[prop] as string;\n      break;\n    }\n  }\n  return nameLabelValue;\n}\n\nfunction extractPrometheusLabels(promQuery: string): string[][] {\n  const labels: string[][] = [];\n  if (!promQuery || promQuery.length === 0) {\n    return labels;\n  }\n  const tokens = Prism.tokenize(promQuery, grammar);\n  const nameLabelValue = getNameLabelValue(promQuery, tokens);\n  if (nameLabelValue && nameLabelValue.length > 0) {\n    labels.push(['__name__', '=', '\"' + nameLabelValue + '\"']);\n  }\n\n  for (let prop in tokens) {\n    if (tokens[prop] instanceof Token) {\n      let token: Token = tokens[prop] as Token;\n      if (token.type === 'context-labels') {\n        let labelKey = '';\n        let labelValue = '';\n        let labelOperator = '';\n        let contentTokens: any[] = token.content as any[];\n        for (let currentToken in contentTokens) {\n          if (typeof contentTokens[currentToken] === 'string') {\n            let currentStr: string;\n            currentStr = contentTokens[currentToken] as string;\n            if (currentStr === '=' || currentStr === '!=' || currentStr === '=~' || currentStr === '!~') {\n              labelOperator = currentStr;\n            }\n          } else if (contentTokens[currentToken] instanceof Token) {\n            switch (contentTokens[currentToken].type) {\n              case 'label-key':\n                labelKey = contentTokens[currentToken].content as string;\n                break;\n              case 'label-value':\n                labelValue = contentTokens[currentToken].content as string;\n                labels.push([labelKey, labelOperator, labelValue]);\n                break;\n            }\n          }\n        }\n      }\n    }\n  }\n  return labels;\n}\n\nfunction getElasticsearchQuery(prometheusLabels: string[][]): string {\n  let elasticsearchLuceneLabels = [];\n  for (let keyOperatorValue of prometheusLabels) {\n    switch (keyOperatorValue[1]) {\n      case '=': {\n        elasticsearchLuceneLabels.push(keyOperatorValue[0] + ':' + keyOperatorValue[2]);\n        break;\n      }\n      case '!=': {\n        elasticsearchLuceneLabels.push('NOT ' + keyOperatorValue[0] + ':' + keyOperatorValue[2]);\n        break;\n      }\n      case '=~': {\n        elasticsearchLuceneLabels.push(\n          keyOperatorValue[0] + ':/' + keyOperatorValue[2].substring(1, keyOperatorValue[2].length - 1) + '/'\n        );\n        break;\n      }\n      case '!~': {\n        elasticsearchLuceneLabels.push(\n          'NOT ' + keyOperatorValue[0] + ':/' + keyOperatorValue[2].substring(1, keyOperatorValue[2].length - 1) + '/'\n        );\n        break;\n      }\n    }\n  }\n  return elasticsearchLuceneLabels.join(' AND ');\n}\n\nexport default class ElasticsearchLanguageProvider extends LanguageProvider {\n  request: (url: string, params?: any) => Promise<any>;\n  start: () => Promise<any[]>;\n  datasource: ElasticDatasource;\n\n  constructor(datasource: ElasticDatasource, initialValues?: any) {\n    super();\n    this.datasource = datasource;\n\n    Object.assign(this, initialValues);\n  }\n\n  importQueries(queries: DataQuery[], datasourceType: string): ElasticsearchQuery[] {\n    if (datasourceType === 'prometheus' || datasourceType === 'loki') {\n      return queries.map(query => {\n        let prometheusQuery: PromQuery = query as PromQuery;\n        const expr = getElasticsearchQuery(extractPrometheusLabels(prometheusQuery.expr));\n        return {\n          isLogsQuery: true,\n          query: expr,\n          refId: query.refId,\n        };\n      });\n    }\n    return queries.map(query => {\n      return {\n        isLogsQuery: true,\n        query: '',\n        refId: query.refId,\n      };\n    });\n  }\n}\n","import _ from 'lodash';\nimport { ElasticsearchAggregation, ElasticsearchQuery } from './types';\n\nexport const metricAggTypes = [\n  { text: 'Count', value: 'count', requiresField: false },\n  {\n    text: 'Average',\n    value: 'avg',\n    requiresField: true,\n    supportsInlineScript: true,\n    supportsMissing: true,\n  },\n  {\n    text: 'Sum',\n    value: 'sum',\n    requiresField: true,\n    supportsInlineScript: true,\n    supportsMissing: true,\n  },\n  {\n    text: 'Max',\n    value: 'max',\n    requiresField: true,\n    supportsInlineScript: true,\n    supportsMissing: true,\n  },\n  {\n    text: 'Min',\n    value: 'min',\n    requiresField: true,\n    supportsInlineScript: true,\n    supportsMissing: true,\n  },\n  {\n    text: 'Extended Stats',\n    value: 'extended_stats',\n    requiresField: true,\n    supportsMissing: true,\n    supportsInlineScript: true,\n  },\n  {\n    text: 'Percentiles',\n    value: 'percentiles',\n    requiresField: true,\n    supportsMissing: true,\n    supportsInlineScript: true,\n  },\n  {\n    text: 'Unique Count',\n    value: 'cardinality',\n    requiresField: true,\n    supportsMissing: true,\n  },\n  {\n    text: 'Moving Average',\n    value: 'moving_avg',\n    requiresField: false,\n    isPipelineAgg: true,\n    minVersion: 2,\n  },\n  {\n    text: 'Derivative',\n    value: 'derivative',\n    requiresField: false,\n    isPipelineAgg: true,\n    minVersion: 2,\n  },\n  {\n    text: 'Cumulative Sum',\n    value: 'cumulative_sum',\n    requiresField: false,\n    isPipelineAgg: true,\n    minVersion: 2,\n  },\n  {\n    text: 'Bucket Script',\n    value: 'bucket_script',\n    requiresField: false,\n    isPipelineAgg: true,\n    supportsMultipleBucketPaths: true,\n    minVersion: 2,\n  },\n  { text: 'Raw Document (legacy)', value: 'raw_document', requiresField: false },\n  { text: 'Raw Data', value: 'raw_data', requiresField: false },\n  { text: 'Logs', value: 'logs', requiresField: false },\n];\n\nexport const bucketAggTypes = [\n  { text: 'Terms', value: 'terms', requiresField: true },\n  { text: 'Filters', value: 'filters' },\n  { text: 'Geo Hash Grid', value: 'geohash_grid', requiresField: true },\n  { text: 'Date Histogram', value: 'date_histogram', requiresField: true },\n  { text: 'Histogram', value: 'histogram', requiresField: true },\n];\n\nexport const orderByOptions = [\n  { text: 'Doc Count', value: '_count' },\n  { text: 'Term value', value: '_term' },\n];\n\nexport const orderOptions = [\n  { text: 'Top', value: 'desc' },\n  { text: 'Bottom', value: 'asc' },\n];\n\nexport const sizeOptions = [\n  { text: 'No limit', value: '0' },\n  { text: '1', value: '1' },\n  { text: '2', value: '2' },\n  { text: '3', value: '3' },\n  { text: '5', value: '5' },\n  { text: '10', value: '10' },\n  { text: '15', value: '15' },\n  { text: '20', value: '20' },\n];\n\nexport const extendedStats = [\n  { text: 'Avg', value: 'avg' },\n  { text: 'Min', value: 'min' },\n  { text: 'Max', value: 'max' },\n  { text: 'Sum', value: 'sum' },\n  { text: 'Count', value: 'count' },\n  { text: 'Std Dev', value: 'std_deviation' },\n  { text: 'Std Dev Upper', value: 'std_deviation_bounds_upper' },\n  { text: 'Std Dev Lower', value: 'std_deviation_bounds_lower' },\n];\n\nexport const intervalOptions = [\n  { text: 'auto', value: 'auto' },\n  { text: '10s', value: '10s' },\n  { text: '1m', value: '1m' },\n  { text: '5m', value: '5m' },\n  { text: '10m', value: '10m' },\n  { text: '20m', value: '20m' },\n  { text: '1h', value: '1h' },\n  { text: '1d', value: '1d' },\n];\n\nexport const movingAvgModelOptions = [\n  { text: 'Simple', value: 'simple' },\n  { text: 'Linear', value: 'linear' },\n  { text: 'Exponentially Weighted', value: 'ewma' },\n  { text: 'Holt Linear', value: 'holt' },\n  { text: 'Holt Winters', value: 'holt_winters' },\n];\n\nexport const pipelineOptions: any = {\n  moving_avg: [\n    { text: 'window', default: 5 },\n    { text: 'model', default: 'simple' },\n    { text: 'predict', default: undefined },\n    { text: 'minimize', default: false },\n  ],\n  derivative: [{ text: 'unit', default: undefined }],\n  cumulative_sum: [{ text: 'format', default: undefined }],\n  bucket_script: [],\n};\n\nexport const movingAvgModelSettings: any = {\n  simple: [],\n  linear: [],\n  ewma: [{ text: 'Alpha', value: 'alpha', default: undefined }],\n  holt: [\n    { text: 'Alpha', value: 'alpha', default: undefined },\n    { text: 'Beta', value: 'beta', default: undefined },\n  ],\n  holt_winters: [\n    { text: 'Alpha', value: 'alpha', default: undefined },\n    { text: 'Beta', value: 'beta', default: undefined },\n    { text: 'Gamma', value: 'gamma', default: undefined },\n    { text: 'Period', value: 'period', default: undefined },\n    { text: 'Pad', value: 'pad', default: undefined, isCheckbox: true },\n  ],\n};\n\nexport function getMetricAggTypes(esVersion: any) {\n  return _.filter(metricAggTypes, f => {\n    if (f.minVersion) {\n      return f.minVersion <= esVersion;\n    } else {\n      return true;\n    }\n  });\n}\n\nexport function getPipelineOptions(metric: any) {\n  if (!isPipelineAgg(metric.type)) {\n    return [];\n  }\n\n  return pipelineOptions[metric.type];\n}\n\nexport function isPipelineAgg(metricType: any) {\n  if (metricType) {\n    const po = pipelineOptions[metricType];\n    return po !== null && po !== undefined;\n  }\n\n  return false;\n}\n\nexport function isPipelineAggWithMultipleBucketPaths(metricType: any) {\n  if (metricType) {\n    return metricAggTypes.find(t => t.value === metricType && t.supportsMultipleBucketPaths) !== undefined;\n  }\n\n  return false;\n}\n\nexport function getAncestors(target: ElasticsearchQuery, metric?: ElasticsearchAggregation) {\n  const { metrics } = target;\n  if (!metrics) {\n    return (metric && [metric.id]) || [];\n  }\n  const initialAncestors = metric != null ? [metric.id] : ([] as string[]);\n  return metrics.reduce((acc: string[], metric: ElasticsearchAggregation) => {\n    const includedInField = (metric.field && acc.includes(metric.field)) || false;\n    const includedInVariables = metric.pipelineVariables?.some(pv => acc.includes(pv?.pipelineAgg ?? ''));\n    return includedInField || includedInVariables ? [...acc, metric.id] : acc;\n  }, initialAncestors);\n}\n\nexport function getPipelineAggOptions(target: ElasticsearchQuery, metric?: ElasticsearchAggregation) {\n  const { metrics } = target;\n  if (!metrics) {\n    return [];\n  }\n  const ancestors = getAncestors(target, metric);\n  return metrics.filter(m => !ancestors.includes(m.id)).map(m => ({ text: describeMetric(m), value: m.id }));\n}\n\nexport function getMovingAvgSettings(model: any, filtered: boolean) {\n  const filteredResult: any[] = [];\n  if (filtered) {\n    _.each(movingAvgModelSettings[model], setting => {\n      if (!setting.isCheckbox) {\n        filteredResult.push(setting);\n      }\n    });\n    return filteredResult;\n  }\n  return movingAvgModelSettings[model];\n}\n\nexport function getOrderByOptions(target: any) {\n  const metricRefs: any[] = [];\n  _.each(target.metrics, metric => {\n    if (metric.type !== 'count' && !isPipelineAgg(metric.type)) {\n      metricRefs.push({ text: describeMetric(metric), value: metric.id });\n    }\n  });\n\n  return orderByOptions.concat(metricRefs);\n}\n\nexport function describeOrder(order: string) {\n  const def: any = _.find(orderOptions, { value: order });\n  return def.text;\n}\n\nexport function describeMetric(metric: ElasticsearchAggregation) {\n  const def: any = _.find(metricAggTypes, { value: metric.type });\n  if (!def.requiresField && !isPipelineAgg(metric.type)) {\n    return def.text;\n  }\n  return def.text + ' ' + metric.field;\n}\n\nexport function describeOrderBy(orderBy: any, target: any) {\n  const def: any = _.find(orderByOptions, { value: orderBy });\n  if (def) {\n    return def.text;\n  }\n  const metric: any = _.find(target.metrics, { id: orderBy });\n  if (metric) {\n    return describeMetric(metric);\n  } else {\n    return 'metric not found';\n  }\n}\n\nexport function defaultMetricAgg() {\n  return { type: 'count', id: '1' };\n}\n\nexport function defaultBucketAgg() {\n  return { type: 'date_histogram', id: '2', settings: { interval: 'auto' } };\n}\n\nexport const findMetricById = (metrics: any[], id: any) => {\n  return _.find(metrics, { id: id });\n};\n\nexport function hasMetricOfType(target: any, type: string): boolean {\n  return target && target.metrics && target.metrics.some((m: any) => m.type === type);\n}\n","import _ from 'lodash';\nimport flatten from 'app/core/utils/flatten';\nimport * as queryDef from './query_def';\nimport TableModel from 'app/core/table_model';\nimport {\n  DataQueryResponse,\n  DataFrame,\n  toDataFrame,\n  FieldType,\n  MutableDataFrame,\n  PreferredVisualisationType,\n} from '@grafana/data';\nimport { ElasticsearchAggregation } from './types';\n\nexport class ElasticResponse {\n  constructor(private targets: any, private response: any) {\n    this.targets = targets;\n    this.response = response;\n  }\n\n  processMetrics(esAgg: any, target: any, seriesList: any, props: any) {\n    let metric, y, i, bucket, value;\n    let newSeries: any;\n\n    for (y = 0; y < target.metrics.length; y++) {\n      metric = target.metrics[y];\n      if (metric.hide) {\n        continue;\n      }\n\n      switch (metric.type) {\n        case 'count': {\n          newSeries = { datapoints: [], metric: 'count', props: props, refId: target.refId };\n          for (i = 0; i < esAgg.buckets.length; i++) {\n            bucket = esAgg.buckets[i];\n            value = bucket.doc_count;\n            newSeries.datapoints.push([value, bucket.key]);\n          }\n          seriesList.push(newSeries);\n          break;\n        }\n        case 'percentiles': {\n          if (esAgg.buckets.length === 0) {\n            break;\n          }\n\n          const firstBucket = esAgg.buckets[0];\n          const percentiles = firstBucket[metric.id].values;\n\n          for (const percentileName in percentiles) {\n            newSeries = {\n              datapoints: [],\n              metric: 'p' + percentileName,\n              props: props,\n              field: metric.field,\n              refId: target.refId,\n            };\n\n            for (i = 0; i < esAgg.buckets.length; i++) {\n              bucket = esAgg.buckets[i];\n              const values = bucket[metric.id].values;\n              newSeries.datapoints.push([values[percentileName], bucket.key]);\n            }\n            seriesList.push(newSeries);\n          }\n\n          break;\n        }\n        case 'extended_stats': {\n          for (const statName in metric.meta) {\n            if (!metric.meta[statName]) {\n              continue;\n            }\n\n            newSeries = {\n              datapoints: [],\n              metric: statName,\n              props: props,\n              field: metric.field,\n              refId: target.refId,\n            };\n\n            for (i = 0; i < esAgg.buckets.length; i++) {\n              bucket = esAgg.buckets[i];\n              const stats = bucket[metric.id];\n\n              // add stats that are in nested obj to top level obj\n              stats.std_deviation_bounds_upper = stats.std_deviation_bounds.upper;\n              stats.std_deviation_bounds_lower = stats.std_deviation_bounds.lower;\n\n              newSeries.datapoints.push([stats[statName], bucket.key]);\n            }\n\n            seriesList.push(newSeries);\n          }\n\n          break;\n        }\n        default: {\n          newSeries = {\n            datapoints: [],\n            metric: metric.type,\n            field: metric.field,\n            metricId: metric.id,\n            props: props,\n            refId: target.refId,\n          };\n          for (i = 0; i < esAgg.buckets.length; i++) {\n            bucket = esAgg.buckets[i];\n\n            value = bucket[metric.id];\n            if (value !== undefined) {\n              if (value.normalized_value) {\n                newSeries.datapoints.push([value.normalized_value, bucket.key]);\n              } else {\n                newSeries.datapoints.push([value.value, bucket.key]);\n              }\n            }\n          }\n          seriesList.push(newSeries);\n          break;\n        }\n      }\n    }\n  }\n\n  processAggregationDocs(esAgg: any, aggDef: ElasticsearchAggregation, target: any, table: any, props: any) {\n    // add columns\n    if (table.columns.length === 0) {\n      for (const propKey of _.keys(props)) {\n        table.addColumn({ text: propKey, filterable: true });\n      }\n      table.addColumn({ text: aggDef.field, filterable: true });\n    }\n\n    // helper func to add values to value array\n    const addMetricValue = (values: any[], metricName: string, value: any) => {\n      table.addColumn({ text: metricName });\n      values.push(value);\n    };\n    const buckets = _.isArray(esAgg.buckets) ? esAgg.buckets : [esAgg.buckets];\n    for (const bucket of buckets) {\n      const values = [];\n\n      for (const propValues of _.values(props)) {\n        values.push(propValues);\n      }\n\n      // add bucket key (value)\n      values.push(bucket.key);\n\n      for (const metric of target.metrics) {\n        switch (metric.type) {\n          case 'count': {\n            addMetricValue(values, this.getMetricName(metric.type), bucket.doc_count);\n            break;\n          }\n          case 'extended_stats': {\n            for (const statName in metric.meta) {\n              if (!metric.meta[statName]) {\n                continue;\n              }\n\n              const stats = bucket[metric.id];\n              // add stats that are in nested obj to top level obj\n              stats.std_deviation_bounds_upper = stats.std_deviation_bounds.upper;\n              stats.std_deviation_bounds_lower = stats.std_deviation_bounds.lower;\n\n              addMetricValue(values, this.getMetricName(statName), stats[statName]);\n            }\n            break;\n          }\n          case 'percentiles': {\n            const percentiles = bucket[metric.id].values;\n\n            for (const percentileName in percentiles) {\n              addMetricValue(values, `p${percentileName} ${metric.field}`, percentiles[percentileName]);\n            }\n            break;\n          }\n          default: {\n            let metricName = this.getMetricName(metric.type);\n            const otherMetrics = _.filter(target.metrics, { type: metric.type });\n\n            // if more of the same metric type include field field name in property\n            if (otherMetrics.length > 1) {\n              metricName += ' ' + metric.field;\n              if (metric.type === 'bucket_script') {\n                //Use the formula in the column name\n                metricName = metric.settings.script;\n              }\n            }\n\n            addMetricValue(values, metricName, bucket[metric.id].value);\n            break;\n          }\n        }\n      }\n\n      table.rows.push(values);\n    }\n  }\n\n  // This is quite complex\n  // need to recurse down the nested buckets to build series\n  processBuckets(aggs: any, target: any, seriesList: any, table: TableModel, props: any, depth: any) {\n    let bucket, aggDef: any, esAgg, aggId;\n    const maxDepth = target.bucketAggs.length - 1;\n\n    for (aggId in aggs) {\n      aggDef = _.find(target.bucketAggs, { id: aggId });\n      esAgg = aggs[aggId];\n\n      if (!aggDef) {\n        continue;\n      }\n\n      if (depth === maxDepth) {\n        if (aggDef.type === 'date_histogram') {\n          this.processMetrics(esAgg, target, seriesList, props);\n        } else {\n          this.processAggregationDocs(esAgg, aggDef, target, table, props);\n        }\n      } else {\n        for (const nameIndex in esAgg.buckets) {\n          bucket = esAgg.buckets[nameIndex];\n          props = _.clone(props);\n          if (bucket.key !== void 0) {\n            props[aggDef.field] = bucket.key;\n          } else {\n            props['filter'] = nameIndex;\n          }\n          if (bucket.key_as_string) {\n            props[aggDef.field] = bucket.key_as_string;\n          }\n          this.processBuckets(bucket, target, seriesList, table, props, depth + 1);\n        }\n      }\n    }\n  }\n\n  private getMetricName(metric: any) {\n    let metricDef: any = _.find(queryDef.metricAggTypes, { value: metric });\n    if (!metricDef) {\n      metricDef = _.find(queryDef.extendedStats, { value: metric });\n    }\n\n    return metricDef ? metricDef.text : metric;\n  }\n\n  private getSeriesName(series: any, target: any, metricTypeCount: any) {\n    let metricName = this.getMetricName(series.metric);\n\n    if (target.alias) {\n      const regex = /\\{\\{([\\s\\S]+?)\\}\\}/g;\n\n      return target.alias.replace(regex, (match: any, g1: any, g2: any) => {\n        const group = g1 || g2;\n\n        if (group.indexOf('term ') === 0) {\n          return series.props[group.substring(5)];\n        }\n        if (series.props[group] !== void 0) {\n          return series.props[group];\n        }\n        if (group === 'metric') {\n          return metricName;\n        }\n        if (group === 'field') {\n          return series.field || '';\n        }\n\n        return match;\n      });\n    }\n\n    if (series.field && queryDef.isPipelineAgg(series.metric)) {\n      if (series.metric && queryDef.isPipelineAggWithMultipleBucketPaths(series.metric)) {\n        const agg: any = _.find(target.metrics, { id: series.metricId });\n        if (agg && agg.settings.script) {\n          metricName = agg.settings.script;\n\n          for (const pv of agg.pipelineVariables) {\n            const appliedAgg: any = _.find(target.metrics, { id: pv.pipelineAgg });\n            if (appliedAgg) {\n              metricName = metricName.replace('params.' + pv.name, queryDef.describeMetric(appliedAgg));\n            }\n          }\n        } else {\n          metricName = 'Unset';\n        }\n      } else {\n        const appliedAgg: any = _.find(target.metrics, { id: series.field });\n        if (appliedAgg) {\n          metricName += ' ' + queryDef.describeMetric(appliedAgg);\n        } else {\n          metricName = 'Unset';\n        }\n      }\n    } else if (series.field) {\n      metricName += ' ' + series.field;\n    }\n\n    const propKeys = _.keys(series.props);\n    if (propKeys.length === 0) {\n      return metricName;\n    }\n\n    let name = '';\n    for (const propName in series.props) {\n      name += series.props[propName] + ' ';\n    }\n\n    if (metricTypeCount === 1) {\n      return name.trim();\n    }\n\n    return name.trim() + ' ' + metricName;\n  }\n\n  nameSeries(seriesList: any, target: any) {\n    const metricTypeCount = _.uniq(_.map(seriesList, 'metric')).length;\n\n    for (let i = 0; i < seriesList.length; i++) {\n      const series = seriesList[i];\n      series.target = this.getSeriesName(series, target, metricTypeCount);\n    }\n  }\n\n  processHits(hits: { total: { value: any }; hits: any[] }, seriesList: any[], target: any) {\n    const hitsTotal = typeof hits.total === 'number' ? hits.total : hits.total.value; // <- Works with Elasticsearch 7.0+\n\n    const series: any = {\n      target: target.refId,\n      type: 'docs',\n      refId: target.refId,\n      datapoints: [],\n      total: hitsTotal,\n      filterable: true,\n    };\n    let propName, hit, doc: any, i;\n\n    for (i = 0; i < hits.hits.length; i++) {\n      hit = hits.hits[i];\n      doc = {\n        _id: hit._id,\n        _type: hit._type,\n        _index: hit._index,\n      };\n\n      if (hit._source) {\n        for (propName in hit._source) {\n          doc[propName] = hit._source[propName];\n        }\n      }\n\n      for (propName in hit.fields) {\n        doc[propName] = hit.fields[propName];\n      }\n      series.datapoints.push(doc);\n    }\n\n    seriesList.push(series);\n  }\n\n  trimDatapoints(aggregations: any, target: any) {\n    const histogram: any = _.find(target.bucketAggs, { type: 'date_histogram' });\n\n    const shouldDropFirstAndLast = histogram && histogram.settings && histogram.settings.trimEdges;\n    if (shouldDropFirstAndLast) {\n      const trim = histogram.settings.trimEdges;\n      for (const prop in aggregations) {\n        const points = aggregations[prop];\n        if (points.datapoints.length > trim * 2) {\n          points.datapoints = points.datapoints.slice(trim, points.datapoints.length - trim);\n        }\n      }\n    }\n  }\n\n  getErrorFromElasticResponse(response: any, err: any) {\n    const result: any = {};\n    result.data = JSON.stringify(err, null, 4);\n    if (err.root_cause && err.root_cause.length > 0 && err.root_cause[0].reason) {\n      result.message = err.root_cause[0].reason;\n    } else {\n      result.message = err.reason || 'Unknown elastic error response';\n    }\n\n    if (response.$$config) {\n      result.config = response.$$config;\n    }\n\n    return result;\n  }\n\n  getTimeSeries() {\n    if (this.targets.some((target: any) => target.metrics.some((metric: any) => metric.type === 'raw_data'))) {\n      return this.processResponseToDataFrames(false);\n    }\n    return this.processResponseToSeries();\n  }\n\n  getLogs(logMessageField?: string, logLevelField?: string): DataQueryResponse {\n    return this.processResponseToDataFrames(true, logMessageField, logLevelField);\n  }\n\n  processResponseToDataFrames(\n    isLogsRequest: boolean,\n    logMessageField?: string,\n    logLevelField?: string\n  ): DataQueryResponse {\n    const dataFrame: DataFrame[] = [];\n\n    for (let n = 0; n < this.response.responses.length; n++) {\n      const response = this.response.responses[n];\n      if (response.error) {\n        throw this.getErrorFromElasticResponse(this.response, response.error);\n      }\n\n      if (response.hits && response.hits.hits.length > 0) {\n        const { propNames, docs } = flattenHits(response.hits.hits);\n        if (docs.length > 0) {\n          let series = createEmptyDataFrame(\n            propNames,\n            this.targets[0].timeField,\n            isLogsRequest,\n            logMessageField,\n            logLevelField\n          );\n\n          // Add a row for each document\n          for (const doc of docs) {\n            if (logLevelField) {\n              // Remap level field based on the datasource config. This field is then used in explore to figure out the\n              // log level. We may rewrite some actual data in the level field if they are different.\n              doc['level'] = doc[logLevelField];\n            }\n\n            series.add(doc);\n          }\n          if (isLogsRequest) {\n            series = addPreferredVisualisationType(series, 'logs');\n          }\n          const target = this.targets[n];\n          series.refId = target.refId;\n          dataFrame.push(series);\n        }\n      }\n\n      if (response.aggregations) {\n        const aggregations = response.aggregations;\n        const target = this.targets[n];\n        const tmpSeriesList: any[] = [];\n        const table = new TableModel();\n\n        this.processBuckets(aggregations, target, tmpSeriesList, table, {}, 0);\n        this.trimDatapoints(tmpSeriesList, target);\n        this.nameSeries(tmpSeriesList, target);\n\n        if (table.rows.length > 0) {\n          const series = toDataFrame(table);\n          series.refId = target.refId;\n          dataFrame.push(series);\n        }\n\n        for (let y = 0; y < tmpSeriesList.length; y++) {\n          let series = toDataFrame(tmpSeriesList[y]);\n\n          // When log results, show aggregations only in graph. Log fields are then going to be shown in table.\n          if (isLogsRequest) {\n            series = addPreferredVisualisationType(series, 'graph');\n          }\n\n          series.refId = target.refId;\n          dataFrame.push(series);\n        }\n      }\n    }\n\n    return { data: dataFrame };\n  }\n\n  processResponseToSeries = () => {\n    const seriesList = [];\n\n    for (let i = 0; i < this.response.responses.length; i++) {\n      const response = this.response.responses[i];\n      const target = this.targets[i];\n\n      if (response.error) {\n        throw this.getErrorFromElasticResponse(this.response, response.error);\n      }\n\n      if (response.hits && response.hits.hits.length > 0) {\n        this.processHits(response.hits, seriesList, target);\n      }\n\n      if (response.aggregations) {\n        const aggregations = response.aggregations;\n        const tmpSeriesList: any[] = [];\n        const table = new TableModel();\n        table.refId = target.refId;\n\n        this.processBuckets(aggregations, target, tmpSeriesList, table, {}, 0);\n        this.trimDatapoints(tmpSeriesList, target);\n        this.nameSeries(tmpSeriesList, target);\n\n        for (let y = 0; y < tmpSeriesList.length; y++) {\n          seriesList.push(tmpSeriesList[y]);\n        }\n\n        if (table.rows.length > 0) {\n          seriesList.push(table);\n        }\n      }\n    }\n\n    return { data: seriesList };\n  };\n}\n\ntype Doc = {\n  _id: string;\n  _type: string;\n  _index: string;\n  _source?: any;\n};\n\n/**\n * Flatten the docs from response mainly the _source part which can be nested. This flattens it so that it is one level\n * deep and the keys are: `level1Name.level2Name...`. Also returns list of all properties from all the docs (not all\n * docs have to have the same keys).\n * @param hits\n */\nconst flattenHits = (hits: Doc[]): { docs: Array<Record<string, any>>; propNames: string[] } => {\n  const docs: any[] = [];\n  // We keep a list of all props so that we can create all the fields in the dataFrame, this can lead\n  // to wide sparse dataframes in case the scheme is different per document.\n  let propNames: string[] = [];\n\n  for (const hit of hits) {\n    const flattened = hit._source ? flatten(hit._source) : {};\n    const doc = {\n      _id: hit._id,\n      _type: hit._type,\n      _index: hit._index,\n      _source: { ...flattened },\n      ...flattened,\n    };\n\n    for (const propName of Object.keys(doc)) {\n      if (propNames.indexOf(propName) === -1) {\n        propNames.push(propName);\n      }\n    }\n\n    docs.push(doc);\n  }\n\n  propNames.sort();\n  return { docs, propNames };\n};\n\n/**\n * Create empty dataframe but with created fields. Fields are based from propNames (should be from the response) and\n * also from configuration specified fields for message, time, and level.\n * @param propNames\n * @param timeField\n * @param logMessageField\n * @param logLevelField\n */\nconst createEmptyDataFrame = (\n  propNames: string[],\n  timeField: string,\n  isLogsRequest: boolean,\n  logMessageField?: string,\n  logLevelField?: string\n): MutableDataFrame => {\n  const series = new MutableDataFrame({ fields: [] });\n\n  series.addField({\n    config: {\n      filterable: true,\n    },\n    name: timeField,\n    type: FieldType.time,\n  });\n\n  if (logMessageField) {\n    series.addField({\n      name: logMessageField,\n      type: FieldType.string,\n    }).parse = (v: any) => {\n      return v || '';\n    };\n  }\n\n  if (logLevelField) {\n    series.addField({\n      name: 'level',\n      type: FieldType.string,\n    }).parse = (v: any) => {\n      return v || '';\n    };\n  }\n\n  const fieldNames = series.fields.map(field => field.name);\n\n  for (const propName of propNames) {\n    // Do not duplicate fields. This can mean that we will shadow some fields.\n    if (fieldNames.includes(propName)) {\n      continue;\n    }\n    // Do not add _source field (besides logs) as we are showing each _source field in table instead.\n    if (!isLogsRequest && propName === '_source') {\n      continue;\n    }\n\n    series.addField({\n      config: {\n        filterable: true,\n      },\n      name: propName,\n      type: FieldType.string,\n    }).parse = (v: any) => {\n      return v || '';\n    };\n  }\n\n  return series;\n};\n\nconst addPreferredVisualisationType = (series: any, type: PreferredVisualisationType) => {\n  let s = series;\n  s.meta\n    ? (s.meta.preferredVisualisationType = type)\n    : (s.meta = {\n        preferredVisualisationType: type,\n      });\n\n  return s;\n};\n","import { toUtc, dateTime } from '@grafana/data';\n\nconst intervalMap: any = {\n  Hourly: { startOf: 'hour', amount: 'hours' },\n  Daily: { startOf: 'day', amount: 'days' },\n  Weekly: { startOf: 'isoWeek', amount: 'weeks' },\n  Monthly: { startOf: 'month', amount: 'months' },\n  Yearly: { startOf: 'year', amount: 'years' },\n};\n\nexport class IndexPattern {\n  private dateLocale = 'en';\n\n  constructor(private pattern: any, private interval?: string) {}\n\n  getIndexForToday() {\n    if (this.interval) {\n      return toUtc()\n        .locale(this.dateLocale)\n        .format(this.pattern);\n    } else {\n      return this.pattern;\n    }\n  }\n\n  getIndexList(from: any, to: any) {\n    if (!this.interval) {\n      return this.pattern;\n    }\n\n    const intervalInfo = intervalMap[this.interval];\n    const start = dateTime(from)\n      .utc()\n      .startOf(intervalInfo.startOf);\n    const endEpoch = dateTime(to)\n      .utc()\n      .startOf(intervalInfo.startOf)\n      .valueOf();\n    const indexList = [];\n\n    while (start.valueOf() <= endEpoch) {\n      indexList.push(start.locale(this.dateLocale).format(this.pattern));\n      start.add(1, intervalInfo.amount);\n    }\n\n    return indexList;\n  }\n}\n","import * as queryDef from './query_def';\nimport { ElasticsearchAggregation } from './types';\n\nexport class ElasticQueryBuilder {\n  timeField: string;\n  esVersion: number;\n\n  constructor(options: { timeField: string; esVersion: number }) {\n    this.timeField = options.timeField;\n    this.esVersion = options.esVersion;\n  }\n\n  getRangeFilter() {\n    const filter: any = {};\n    filter[this.timeField] = {\n      gte: '$timeFrom',\n      lte: '$timeTo',\n      format: 'epoch_millis',\n    };\n\n    return filter;\n  }\n\n  buildTermsAgg(aggDef: ElasticsearchAggregation, queryNode: { terms?: any; aggs?: any }, target: { metrics: any[] }) {\n    let metricRef, metric, y;\n    queryNode.terms = { field: aggDef.field };\n\n    if (!aggDef.settings) {\n      return queryNode;\n    }\n\n    queryNode.terms.size = parseInt(aggDef.settings.size, 10) === 0 ? 500 : parseInt(aggDef.settings.size, 10);\n    if (aggDef.settings.orderBy !== void 0) {\n      queryNode.terms.order = {};\n      if (aggDef.settings.orderBy === '_term' && this.esVersion >= 60) {\n        queryNode.terms.order['_key'] = aggDef.settings.order;\n      } else {\n        queryNode.terms.order[aggDef.settings.orderBy] = aggDef.settings.order;\n      }\n\n      // if metric ref, look it up and add it to this agg level\n      metricRef = parseInt(aggDef.settings.orderBy, 10);\n      if (!isNaN(metricRef)) {\n        for (y = 0; y < target.metrics.length; y++) {\n          metric = target.metrics[y];\n          if (metric.id === aggDef.settings.orderBy) {\n            queryNode.aggs = {};\n            queryNode.aggs[metric.id] = {};\n            queryNode.aggs[metric.id][metric.type] = { field: metric.field };\n            break;\n          }\n        }\n      }\n    }\n\n    if (aggDef.settings.min_doc_count !== void 0) {\n      queryNode.terms.min_doc_count = parseInt(aggDef.settings.min_doc_count, 10);\n\n      if (isNaN(queryNode.terms.min_doc_count)) {\n        queryNode.terms.min_doc_count = aggDef.settings.min_doc_count;\n      }\n    }\n\n    if (aggDef.settings.missing) {\n      queryNode.terms.missing = aggDef.settings.missing;\n    }\n\n    return queryNode;\n  }\n\n  getDateHistogramAgg(aggDef: ElasticsearchAggregation) {\n    const esAgg: any = {};\n    const settings = aggDef.settings || {};\n    esAgg.interval = settings.interval;\n    esAgg.field = this.timeField;\n    esAgg.min_doc_count = settings.min_doc_count || 0;\n    esAgg.extended_bounds = { min: '$timeFrom', max: '$timeTo' };\n    esAgg.format = 'epoch_millis';\n\n    if (settings.offset !== '') {\n      esAgg.offset = settings.offset;\n    }\n\n    if (esAgg.interval === 'auto') {\n      esAgg.interval = '$__interval';\n    }\n\n    if (settings.missing) {\n      esAgg.missing = settings.missing;\n    }\n\n    return esAgg;\n  }\n\n  getHistogramAgg(aggDef: ElasticsearchAggregation) {\n    const esAgg: any = {};\n    const settings = aggDef.settings || {};\n    esAgg.interval = settings.interval;\n    esAgg.field = aggDef.field;\n    esAgg.min_doc_count = settings.min_doc_count || 0;\n\n    if (settings.missing) {\n      esAgg.missing = settings.missing;\n    }\n    return esAgg;\n  }\n\n  getFiltersAgg(aggDef: ElasticsearchAggregation) {\n    const filterObj: any = {};\n    for (let i = 0; i < aggDef.settings.filters.length; i++) {\n      const query = aggDef.settings.filters[i].query;\n      let label = aggDef.settings.filters[i].label;\n      label = label === '' || label === undefined ? query : label;\n      filterObj[label] = {\n        query_string: {\n          query: query,\n          analyze_wildcard: true,\n        },\n      };\n    }\n\n    return filterObj;\n  }\n\n  documentQuery(query: any, size: number) {\n    query.size = size;\n    query.sort = {};\n    query.sort[this.timeField] = { order: 'desc', unmapped_type: 'boolean' };\n\n    // fields field not supported on ES 5.x\n    if (this.esVersion < 5) {\n      query.fields = ['*', '_source'];\n    }\n\n    query.script_fields = {};\n    return query;\n  }\n\n  addAdhocFilters(query: any, adhocFilters: any) {\n    if (!adhocFilters) {\n      return;\n    }\n\n    let i, filter, condition: any, queryCondition: any;\n\n    for (i = 0; i < adhocFilters.length; i++) {\n      filter = adhocFilters[i];\n      condition = {};\n      condition[filter.key] = filter.value;\n      queryCondition = {};\n      queryCondition[filter.key] = { query: filter.value };\n\n      switch (filter.operator) {\n        case '=':\n          if (!query.query.bool.must) {\n            query.query.bool.must = [];\n          }\n          query.query.bool.must.push({ match_phrase: queryCondition });\n          break;\n        case '!=':\n          if (!query.query.bool.must_not) {\n            query.query.bool.must_not = [];\n          }\n          query.query.bool.must_not.push({ match_phrase: queryCondition });\n          break;\n        case '<':\n          condition[filter.key] = { lt: filter.value };\n          query.query.bool.filter.push({ range: condition });\n          break;\n        case '>':\n          condition[filter.key] = { gt: filter.value };\n          query.query.bool.filter.push({ range: condition });\n          break;\n        case '=~':\n          query.query.bool.filter.push({ regexp: condition });\n          break;\n        case '!~':\n          query.query.bool.filter.push({\n            bool: { must_not: { regexp: condition } },\n          });\n          break;\n      }\n    }\n  }\n\n  build(target: any, adhocFilters?: any, queryString?: string) {\n    // make sure query has defaults;\n    target.metrics = target.metrics || [queryDef.defaultMetricAgg()];\n    target.bucketAggs = target.bucketAggs || [queryDef.defaultBucketAgg()];\n    target.timeField = this.timeField;\n\n    let i, j, pv, nestedAggs, metric;\n    const query = {\n      size: 0,\n      query: {\n        bool: {\n          filter: [\n            { range: this.getRangeFilter() },\n            {\n              query_string: {\n                analyze_wildcard: true,\n                query: queryString,\n              },\n            },\n          ],\n        },\n      },\n    };\n\n    this.addAdhocFilters(query, adhocFilters);\n\n    // If target doesn't have bucketAggs and type is not raw_document, it is invalid query.\n    if (target.bucketAggs.length === 0) {\n      metric = target.metrics[0];\n\n      if (!metric || !(metric.type === 'raw_document' || metric.type === 'raw_data')) {\n        throw { message: 'Invalid query' };\n      }\n    }\n\n    /* Handle document query:\n     * Check if metric type is raw_document. If metric doesn't have size (or size is 0), update size to 500.\n     * Otherwise it will not be a valid query and error will be thrown.\n     */\n    if (target.metrics?.[0]?.type === 'raw_document' || target.metrics?.[0]?.type === 'raw_data') {\n      metric = target.metrics[0];\n      const size = (metric.settings && metric.settings.size !== 0 && metric.settings.size) || 500;\n      return this.documentQuery(query, size);\n    }\n\n    nestedAggs = query;\n\n    for (i = 0; i < target.bucketAggs.length; i++) {\n      const aggDef: any = target.bucketAggs[i];\n      const esAgg: any = {};\n\n      switch (aggDef.type) {\n        case 'date_histogram': {\n          esAgg['date_histogram'] = this.getDateHistogramAgg(aggDef);\n          break;\n        }\n        case 'histogram': {\n          esAgg['histogram'] = this.getHistogramAgg(aggDef);\n          break;\n        }\n        case 'filters': {\n          esAgg['filters'] = { filters: this.getFiltersAgg(aggDef) };\n          break;\n        }\n        case 'terms': {\n          this.buildTermsAgg(aggDef, esAgg, target);\n          break;\n        }\n        case 'geohash_grid': {\n          esAgg['geohash_grid'] = {\n            field: aggDef.field,\n            precision: aggDef.settings.precision,\n          };\n          break;\n        }\n      }\n\n      nestedAggs.aggs = nestedAggs.aggs || {};\n      nestedAggs.aggs[aggDef.id] = esAgg;\n      nestedAggs = esAgg;\n    }\n\n    nestedAggs.aggs = {};\n\n    for (i = 0; i < target.metrics.length; i++) {\n      metric = target.metrics[i];\n      if (metric.type === 'count') {\n        continue;\n      }\n\n      const aggField: any = {};\n      let metricAgg: any = null;\n\n      if (queryDef.isPipelineAgg(metric.type)) {\n        if (queryDef.isPipelineAggWithMultipleBucketPaths(metric.type)) {\n          if (metric.pipelineVariables) {\n            metricAgg = {\n              buckets_path: {},\n            };\n\n            for (j = 0; j < metric.pipelineVariables.length; j++) {\n              pv = metric.pipelineVariables[j];\n\n              if (pv.name && pv.pipelineAgg && /^\\d*$/.test(pv.pipelineAgg)) {\n                const appliedAgg = queryDef.findMetricById(target.metrics, pv.pipelineAgg);\n                if (appliedAgg) {\n                  if (appliedAgg.type === 'count') {\n                    metricAgg.buckets_path[pv.name] = '_count';\n                  } else {\n                    metricAgg.buckets_path[pv.name] = pv.pipelineAgg;\n                  }\n                }\n              }\n            }\n          } else {\n            continue;\n          }\n        } else {\n          if (metric.pipelineAgg && /^\\d*$/.test(metric.pipelineAgg)) {\n            const appliedAgg = queryDef.findMetricById(target.metrics, metric.pipelineAgg);\n            if (appliedAgg) {\n              if (appliedAgg.type === 'count') {\n                metricAgg = { buckets_path: '_count' };\n              } else {\n                metricAgg = { buckets_path: metric.pipelineAgg };\n              }\n            }\n          } else {\n            continue;\n          }\n        }\n      } else {\n        metricAgg = { field: metric.field };\n      }\n\n      for (const prop in metric.settings) {\n        if (metric.settings.hasOwnProperty(prop) && metric.settings[prop] !== null) {\n          metricAgg[prop] = metric.settings[prop];\n        }\n      }\n\n      aggField[metric.type] = metricAgg;\n      nestedAggs.aggs[metric.id] = aggField;\n    }\n\n    return query;\n  }\n\n  getTermsQuery(queryDef: any) {\n    const query: any = {\n      size: 0,\n      query: {\n        bool: {\n          filter: [{ range: this.getRangeFilter() }],\n        },\n      },\n    };\n\n    if (queryDef.query) {\n      query.query.bool.filter.push({\n        query_string: {\n          analyze_wildcard: true,\n          query: queryDef.query,\n        },\n      });\n    }\n\n    let size = 500;\n    if (queryDef.size) {\n      size = queryDef.size;\n    }\n\n    query.aggs = {\n      '1': {\n        terms: {\n          field: queryDef.field,\n          size: size,\n          order: {},\n        },\n      },\n    };\n\n    // Default behaviour is to order results by { _key: asc }\n    // queryDef.order allows selection of asc/desc\n    // queryDef.orderBy allows selection of doc_count ordering (defaults desc)\n\n    const { orderBy = 'key', order = orderBy === 'doc_count' ? 'desc' : 'asc' } = queryDef;\n\n    if (['asc', 'desc'].indexOf(order) < 0) {\n      throw { message: `Invalid query sort order ${order}` };\n    }\n\n    switch (orderBy) {\n      case 'key':\n      case 'term':\n        const keyname = this.esVersion >= 60 ? '_key' : '_term';\n        query.aggs['1'].terms.order[keyname] = order;\n        break;\n      case 'doc_count':\n        query.aggs['1'].terms.order['_count'] = order;\n        break;\n      default:\n        throw { message: `Invalid query sort type ${orderBy}` };\n    }\n\n    return query;\n  }\n\n  getLogsQuery(target: any, adhocFilters?: any, querystring?: string) {\n    let query: any = {\n      size: 0,\n      query: {\n        bool: {\n          filter: [{ range: this.getRangeFilter() }],\n        },\n      },\n    };\n\n    this.addAdhocFilters(query, adhocFilters);\n\n    if (target.query) {\n      query.query.bool.filter.push({\n        query_string: {\n          analyze_wildcard: true,\n          query: querystring,\n        },\n      });\n    }\n\n    query = this.documentQuery(query, 500);\n\n    return {\n      ...query,\n      aggs: this.build(target, null, querystring).aggs,\n    };\n  }\n}\n","import angular from 'angular';\nimport _ from 'lodash';\nimport {\n  DataSourceApi,\n  DataSourceInstanceSettings,\n  DataQueryRequest,\n  DataQueryResponse,\n  DataFrame,\n  ScopedVars,\n  DataLink,\n  PluginMeta,\n  DataQuery,\n} from '@grafana/data';\nimport LanguageProvider from './language_provider';\nimport { ElasticResponse } from './elastic_response';\nimport { IndexPattern } from './index_pattern';\nimport { ElasticQueryBuilder } from './query_builder';\nimport { toUtc } from '@grafana/data';\nimport * as queryDef from './query_def';\nimport { getBackendSrv } from '@grafana/runtime';\nimport { getTemplateSrv, TemplateSrv } from 'app/features/templating/template_srv';\nimport { getTimeSrv, TimeSrv } from 'app/features/dashboard/services/TimeSrv';\nimport { DataLinkConfig, ElasticsearchOptions, ElasticsearchQuery } from './types';\n\n// Those are metadata fields as defined in https://www.elastic.co/guide/en/elasticsearch/reference/current/mapping-fields.html#_identity_metadata_fields.\n// custom fields can start with underscores, therefore is not safe to exclude anything that starts with one.\nconst ELASTIC_META_FIELDS = [\n  '_index',\n  '_type',\n  '_id',\n  '_source',\n  '_size',\n  '_field_names',\n  '_ignored',\n  '_routing',\n  '_meta',\n];\n\nexport class ElasticDatasource extends DataSourceApi<ElasticsearchQuery, ElasticsearchOptions> {\n  basicAuth?: string;\n  withCredentials?: boolean;\n  url: string;\n  name: string;\n  index: string;\n  timeField: string;\n  esVersion: number;\n  interval: string;\n  maxConcurrentShardRequests?: number;\n  queryBuilder: ElasticQueryBuilder;\n  indexPattern: IndexPattern;\n  logMessageField?: string;\n  logLevelField?: string;\n  dataLinks: DataLinkConfig[];\n  languageProvider: LanguageProvider;\n\n  constructor(\n    instanceSettings: DataSourceInstanceSettings<ElasticsearchOptions>,\n    private readonly templateSrv: TemplateSrv = getTemplateSrv(),\n    private readonly timeSrv: TimeSrv = getTimeSrv()\n  ) {\n    super(instanceSettings);\n    this.basicAuth = instanceSettings.basicAuth;\n    this.withCredentials = instanceSettings.withCredentials;\n    this.url = instanceSettings.url!;\n    this.name = instanceSettings.name;\n    this.index = instanceSettings.database ?? '';\n    const settingsData = instanceSettings.jsonData || ({} as ElasticsearchOptions);\n\n    this.timeField = settingsData.timeField;\n    this.esVersion = settingsData.esVersion;\n    this.indexPattern = new IndexPattern(this.index, settingsData.interval);\n    this.interval = settingsData.timeInterval;\n    this.maxConcurrentShardRequests = settingsData.maxConcurrentShardRequests;\n    this.queryBuilder = new ElasticQueryBuilder({\n      timeField: this.timeField,\n      esVersion: this.esVersion,\n    });\n    this.logMessageField = settingsData.logMessageField || '';\n    this.logLevelField = settingsData.logLevelField || '';\n    this.dataLinks = settingsData.dataLinks || [];\n\n    if (this.logMessageField === '') {\n      this.logMessageField = undefined;\n    }\n\n    if (this.logLevelField === '') {\n      this.logLevelField = undefined;\n    }\n    this.languageProvider = new LanguageProvider(this);\n  }\n\n  private request(method: string, url: string, data?: undefined) {\n    const options: any = {\n      url: this.url + '/' + url,\n      method: method,\n      data: data,\n    };\n\n    if (this.basicAuth || this.withCredentials) {\n      options.withCredentials = true;\n    }\n    if (this.basicAuth) {\n      options.headers = {\n        Authorization: this.basicAuth,\n      };\n    }\n\n    return getBackendSrv()\n      .datasourceRequest(options)\n      .catch((err: any) => {\n        if (err.data && err.data.error) {\n          throw {\n            message: 'Elasticsearch error: ' + err.data.error.reason,\n            error: err.data.error,\n          };\n        }\n        throw err;\n      });\n  }\n\n  async importQueries(queries: DataQuery[], originMeta: PluginMeta): Promise<ElasticsearchQuery[]> {\n    return this.languageProvider.importQueries(queries, originMeta.id);\n  }\n\n  /**\n   * Sends a GET request to the specified url on the newest matching and available index.\n   *\n   * When multiple indices span the provided time range, the request is sent starting from the newest index,\n   * and then going backwards until an index is found.\n   *\n   * @param url the url to query the index on, for example `/_mapping`.\n   */\n  private get(url: string) {\n    const range = this.timeSrv.timeRange();\n    const indexList = this.indexPattern.getIndexList(range.from.valueOf(), range.to.valueOf());\n    if (_.isArray(indexList) && indexList.length) {\n      return this.requestAllIndices(indexList, url).then((results: any) => {\n        results.data.$$config = results.config;\n        return results.data;\n      });\n    } else {\n      return this.request('GET', this.indexPattern.getIndexForToday() + url).then((results: any) => {\n        results.data.$$config = results.config;\n        return results.data;\n      });\n    }\n  }\n\n  private async requestAllIndices(indexList: string[], url: string): Promise<any> {\n    const maxTraversals = 7; // do not go beyond one week (for a daily pattern)\n    const listLen = indexList.length;\n    for (let i = 0; i < Math.min(listLen, maxTraversals); i++) {\n      try {\n        return await this.request('GET', indexList[listLen - i - 1] + url);\n      } catch (err) {\n        if (err.status !== 404 || i === maxTraversals - 1) {\n          throw err;\n        }\n      }\n    }\n  }\n\n  private post(url: string, data: any) {\n    return this.request('POST', url, data).then((results: any) => {\n      results.data.$$config = results.config;\n      return results.data;\n    });\n  }\n\n  annotationQuery(options: any): Promise<any> {\n    const annotation = options.annotation;\n    const timeField = annotation.timeField || '@timestamp';\n    const timeEndField = annotation.timeEndField || null;\n    const queryString = annotation.query || '*';\n    const tagsField = annotation.tagsField || 'tags';\n    const textField = annotation.textField || null;\n\n    const dateRanges = [];\n    const rangeStart: any = {};\n    rangeStart[timeField] = {\n      from: options.range.from.valueOf(),\n      to: options.range.to.valueOf(),\n      format: 'epoch_millis',\n    };\n    dateRanges.push({ range: rangeStart });\n\n    if (timeEndField) {\n      const rangeEnd: any = {};\n      rangeEnd[timeEndField] = {\n        from: options.range.from.valueOf(),\n        to: options.range.to.valueOf(),\n        format: 'epoch_millis',\n      };\n      dateRanges.push({ range: rangeEnd });\n    }\n\n    const queryInterpolated = this.templateSrv.replace(queryString, {}, 'lucene');\n    const query = {\n      bool: {\n        filter: [\n          {\n            bool: {\n              should: dateRanges,\n              minimum_should_match: 1,\n            },\n          },\n          {\n            query_string: {\n              query: queryInterpolated,\n            },\n          },\n        ],\n      },\n    };\n\n    const data: any = {\n      query,\n      size: 10000,\n    };\n\n    // fields field not supported on ES 5.x\n    if (this.esVersion < 5) {\n      data['fields'] = [timeField, '_source'];\n    }\n\n    const header: any = {\n      search_type: 'query_then_fetch',\n      ignore_unavailable: true,\n    };\n\n    // old elastic annotations had index specified on them\n    if (annotation.index) {\n      header.index = annotation.index;\n    } else {\n      header.index = this.indexPattern.getIndexList(options.range.from, options.range.to);\n    }\n\n    const payload = angular.toJson(header) + '\\n' + angular.toJson(data) + '\\n';\n\n    return this.post('_msearch', payload).then((res: any) => {\n      const list = [];\n      const hits = res.responses[0].hits.hits;\n\n      const getFieldFromSource = (source: any, fieldName: any) => {\n        if (!fieldName) {\n          return;\n        }\n\n        const fieldNames = fieldName.split('.');\n        let fieldValue = source;\n\n        for (let i = 0; i < fieldNames.length; i++) {\n          fieldValue = fieldValue[fieldNames[i]];\n          if (!fieldValue) {\n            console.log('could not find field in annotation: ', fieldName);\n            return '';\n          }\n        }\n\n        return fieldValue;\n      };\n\n      for (let i = 0; i < hits.length; i++) {\n        const source = hits[i]._source;\n        let time = getFieldFromSource(source, timeField);\n        if (typeof hits[i].fields !== 'undefined') {\n          const fields = hits[i].fields;\n          if (_.isString(fields[timeField]) || _.isNumber(fields[timeField])) {\n            time = fields[timeField];\n          }\n        }\n\n        const event: {\n          annotation: any;\n          time: number;\n          timeEnd?: number;\n          text: string;\n          tags: string | string[];\n        } = {\n          annotation: annotation,\n          time: toUtc(time).valueOf(),\n          text: getFieldFromSource(source, textField),\n          tags: getFieldFromSource(source, tagsField),\n        };\n\n        if (timeEndField) {\n          const timeEnd = getFieldFromSource(source, timeEndField);\n          if (timeEnd) {\n            event.timeEnd = toUtc(timeEnd).valueOf();\n          }\n        }\n\n        // legacy support for title tield\n        if (annotation.titleField) {\n          const title = getFieldFromSource(source, annotation.titleField);\n          if (title) {\n            event.text = title + '\\n' + event.text;\n          }\n        }\n\n        if (typeof event.tags === 'string') {\n          event.tags = event.tags.split(',');\n        }\n\n        list.push(event);\n      }\n      return list;\n    });\n  }\n\n  interpolateVariablesInQueries(queries: ElasticsearchQuery[], scopedVars: ScopedVars): ElasticsearchQuery[] {\n    let expandedQueries = queries;\n    if (queries && queries.length > 0) {\n      expandedQueries = queries.map(query => {\n        const expandedQuery = {\n          ...query,\n          datasource: this.name,\n          query: this.templateSrv.replace(query.query, scopedVars, 'lucene'),\n        };\n        return expandedQuery;\n      });\n    }\n    return expandedQueries;\n  }\n\n  testDatasource() {\n    // validate that the index exist and has date field\n    return this.getFields({ type: 'date' }).then(\n      (dateFields: any) => {\n        const timeField: any = _.find(dateFields, { text: this.timeField });\n        if (!timeField) {\n          return {\n            status: 'error',\n            message: 'No date field named ' + this.timeField + ' found',\n          };\n        }\n        return { status: 'success', message: 'Index OK. Time field name OK.' };\n      },\n      (err: any) => {\n        console.error(err);\n        if (err.message) {\n          return { status: 'error', message: err.message };\n        } else {\n          return { status: 'error', message: err.status };\n        }\n      }\n    );\n  }\n\n  getQueryHeader(searchType: any, timeFrom: any, timeTo: any) {\n    const queryHeader: any = {\n      search_type: searchType,\n      ignore_unavailable: true,\n      index: this.indexPattern.getIndexList(timeFrom, timeTo),\n    };\n\n    if (this.esVersion >= 56 && this.esVersion < 70) {\n      queryHeader['max_concurrent_shard_requests'] = this.maxConcurrentShardRequests;\n    }\n\n    return angular.toJson(queryHeader);\n  }\n\n  query(options: DataQueryRequest<ElasticsearchQuery>): Promise<DataQueryResponse> {\n    let payload = '';\n    const targets = _.cloneDeep(options.targets);\n    const sentTargets: ElasticsearchQuery[] = [];\n\n    // add global adhoc filters to timeFilter\n    const adhocFilters = this.templateSrv.getAdhocFilters(this.name);\n\n    for (const target of targets) {\n      if (target.hide) {\n        continue;\n      }\n\n      let queryString = this.templateSrv.replace(target.query, options.scopedVars, 'lucene');\n      // Elasticsearch queryString should always be '*' if empty string\n      if (!queryString || queryString === '') {\n        queryString = '*';\n      }\n\n      let queryObj;\n      if (target.isLogsQuery || queryDef.hasMetricOfType(target, 'logs')) {\n        target.bucketAggs = [queryDef.defaultBucketAgg()];\n        target.metrics = [];\n        // Setting this for metrics queries that are typed as logs\n        target.isLogsQuery = true;\n        queryObj = this.queryBuilder.getLogsQuery(target, adhocFilters, queryString);\n      } else {\n        if (target.alias) {\n          target.alias = this.templateSrv.replace(target.alias, options.scopedVars, 'lucene');\n        }\n\n        queryObj = this.queryBuilder.build(target, adhocFilters, queryString);\n      }\n\n      const esQuery = angular.toJson(queryObj);\n\n      const searchType = queryObj.size === 0 && this.esVersion < 5 ? 'count' : 'query_then_fetch';\n      const header = this.getQueryHeader(searchType, options.range.from, options.range.to);\n      payload += header + '\\n';\n\n      payload += esQuery + '\\n';\n\n      sentTargets.push(target);\n    }\n\n    if (sentTargets.length === 0) {\n      return Promise.resolve({ data: [] });\n    }\n\n    // We replace the range here for actual values. We need to replace it together with enclosing \"\" so that we replace\n    // it as an integer not as string with digits. This is because elastic will convert the string only if the time\n    // field is specified as type date (which probably should) but can also be specified as integer (millisecond epoch)\n    // and then sending string will error out.\n    payload = payload.replace(/\"\\$timeFrom\"/g, options.range.from.valueOf().toString());\n    payload = payload.replace(/\"\\$timeTo\"/g, options.range.to.valueOf().toString());\n    payload = this.templateSrv.replace(payload, options.scopedVars);\n\n    const url = this.getMultiSearchUrl();\n\n    return this.post(url, payload).then((res: any) => {\n      const er = new ElasticResponse(sentTargets, res);\n\n      if (sentTargets.some(target => target.isLogsQuery)) {\n        const response = er.getLogs(this.logMessageField, this.logLevelField);\n        for (const dataFrame of response.data) {\n          enhanceDataFrame(dataFrame, this.dataLinks);\n        }\n        return response;\n      }\n\n      return er.getTimeSeries();\n    });\n  }\n\n  isMetadataField(fieldName: string) {\n    return ELASTIC_META_FIELDS.includes(fieldName);\n  }\n\n  getFields(query: any) {\n    const configuredEsVersion = this.esVersion;\n    return this.get('/_mapping').then((result: any) => {\n      const typeMap: any = {\n        float: 'number',\n        double: 'number',\n        integer: 'number',\n        long: 'number',\n        date: 'date',\n        date_nanos: 'date',\n        string: 'string',\n        text: 'string',\n        scaled_float: 'number',\n        nested: 'nested',\n      };\n\n      const shouldAddField = (obj: any, key: string, query: any) => {\n        if (this.isMetadataField(key)) {\n          return false;\n        }\n\n        if (!query.type) {\n          return true;\n        }\n\n        // equal query type filter, or via typemap translation\n        return query.type === obj.type || query.type === typeMap[obj.type];\n      };\n\n      // Store subfield names: [system, process, cpu, total] -> system.process.cpu.total\n      const fieldNameParts: any = [];\n      const fields: any = {};\n\n      function getFieldsRecursively(obj: any) {\n        for (const key in obj) {\n          const subObj = obj[key];\n\n          // Check mapping field for nested fields\n          if (_.isObject(subObj.properties)) {\n            fieldNameParts.push(key);\n            getFieldsRecursively(subObj.properties);\n          }\n\n          if (_.isObject(subObj.fields)) {\n            fieldNameParts.push(key);\n            getFieldsRecursively(subObj.fields);\n          }\n\n          if (_.isString(subObj.type)) {\n            const fieldName = fieldNameParts.concat(key).join('.');\n\n            // Hide meta-fields and check field type\n            if (shouldAddField(subObj, key, query)) {\n              fields[fieldName] = {\n                text: fieldName,\n                type: subObj.type,\n              };\n            }\n          }\n        }\n        fieldNameParts.pop();\n      }\n\n      for (const indexName in result) {\n        const index = result[indexName];\n        if (index && index.mappings) {\n          const mappings = index.mappings;\n\n          if (configuredEsVersion < 70) {\n            for (const typeName in mappings) {\n              const properties = mappings[typeName].properties;\n              getFieldsRecursively(properties);\n            }\n          } else {\n            const properties = mappings.properties;\n            getFieldsRecursively(properties);\n          }\n        }\n      }\n\n      // transform to array\n      return _.map(fields, value => {\n        return value;\n      });\n    });\n  }\n\n  getTerms(queryDef: any) {\n    const range = this.timeSrv.timeRange();\n    const searchType = this.esVersion >= 5 ? 'query_then_fetch' : 'count';\n    const header = this.getQueryHeader(searchType, range.from, range.to);\n    let esQuery = angular.toJson(this.queryBuilder.getTermsQuery(queryDef));\n\n    esQuery = esQuery.replace(/\\$timeFrom/g, range.from.valueOf().toString());\n    esQuery = esQuery.replace(/\\$timeTo/g, range.to.valueOf().toString());\n    esQuery = header + '\\n' + esQuery + '\\n';\n\n    const url = this.getMultiSearchUrl();\n\n    return this.post(url, esQuery).then((res: any) => {\n      if (!res.responses[0].aggregations) {\n        return [];\n      }\n\n      const buckets = res.responses[0].aggregations['1'].buckets;\n      return _.map(buckets, bucket => {\n        return {\n          text: bucket.key_as_string || bucket.key,\n          value: bucket.key,\n        };\n      });\n    });\n  }\n\n  getMultiSearchUrl() {\n    if (this.esVersion >= 70 && this.maxConcurrentShardRequests) {\n      return `_msearch?max_concurrent_shard_requests=${this.maxConcurrentShardRequests}`;\n    }\n\n    return '_msearch';\n  }\n\n  metricFindQuery(query: any) {\n    query = angular.fromJson(query);\n    if (query) {\n      if (query.find === 'fields') {\n        query.field = this.templateSrv.replace(query.field, {}, 'lucene');\n        return this.getFields(query);\n      }\n\n      if (query.find === 'terms') {\n        query.field = this.templateSrv.replace(query.field, {}, 'lucene');\n        query.query = this.templateSrv.replace(query.query || '*', {}, 'lucene');\n        return this.getTerms(query);\n      }\n    }\n\n    return Promise.resolve([]);\n  }\n\n  getTagKeys() {\n    return this.getFields({});\n  }\n\n  getTagValues(options: any) {\n    return this.getTerms({ field: options.key, query: '*' });\n  }\n\n  targetContainsTemplate(target: any) {\n    if (this.templateSrv.variableExists(target.query) || this.templateSrv.variableExists(target.alias)) {\n      return true;\n    }\n\n    for (const bucketAgg of target.bucketAggs) {\n      if (this.templateSrv.variableExists(bucketAgg.field) || this.objectContainsTemplate(bucketAgg.settings)) {\n        return true;\n      }\n    }\n\n    for (const metric of target.metrics) {\n      if (\n        this.templateSrv.variableExists(metric.field) ||\n        this.objectContainsTemplate(metric.settings) ||\n        this.objectContainsTemplate(metric.meta)\n      ) {\n        return true;\n      }\n    }\n\n    return false;\n  }\n\n  private isPrimitive(obj: any) {\n    if (obj === null || obj === undefined) {\n      return true;\n    }\n    if (['string', 'number', 'boolean'].some(type => type === typeof true)) {\n      return true;\n    }\n\n    return false;\n  }\n\n  private objectContainsTemplate(obj: any) {\n    if (!obj) {\n      return false;\n    }\n\n    for (const key of Object.keys(obj)) {\n      if (this.isPrimitive(obj[key])) {\n        if (this.templateSrv.variableExists(obj[key])) {\n          return true;\n        }\n      } else if (Array.isArray(obj[key])) {\n        for (const item of obj[key]) {\n          if (this.objectContainsTemplate(item)) {\n            return true;\n          }\n        }\n      } else {\n        if (this.objectContainsTemplate(obj[key])) {\n          return true;\n        }\n      }\n    }\n\n    return false;\n  }\n}\n\n/**\n * Modifies dataframe and adds dataLinks from the config.\n * Exported for tests.\n */\nexport function enhanceDataFrame(dataFrame: DataFrame, dataLinks: DataLinkConfig[]) {\n  if (dataLinks.length) {\n    for (const field of dataFrame.fields) {\n      const dataLinkConfig = dataLinks.find(dataLink => field.name && field.name.match(dataLink.field));\n      if (dataLinkConfig) {\n        let link: DataLink;\n        if (dataLinkConfig.datasourceUid) {\n          link = {\n            title: '',\n            url: '',\n            internal: {\n              query: { query: dataLinkConfig.url },\n              datasourceUid: dataLinkConfig.datasourceUid,\n            },\n          };\n        } else {\n          link = {\n            title: '',\n            url: dataLinkConfig.url,\n          };\n        }\n        field.config = field.config || {};\n        field.config.links = [...(field.config.links || []), link];\n      }\n    }\n  }\n}\n","import coreModule from 'app/core/core_module';\nimport _ from 'lodash';\nimport * as queryDef from './query_def';\nimport { GrafanaRootScope } from 'app/routes/GrafanaCtrl';\nimport { CoreEvents } from 'app/types';\n\nexport class ElasticBucketAggCtrl {\n  /** @ngInject */\n  constructor($scope: any, uiSegmentSrv: any, $rootScope: GrafanaRootScope) {\n    const bucketAggs = $scope.target.bucketAggs;\n\n    $scope.orderByOptions = [];\n\n    $scope.getBucketAggTypes = () => {\n      return queryDef.bucketAggTypes;\n    };\n\n    $scope.getOrderOptions = () => {\n      return queryDef.orderOptions;\n    };\n\n    $scope.getSizeOptions = () => {\n      return queryDef.sizeOptions;\n    };\n\n    $rootScope.onAppEvent(\n      CoreEvents.elasticQueryUpdated,\n      () => {\n        $scope.validateModel();\n      },\n      $scope\n    );\n\n    $scope.init = () => {\n      $scope.agg = bucketAggs[$scope.index] || {};\n      $scope.validateModel();\n    };\n\n    $scope.onChangeInternal = () => {\n      $scope.onChange();\n    };\n\n    $scope.onTypeChanged = () => {\n      $scope.agg.settings = {};\n      $scope.showOptions = false;\n\n      switch ($scope.agg.type) {\n        case 'date_histogram':\n        case 'histogram':\n        case 'terms': {\n          delete $scope.agg.query;\n          $scope.agg.field = 'select field';\n          break;\n        }\n        case 'filters': {\n          delete $scope.agg.field;\n          $scope.agg.query = '*';\n          break;\n        }\n        case 'geohash_grid': {\n          $scope.agg.settings.precision = 3;\n          break;\n        }\n      }\n\n      $scope.validateModel();\n      $scope.onChange();\n    };\n\n    $scope.validateModel = () => {\n      $scope.index = _.indexOf(bucketAggs, $scope.agg);\n      $scope.isFirst = $scope.index === 0;\n      $scope.bucketAggCount = bucketAggs.length;\n\n      let settingsLinkText = '';\n      const settings = $scope.agg.settings || {};\n\n      switch ($scope.agg.type) {\n        case 'terms': {\n          settings.order = settings.order || 'desc';\n          settings.size = settings.size || '10';\n          settings.min_doc_count = settings.min_doc_count || 0;\n          settings.orderBy = settings.orderBy || '_term';\n\n          if (settings.size !== '0') {\n            settingsLinkText = queryDef.describeOrder(settings.order) + ' ' + settings.size + ', ';\n          }\n\n          if (settings.min_doc_count > 0) {\n            settingsLinkText += 'Min Doc Count: ' + settings.min_doc_count + ', ';\n          }\n\n          settingsLinkText += 'Order by: ' + queryDef.describeOrderBy(settings.orderBy, $scope.target);\n\n          if (settings.size === '0') {\n            settingsLinkText += ' (' + settings.order + ')';\n          }\n\n          break;\n        }\n        case 'filters': {\n          settings.filters = settings.filters || [{ query: '*' }];\n          settingsLinkText = _.reduce(\n            settings.filters,\n            (memo, value, index) => {\n              memo += 'Q' + (index + 1) + '  = ' + value.query + ' ';\n              return memo;\n            },\n            ''\n          );\n          if (settingsLinkText.length > 50) {\n            settingsLinkText = settingsLinkText.substr(0, 50) + '...';\n          }\n          settingsLinkText = 'Filter Queries (' + settings.filters.length + ')';\n          break;\n        }\n        case 'date_histogram': {\n          settings.interval = settings.interval || 'auto';\n          settings.min_doc_count = settings.min_doc_count || 0;\n          $scope.agg.field = $scope.target.timeField;\n          settingsLinkText = 'Interval: ' + settings.interval;\n\n          if (settings.min_doc_count > 0) {\n            settingsLinkText += ', Min Doc Count: ' + settings.min_doc_count;\n          }\n\n          if (settings.trimEdges === undefined || settings.trimEdges < 0) {\n            settings.trimEdges = 0;\n          }\n\n          if (settings.trimEdges && settings.trimEdges > 0) {\n            settingsLinkText += ', Trim edges: ' + settings.trimEdges;\n          }\n          break;\n        }\n        case 'histogram': {\n          settings.interval = settings.interval || 1000;\n          settings.min_doc_count = _.defaultTo(settings.min_doc_count, 1);\n          settingsLinkText = 'Interval: ' + settings.interval;\n\n          if (settings.min_doc_count > 0) {\n            settingsLinkText += ', Min Doc Count: ' + settings.min_doc_count;\n          }\n          break;\n        }\n        case 'geohash_grid': {\n          // limit precision to 12\n          settings.precision = Math.max(Math.min(settings.precision, 12), 1);\n          settingsLinkText = 'Precision: ' + settings.precision;\n          break;\n        }\n      }\n\n      $scope.settingsLinkText = settingsLinkText;\n      $scope.agg.settings = settings;\n      return true;\n    };\n\n    $scope.addFiltersQuery = () => {\n      $scope.agg.settings.filters.push({ query: '*' });\n    };\n\n    $scope.removeFiltersQuery = (filter: any) => {\n      $scope.agg.settings.filters = _.without($scope.agg.settings.filters, filter);\n    };\n\n    $scope.toggleOptions = () => {\n      $scope.showOptions = !$scope.showOptions;\n    };\n\n    $scope.getOrderByOptions = () => {\n      return queryDef.getOrderByOptions($scope.target);\n    };\n\n    $scope.getFieldsInternal = () => {\n      if ($scope.agg.type === 'date_histogram') {\n        return $scope.getFields({ $fieldType: 'date' });\n      } else {\n        return $scope.getFields();\n      }\n    };\n\n    $scope.getIntervalOptions = () => {\n      return Promise.resolve(uiSegmentSrv.transformToSegments(true, 'interval')(queryDef.intervalOptions));\n    };\n\n    $scope.addBucketAgg = () => {\n      // if last is date histogram add it before\n      const lastBucket = bucketAggs[bucketAggs.length - 1];\n      let addIndex = bucketAggs.length - 1;\n\n      if (lastBucket && lastBucket.type === 'date_histogram') {\n        addIndex -= 1;\n      }\n\n      const id = _.reduce(\n        $scope.target.bucketAggs.concat($scope.target.metrics),\n        (max, val) => {\n          return parseInt(val.id, 10) > max ? parseInt(val.id, 10) : max;\n        },\n        0\n      );\n\n      bucketAggs.splice(addIndex, 0, { type: 'terms', field: 'select field', id: (id + 1).toString(), fake: true });\n      $scope.onChange();\n    };\n\n    $scope.removeBucketAgg = () => {\n      bucketAggs.splice($scope.index, 1);\n      $scope.onChange();\n    };\n\n    $scope.init();\n  }\n}\n\nexport function elasticBucketAgg() {\n  return {\n    templateUrl: 'public/app/plugins/datasource/elasticsearch/partials/bucket_agg.html',\n    controller: ElasticBucketAggCtrl,\n    restrict: 'E',\n    scope: {\n      target: '=',\n      index: '=',\n      onChange: '&',\n      getFields: '&',\n    },\n  };\n}\n\ncoreModule.directive('elasticBucketAgg', elasticBucketAgg);\n","import coreModule from 'app/core/core_module';\nimport _ from 'lodash';\nimport * as queryDef from './query_def';\nimport { ElasticsearchAggregation } from './types';\nimport { GrafanaRootScope } from 'app/routes/GrafanaCtrl';\nimport { CoreEvents } from 'app/types';\n\nfunction createDefaultMetric(id = 0): ElasticsearchAggregation {\n  return { type: 'count', field: 'select field', id: (id + 1).toString() };\n}\n\nexport class ElasticMetricAggCtrl {\n  /** @ngInject */\n  constructor($scope: any, uiSegmentSrv: any, $rootScope: GrafanaRootScope) {\n    const metricAggs: ElasticsearchAggregation[] = $scope.target.metrics;\n    $scope.metricAggTypes = queryDef.getMetricAggTypes($scope.esVersion);\n    $scope.extendedStats = queryDef.extendedStats;\n    $scope.pipelineAggOptions = [];\n    $scope.modelSettingsValues = {};\n\n    $scope.init = () => {\n      $scope.agg = metricAggs[$scope.index];\n      $scope.validateModel();\n      $scope.updatePipelineAggOptions();\n    };\n\n    $scope.updatePipelineAggOptions = () => {\n      $scope.pipelineAggOptions = queryDef.getPipelineAggOptions($scope.target, $scope.agg);\n    };\n\n    $rootScope.onAppEvent(\n      CoreEvents.elasticQueryUpdated,\n      () => {\n        $scope.index = _.indexOf(metricAggs, $scope.agg);\n        $scope.updatePipelineAggOptions();\n        $scope.validateModel();\n      },\n      $scope\n    );\n\n    $scope.validateModel = () => {\n      $scope.isFirst = $scope.index === 0;\n      $scope.isSingle = metricAggs.length === 1;\n      $scope.settingsLinkText = '';\n      $scope.variablesLinkText = '';\n      $scope.aggDef = _.find($scope.metricAggTypes, { value: $scope.agg.type });\n\n      if (queryDef.isPipelineAgg($scope.agg.type)) {\n        if (queryDef.isPipelineAggWithMultipleBucketPaths($scope.agg.type)) {\n          $scope.variablesLinkText = 'Options';\n\n          if ($scope.agg.settings.script) {\n            $scope.variablesLinkText = 'Script: ' + $scope.agg.settings.script.replace(new RegExp('params.', 'g'), '');\n          }\n        } else {\n          $scope.agg.pipelineAgg = $scope.agg.pipelineAgg || 'select metric';\n          $scope.agg.field = $scope.agg.pipelineAgg;\n        }\n\n        const pipelineOptions = queryDef.getPipelineOptions($scope.agg);\n        if (pipelineOptions.length > 0) {\n          _.each(pipelineOptions, opt => {\n            $scope.agg.settings[opt.text] = $scope.agg.settings[opt.text] || opt.default;\n          });\n          $scope.settingsLinkText = 'Options';\n        }\n      } else if (!$scope.agg.field) {\n        $scope.agg.field = 'select field';\n      }\n      switch ($scope.agg.type) {\n        case 'cardinality': {\n          const precisionThreshold = $scope.agg.settings.precision_threshold || '';\n          $scope.settingsLinkText = 'Precision threshold: ' + precisionThreshold;\n          break;\n        }\n        case 'percentiles': {\n          $scope.agg.settings.percents = $scope.agg.settings.percents || [25, 50, 75, 95, 99];\n          $scope.settingsLinkText = 'Values: ' + $scope.agg.settings.percents.join(',');\n          break;\n        }\n        case 'extended_stats': {\n          if (_.keys($scope.agg.meta).length === 0) {\n            $scope.agg.meta.std_deviation_bounds_lower = true;\n            $scope.agg.meta.std_deviation_bounds_upper = true;\n          }\n\n          const stats = _.reduce(\n            $scope.agg.meta,\n            (memo, val, key) => {\n              if (val) {\n                const def: any = _.find($scope.extendedStats, { value: key });\n                memo.push(def.text);\n              }\n              return memo;\n            },\n            [] as string[]\n          );\n\n          $scope.settingsLinkText = 'Stats: ' + stats.join(', ');\n          break;\n        }\n        case 'moving_avg': {\n          $scope.movingAvgModelTypes = queryDef.movingAvgModelOptions;\n          $scope.modelSettings = queryDef.getMovingAvgSettings($scope.agg.settings.model, true);\n          $scope.updateMovingAvgModelSettings();\n          break;\n        }\n        case 'raw_document':\n        case 'raw_data': {\n          $scope.agg.settings.size = $scope.agg.settings.size || 500;\n          $scope.settingsLinkText = 'Size: ' + $scope.agg.settings.size;\n          $scope.target.metrics.splice(0, $scope.target.metrics.length, $scope.agg);\n\n          $scope.target.bucketAggs = [];\n          break;\n        }\n      }\n      if ($scope.aggDef.supportsInlineScript) {\n        // I know this stores the inline script twice\n        // but having it like this simplifes the query_builder\n        const inlineScript = $scope.agg.inlineScript;\n        if (inlineScript) {\n          $scope.agg.settings.script = { inline: inlineScript };\n        } else {\n          delete $scope.agg.settings.script;\n        }\n\n        if ($scope.settingsLinkText === '') {\n          $scope.settingsLinkText = 'Options';\n        }\n      }\n    };\n\n    $scope.toggleOptions = () => {\n      $scope.showOptions = !$scope.showOptions;\n      $scope.updatePipelineAggOptions();\n    };\n\n    $scope.toggleVariables = () => {\n      $scope.showVariables = !$scope.showVariables;\n    };\n\n    $scope.onChangeInternal = () => {\n      $scope.onChange();\n    };\n\n    $scope.updateMovingAvgModelSettings = () => {\n      const modelSettingsKeys = [];\n      const modelSettings = queryDef.getMovingAvgSettings($scope.agg.settings.model, false);\n      for (let i = 0; i < modelSettings.length; i++) {\n        modelSettingsKeys.push(modelSettings[i].value);\n      }\n\n      for (const key in $scope.agg.settings.settings) {\n        if ($scope.agg.settings.settings[key] === null || modelSettingsKeys.indexOf(key) === -1) {\n          delete $scope.agg.settings.settings[key];\n        }\n      }\n    };\n\n    $scope.onChangeClearInternal = () => {\n      delete $scope.agg.settings.minimize;\n      $scope.onChange();\n    };\n\n    $scope.onTypeChange = () => {\n      $scope.agg.settings = {};\n      $scope.agg.meta = {};\n      $scope.showOptions = false;\n\n      // reset back to metric/group by query\n      if (\n        $scope.target.bucketAggs.length === 0 &&\n        ($scope.agg.type !== 'raw_document' || $scope.agg.type !== 'raw_data')\n      ) {\n        $scope.target.bucketAggs = [queryDef.defaultBucketAgg()];\n      }\n\n      $scope.showVariables = queryDef.isPipelineAggWithMultipleBucketPaths($scope.agg.type);\n      $scope.updatePipelineAggOptions();\n      $scope.onChange();\n    };\n\n    $scope.getFieldsInternal = () => {\n      if ($scope.agg.type === 'cardinality') {\n        return $scope.getFields();\n      }\n      return $scope.getFields({ $fieldType: 'number' });\n    };\n\n    $scope.addMetricAgg = () => {\n      const addIndex = metricAggs.length;\n\n      const id = _.reduce(\n        $scope.target.bucketAggs.concat($scope.target.metrics),\n        (max, val) => {\n          return parseInt(val.id, 10) > max ? parseInt(val.id, 10) : max;\n        },\n        0\n      );\n\n      metricAggs.splice(addIndex, 0, createDefaultMetric(id));\n      $scope.onChange();\n    };\n\n    $scope.removeMetricAgg = () => {\n      const metricBeingRemoved = metricAggs[$scope.index];\n      const metricsToRemove = queryDef.getAncestors($scope.target, metricBeingRemoved);\n      const newMetricAggs = metricAggs.filter(m => !metricsToRemove.includes(m.id));\n      if (newMetricAggs.length > 0) {\n        metricAggs.splice(0, metricAggs.length, ...newMetricAggs);\n      } else {\n        metricAggs.splice(0, metricAggs.length, createDefaultMetric());\n      }\n      $scope.onChange();\n    };\n\n    $scope.toggleShowMetric = () => {\n      $scope.agg.hide = !$scope.agg.hide;\n      if (!$scope.agg.hide) {\n        delete $scope.agg.hide;\n      }\n      $scope.onChange();\n    };\n\n    $scope.init();\n  }\n}\n\nexport function elasticMetricAgg() {\n  return {\n    templateUrl: 'public/app/plugins/datasource/elasticsearch/partials/metric_agg.html',\n    controller: ElasticMetricAggCtrl,\n    restrict: 'E',\n    scope: {\n      target: '=',\n      index: '=',\n      onChange: '&',\n      getFields: '&',\n      esVersion: '=',\n    },\n  };\n}\n\ncoreModule.directive('elasticMetricAgg', elasticMetricAgg);\n","import coreModule from 'app/core/core_module';\nimport _ from 'lodash';\n\nexport function elasticPipelineVariables() {\n  return {\n    templateUrl: 'public/app/plugins/datasource/elasticsearch/partials/pipeline_variables.html',\n    controller: 'ElasticPipelineVariablesCtrl',\n    restrict: 'E',\n    scope: {\n      onChange: '&',\n      variables: '=',\n      options: '=',\n    },\n  };\n}\n\nconst newVariable = (index: any) => {\n  return {\n    name: 'var' + index,\n    pipelineAgg: 'select metric',\n  };\n};\n\nexport class ElasticPipelineVariablesCtrl {\n  /** @ngInject */\n  constructor($scope: any) {\n    $scope.variables = $scope.variables || [newVariable(1)];\n\n    $scope.onChangeInternal = () => {\n      $scope.onChange();\n    };\n\n    $scope.add = () => {\n      $scope.variables.push(newVariable($scope.variables.length + 1));\n      $scope.onChange();\n    };\n\n    $scope.remove = (index: number) => {\n      $scope.variables.splice(index, 1);\n      $scope.onChange();\n    };\n  }\n}\n\ncoreModule.directive('elasticPipelineVariables', elasticPipelineVariables);\ncoreModule.controller('ElasticPipelineVariablesCtrl', ElasticPipelineVariablesCtrl);\n","import './bucket_agg';\nimport './metric_agg';\nimport './pipeline_variables';\n\nimport angular, { auto } from 'angular';\nimport _ from 'lodash';\nimport * as queryDef from './query_def';\nimport { QueryCtrl } from 'app/plugins/sdk';\nimport { ElasticsearchAggregation } from './types';\nimport { GrafanaRootScope } from 'app/routes/GrafanaCtrl';\nimport { CoreEvents } from 'app/types';\n\nexport class ElasticQueryCtrl extends QueryCtrl {\n  static templateUrl = 'partials/query.editor.html';\n\n  esVersion: any;\n  rawQueryOld: string;\n  targetMetricsOld: string;\n\n  /** @ngInject */\n  constructor(\n    $scope: any,\n    $injector: auto.IInjectorService,\n    private $rootScope: GrafanaRootScope,\n    private uiSegmentSrv: any\n  ) {\n    super($scope, $injector);\n\n    this.esVersion = this.datasource.esVersion;\n\n    this.target = this.target || {};\n    this.target.metrics = this.target.metrics || [queryDef.defaultMetricAgg()];\n    this.target.bucketAggs = this.target.bucketAggs || [queryDef.defaultBucketAgg()];\n\n    if (this.target.bucketAggs.length === 0) {\n      const metric = this.target.metrics[0];\n      if (!metric || metric.type !== 'raw_document') {\n        this.target.bucketAggs = [queryDef.defaultBucketAgg()];\n      }\n      this.refresh();\n    }\n\n    this.queryUpdated();\n  }\n\n  getFields(type: any) {\n    const jsonStr = angular.toJson({ find: 'fields', type: type });\n    return this.datasource\n      .metricFindQuery(jsonStr)\n      .then(this.uiSegmentSrv.transformToSegments(false))\n      .catch(this.handleQueryError.bind(this));\n  }\n\n  queryUpdated() {\n    const newJsonTargetMetrics = angular.toJson(this.target.metrics);\n    const newJsonRawQuery = angular.toJson(this.datasource.queryBuilder.build(this.target), true);\n    if (\n      (this.rawQueryOld && newJsonRawQuery !== this.rawQueryOld) ||\n      (this.targetMetricsOld && newJsonTargetMetrics !== this.targetMetricsOld)\n    ) {\n      this.refresh();\n    }\n\n    this.rawQueryOld = newJsonRawQuery;\n    this.targetMetricsOld = newJsonTargetMetrics;\n    this.$rootScope.appEvent(CoreEvents.elasticQueryUpdated);\n  }\n\n  getCollapsedText() {\n    const metricAggs: ElasticsearchAggregation[] = this.target.metrics;\n    const bucketAggs = this.target.bucketAggs;\n    const metricAggTypes = queryDef.getMetricAggTypes(this.esVersion);\n    const bucketAggTypes = queryDef.bucketAggTypes;\n    let text = '';\n\n    if (this.target.query) {\n      text += 'Query: ' + this.target.query + ', ';\n    }\n\n    text += 'Metrics: ';\n\n    _.each(metricAggs, (metric, index) => {\n      const aggDef: any = _.find(metricAggTypes, { value: metric.type });\n      text += aggDef.text + '(';\n      if (aggDef.requiresField) {\n        text += metric.field;\n      }\n      if (aggDef.supportsMultipleBucketPaths) {\n        text += metric.settings.script.replace(new RegExp('params.', 'g'), '');\n      }\n      text += '), ';\n    });\n\n    _.each(bucketAggs, (bucketAgg: any, index: number) => {\n      if (index === 0) {\n        text += ' Group by: ';\n      }\n\n      const aggDef: any = _.find(bucketAggTypes, { value: bucketAgg.type });\n      text += aggDef.text + '(';\n      if (aggDef.requiresField) {\n        text += bucketAgg.field;\n      }\n      text += '), ';\n    });\n\n    if (this.target.alias) {\n      text += 'Alias: ' + this.target.alias;\n    }\n\n    return text;\n  }\n\n  handleQueryError(err: any): any[] {\n    this.error = err.message || 'Failed to issue metric query';\n    return [];\n  }\n}\n","import React from 'react';\nimport { EventsWithValidation, regexValidation, LegacyForms } from '@grafana/ui';\nconst { Select, Input, FormField } = LegacyForms;\nimport { ElasticsearchOptions } from '../types';\nimport { DataSourceSettings, SelectableValue } from '@grafana/data';\n\nconst indexPatternTypes = [\n  { label: 'No pattern', value: 'none' },\n  { label: 'Hourly', value: 'Hourly', example: '[logstash-]YYYY.MM.DD.HH' },\n  { label: 'Daily', value: 'Daily', example: '[logstash-]YYYY.MM.DD' },\n  { label: 'Weekly', value: 'Weekly', example: '[logstash-]GGGG.WW' },\n  { label: 'Monthly', value: 'Monthly', example: '[logstash-]YYYY.MM' },\n  { label: 'Yearly', value: 'Yearly', example: '[logstash-]YYYY' },\n];\n\nconst esVersions = [\n  { label: '2.x', value: 2 },\n  { label: '5.x', value: 5 },\n  { label: '5.6+', value: 56 },\n  { label: '6.0+', value: 60 },\n  { label: '7.0+', value: 70 },\n];\n\ntype Props = {\n  value: DataSourceSettings<ElasticsearchOptions>;\n  onChange: (value: DataSourceSettings<ElasticsearchOptions>) => void;\n};\nexport const ElasticDetails = (props: Props) => {\n  const { value, onChange } = props;\n\n  return (\n    <>\n      <h3 className=\"page-heading\">Elasticsearch details</h3>\n\n      <div className=\"gf-form-group\">\n        <div className=\"gf-form-inline\">\n          <div className=\"gf-form max-width-25\">\n            <FormField\n              labelWidth={10}\n              inputWidth={15}\n              label=\"Index name\"\n              value={value.database || ''}\n              onChange={changeHandler('database', value, onChange)}\n              placeholder={'es-index-name'}\n              required\n            />\n          </div>\n\n          <div className=\"gf-form width-14\">\n            <FormField\n              labelWidth={10}\n              label=\"Pattern\"\n              inputEl={\n                <Select\n                  options={indexPatternTypes}\n                  onChange={intervalHandler(value, onChange)}\n                  value={indexPatternTypes.find(\n                    pattern =>\n                      pattern.value === (value.jsonData.interval === undefined ? 'none' : value.jsonData.interval)\n                  )}\n                />\n              }\n            />\n          </div>\n        </div>\n\n        <div className=\"gf-form max-width-25\">\n          <FormField\n            labelWidth={10}\n            inputWidth={15}\n            label=\"Time field name\"\n            value={value.jsonData.timeField || ''}\n            onChange={jsonDataChangeHandler('timeField', value, onChange)}\n            required\n          />\n        </div>\n\n        <div className=\"gf-form\">\n          <span className=\"gf-form-select-wrapper\">\n            <FormField\n              labelWidth={10}\n              label=\"Version\"\n              inputEl={\n                <Select\n                  options={esVersions}\n                  onChange={option => {\n                    const maxConcurrentShardRequests = getMaxConcurrenShardRequestOrDefault(\n                      value.jsonData.maxConcurrentShardRequests,\n                      option.value!\n                    );\n                    onChange({\n                      ...value,\n                      jsonData: {\n                        ...value.jsonData,\n                        esVersion: option.value!,\n                        maxConcurrentShardRequests,\n                      },\n                    });\n                  }}\n                  value={esVersions.find(version => version.value === value.jsonData.esVersion)}\n                />\n              }\n            />\n          </span>\n        </div>\n        {value.jsonData.esVersion >= 56 && (\n          <div className=\"gf-form max-width-30\">\n            <FormField\n              aria-label={'Max concurrent Shard Requests input'}\n              labelWidth={15}\n              label=\"Max concurrent Shard Requests\"\n              value={value.jsonData.maxConcurrentShardRequests || ''}\n              onChange={jsonDataChangeHandler('maxConcurrentShardRequests', value, onChange)}\n            />\n          </div>\n        )}\n        <div className=\"gf-form-inline\">\n          <div className=\"gf-form\">\n            <FormField\n              labelWidth={10}\n              label=\"Min time interval\"\n              inputEl={\n                <Input\n                  className={'width-6'}\n                  value={value.jsonData.timeInterval || ''}\n                  onChange={jsonDataChangeHandler('timeInterval', value, onChange)}\n                  placeholder=\"10s\"\n                  validationEvents={{\n                    [EventsWithValidation.onBlur]: [\n                      regexValidation(\n                        /^\\d+(ms|[Mwdhmsy])$/,\n                        'Value is not valid, you can use number with time unit specifier: y, M, w, d, h, m, s'\n                      ),\n                    ],\n                  }}\n                />\n              }\n              tooltip={\n                <>\n                  A lower limit for the auto group by time interval. Recommended to be set to write frequency, for\n                  example <code>1m</code> if your data is written every minute.\n                </>\n              }\n            />\n          </div>\n        </div>\n      </div>\n    </>\n  );\n};\n\nconst changeHandler = (\n  key: keyof DataSourceSettings<ElasticsearchOptions>,\n  value: Props['value'],\n  onChange: Props['onChange']\n) => (event: React.SyntheticEvent<HTMLInputElement | HTMLSelectElement>) => {\n  onChange({\n    ...value,\n    [key]: event.currentTarget.value,\n  });\n};\n\nconst jsonDataChangeHandler = (key: keyof ElasticsearchOptions, value: Props['value'], onChange: Props['onChange']) => (\n  event: React.SyntheticEvent<HTMLInputElement | HTMLSelectElement>\n) => {\n  onChange({\n    ...value,\n    jsonData: {\n      ...value.jsonData,\n      [key]: event.currentTarget.value,\n    },\n  });\n};\n\nconst intervalHandler = (value: Props['value'], onChange: Props['onChange']) => (option: SelectableValue<string>) => {\n  const { database } = value;\n  // If option value is undefined it will send its label instead so we have to convert made up value to undefined here.\n  const newInterval = option.value === 'none' ? undefined : option.value;\n\n  if (!database || database.length === 0 || database.startsWith('[logstash-]')) {\n    let newDatabase = '';\n\n    if (newInterval !== undefined) {\n      const pattern = indexPatternTypes.find(pattern => pattern.value === newInterval);\n\n      if (pattern) {\n        newDatabase = pattern.example ?? '';\n      }\n    }\n\n    onChange({\n      ...value,\n      database: newDatabase,\n      jsonData: {\n        ...value.jsonData,\n        interval: newInterval,\n      },\n    });\n  } else {\n    onChange({\n      ...value,\n      jsonData: {\n        ...value.jsonData,\n        interval: newInterval,\n      },\n    });\n  }\n};\n\nfunction getMaxConcurrenShardRequestOrDefault(maxConcurrentShardRequests: number | undefined, version: number): number {\n  if (maxConcurrentShardRequests === 5 && version < 70) {\n    return 256;\n  }\n\n  if (maxConcurrentShardRequests === 256 && version >= 70) {\n    return 5;\n  }\n\n  return maxConcurrentShardRequests || defaultMaxConcurrentShardRequests(version);\n}\n\nexport function defaultMaxConcurrentShardRequests(version: number) {\n  return version >= 70 ? 5 : 256;\n}\n","import React from 'react';\nimport { LegacyForms } from '@grafana/ui';\nconst { FormField } = LegacyForms;\nimport { ElasticsearchOptions } from '../types';\n\ntype Props = {\n  value: ElasticsearchOptions;\n  onChange: (value: ElasticsearchOptions) => void;\n};\nexport const LogsConfig = (props: Props) => {\n  const { value, onChange } = props;\n  const changeHandler = (key: keyof ElasticsearchOptions) => (\n    event: React.SyntheticEvent<HTMLInputElement | HTMLSelectElement>\n  ) => {\n    onChange({\n      ...value,\n      [key]: event.currentTarget.value,\n    });\n  };\n\n  return (\n    <>\n      <h3 className=\"page-heading\">Logs</h3>\n\n      <div className=\"gf-form-group\">\n        <div className=\"gf-form max-width-30\">\n          <FormField\n            labelWidth={11}\n            label=\"Message field name\"\n            value={value.logMessageField}\n            onChange={changeHandler('logMessageField')}\n            placeholder=\"_source\"\n          />\n        </div>\n        <div className=\"gf-form max-width-30\">\n          <FormField\n            labelWidth={11}\n            label=\"Level field name\"\n            value={value.logLevelField}\n            onChange={changeHandler('logLevelField')}\n          />\n        </div>\n      </div>\n    </>\n  );\n};\n","import React, { Dispatch, SetStateAction, useEffect, useState } from 'react';\nimport { css } from 'emotion';\nimport { DataSourceSelectItem, VariableSuggestion } from '@grafana/data';\nimport { Button, LegacyForms, DataLinkInput, stylesFactory } from '@grafana/ui';\nconst { FormField, Switch } = LegacyForms;\nimport { DataLinkConfig } from '../types';\nimport { usePrevious } from 'react-use';\nimport { getDatasourceSrv } from '../../../../features/plugins/datasource_srv';\nimport DataSourcePicker from '../../../../core/components/Select/DataSourcePicker';\n\nconst getStyles = stylesFactory(() => ({\n  firstRow: css`\n    display: flex;\n  `,\n  nameField: css`\n    flex: 2;\n  `,\n  regexField: css`\n    flex: 3;\n  `,\n  row: css`\n    display: flex;\n    align-items: baseline;\n  `,\n}));\n\ntype Props = {\n  value: DataLinkConfig;\n  onChange: (value: DataLinkConfig) => void;\n  onDelete: () => void;\n  suggestions: VariableSuggestion[];\n  className?: string;\n};\nexport const DataLink = (props: Props) => {\n  const { value, onChange, onDelete, suggestions, className } = props;\n  const styles = getStyles();\n  const [showInternalLink, setShowInternalLink] = useInternalLink(value.datasourceUid);\n\n  const handleChange = (field: keyof typeof value) => (event: React.ChangeEvent<HTMLInputElement>) => {\n    onChange({\n      ...value,\n      [field]: event.currentTarget.value,\n    });\n  };\n\n  return (\n    <div className={className}>\n      <div className={styles.firstRow + ' gf-form'}>\n        <FormField\n          className={styles.nameField}\n          labelWidth={6}\n          // A bit of a hack to prevent using default value for the width from FormField\n          inputWidth={null}\n          label=\"Field\"\n          type=\"text\"\n          value={value.field}\n          tooltip={'Can be exact field name or a regex pattern that will match on the field name.'}\n          onChange={handleChange('field')}\n        />\n        <Button\n          variant={'destructive'}\n          title=\"Remove field\"\n          icon=\"times\"\n          onClick={event => {\n            event.preventDefault();\n            onDelete();\n          }}\n        />\n      </div>\n      <div className=\"gf-form\">\n        <FormField\n          label={showInternalLink ? 'Query' : 'URL'}\n          labelWidth={6}\n          inputEl={\n            <DataLinkInput\n              placeholder={showInternalLink ? '${__value.raw}' : 'http://example.com/${__value.raw}'}\n              value={value.url || ''}\n              onChange={newValue =>\n                onChange({\n                  ...value,\n                  url: newValue,\n                })\n              }\n              suggestions={suggestions}\n            />\n          }\n          className={css`\n            width: 100%;\n          `}\n        />\n      </div>\n\n      <div className={styles.row}>\n        <Switch\n          label=\"Internal link\"\n          checked={showInternalLink}\n          onChange={() => {\n            if (showInternalLink) {\n              onChange({\n                ...value,\n                datasourceUid: undefined,\n              });\n            }\n            setShowInternalLink(!showInternalLink);\n          }}\n        />\n\n        {showInternalLink && (\n          <DataSourceSection\n            onChange={datasourceUid => {\n              onChange({\n                ...value,\n                datasourceUid,\n              });\n            }}\n            datasourceUid={value.datasourceUid}\n          />\n        )}\n      </div>\n    </div>\n  );\n};\n\ntype DataSourceSectionProps = {\n  datasourceUid?: string;\n  onChange: (uid: string) => void;\n};\n\nconst DataSourceSection = (props: DataSourceSectionProps) => {\n  const { datasourceUid, onChange } = props;\n  const datasources: DataSourceSelectItem[] = getDatasourceSrv()\n    .getExternal()\n    // At this moment only Jaeger and Zipkin datasource is supported as the link target.\n    .filter(ds => ds.meta.tracing)\n    .map(\n      ds =>\n        ({\n          value: ds.uid,\n          name: ds.name,\n          meta: ds.meta,\n        } as DataSourceSelectItem)\n    );\n\n  let selectedDatasource = datasourceUid && datasources.find(d => d.value === datasourceUid);\n  return (\n    <DataSourcePicker\n      // Uid and value should be always set in the db and so in the items.\n      onChange={ds => onChange(ds.value!)}\n      datasources={datasources}\n      current={selectedDatasource || undefined}\n    />\n  );\n};\n\nfunction useInternalLink(datasourceUid?: string): [boolean, Dispatch<SetStateAction<boolean>>] {\n  const [showInternalLink, setShowInternalLink] = useState<boolean>(!!datasourceUid);\n  const previousUid = usePrevious(datasourceUid);\n\n  // Force internal link visibility change if uid changed outside of this component.\n  useEffect(() => {\n    if (!previousUid && datasourceUid && !showInternalLink) {\n      setShowInternalLink(true);\n    }\n    if (previousUid && !datasourceUid && showInternalLink) {\n      setShowInternalLink(false);\n    }\n  }, [previousUid, datasourceUid, showInternalLink]);\n\n  return [showInternalLink, setShowInternalLink];\n}\n","import React from 'react';\nimport { css } from 'emotion';\nimport { Button, stylesFactory, useTheme } from '@grafana/ui';\nimport { GrafanaTheme, VariableOrigin, DataLinkBuiltInVars } from '@grafana/data';\nimport { DataLinkConfig } from '../types';\nimport { DataLink } from './DataLink';\n\nconst getStyles = stylesFactory((theme: GrafanaTheme) => ({\n  infoText: css`\n    padding-bottom: ${theme.spacing.md};\n    color: ${theme.colors.textWeak};\n  `,\n  dataLink: css`\n    margin-bottom: ${theme.spacing.sm};\n  `,\n}));\n\ntype Props = {\n  value?: DataLinkConfig[];\n  onChange: (value: DataLinkConfig[]) => void;\n};\nexport const DataLinks = (props: Props) => {\n  const { value, onChange } = props;\n  const theme = useTheme();\n  const styles = getStyles(theme);\n\n  return (\n    <>\n      <h3 className=\"page-heading\">Data links</h3>\n\n      <div className={styles.infoText}>\n        Add links to existing fields. Links will be shown in log row details next to the field value.\n      </div>\n\n      <div className=\"gf-form-group\">\n        {value &&\n          value.map((field, index) => {\n            return (\n              <DataLink\n                className={styles.dataLink}\n                key={index}\n                value={field}\n                onChange={newField => {\n                  const newDataLinks = [...value];\n                  newDataLinks.splice(index, 1, newField);\n                  onChange(newDataLinks);\n                }}\n                onDelete={() => {\n                  const newDataLinks = [...value];\n                  newDataLinks.splice(index, 1);\n                  onChange(newDataLinks);\n                }}\n                suggestions={[\n                  {\n                    value: DataLinkBuiltInVars.valueRaw,\n                    label: 'Raw value',\n                    documentation: 'Raw value of the field',\n                    origin: VariableOrigin.Value,\n                  },\n                ]}\n              />\n            );\n          })}\n        <div>\n          <Button\n            variant={'secondary'}\n            className={css`\n              margin-right: 10px;\n            `}\n            icon=\"plus\"\n            onClick={event => {\n              event.preventDefault();\n              const newDataLinks = [...(value || []), { field: '', url: '' }];\n              onChange(newDataLinks);\n            }}\n          >\n            Add\n          </Button>\n        </div>\n      </div>\n    </>\n  );\n};\n","import { DataSourcePlugin } from '@grafana/data';\nimport { ElasticDatasource } from './datasource';\nimport { ElasticQueryCtrl } from './query_ctrl';\nimport { ConfigEditor } from './configuration/ConfigEditor';\n\nclass ElasticAnnotationsQueryCtrl {\n  static templateUrl = 'partials/annotations.editor.html';\n}\n\nexport const plugin = new DataSourcePlugin(ElasticDatasource)\n  .setQueryCtrl(ElasticQueryCtrl)\n  .setConfigEditor(ConfigEditor)\n  .setAnnotationQueryCtrl(ElasticAnnotationsQueryCtrl);\n","import React, { useEffect } from 'react';\nimport { DataSourceHttpSettings } from '@grafana/ui';\nimport { DataSourcePluginOptionsEditorProps } from '@grafana/data';\nimport { ElasticsearchOptions } from '../types';\nimport { defaultMaxConcurrentShardRequests, ElasticDetails } from './ElasticDetails';\nimport { LogsConfig } from './LogsConfig';\nimport { DataLinks } from './DataLinks';\nimport { config } from 'app/core/config';\n\nexport type Props = DataSourcePluginOptionsEditorProps<ElasticsearchOptions>;\nexport const ConfigEditor = (props: Props) => {\n  const { options, onOptionsChange } = props;\n\n  // Apply some defaults on initial render\n  useEffect(() => {\n    const esVersion = options.jsonData.esVersion || 5;\n    onOptionsChange({\n      ...options,\n      jsonData: {\n        ...options.jsonData,\n        timeField: options.jsonData.timeField || '@timestamp',\n        esVersion,\n        maxConcurrentShardRequests:\n          options.jsonData.maxConcurrentShardRequests || defaultMaxConcurrentShardRequests(esVersion),\n        logMessageField: options.jsonData.logMessageField || '',\n        logLevelField: options.jsonData.logLevelField || '',\n      },\n    });\n  }, []);\n\n  return (\n    <>\n      <DataSourceHttpSettings\n        defaultUrl={'http://localhost:9200'}\n        dataSourceConfig={options}\n        showAccessOptions={true}\n        onChange={onOptionsChange}\n        sigV4AuthToggleEnabled={config.sigV4AuthEnabled}\n      />\n\n      <ElasticDetails value={options} onChange={onOptionsChange} />\n\n      <LogsConfig\n        value={options.jsonData}\n        onChange={newValue =>\n          onOptionsChange({\n            ...options,\n            jsonData: newValue,\n          })\n        }\n      />\n\n      <DataLinks\n        value={options.jsonData.dataLinks}\n        onChange={newValue => {\n          onOptionsChange({\n            ...options,\n            jsonData: {\n              ...options.jsonData,\n              dataLinks: newValue,\n            },\n          });\n        }}\n      />\n    </>\n  );\n};\n","// Libraries\nimport React, { PureComponent } from 'react';\n\n// Components\nimport { HorizontalGroup, Select } from '@grafana/ui';\nimport { SelectableValue, DataSourceSelectItem } from '@grafana/data';\nimport { selectors } from '@grafana/e2e-selectors';\nimport { isUnsignedPluginSignature, PluginSignatureBadge } from '../../../features/plugins/PluginSignatureBadge';\n\nexport interface Props {\n  onChange: (ds: DataSourceSelectItem) => void;\n  datasources: DataSourceSelectItem[];\n  current?: DataSourceSelectItem | null;\n  hideTextValue?: boolean;\n  onBlur?: () => void;\n  autoFocus?: boolean;\n  openMenuOnFocus?: boolean;\n  showLoading?: boolean;\n  placeholder?: string;\n  invalid?: boolean;\n}\n\nexport class DataSourcePicker extends PureComponent<Props> {\n  static defaultProps: Partial<Props> = {\n    autoFocus: false,\n    openMenuOnFocus: false,\n    placeholder: 'Select datasource',\n  };\n\n  searchInput: HTMLElement;\n\n  constructor(props: Props) {\n    super(props);\n  }\n\n  onChange = (item: SelectableValue<string>) => {\n    const ds = this.props.datasources.find(ds => ds.name === item.value);\n\n    if (ds) {\n      this.props.onChange(ds);\n    }\n  };\n\n  render() {\n    const {\n      datasources,\n      current,\n      autoFocus,\n      hideTextValue,\n      onBlur,\n      openMenuOnFocus,\n      showLoading,\n      placeholder,\n      invalid,\n    } = this.props;\n\n    const options = datasources.map(ds => ({\n      value: ds.name,\n      label: ds.name,\n      imgUrl: ds.meta.info.logos.small,\n      meta: ds.meta,\n    }));\n\n    const value = current && {\n      label: current.name.substr(0, 37),\n      value: current.name,\n      imgUrl: current.meta.info.logos.small,\n      loading: showLoading,\n      hideText: hideTextValue,\n      meta: current.meta,\n    };\n\n    return (\n      <div aria-label={selectors.components.DataSourcePicker.container}>\n        <Select\n          className=\"ds-picker select-container\"\n          isMulti={false}\n          isClearable={false}\n          backspaceRemovesValue={false}\n          onChange={this.onChange}\n          options={options}\n          autoFocus={autoFocus}\n          onBlur={onBlur}\n          openMenuOnFocus={openMenuOnFocus}\n          maxMenuHeight={500}\n          menuPlacement=\"bottom\"\n          placeholder={placeholder}\n          noOptionsMessage=\"No datasources found\"\n          value={value}\n          invalid={invalid}\n          getOptionLabel={o => {\n            if (isUnsignedPluginSignature(o.meta.signature) && o !== value) {\n              return (\n                <HorizontalGroup align=\"center\" justify=\"space-between\">\n                  <span>{o.label}</span> <PluginSignatureBadge status={o.meta.signature} />\n                </HorizontalGroup>\n              );\n            }\n            return o.label || '';\n          }}\n        />\n      </div>\n    );\n  }\n}\n\nexport default DataSourcePicker;\n","import { CompletionItem } from '@grafana/ui';\n\nexport const RATE_RANGES: CompletionItem[] = [\n  { label: '$__interval', sortText: '$__interval' },\n  { label: '$__rate_interval', sortText: '$__rate_interval' },\n  { label: '1m', sortText: '00:01:00' },\n  { label: '5m', sortText: '00:05:00' },\n  { label: '10m', sortText: '00:10:00' },\n  { label: '30m', sortText: '00:30:00' },\n  { label: '1h', sortText: '01:00:00' },\n  { label: '1d', sortText: '24:00:00' },\n];\n\nexport const OPERATORS = ['by', 'group_left', 'group_right', 'ignoring', 'on', 'offset', 'without'];\n\nconst AGGREGATION_OPERATORS: CompletionItem[] = [\n  {\n    label: 'sum',\n    insertText: 'sum',\n    documentation: 'Calculate sum over dimensions',\n  },\n  {\n    label: 'min',\n    insertText: 'min',\n    documentation: 'Select minimum over dimensions',\n  },\n  {\n    label: 'max',\n    insertText: 'max',\n    documentation: 'Select maximum over dimensions',\n  },\n  {\n    label: 'avg',\n    insertText: 'avg',\n    documentation: 'Calculate the average over dimensions',\n  },\n  {\n    label: 'stddev',\n    insertText: 'stddev',\n    documentation: 'Calculate population standard deviation over dimensions',\n  },\n  {\n    label: 'stdvar',\n    insertText: 'stdvar',\n    documentation: 'Calculate population standard variance over dimensions',\n  },\n  {\n    label: 'count',\n    insertText: 'count',\n    documentation: 'Count number of elements in the vector',\n  },\n  {\n    label: 'count_values',\n    insertText: 'count_values',\n    documentation: 'Count number of elements with the same value',\n  },\n  {\n    label: 'bottomk',\n    insertText: 'bottomk',\n    documentation: 'Smallest k elements by sample value',\n  },\n  {\n    label: 'topk',\n    insertText: 'topk',\n    documentation: 'Largest k elements by sample value',\n  },\n  {\n    label: 'quantile',\n    insertText: 'quantile',\n    documentation: 'Calculate φ-quantile (0 ≤ φ ≤ 1) over dimensions',\n  },\n];\n\nexport const FUNCTIONS = [\n  ...AGGREGATION_OPERATORS,\n  {\n    insertText: 'abs',\n    label: 'abs',\n    detail: 'abs(v instant-vector)',\n    documentation: 'Returns the input vector with all sample values converted to their absolute value.',\n  },\n  {\n    insertText: 'absent',\n    label: 'absent',\n    detail: 'absent(v instant-vector)',\n    documentation:\n      'Returns an empty vector if the vector passed to it has any elements and a 1-element vector with the value 1 if the vector passed to it has no elements. This is useful for alerting on when no time series exist for a given metric name and label combination.',\n  },\n  {\n    insertText: 'ceil',\n    label: 'ceil',\n    detail: 'ceil(v instant-vector)',\n    documentation: 'Rounds the sample values of all elements in `v` up to the nearest integer.',\n  },\n  {\n    insertText: 'changes',\n    label: 'changes',\n    detail: 'changes(v range-vector)',\n    documentation:\n      'For each input time series, `changes(v range-vector)` returns the number of times its value has changed within the provided time range as an instant vector.',\n  },\n  {\n    insertText: 'clamp_max',\n    label: 'clamp_max',\n    detail: 'clamp_max(v instant-vector, max scalar)',\n    documentation: 'Clamps the sample values of all elements in `v` to have an upper limit of `max`.',\n  },\n  {\n    insertText: 'clamp_min',\n    label: 'clamp_min',\n    detail: 'clamp_min(v instant-vector, min scalar)',\n    documentation: 'Clamps the sample values of all elements in `v` to have a lower limit of `min`.',\n  },\n  {\n    insertText: 'count_scalar',\n    label: 'count_scalar',\n    detail: 'count_scalar(v instant-vector)',\n    documentation:\n      'Returns the number of elements in a time series vector as a scalar. This is in contrast to the `count()` aggregation operator, which always returns a vector (an empty one if the input vector is empty) and allows grouping by labels via a `by` clause.',\n  },\n  {\n    insertText: 'day_of_month',\n    label: 'day_of_month',\n    detail: 'day_of_month(v=vector(time()) instant-vector)',\n    documentation: 'Returns the day of the month for each of the given times in UTC. Returned values are from 1 to 31.',\n  },\n  {\n    insertText: 'day_of_week',\n    label: 'day_of_week',\n    detail: 'day_of_week(v=vector(time()) instant-vector)',\n    documentation:\n      'Returns the day of the week for each of the given times in UTC. Returned values are from 0 to 6, where 0 means Sunday etc.',\n  },\n  {\n    insertText: 'days_in_month',\n    label: 'days_in_month',\n    detail: 'days_in_month(v=vector(time()) instant-vector)',\n    documentation:\n      'Returns number of days in the month for each of the given times in UTC. Returned values are from 28 to 31.',\n  },\n  {\n    insertText: 'delta',\n    label: 'delta',\n    detail: 'delta(v range-vector)',\n    documentation:\n      'Calculates the difference between the first and last value of each time series element in a range vector `v`, returning an instant vector with the given deltas and equivalent labels. The delta is extrapolated to cover the full time range as specified in the range vector selector, so that it is possible to get a non-integer result even if the sample values are all integers.',\n  },\n  {\n    insertText: 'deriv',\n    label: 'deriv',\n    detail: 'deriv(v range-vector)',\n    documentation:\n      'Calculates the per-second derivative of the time series in a range vector `v`, using simple linear regression.',\n  },\n  {\n    insertText: 'drop_common_labels',\n    label: 'drop_common_labels',\n    detail: 'drop_common_labels(instant-vector)',\n    documentation: 'Drops all labels that have the same name and value across all series in the input vector.',\n  },\n  {\n    insertText: 'exp',\n    label: 'exp',\n    detail: 'exp(v instant-vector)',\n    documentation:\n      'Calculates the exponential function for all elements in `v`.\\nSpecial cases are:\\n* `Exp(+Inf) = +Inf` \\n* `Exp(NaN) = NaN`',\n  },\n  {\n    insertText: 'floor',\n    label: 'floor',\n    detail: 'floor(v instant-vector)',\n    documentation: 'Rounds the sample values of all elements in `v` down to the nearest integer.',\n  },\n  {\n    insertText: 'histogram_quantile',\n    label: 'histogram_quantile',\n    detail: 'histogram_quantile(φ float, b instant-vector)',\n    documentation:\n      'Calculates the φ-quantile (0 ≤ φ ≤ 1) from the buckets `b` of a histogram. The samples in `b` are the counts of observations in each bucket. Each sample must have a label `le` where the label value denotes the inclusive upper bound of the bucket. (Samples without such a label are silently ignored.) The histogram metric type automatically provides time series with the `_bucket` suffix and the appropriate labels.',\n  },\n  {\n    insertText: 'holt_winters',\n    label: 'holt_winters',\n    detail: 'holt_winters(v range-vector, sf scalar, tf scalar)',\n    documentation:\n      'Produces a smoothed value for time series based on the range in `v`. The lower the smoothing factor `sf`, the more importance is given to old data. The higher the trend factor `tf`, the more trends in the data is considered. Both `sf` and `tf` must be between 0 and 1.',\n  },\n  {\n    insertText: 'hour',\n    label: 'hour',\n    detail: 'hour(v=vector(time()) instant-vector)',\n    documentation: 'Returns the hour of the day for each of the given times in UTC. Returned values are from 0 to 23.',\n  },\n  {\n    insertText: 'idelta',\n    label: 'idelta',\n    detail: 'idelta(v range-vector)',\n    documentation:\n      'Calculates the difference between the last two samples in the range vector `v`, returning an instant vector with the given deltas and equivalent labels.',\n  },\n  {\n    insertText: 'increase',\n    label: 'increase',\n    detail: 'increase(v range-vector)',\n    documentation:\n      'Calculates the increase in the time series in the range vector. Breaks in monotonicity (such as counter resets due to target restarts) are automatically adjusted for. The increase is extrapolated to cover the full time range as specified in the range vector selector, so that it is possible to get a non-integer result even if a counter increases only by integer increments.',\n  },\n  {\n    insertText: 'irate',\n    label: 'irate',\n    detail: 'irate(v range-vector)',\n    documentation:\n      'Calculates the per-second instant rate of increase of the time series in the range vector. This is based on the last two data points. Breaks in monotonicity (such as counter resets due to target restarts) are automatically adjusted for.',\n  },\n  {\n    insertText: 'label_replace',\n    label: 'label_replace',\n    detail: 'label_replace(v instant-vector, dst_label string, replacement string, src_label string, regex string)',\n    documentation:\n      \"For each timeseries in `v`, `label_replace(v instant-vector, dst_label string, replacement string, src_label string, regex string)`  matches the regular expression `regex` against the label `src_label`.  If it matches, then the timeseries is returned with the label `dst_label` replaced by the expansion of `replacement`. `$1` is replaced with the first matching subgroup, `$2` with the second etc. If the regular expression doesn't match then the timeseries is returned unchanged.\",\n  },\n  {\n    insertText: 'ln',\n    label: 'ln',\n    detail: 'ln(v instant-vector)',\n    documentation:\n      'calculates the natural logarithm for all elements in `v`.\\nSpecial cases are:\\n * `ln(+Inf) = +Inf`\\n * `ln(0) = -Inf`\\n * `ln(x < 0) = NaN`\\n * `ln(NaN) = NaN`',\n  },\n  {\n    insertText: 'log2',\n    label: 'log2',\n    detail: 'log2(v instant-vector)',\n    documentation:\n      'Calculates the binary logarithm for all elements in `v`. The special cases are equivalent to those in `ln`.',\n  },\n  {\n    insertText: 'log10',\n    label: 'log10',\n    detail: 'log10(v instant-vector)',\n    documentation:\n      'Calculates the decimal logarithm for all elements in `v`. The special cases are equivalent to those in `ln`.',\n  },\n  {\n    insertText: 'minute',\n    label: 'minute',\n    detail: 'minute(v=vector(time()) instant-vector)',\n    documentation:\n      'Returns the minute of the hour for each of the given times in UTC. Returned values are from 0 to 59.',\n  },\n  {\n    insertText: 'month',\n    label: 'month',\n    detail: 'month(v=vector(time()) instant-vector)',\n    documentation:\n      'Returns the month of the year for each of the given times in UTC. Returned values are from 1 to 12, where 1 means January etc.',\n  },\n  {\n    insertText: 'predict_linear',\n    label: 'predict_linear',\n    detail: 'predict_linear(v range-vector, t scalar)',\n    documentation:\n      'Predicts the value of time series `t` seconds from now, based on the range vector `v`, using simple linear regression.',\n  },\n  {\n    insertText: 'rate',\n    label: 'rate',\n    detail: 'rate(v range-vector)',\n    documentation:\n      \"Calculates the per-second average rate of increase of the time series in the range vector. Breaks in monotonicity (such as counter resets due to target restarts) are automatically adjusted for. Also, the calculation extrapolates to the ends of the time range, allowing for missed scrapes or imperfect alignment of scrape cycles with the range's time period.\",\n  },\n  {\n    insertText: 'resets',\n    label: 'resets',\n    detail: 'resets(v range-vector)',\n    documentation:\n      'For each input time series, `resets(v range-vector)` returns the number of counter resets within the provided time range as an instant vector. Any decrease in the value between two consecutive samples is interpreted as a counter reset.',\n  },\n  {\n    insertText: 'round',\n    label: 'round',\n    detail: 'round(v instant-vector, to_nearest=1 scalar)',\n    documentation:\n      'Rounds the sample values of all elements in `v` to the nearest integer. Ties are resolved by rounding up. The optional `to_nearest` argument allows specifying the nearest multiple to which the sample values should be rounded. This multiple may also be a fraction.',\n  },\n  {\n    insertText: 'scalar',\n    label: 'scalar',\n    detail: 'scalar(v instant-vector)',\n    documentation:\n      'Given a single-element input vector, `scalar(v instant-vector)` returns the sample value of that single element as a scalar. If the input vector does not have exactly one element, `scalar` will return `NaN`.',\n  },\n  {\n    insertText: 'sort',\n    label: 'sort',\n    detail: 'sort(v instant-vector)',\n    documentation: 'Returns vector elements sorted by their sample values, in ascending order.',\n  },\n  {\n    insertText: 'sort_desc',\n    label: 'sort_desc',\n    detail: 'sort_desc(v instant-vector)',\n    documentation: 'Returns vector elements sorted by their sample values, in descending order.',\n  },\n  {\n    insertText: 'sqrt',\n    label: 'sqrt',\n    detail: 'sqrt(v instant-vector)',\n    documentation: 'Calculates the square root of all elements in `v`.',\n  },\n  {\n    insertText: 'time',\n    label: 'time',\n    detail: 'time()',\n    documentation:\n      'Returns the number of seconds since January 1, 1970 UTC. Note that this does not actually return the current time, but the time at which the expression is to be evaluated.',\n  },\n  {\n    insertText: 'vector',\n    label: 'vector',\n    detail: 'vector(s scalar)',\n    documentation: 'Returns the scalar `s` as a vector with no labels.',\n  },\n  {\n    insertText: 'year',\n    label: 'year',\n    detail: 'year(v=vector(time()) instant-vector)',\n    documentation: 'Returns the year for each of the given times in UTC.',\n  },\n  {\n    insertText: 'avg_over_time',\n    label: 'avg_over_time',\n    detail: 'avg_over_time(range-vector)',\n    documentation: 'The average value of all points in the specified interval.',\n  },\n  {\n    insertText: 'min_over_time',\n    label: 'min_over_time',\n    detail: 'min_over_time(range-vector)',\n    documentation: 'The minimum value of all points in the specified interval.',\n  },\n  {\n    insertText: 'max_over_time',\n    label: 'max_over_time',\n    detail: 'max_over_time(range-vector)',\n    documentation: 'The maximum value of all points in the specified interval.',\n  },\n  {\n    insertText: 'sum_over_time',\n    label: 'sum_over_time',\n    detail: 'sum_over_time(range-vector)',\n    documentation: 'The sum of all values in the specified interval.',\n  },\n  {\n    insertText: 'count_over_time',\n    label: 'count_over_time',\n    detail: 'count_over_time(range-vector)',\n    documentation: 'The count of all values in the specified interval.',\n  },\n  {\n    insertText: 'quantile_over_time',\n    label: 'quantile_over_time',\n    detail: 'quantile_over_time(scalar, range-vector)',\n    documentation: 'The φ-quantile (0 ≤ φ ≤ 1) of the values in the specified interval.',\n  },\n  {\n    insertText: 'stddev_over_time',\n    label: 'stddev_over_time',\n    detail: 'stddev_over_time(range-vector)',\n    documentation: 'The population standard deviation of the values in the specified interval.',\n  },\n  {\n    insertText: 'stdvar_over_time',\n    label: 'stdvar_over_time',\n    detail: 'stdvar_over_time(range-vector)',\n    documentation: 'The population standard variance of the values in the specified interval.',\n  },\n];\n\nconst tokenizer = {\n  comment: {\n    pattern: /#.*/,\n  },\n  'context-aggregation': {\n    pattern: /((by|without)\\s*)\\([^)]*\\)/, // by ()\n    lookbehind: true,\n    inside: {\n      'label-key': {\n        pattern: /[^(),\\s][^,)]*[^),\\s]*/,\n        alias: 'attr-name',\n      },\n      punctuation: /[()]/,\n    },\n  },\n  'context-labels': {\n    pattern: /\\{[^}]*(?=})/,\n    greedy: true,\n    inside: {\n      comment: {\n        pattern: /#.*/,\n      },\n      'label-key': {\n        pattern: /[a-z_]\\w*(?=\\s*(=|!=|=~|!~))/,\n        alias: 'attr-name',\n        greedy: true,\n      },\n      'label-value': {\n        pattern: /\"(?:\\\\.|[^\\\\\"])*\"/,\n        greedy: true,\n        alias: 'attr-value',\n      },\n      punctuation: /[{]/,\n    },\n  },\n  function: new RegExp(`\\\\b(?:${FUNCTIONS.map(f => f.label).join('|')})(?=\\\\s*\\\\()`, 'i'),\n  'context-range': [\n    {\n      pattern: /\\[[^\\]]*(?=])/, // [1m]\n      inside: {\n        'range-duration': {\n          pattern: /\\b\\d+[smhdwy]\\b/i,\n          alias: 'number',\n        },\n      },\n    },\n    {\n      pattern: /(offset\\s+)\\w+/, // offset 1m\n      lookbehind: true,\n      inside: {\n        'range-duration': {\n          pattern: /\\b\\d+[smhdwy]\\b/i,\n          alias: 'number',\n        },\n      },\n    },\n  ],\n  number: /\\b-?\\d+((\\.\\d*)?([eE][+-]?\\d+)?)?\\b/,\n  operator: new RegExp(`/[-+*/=%^~]|&&?|\\\\|?\\\\||!=?|<(?:=>?|<|>)?|>[>=]?|\\\\b(?:${OPERATORS.join('|')})\\\\b`, 'i'),\n  punctuation: /[{};()`,.]/,\n};\n\nexport default tokenizer;\n"],"sourceRoot":""}