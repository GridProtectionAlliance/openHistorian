{"version":3,"sources":["webpack:///./public/app/plugins/datasource/prometheus/language_provider.ts","webpack:///./public/app/plugins/datasource/prometheus/metric_find_query.ts","webpack:///./public/app/plugins/datasource/prometheus/query_hints.ts","webpack:///./public/app/plugins/datasource/prometheus/types.ts","webpack:///./public/app/plugins/datasource/prometheus/result_transformer.ts","webpack:///./public/app/plugins/datasource/prometheus/datasource.ts","webpack:///./public/app/plugins/datasource/prometheus/components/PromQueryField.tsx","webpack:///./public/app/plugins/datasource/prometheus/components/PromLink.tsx","webpack:///./public/app/plugins/datasource/prometheus/components/PromQueryEditor.tsx","webpack:///./public/app/plugins/datasource/prometheus/components/PromCheatSheet.tsx","webpack:///./public/app/plugins/datasource/prometheus/components/PromExploreExtraField.tsx","webpack:///./public/app/plugins/datasource/prometheus/components/PromExploreQueryEditor.tsx","webpack:///./public/app/plugins/datasource/prometheus/configuration/PromSettings.tsx","webpack:///./public/app/plugins/datasource/prometheus/module.ts","webpack:///./public/app/plugins/datasource/prometheus/configuration/ConfigEditor.tsx","webpack:///./public/app/core/utils/CancelablePromise.ts"],"names":["DEFAULT_KEYS","wrapLabel","label","setFunctionKind","suggestion","kind","PREFIX_DELIMITER_REGEX","PromQlLanguageProvider","datasource","initialValues","labelsCache","LRU","request","url","defaultValue","metadataRequest","res","data","console","error","start","lookupsDisabled","tRange","getTimeRange","params","URLSearchParams","toString","end","metrics","length","lookupMetricsThreshold","fixSummariesMetadata","metricsMetadata","processHistogramMetrics","values","processHistogramLabels","histogramMetrics","slice","sort","provideCompletionItems","prefix","text","value","labelKey","wrapperClasses","context","history","emptyResult","suggestions","empty","document","selectedLines","getTextsAtRange","selection","currentLine","size","first","getText","nextCharacter","anchor","offset","tokenRecognized","prefixUnrecognized","noSuffix","safePrefix","match","operatorsPattern","isNextOperand","includes","getRangeCompletionItems","getLabelCompletionItems","getAggregationCompletionItems","getEmptyCompletionItems","getBeginningCompletionItems","getTermCompletionItems","historyItems","_","chain","map","h","query","expr","filter","uniq","take","item","cutoffTs","Date","now","historyForItem","ts","count","recent","hint","lastQueried","dateTime","fromNow","documentation","addHistoryMetadata","push","prefixMatch","skipSort","items","FUNCTIONS","m","metric","metadata","type","help","toUpperCase","addMetricsMetadata","queryText","getBlocks","reduce","block","blockText","anchorBlock","key","queryOffset","openParensAggregationIndex","lastIndexOf","openParensSelectorIndex","closeParensSelectorIndex","indexOf","closeParensAggregationIndex","result","selectorString","replace","selector","parseSelector","getLabelValues","labelValues","Object","keys","line","cursorOffset","suffix","substr","isValueStart","isValueEnd","isPreValue","hasValuePrefix","parsedSelector","containsMetric","existingKeys","labelKeys","warn","possibleKeys","difference","newItems","newSuggestion","fetchLabelValues","fetchSeriesLabels","name","withName","set","roundToMinutes","append","cacheKey","get","processLabels","fetchDefaultLabels","once","Promise","all","acc","timeRange","assign","s","split","pop","trimLeft","RATE_RANGES","this","undefined","seconds","Math","floor","PromqlSyntax","LanguageProvider","PrometheusMetricFindQuery","range","getTimeSrv","labelNamesQuery","labelValuesQuery","metricNamesQuery","metricNameQuery","queryResultQuery","toPromise","metricNameAndLabelsQuery","getPrometheusTime","from","to","then","_labels","expandable","metricFilterPattern","metricName","RegExp","test","matchedMetricName","instantQuery","performInstantQuery","pipe","metricData","__name__","v","k","join","self","getOriginalMetricName","getQueryHints","series","hints","trim","fix","action","nameMatch","counterNameMetric","languageProvider","metricMetadataKeys","certain","find","toLowerCase","metricRegex","simpleMetric","verb","ruleMappings","mapping","mappingForQuery","ruleName","search","preventSubmit","isFetchErrorResponse","response","isMatrixData","transform","transformOptions","options","format","target","step","legendFormat","responseListLength","scopedVars","refId","valueWithRefId","meta","preferredVisualisationType","getPreferredVisualisationType","instant","mixedQueries","prometheusResult","resultType","fields","getTimeField","getValueField","md","valueText","timeField","metricFields","config","filterable","FieldType","other","ArrayVector","valueField","valueName","forEach","d","val","add","metricField","getLabelValue","parseSampleValue","transformMetricDataToTable","dataFrame","labels","renderTemplate","getTemplateSrv","labelsWithoutName","labelPart","formatLabels","createLabelInfo","stepMs","NaN","baseTimestamp","dps","dpValue","isNaN","timestamp","t","endTimestamp","parseValue","displayName","transformToDataFrame","sortSeriesByLabel","seriesList","i","topSeries","TIME_SERIES_VALUE_FIELD_NAME","bottomSeries","Error","j","bottomPoint","toArray","transformToHistogramOverTime","isInstantQuery","hasOwnProperty","isMs","TIME_SERIES_TIME_FIELD_NAME","time","number","aliasPattern","aliasData","_match","g1","s1","s2","le1","le2","err","Number","POSITIVE_INFINITY","NEGATIVE_INFINITY","parseFloat","PrometheusDatasource","instanceSettings","templateSrv","timeSrv","metricsNameCache","init","loadRules","prepareTargets","queries","activeTargets","targets","hide","requestId","panelId","instantTarget","cloneDeep","maxDataPoints","rangeTarget","createQuery","app","CoreApp","Explore","handleErrors","message","statusText","safeStringifyValue","status","createAnnotationQueryOptions","annotation","interval","editorSrc","basicAuth","withCredentials","jsonData","timeInterval","queryTimeout","httpMethod","directUrl","PrometheusLanguageProvider","disableMetricsLookup","customQueryParameters","httpOptions","headers","dashboardId","overrides","defaults","method","entries","encodeURIComponent","Authorization","getBackendSrv","fetch","_request","hideFromInspector","variable","multi","includeAll","prometheusRegularEscape","prometheusSpecialRegexEscape","escapedValues","variableExists","exploreQuery","panelsQuery","of","state","LoadingState","Done","runningQueriesCount","some","subQueries","index","filterAndMapResponse","tap","cancelled","Loading","performTimeSeriesQuery","merge","observables","forkJoin","results","current","hinting","ceil","rangeUtil","intervalToSeconds","minInterval","scrapeInterval","intervalFactor","adjustedInterval","adjustInterval","getRangeScopedVars","getRateIntervalScopedVariable","__interval","__interval_ms","getAdhocFilters","operator","addLabelToQuery","interpolateQueryExpr","adjusted","utcOffsetSec","alignedEnd","alignedStart","alignRange","utcOffset","_addTracingHeaders","rateInterval","max","__rate_interval","safeInterval","catchError","throwError","resolve","intervalToMs","interpolated","metricFindQuery","process","msRange","diff","sRange","round","__range_ms","__range_s","__range","tagKeys","titleFormat","textFormat","queryOptions","queryModel","eventList","splitKeys","tags","timestampValue","useValueForTime","activeValuesTimestamps","latestEvent","timeEnd","title","getTime","expandedQueries","groups","extractRuleMappingFromGroups","log","expression","expandRecordingRules","date","roundUp","dateMath","parse","valueOf","labelData","DataSourceApi","group","rules","rule","HISTOGRAM_GROUP","willApplySuggestion","typeaheadContext","typeaheadText","nextChar","DOMUtil","getNextCharacter","PromQueryField","props","refreshHint","isDataFrame","toLegacyResponseData","setState","refreshMetrics","Prism","languages","syntax","languageProviderInitializationPromise","makePromiseCancelable","promise","remainingTasks","onUpdateLanguage","isCanceled","onChangeMetrics","selectedOptions","selectedOption","children","onChangeQuery","override","onChange","onRunQuery","onClickHintFix","modifyQuery","metricsByPrefix","ruleRegex","ruleNames","rulesOption","metricsOptions","groupBy","metricsForPrefix","option","sortBy","groupMetricsByPrefix","histogramOptions","hm","isLeaf","syntaxLoaded","onTypeahead","typeahead","plugins","BracesPlugin","SlatePrism","onlyIn","node","getSyntax","cancel","prevProps","rangeChanged","isEqual","metricsLookupDisabled","hasSyntax","ExtraFieldElement","cleanText","chooserText","buttonDisabled","className","disabled","additionalPlugins","onWillApplySuggestion","onBlur","placeholder","portalOrigin","onClick","React","PureComponent","PromLink","href","panelData","getExternalLink","rangeDiff","endTime","utc","args","rel","Component","Switch","LegacyForms","FORMAT_OPTIONS","INTERVAL_FACTOR_OPTIONS","PromQueryEditor","onFieldChange","onFormatChange","formatOption","onInstantChange","e","checked","onIntervalChange","currentTarget","onIntervalFactorChange","intervalFactorOption","onLegendChange","Boolean","width","tooltip","isSearchable","menuPlacement","CHEAT_SHEET_ITEMS","PromExploreExtraField","memo","queryType","stepValue","onStepChange","onQueryTypeChange","onKeyDownFunc","aria-label","data-testid","cx","css","onKeyDown","onChangeQueryStep","shiftKey","ctrlKey","Select","Input","FormField","PromSettings","onOptionsChange","labelWidth","inputEl","spellCheck","onChangeHandler","validationEvents","promSettingsValidationEvents","o","labelClass","onUpdateDatasourceJsonDataOptionChecked","EventsWithValidation","regexValidation","getValueFromEventItem","eventItem","PrometheusAnnotationsQueryCtrl","stepDefaultValuePlaceholder","templateUrl","plugin","DataSourcePlugin","setQueryEditor","setConfigEditor","defaultUrl","dataSourceConfig","showAccessOptions","sigV4AuthToggleEnabled","sigV4AuthEnabled","setExploreMetricsQueryField","PromExploreQueryEditor","setAnnotationQueryCtrl","setExploreStartPage","onClickExample","hasCanceled_","reject","catch"],"mappings":"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","file":"prometheusPlugin.591ee81e63053ad31983.js","sourcesContent":["import _ from 'lodash';\nimport LRU from 'lru-cache';\nimport { Value } from 'slate';\n\nimport { dateTime, HistoryItem, LanguageProvider } from '@grafana/data';\nimport { CompletionItem, CompletionItemGroup, TypeaheadInput, TypeaheadOutput } from '@grafana/ui';\n\nimport { fixSummariesMetadata, parseSelector, processHistogramLabels, processLabels } from './language_utils';\nimport PromqlSyntax, { FUNCTIONS, RATE_RANGES } from './promql';\n\nimport { PrometheusDatasource } from './datasource';\nimport { PromMetricsMetadata, PromQuery } from './types';\n\nconst DEFAULT_KEYS = ['job', 'instance'];\nconst EMPTY_SELECTOR = '{}';\nconst HISTORY_ITEM_COUNT = 5;\nconst HISTORY_COUNT_CUTOFF = 1000 * 60 * 60 * 24; // 24h\nexport const DEFAULT_LOOKUP_METRICS_THRESHOLD = 10000; // number of metrics defining an installation that's too big\n\nconst wrapLabel = (label: string): CompletionItem => ({ label });\n\nconst setFunctionKind = (suggestion: CompletionItem): CompletionItem => {\n  suggestion.kind = 'function';\n  return suggestion;\n};\n\nexport function addHistoryMetadata(item: CompletionItem, history: any[]): CompletionItem {\n  const cutoffTs = Date.now() - HISTORY_COUNT_CUTOFF;\n  const historyForItem = history.filter(h => h.ts > cutoffTs && h.query === item.label);\n  const count = historyForItem.length;\n  const recent = historyForItem[0];\n  let hint = `Queried ${count} times in the last 24h.`;\n\n  if (recent) {\n    const lastQueried = dateTime(recent.ts).fromNow();\n    hint = `${hint} Last queried ${lastQueried}.`;\n  }\n\n  return {\n    ...item,\n    documentation: hint,\n  };\n}\n\nfunction addMetricsMetadata(metric: string, metadata?: PromMetricsMetadata): CompletionItem {\n  const item: CompletionItem = { label: metric };\n  if (metadata && metadata[metric]) {\n    const { type, help } = metadata[metric][0];\n    item.documentation = `${type.toUpperCase()}: ${help}`;\n  }\n  return item;\n}\n\nconst PREFIX_DELIMITER_REGEX = /(=\"|!=\"|=~\"|!~\"|\\{|\\[|\\(|\\+|-|\\/|\\*|%|\\^|\\band\\b|\\bor\\b|\\bunless\\b|==|>=|!=|<=|>|<|=|~|,)/;\n\nexport default class PromQlLanguageProvider extends LanguageProvider {\n  histogramMetrics: string[];\n  timeRange?: { start: number; end: number };\n  metrics: string[];\n  metricsMetadata?: PromMetricsMetadata;\n  startTask: Promise<any>;\n  datasource: PrometheusDatasource;\n  lookupMetricsThreshold: number;\n  lookupsDisabled: boolean; // Dynamically set to true for big/slow instances\n\n  /**\n   *  Cache for labels of series. This is bit simplistic in the sense that it just counts responses each as a 1 and does\n   *  not account for different size of a response. If that is needed a `length` function can be added in the options.\n   *  10 as a max size is totally arbitrary right now.\n   */\n  private labelsCache = new LRU<string, Record<string, string[]>>(10);\n\n  constructor(datasource: PrometheusDatasource, initialValues?: Partial<PromQlLanguageProvider>) {\n    super();\n\n    this.datasource = datasource;\n    this.histogramMetrics = [];\n    this.timeRange = { start: 0, end: 0 };\n    this.metrics = [];\n    // Disable lookups until we know the instance is small enough\n    this.lookupMetricsThreshold = DEFAULT_LOOKUP_METRICS_THRESHOLD;\n    this.lookupsDisabled = true;\n\n    Object.assign(this, initialValues);\n  }\n\n  // Strip syntax chars so that typeahead suggestions can work on clean inputs\n  cleanText(s: string) {\n    const parts = s.split(PREFIX_DELIMITER_REGEX);\n    const last = parts.pop()!;\n    return last\n      .trimLeft()\n      .replace(/\"$/, '')\n      .replace(/^\"/, '');\n  }\n\n  get syntax() {\n    return PromqlSyntax;\n  }\n\n  request = async (url: string, defaultValue: any): Promise<any> => {\n    try {\n      const res = await this.datasource.metadataRequest(url);\n      return res.data.data;\n    } catch (error) {\n      console.error(error);\n    }\n\n    return defaultValue;\n  };\n\n  start = async (): Promise<any[]> => {\n    if (this.datasource.lookupsDisabled) {\n      return [];\n    }\n\n    const tRange = this.datasource.getTimeRange();\n    const params = new URLSearchParams({\n      start: tRange['start'].toString(),\n      end: tRange['end'].toString(),\n    });\n    const url = `/api/v1/label/__name__/values?${params.toString()}`;\n\n    this.metrics = await this.request(url, []);\n    this.lookupsDisabled = this.metrics.length > this.lookupMetricsThreshold;\n    this.metricsMetadata = fixSummariesMetadata(await this.request('/api/v1/metadata', {}));\n    this.processHistogramMetrics(this.metrics);\n\n    return [];\n  };\n\n  processHistogramMetrics = (data: string[]) => {\n    const { values } = processHistogramLabels(data);\n\n    if (values && values['__name__']) {\n      this.histogramMetrics = values['__name__'].slice().sort();\n    }\n  };\n\n  provideCompletionItems = async (\n    { prefix, text, value, labelKey, wrapperClasses }: TypeaheadInput,\n    context: { history: Array<HistoryItem<PromQuery>> } = { history: [] }\n  ): Promise<TypeaheadOutput> => {\n    const emptyResult: TypeaheadOutput = { suggestions: [] };\n\n    if (!value) {\n      return emptyResult;\n    }\n\n    // Local text properties\n    const empty = value.document.text.length === 0;\n    const selectedLines = value.document.getTextsAtRange(value.selection);\n    const currentLine = selectedLines.size === 1 ? selectedLines.first().getText() : null;\n\n    const nextCharacter = currentLine ? currentLine[value.selection.anchor.offset] : null;\n\n    // Syntax spans have 3 classes by default. More indicate a recognized token\n    const tokenRecognized = wrapperClasses.length > 3;\n    // Non-empty prefix, but not inside known token\n    const prefixUnrecognized = prefix && !tokenRecognized;\n\n    // Prevent suggestions in `function(|suffix)`\n    const noSuffix = !nextCharacter || nextCharacter === ')';\n\n    // Prefix is safe if it does not immediately follow a complete expression and has no text after it\n    const safePrefix = prefix && !text.match(/^[\\]})\\s]+$/) && noSuffix;\n\n    // About to type next operand if preceded by binary operator\n    const operatorsPattern = /[+\\-*/^%]/;\n    const isNextOperand = text.match(operatorsPattern);\n\n    // Determine candidates by CSS context\n    if (wrapperClasses.includes('context-range')) {\n      // Suggestions for metric[|]\n      return this.getRangeCompletionItems();\n    } else if (wrapperClasses.includes('context-labels')) {\n      // Suggestions for metric{|} and metric{foo=|}, as well as metric-independent label queries like {|}\n      return this.getLabelCompletionItems({ prefix, text, value, labelKey, wrapperClasses });\n    } else if (wrapperClasses.includes('context-aggregation')) {\n      // Suggestions for sum(metric) by (|)\n      return this.getAggregationCompletionItems(value);\n    } else if (empty) {\n      // Suggestions for empty query field\n      return this.getEmptyCompletionItems(context);\n    } else if (prefixUnrecognized && noSuffix && !isNextOperand) {\n      // Show term suggestions in a couple of scenarios\n      return this.getBeginningCompletionItems(context);\n    } else if (prefixUnrecognized && safePrefix) {\n      // Show term suggestions in a couple of scenarios\n      return this.getTermCompletionItems();\n    }\n\n    return emptyResult;\n  };\n\n  getBeginningCompletionItems = (context: { history: Array<HistoryItem<PromQuery>> }): TypeaheadOutput => {\n    return {\n      suggestions: [...this.getEmptyCompletionItems(context).suggestions, ...this.getTermCompletionItems().suggestions],\n    };\n  };\n\n  getEmptyCompletionItems = (context: { history: Array<HistoryItem<PromQuery>> }): TypeaheadOutput => {\n    const { history } = context;\n    const suggestions = [];\n\n    if (history && history.length) {\n      const historyItems = _.chain(history)\n        .map(h => h.query.expr)\n        .filter()\n        .uniq()\n        .take(HISTORY_ITEM_COUNT)\n        .map(wrapLabel)\n        .map(item => addHistoryMetadata(item, history))\n        .value();\n\n      suggestions.push({\n        prefixMatch: true,\n        skipSort: true,\n        label: 'History',\n        items: historyItems,\n      });\n    }\n\n    return { suggestions };\n  };\n\n  getTermCompletionItems = (): TypeaheadOutput => {\n    const { metrics, metricsMetadata } = this;\n    const suggestions = [];\n\n    suggestions.push({\n      prefixMatch: true,\n      label: 'Functions',\n      items: FUNCTIONS.map(setFunctionKind),\n    });\n\n    if (metrics && metrics.length) {\n      suggestions.push({\n        label: 'Metrics',\n        items: metrics.map(m => addMetricsMetadata(m, metricsMetadata)),\n      });\n    }\n\n    return { suggestions };\n  };\n\n  getRangeCompletionItems(): TypeaheadOutput {\n    return {\n      context: 'context-range',\n      suggestions: [\n        {\n          label: 'Range vector',\n          items: [...RATE_RANGES],\n        },\n      ],\n    };\n  }\n\n  getAggregationCompletionItems = async (value: Value): Promise<TypeaheadOutput> => {\n    const suggestions: CompletionItemGroup[] = [];\n\n    // Stitch all query lines together to support multi-line queries\n    let queryOffset;\n    const queryText = value.document.getBlocks().reduce((text: string, block) => {\n      if (!block) {\n        return text;\n      }\n\n      const blockText = block?.getText();\n\n      if (value.anchorBlock.key === block.key) {\n        // Newline characters are not accounted for but this is irrelevant\n        // for the purpose of extracting the selector string\n        queryOffset = value.selection.anchor.offset + text.length;\n      }\n\n      return text + blockText;\n    }, '');\n\n    // Try search for selector part on the left-hand side, such as `sum (m) by (l)`\n    const openParensAggregationIndex = queryText.lastIndexOf('(', queryOffset);\n    let openParensSelectorIndex = queryText.lastIndexOf('(', openParensAggregationIndex - 1);\n    let closeParensSelectorIndex = queryText.indexOf(')', openParensSelectorIndex);\n\n    // Try search for selector part of an alternate aggregation clause, such as `sum by (l) (m)`\n    if (openParensSelectorIndex === -1) {\n      const closeParensAggregationIndex = queryText.indexOf(')', queryOffset);\n      closeParensSelectorIndex = queryText.indexOf(')', closeParensAggregationIndex + 1);\n      openParensSelectorIndex = queryText.lastIndexOf('(', closeParensSelectorIndex);\n    }\n\n    const result = {\n      suggestions,\n      context: 'context-aggregation',\n    };\n\n    // Suggestions are useless for alternative aggregation clauses without a selector in context\n    if (openParensSelectorIndex === -1) {\n      return result;\n    }\n\n    // Range vector syntax not accounted for by subsequent parse so discard it if present\n    const selectorString = queryText\n      .slice(openParensSelectorIndex + 1, closeParensSelectorIndex)\n      .replace(/\\[[^\\]]+\\]$/, '');\n\n    const selector = parseSelector(selectorString, selectorString.length - 2).selector;\n\n    const labelValues = await this.getLabelValues(selector);\n    if (labelValues) {\n      suggestions.push({ label: 'Labels', items: Object.keys(labelValues).map(wrapLabel) });\n    }\n    return result;\n  };\n\n  getLabelCompletionItems = async ({\n    text,\n    wrapperClasses,\n    labelKey,\n    value,\n  }: TypeaheadInput): Promise<TypeaheadOutput> => {\n    if (!value) {\n      return { suggestions: [] };\n    }\n\n    const suggestions: CompletionItemGroup[] = [];\n    const line = value.anchorBlock.getText();\n    const cursorOffset = value.selection.anchor.offset;\n    const suffix = line.substr(cursorOffset);\n    const prefix = line.substr(0, cursorOffset);\n    const isValueStart = text.match(/^(=|=~|!=|!~)/);\n    const isValueEnd = suffix.match(/^\"?[,}]/);\n    // detect cursor in front of value, e.g., {key=|\"}\n    const isPreValue = prefix.match(/(=|=~|!=|!~)$/) && suffix.match(/^\"/);\n\n    // Don't suggestq anything at the beginning or inside a value\n    const isValueEmpty = isValueStart && isValueEnd;\n    const hasValuePrefix = isValueEnd && !isValueStart;\n    if ((!isValueEmpty && !hasValuePrefix) || isPreValue) {\n      return { suggestions };\n    }\n\n    // Get normalized selector\n    let selector;\n    let parsedSelector;\n    try {\n      parsedSelector = parseSelector(line, cursorOffset);\n      selector = parsedSelector.selector;\n    } catch {\n      selector = EMPTY_SELECTOR;\n    }\n\n    const containsMetric = selector.includes('__name__=');\n    const existingKeys = parsedSelector ? parsedSelector.labelKeys : [];\n\n    let labelValues;\n    // Query labels for selector\n    if (selector) {\n      labelValues = await this.getLabelValues(selector, !containsMetric);\n    }\n\n    if (!labelValues) {\n      console.warn(`Server did not return any values for selector = ${selector}`);\n      return { suggestions };\n    }\n\n    let context: string | undefined;\n\n    if ((text && isValueStart) || wrapperClasses.includes('attr-value')) {\n      // Label values\n      if (labelKey && labelValues[labelKey]) {\n        context = 'context-label-values';\n        suggestions.push({\n          label: `Label values for \"${labelKey}\"`,\n          items: labelValues[labelKey].map(wrapLabel),\n        });\n      }\n    } else {\n      // Label keys\n      const labelKeys = labelValues ? Object.keys(labelValues) : containsMetric ? null : DEFAULT_KEYS;\n\n      if (labelKeys) {\n        const possibleKeys = _.difference(labelKeys, existingKeys);\n        if (possibleKeys.length) {\n          context = 'context-labels';\n          const newItems = possibleKeys.map(key => ({ label: key }));\n          const newSuggestion: CompletionItemGroup = { label: `Labels`, items: newItems };\n          suggestions.push(newSuggestion);\n        }\n      }\n    }\n\n    return { context, suggestions };\n  };\n\n  async getLabelValues(selector: string, withName?: boolean) {\n    if (this.lookupsDisabled) {\n      return undefined;\n    }\n    try {\n      if (selector === EMPTY_SELECTOR) {\n        return await this.fetchDefaultLabels();\n      } else {\n        return await this.fetchSeriesLabels(selector, withName);\n      }\n    } catch (error) {\n      // TODO: better error handling\n      console.error(error);\n      return undefined;\n    }\n  }\n\n  fetchLabelValues = async (key: string): Promise<Record<string, string[]>> => {\n    const tRange = this.datasource.getTimeRange();\n    const params = new URLSearchParams({\n      start: tRange['start'].toString(),\n      end: tRange['end'].toString(),\n    });\n    const url = `/api/v1/label/${key}/values?${params.toString()}`;\n    const data = await this.request(url, []);\n    return { [key]: data };\n  };\n\n  roundToMinutes(seconds: number): number {\n    return Math.floor(seconds / 60);\n  }\n\n  /**\n   * Fetch labels for a series. This is cached by it's args but also by the global timeRange currently selected as\n   * they can change over requested time.\n   * @param name\n   * @param withName\n   */\n  fetchSeriesLabels = async (name: string, withName?: boolean): Promise<Record<string, string[]>> => {\n    const tRange = this.datasource.getTimeRange();\n    const params = new URLSearchParams({\n      'match[]': name,\n      start: tRange['start'].toString(),\n      end: tRange['end'].toString(),\n    });\n    const url = `/api/v1/series?${params.toString()}`;\n    // Cache key is a bit different here. We add the `withName` param and also round up to a minute the intervals.\n    // The rounding may seem strange but makes relative intervals like now-1h less prone to need separate request every\n    // millisecond while still actually getting all the keys for the correct interval. This still can create problems\n    // when user does not the newest values for a minute if already cached.\n    params.set('start', this.roundToMinutes(tRange['start']).toString());\n    params.set('end', this.roundToMinutes(tRange['end']).toString());\n    params.append('withName', withName ? 'true' : 'false');\n    const cacheKey = `/api/v1/series?${params.toString()}`;\n    let value = this.labelsCache.get(cacheKey);\n    if (!value) {\n      const data = await this.request(url, []);\n      const { values } = processLabels(data, withName);\n      value = values;\n      this.labelsCache.set(cacheKey, value);\n    }\n    return value;\n  };\n\n  /**\n   * Fetch this only one as we assume this won't change over time. This is cached differently from fetchSeriesLabels\n   * because we can cache more aggressively here and also we do not want to invalidate this cache the same way as in\n   * fetchSeriesLabels.\n   */\n  fetchDefaultLabels = _.once(async () => {\n    const values = await Promise.all(DEFAULT_KEYS.map(key => this.fetchLabelValues(key)));\n    return values.reduce((acc, value) => ({ ...acc, ...value }), {});\n  });\n}\n","import _ from 'lodash';\nimport { map } from 'rxjs/operators';\nimport { MetricFindValue, TimeRange } from '@grafana/data';\nimport { PrometheusDatasource } from './datasource';\nimport { PromQueryRequest } from './types';\nimport { getTimeSrv } from 'app/features/dashboard/services/TimeSrv';\n\nexport default class PrometheusMetricFindQuery {\n  range: TimeRange;\n\n  constructor(private datasource: PrometheusDatasource, private query: string) {\n    this.datasource = datasource;\n    this.query = query;\n    this.range = getTimeSrv().timeRange();\n  }\n\n  process(): Promise<MetricFindValue[]> {\n    const labelNamesRegex = /^label_names\\(\\)\\s*$/;\n    const labelValuesRegex = /^label_values\\((?:(.+),\\s*)?([a-zA-Z_][a-zA-Z0-9_]*)\\)\\s*$/;\n    const metricNamesRegex = /^metrics\\((.+)\\)\\s*$/;\n    const queryResultRegex = /^query_result\\((.+)\\)\\s*$/;\n    const labelNamesQuery = this.query.match(labelNamesRegex);\n    if (labelNamesQuery) {\n      return this.labelNamesQuery();\n    }\n\n    const labelValuesQuery = this.query.match(labelValuesRegex);\n    if (labelValuesQuery) {\n      if (labelValuesQuery[1]) {\n        return this.labelValuesQuery(labelValuesQuery[2], labelValuesQuery[1]);\n      } else {\n        return this.labelValuesQuery(labelValuesQuery[2]);\n      }\n    }\n\n    const metricNamesQuery = this.query.match(metricNamesRegex);\n    if (metricNamesQuery) {\n      return this.metricNameQuery(metricNamesQuery[1]);\n    }\n\n    const queryResultQuery = this.query.match(queryResultRegex);\n    if (queryResultQuery) {\n      return this.queryResultQuery(queryResultQuery[1]).toPromise();\n    }\n\n    // if query contains full metric name, return metric name and label list\n    return this.metricNameAndLabelsQuery(this.query);\n  }\n\n  labelNamesQuery() {\n    const start = this.datasource.getPrometheusTime(this.range.from, false);\n    const end = this.datasource.getPrometheusTime(this.range.to, true);\n    const params = new URLSearchParams({\n      start: start.toString(),\n      end: end.toString(),\n    });\n\n    const url = `/api/v1/labels?${params.toString()}`;\n\n    return this.datasource.metadataRequest(url).then((result: any) => {\n      return _.map(result.data.data, value => {\n        return { text: value };\n      });\n    });\n  }\n\n  labelValuesQuery(label: string, metric?: string) {\n    const start = this.datasource.getPrometheusTime(this.range.from, false);\n    const end = this.datasource.getPrometheusTime(this.range.to, true);\n\n    let url: string;\n\n    if (!metric) {\n      const params = new URLSearchParams({\n        start: start.toString(),\n        end: end.toString(),\n      });\n      // return label values globally\n      url = `/api/v1/label/${label}/values?${params.toString()}`;\n\n      return this.datasource.metadataRequest(url).then((result: any) => {\n        return _.map(result.data.data, value => {\n          return { text: value };\n        });\n      });\n    } else {\n      const params = new URLSearchParams({\n        'match[]': metric,\n        start: start.toString(),\n        end: end.toString(),\n      });\n      url = `/api/v1/series?${params.toString()}`;\n\n      return this.datasource.metadataRequest(url).then((result: any) => {\n        const _labels = _.map(result.data.data, metric => {\n          return metric[label] || '';\n        }).filter(label => {\n          return label !== '';\n        });\n\n        return _.uniq(_labels).map(metric => {\n          return {\n            text: metric,\n            expandable: true,\n          };\n        });\n      });\n    }\n  }\n\n  metricNameQuery(metricFilterPattern: string) {\n    const start = this.datasource.getPrometheusTime(this.range.from, false);\n    const end = this.datasource.getPrometheusTime(this.range.to, true);\n    const params = new URLSearchParams({\n      start: start.toString(),\n      end: end.toString(),\n    });\n    const url = `/api/v1/label/__name__/values?${params.toString()}`;\n\n    return this.datasource.metadataRequest(url).then((result: any) => {\n      return _.chain(result.data.data)\n        .filter(metricName => {\n          const r = new RegExp(metricFilterPattern);\n          return r.test(metricName);\n        })\n        .map(matchedMetricName => {\n          return {\n            text: matchedMetricName,\n            expandable: true,\n          };\n        })\n        .value();\n    });\n  }\n\n  queryResultQuery(query: string) {\n    const end = this.datasource.getPrometheusTime(this.range.to, true);\n    const instantQuery: PromQueryRequest = { expr: query } as PromQueryRequest;\n    return this.datasource.performInstantQuery(instantQuery, end).pipe(\n      map(result => {\n        return _.map(result.data.data.result, metricData => {\n          let text = metricData.metric.__name__ || '';\n          delete metricData.metric.__name__;\n          text +=\n            '{' +\n            _.map(metricData.metric, (v, k) => {\n              return k + '=\"' + v + '\"';\n            }).join(',') +\n            '}';\n          text += ' ' + metricData.value[1] + ' ' + metricData.value[0] * 1000;\n\n          return {\n            text: text,\n            expandable: true,\n          };\n        });\n      })\n    );\n  }\n\n  metricNameAndLabelsQuery(query: string): Promise<MetricFindValue[]> {\n    const start = this.datasource.getPrometheusTime(this.range.from, false);\n    const end = this.datasource.getPrometheusTime(this.range.to, true);\n    const params = new URLSearchParams({\n      'match[]': query,\n      start: start.toString(),\n      end: end.toString(),\n    });\n\n    const url = `/api/v1/series?${params.toString()}`;\n    const self = this;\n\n    return this.datasource.metadataRequest(url).then((result: any) => {\n      return _.map(result.data.data, (metric: { [key: string]: string }) => {\n        return {\n          text: self.datasource.getOriginalMetricName(metric),\n          expandable: true,\n        };\n      });\n    });\n  }\n}\n","import _ from 'lodash';\nimport { QueryHint, QueryFix } from '@grafana/data';\nimport { PrometheusDatasource } from './datasource';\n\n/**\n * Number of time series results needed before starting to suggest sum aggregation hints\n */\nexport const SUM_HINT_THRESHOLD_COUNT = 20;\n\nexport function getQueryHints(query: string, series?: any[], datasource?: PrometheusDatasource): QueryHint[] {\n  const hints = [];\n\n  // ..._bucket metric needs a histogram_quantile()\n  const histogramMetric = query.trim().match(/^\\w+_bucket$/);\n  if (histogramMetric) {\n    const label = 'Time series has buckets, you probably wanted a histogram.';\n    hints.push({\n      type: 'HISTOGRAM_QUANTILE',\n      label,\n      fix: {\n        label: 'Fix by adding histogram_quantile().',\n        action: {\n          type: 'ADD_HISTOGRAM_QUANTILE',\n          query,\n        },\n      } as QueryFix,\n    });\n  }\n\n  // Check for need of rate()\n  if (query.indexOf('rate(') === -1 && query.indexOf('increase(') === -1) {\n    // Use metric metadata for exact types\n    const nameMatch = query.match(/\\b(\\w+_(total|sum|count))\\b/);\n    let counterNameMetric = nameMatch ? nameMatch[1] : '';\n    const metricsMetadata = datasource?.languageProvider?.metricsMetadata ?? {};\n    const metricMetadataKeys = Object.keys(metricsMetadata);\n    let certain = false;\n\n    if (metricMetadataKeys.length > 0) {\n      counterNameMetric =\n        metricMetadataKeys.find(metricName => {\n          // Only considering first type information, could be non-deterministic\n          const metadata = metricsMetadata[metricName][0];\n          if (metadata.type.toLowerCase() === 'counter') {\n            const metricRegex = new RegExp(`\\\\b${metricName}\\\\b`);\n            if (query.match(metricRegex)) {\n              certain = true;\n              return true;\n            }\n          }\n          return false;\n        }) ?? '';\n    }\n\n    if (counterNameMetric) {\n      const simpleMetric = query.trim().match(/^\\w+$/);\n      const verb = certain ? 'is' : 'looks like';\n      let label = `Metric ${counterNameMetric} ${verb} a counter.`;\n      let fix: QueryFix | undefined;\n\n      if (simpleMetric) {\n        fix = {\n          label: 'Fix by adding rate().',\n          action: {\n            type: 'ADD_RATE',\n            query,\n          },\n        };\n      } else {\n        label = `${label} Try applying a rate() function.`;\n      }\n\n      hints.push({\n        type: 'APPLY_RATE',\n        label,\n        fix,\n      });\n    }\n  }\n\n  // Check for recording rules expansion\n  if (datasource && datasource.ruleMappings) {\n    const mapping = datasource.ruleMappings;\n    const mappingForQuery = Object.keys(mapping).reduce((acc, ruleName) => {\n      if (query.search(ruleName) > -1) {\n        return {\n          ...acc,\n          [ruleName]: mapping[ruleName],\n        };\n      }\n      return acc;\n    }, {});\n    if (_.size(mappingForQuery) > 0) {\n      const label = 'Query contains recording rules.';\n      hints.push({\n        type: 'EXPAND_RULES',\n        label,\n        fix: ({\n          label: 'Expand rules',\n          action: {\n            type: 'EXPAND_RULES',\n            query,\n            mapping: mappingForQuery,\n          },\n        } as any) as QueryFix,\n      });\n    }\n  }\n\n  if (series && series.length >= SUM_HINT_THRESHOLD_COUNT) {\n    const simpleMetric = query.trim().match(/^\\w+$/);\n    if (simpleMetric) {\n      hints.push({\n        type: 'ADD_SUM',\n        label: 'Many time series results returned.',\n        fix: {\n          label: 'Consider aggregating with sum().',\n          action: {\n            type: 'ADD_SUM',\n            query: query,\n            preventSubmit: true,\n          },\n        } as QueryFix,\n      });\n    }\n  }\n\n  return hints;\n}\n","import { DataQuery, DataSourceJsonData, QueryResultMeta, ScopedVars } from '@grafana/data';\nimport { FetchError } from '@grafana/runtime';\n\nexport interface PromQuery extends DataQuery {\n  expr: string;\n  format?: string;\n  instant?: boolean;\n  range?: boolean;\n  hinting?: boolean;\n  interval?: string;\n  intervalFactor?: number;\n  legendFormat?: string;\n  valueWithRefId?: boolean;\n  requestId?: string;\n  showingGraph?: boolean;\n  showingTable?: boolean;\n}\n\nexport interface PromOptions extends DataSourceJsonData {\n  timeInterval: string;\n  queryTimeout: string;\n  httpMethod: string;\n  directUrl: string;\n  customQueryParameters?: string;\n  disableMetricsLookup?: boolean;\n}\n\nexport interface PromQueryRequest extends PromQuery {\n  step?: number;\n  requestId?: string;\n  start: number;\n  end: number;\n  headers?: any;\n}\n\nexport interface PromMetricsMetadataItem {\n  type: string;\n  help: string;\n  unit?: string;\n}\n\nexport interface PromMetricsMetadata {\n  [metric: string]: PromMetricsMetadataItem[];\n}\n\nexport interface PromDataSuccessResponse<T = PromData> {\n  status: 'success';\n  data: T;\n}\n\nexport interface PromDataErrorResponse<T = PromData> {\n  status: 'error';\n  errorType: string;\n  error: string;\n  data: T;\n}\n\nexport type PromData = PromMatrixData | PromVectorData | PromScalarData;\n\nexport interface PromVectorData {\n  resultType: 'vector';\n  result: Array<{\n    metric: PromMetric;\n    value: PromValue;\n  }>;\n}\n\nexport interface PromMatrixData {\n  resultType: 'matrix';\n  result: Array<{\n    metric: PromMetric;\n    values: PromValue[];\n  }>;\n}\n\nexport interface PromScalarData {\n  resultType: 'scalar';\n  result: PromValue;\n}\n\nexport type PromValue = [number, any];\n\nexport interface PromMetric {\n  __name__?: string;\n  [index: string]: any;\n}\n\nexport function isFetchErrorResponse(response: any): response is FetchError {\n  return 'cancelled' in response;\n}\n\nexport function isMatrixData(result: MatrixOrVectorResult): result is PromMatrixData['result'][0] {\n  return 'values' in result;\n}\n\nexport type MatrixOrVectorResult = PromMatrixData['result'][0] | PromVectorData['result'][0];\n\nexport interface TransformOptions {\n  format?: string;\n  step?: number;\n  legendFormat?: string;\n  start: number;\n  end: number;\n  query: string;\n  responseListLength: number;\n  scopedVars?: ScopedVars;\n  refId: string;\n  valueWithRefId?: boolean;\n  meta: QueryResultMeta;\n}\n\nexport interface PromLabelQueryResponse {\n  data: {\n    status: string;\n    data: string[];\n  };\n  cancelled?: boolean;\n}\n","import {\n  ArrayVector,\n  DataFrame,\n  Field,\n  FieldType,\n  formatLabels,\n  Labels,\n  MutableField,\n  ScopedVars,\n  TIME_SERIES_TIME_FIELD_NAME,\n  TIME_SERIES_VALUE_FIELD_NAME,\n} from '@grafana/data';\nimport { FetchResponse } from '@grafana/runtime';\nimport { getTemplateSrv } from 'app/features/templating/template_srv';\nimport {\n  isMatrixData,\n  MatrixOrVectorResult,\n  PromDataSuccessResponse,\n  PromMetric,\n  PromQuery,\n  PromQueryRequest,\n  PromValue,\n  TransformOptions,\n} from './types';\n\nconst POSITIVE_INFINITY_SAMPLE_VALUE = '+Inf';\nconst NEGATIVE_INFINITY_SAMPLE_VALUE = '-Inf';\n\nexport function transform(\n  response: FetchResponse<PromDataSuccessResponse>,\n  transformOptions: {\n    query: PromQueryRequest;\n    target: PromQuery;\n    responseListLength: number;\n    scopedVars?: ScopedVars;\n    mixedQueries?: boolean;\n  }\n) {\n  // Create options object from transformOptions\n  const options: TransformOptions = {\n    format: transformOptions.target.format,\n    step: transformOptions.query.step,\n    legendFormat: transformOptions.target.legendFormat,\n    start: transformOptions.query.start,\n    end: transformOptions.query.end,\n    query: transformOptions.query.expr,\n    responseListLength: transformOptions.responseListLength,\n    scopedVars: transformOptions.scopedVars,\n    refId: transformOptions.target.refId,\n    valueWithRefId: transformOptions.target.valueWithRefId,\n    meta: {\n      /**\n       * Fix for showing of Prometheus results in Explore table.\n       * We want to show result of instant query always in table and result of range query based on target.runAll;\n       */\n      preferredVisualisationType: getPreferredVisualisationType(\n        transformOptions.query.instant,\n        transformOptions.mixedQueries\n      ),\n    },\n  };\n  const prometheusResult = response.data.data;\n\n  if (!prometheusResult.result) {\n    return [];\n  }\n\n  // Return early if result type is scalar\n  if (prometheusResult.resultType === 'scalar') {\n    return [\n      {\n        meta: options.meta,\n        refId: options.refId,\n        length: 1,\n        fields: [getTimeField([prometheusResult.result]), getValueField({ data: [prometheusResult.result] })],\n      },\n    ];\n  }\n\n  // Return early again if the format is table, this needs special transformation.\n  if (options.format === 'table') {\n    const tableData = transformMetricDataToTable(prometheusResult.result, options);\n    return [tableData];\n  }\n\n  // Process matrix and vector results to DataFrame\n  const dataFrame: DataFrame[] = [];\n  prometheusResult.result.forEach((data: MatrixOrVectorResult) => dataFrame.push(transformToDataFrame(data, options)));\n\n  // When format is heatmap use the already created data frames and transform it more\n  if (options.format === 'heatmap') {\n    dataFrame.sort(sortSeriesByLabel);\n    const seriesList = transformToHistogramOverTime(dataFrame);\n    return seriesList;\n  }\n\n  // Return matrix or vector result as DataFrame[]\n  return dataFrame;\n}\n\nfunction getPreferredVisualisationType(isInstantQuery?: boolean, mixedQueries?: boolean) {\n  if (isInstantQuery) {\n    return 'table';\n  }\n\n  return mixedQueries ? 'graph' : undefined;\n}\n\n/**\n * Transforms matrix and vector result from Prometheus result to DataFrame\n */\nfunction transformToDataFrame(data: MatrixOrVectorResult, options: TransformOptions): DataFrame {\n  const { name, labels } = createLabelInfo(data.metric, options);\n\n  const fields: Field[] = [];\n\n  if (isMatrixData(data)) {\n    const stepMs = options.step ? options.step * 1000 : NaN;\n    let baseTimestamp = options.start * 1000;\n    const dps: PromValue[] = [];\n\n    for (const value of data.values) {\n      let dpValue: number | null = parseSampleValue(value[1]);\n\n      if (isNaN(dpValue)) {\n        dpValue = null;\n      }\n\n      const timestamp = value[0] * 1000;\n      for (let t = baseTimestamp; t < timestamp; t += stepMs) {\n        dps.push([t, null]);\n      }\n      baseTimestamp = timestamp + stepMs;\n      dps.push([timestamp, dpValue]);\n    }\n\n    const endTimestamp = options.end * 1000;\n    for (let t = baseTimestamp; t <= endTimestamp; t += stepMs) {\n      dps.push([t, null]);\n    }\n    fields.push(getTimeField(dps, true));\n    fields.push(getValueField({ data: dps, parseValue: false, labels, displayName: name }));\n  } else {\n    fields.push(getTimeField([data.value]));\n    fields.push(getValueField({ data: [data.value], labels, displayName: name }));\n  }\n\n  return {\n    meta: options.meta,\n    refId: options.refId,\n    length: fields[0].values.length,\n    fields,\n    name,\n  };\n}\n\nfunction transformMetricDataToTable(md: MatrixOrVectorResult[], options: TransformOptions): DataFrame {\n  if (!md || md.length === 0) {\n    return {\n      meta: options.meta,\n      refId: options.refId,\n      length: 0,\n      fields: [],\n    };\n  }\n\n  const valueText = options.responseListLength > 1 || options.valueWithRefId ? `Value #${options.refId}` : 'Value';\n\n  const timeField = getTimeField([]);\n  const metricFields = Object.keys(md.reduce((acc, series) => ({ ...acc, ...series.metric }), {}))\n    .sort()\n    .map(label => {\n      return {\n        name: label,\n        config: { filterable: true },\n        type: FieldType.other,\n        values: new ArrayVector(),\n      };\n    });\n  const valueField = getValueField({ data: [], valueName: valueText });\n\n  md.forEach(d => {\n    if (isMatrixData(d)) {\n      d.values.forEach(val => {\n        timeField.values.add(val[0] * 1000);\n        metricFields.forEach(metricField => metricField.values.add(getLabelValue(d.metric, metricField.name)));\n        valueField.values.add(parseSampleValue(val[1]));\n      });\n    } else {\n      timeField.values.add(d.value[0] * 1000);\n      metricFields.forEach(metricField => metricField.values.add(getLabelValue(d.metric, metricField.name)));\n      valueField.values.add(parseSampleValue(d.value[1]));\n    }\n  });\n\n  return {\n    meta: options.meta,\n    refId: options.refId,\n    length: timeField.values.length,\n    fields: [timeField, ...metricFields, valueField],\n  };\n}\n\nfunction getLabelValue(metric: PromMetric, label: string): string | number {\n  if (metric.hasOwnProperty(label)) {\n    if (label === 'le') {\n      return parseSampleValue(metric[label]);\n    }\n    return metric[label];\n  }\n  return '';\n}\n\nfunction getTimeField(data: PromValue[], isMs = false): MutableField {\n  return {\n    name: TIME_SERIES_TIME_FIELD_NAME,\n    type: FieldType.time,\n    config: {},\n    values: new ArrayVector<number>(data.map(val => (isMs ? val[0] : val[0] * 1000))),\n  };\n}\ntype ValueFieldOptions = {\n  data: PromValue[];\n  valueName?: string;\n  parseValue?: boolean;\n  labels?: Labels;\n  displayName?: string;\n};\n\nfunction getValueField({\n  data,\n  valueName = TIME_SERIES_VALUE_FIELD_NAME,\n  parseValue = true,\n  labels,\n  displayName,\n}: ValueFieldOptions): MutableField {\n  return {\n    name: valueName,\n    type: FieldType.number,\n    config: {\n      displayName,\n    },\n    labels,\n    values: new ArrayVector<number | null>(data.map(val => (parseValue ? parseSampleValue(val[1]) : val[1]))),\n  };\n}\n\nfunction createLabelInfo(labels: { [key: string]: string }, options: TransformOptions) {\n  if (options?.legendFormat) {\n    const title = renderTemplate(getTemplateSrv().replace(options.legendFormat, options?.scopedVars), labels);\n    return { name: title, labels };\n  }\n\n  const { __name__, ...labelsWithoutName } = labels;\n  const labelPart = formatLabels(labelsWithoutName);\n  const title = `${__name__ ?? ''}${labelPart}`;\n\n  return { name: title, labels: labelsWithoutName };\n}\n\nexport function getOriginalMetricName(labelData: { [key: string]: string }) {\n  const metricName = labelData.__name__ || '';\n  delete labelData.__name__;\n  const labelPart = Object.entries(labelData)\n    .map(label => `${label[0]}=\"${label[1]}\"`)\n    .join(',');\n  return `${metricName}{${labelPart}}`;\n}\n\nexport function renderTemplate(aliasPattern: string, aliasData: { [key: string]: string }) {\n  const aliasRegex = /\\{\\{\\s*(.+?)\\s*\\}\\}/g;\n  return aliasPattern.replace(aliasRegex, (_match, g1) => {\n    if (aliasData[g1]) {\n      return aliasData[g1];\n    }\n    return '';\n  });\n}\n\nfunction transformToHistogramOverTime(seriesList: DataFrame[]) {\n  /*      t1 = timestamp1, t2 = timestamp2 etc.\n            t1  t2  t3          t1  t2  t3\n    le10    10  10  0     =>    10  10  0\n    le20    20  10  30    =>    10  0   30\n    le30    30  10  35    =>    10  0   5\n    */\n  for (let i = seriesList.length - 1; i > 0; i--) {\n    const topSeries = seriesList[i].fields.find(s => s.name === TIME_SERIES_VALUE_FIELD_NAME);\n    const bottomSeries = seriesList[i - 1].fields.find(s => s.name === TIME_SERIES_VALUE_FIELD_NAME);\n    if (!topSeries || !bottomSeries) {\n      throw new Error('Prometheus heatmap transform error: data should be a time series');\n    }\n\n    for (let j = 0; j < topSeries.values.length; j++) {\n      const bottomPoint = bottomSeries.values.get(j) || [0];\n      topSeries.values.toArray()[j] -= bottomPoint;\n    }\n  }\n\n  return seriesList;\n}\n\nfunction sortSeriesByLabel(s1: DataFrame, s2: DataFrame): number {\n  let le1, le2;\n\n  try {\n    // fail if not integer. might happen with bad queries\n    le1 = parseSampleValue(s1.name ?? '');\n    le2 = parseSampleValue(s2.name ?? '');\n  } catch (err) {\n    console.error(err);\n    return 0;\n  }\n\n  if (le1 > le2) {\n    return 1;\n  }\n\n  if (le1 < le2) {\n    return -1;\n  }\n\n  return 0;\n}\n\nfunction parseSampleValue(value: string): number {\n  switch (value) {\n    case POSITIVE_INFINITY_SAMPLE_VALUE:\n      return Number.POSITIVE_INFINITY;\n    case NEGATIVE_INFINITY_SAMPLE_VALUE:\n      return Number.NEGATIVE_INFINITY;\n    default:\n      return parseFloat(value);\n  }\n}\n","import {\n  AnnotationEvent,\n  CoreApp,\n  DataQueryError,\n  DataQueryRequest,\n  DataQueryResponse,\n  DataSourceApi,\n  DataSourceInstanceSettings,\n  dateMath,\n  DateTime,\n  LoadingState,\n  rangeUtil,\n  ScopedVars,\n  TimeRange,\n} from '@grafana/data';\nimport { BackendSrvRequest, FetchError, getBackendSrv } from '@grafana/runtime';\nimport { safeStringifyValue } from 'app/core/utils/explore';\nimport { getTimeSrv, TimeSrv } from 'app/features/dashboard/services/TimeSrv';\nimport { getTemplateSrv, TemplateSrv } from 'app/features/templating/template_srv';\nimport cloneDeep from 'lodash/cloneDeep';\nimport defaults from 'lodash/defaults';\nimport LRU from 'lru-cache';\nimport { forkJoin, merge, Observable, of, pipe, throwError } from 'rxjs';\nimport { catchError, filter, map, tap } from 'rxjs/operators';\nimport addLabelToQuery from './add_label_to_query';\nimport PrometheusLanguageProvider from './language_provider';\nimport { expandRecordingRules } from './language_utils';\nimport PrometheusMetricFindQuery from './metric_find_query';\nimport { getQueryHints } from './query_hints';\nimport { getOriginalMetricName, renderTemplate, transform } from './result_transformer';\nimport {\n  isFetchErrorResponse,\n  PromDataErrorResponse,\n  PromDataSuccessResponse,\n  PromMatrixData,\n  PromOptions,\n  PromQuery,\n  PromQueryRequest,\n  PromScalarData,\n  PromVectorData,\n} from './types';\n\nexport const ANNOTATION_QUERY_STEP_DEFAULT = '60s';\n\nexport class PrometheusDatasource extends DataSourceApi<PromQuery, PromOptions> {\n  type: string;\n  editorSrc: string;\n  ruleMappings: { [index: string]: string };\n  url: string;\n  directUrl: string;\n  basicAuth: any;\n  withCredentials: any;\n  metricsNameCache = new LRU<string, string[]>(10);\n  interval: string;\n  queryTimeout: string;\n  httpMethod: string;\n  languageProvider: PrometheusLanguageProvider;\n  lookupsDisabled: boolean;\n  customQueryParameters: any;\n\n  constructor(\n    instanceSettings: DataSourceInstanceSettings<PromOptions>,\n    private readonly templateSrv: TemplateSrv = getTemplateSrv(),\n    private readonly timeSrv: TimeSrv = getTimeSrv()\n  ) {\n    super(instanceSettings);\n\n    this.type = 'prometheus';\n    this.editorSrc = 'app/features/prometheus/partials/query.editor.html';\n    this.url = instanceSettings.url!;\n    this.basicAuth = instanceSettings.basicAuth;\n    this.withCredentials = instanceSettings.withCredentials;\n    this.interval = instanceSettings.jsonData.timeInterval || '15s';\n    this.queryTimeout = instanceSettings.jsonData.queryTimeout;\n    this.httpMethod = instanceSettings.jsonData.httpMethod || 'GET';\n    this.directUrl = instanceSettings.jsonData.directUrl;\n    this.ruleMappings = {};\n    this.languageProvider = new PrometheusLanguageProvider(this);\n    this.lookupsDisabled = instanceSettings.jsonData.disableMetricsLookup ?? false;\n    this.customQueryParameters = new URLSearchParams(instanceSettings.jsonData.customQueryParameters);\n  }\n\n  init = () => {\n    this.loadRules();\n  };\n\n  getQueryDisplayText(query: PromQuery) {\n    return query.expr;\n  }\n\n  _addTracingHeaders(httpOptions: PromQueryRequest, options: DataQueryRequest<PromQuery>) {\n    httpOptions.headers = {};\n    const proxyMode = !this.url.match(/^http/);\n    if (proxyMode) {\n      httpOptions.headers['X-Dashboard-Id'] = options.dashboardId;\n      httpOptions.headers['X-Panel-Id'] = options.panelId;\n    }\n  }\n\n  _request<T = any>(url: string, data: Record<string, string> | null, overrides: Partial<BackendSrvRequest> = {}) {\n    const options: BackendSrvRequest = defaults(overrides, {\n      url: this.url + url,\n      method: this.httpMethod,\n      headers: {},\n    });\n\n    if (options.method === 'GET') {\n      if (data && Object.keys(data).length) {\n        options.url =\n          options.url +\n          '?' +\n          Object.entries(data)\n            .map(([k, v]) => `${encodeURIComponent(k)}=${encodeURIComponent(v)}`)\n            .join('&');\n      }\n    } else {\n      options.headers!['Content-Type'] = 'application/x-www-form-urlencoded';\n      options.data = data;\n    }\n\n    if (this.basicAuth || this.withCredentials) {\n      options.withCredentials = true;\n    }\n\n    if (this.basicAuth) {\n      options.headers!.Authorization = this.basicAuth;\n    }\n\n    return getBackendSrv().fetch<T>(options);\n  }\n\n  // Use this for tab completion features, wont publish response to other components\n  metadataRequest<T = any>(url: string) {\n    return this._request<T>(url, null, { method: 'GET', hideFromInspector: true }).toPromise(); // toPromise until we change getTagValues, getTagKeys to Observable\n  }\n\n  interpolateQueryExpr(value: string | string[] = [], variable: any) {\n    // if no multi or include all do not regexEscape\n    if (!variable.multi && !variable.includeAll) {\n      return prometheusRegularEscape(value);\n    }\n\n    if (typeof value === 'string') {\n      return prometheusSpecialRegexEscape(value);\n    }\n\n    const escapedValues = value.map(val => prometheusSpecialRegexEscape(val));\n\n    if (escapedValues.length === 1) {\n      return escapedValues[0];\n    }\n\n    return '(' + escapedValues.join('|') + ')';\n  }\n\n  targetContainsTemplate(target: PromQuery) {\n    return this.templateSrv.variableExists(target.expr);\n  }\n\n  prepareTargets = (options: DataQueryRequest<PromQuery>, start: number, end: number) => {\n    const queries: PromQueryRequest[] = [];\n    const activeTargets: PromQuery[] = [];\n\n    for (const target of options.targets) {\n      if (!target.expr || target.hide) {\n        continue;\n      }\n\n      target.requestId = options.panelId + target.refId;\n\n      if (target.range && target.instant) {\n        // If running both (only available in Explore) - instant and range query, prepare both targets\n        // Create instant target\n        const instantTarget: any = cloneDeep(target);\n        instantTarget.format = 'table';\n        instantTarget.instant = true;\n        instantTarget.range = false;\n        instantTarget.valueWithRefId = true;\n        delete instantTarget.maxDataPoints;\n        instantTarget.requestId += '_instant';\n\n        // Create range target\n        const rangeTarget: any = cloneDeep(target);\n        rangeTarget.format = 'time_series';\n        rangeTarget.instant = false;\n        instantTarget.range = true;\n\n        // Add both targets to activeTargets and queries arrays\n        activeTargets.push(instantTarget, rangeTarget);\n        queries.push(\n          this.createQuery(instantTarget, options, start, end),\n          this.createQuery(rangeTarget, options, start, end)\n        );\n      } else if (target.instant && options.app === CoreApp.Explore) {\n        // If running only instant query in Explore, format as table\n        const instantTarget: any = cloneDeep(target);\n        instantTarget.format = 'table';\n        queries.push(this.createQuery(instantTarget, options, start, end));\n        activeTargets.push(instantTarget);\n      } else {\n        queries.push(this.createQuery(target, options, start, end));\n        activeTargets.push(target);\n      }\n    }\n\n    return {\n      queries,\n      activeTargets,\n    };\n  };\n\n  query(options: DataQueryRequest<PromQuery>): Observable<DataQueryResponse> {\n    const start = this.getPrometheusTime(options.range.from, false);\n    const end = this.getPrometheusTime(options.range.to, true);\n    const { queries, activeTargets } = this.prepareTargets(options, start, end);\n\n    // No valid targets, return the empty result to save a round trip.\n    if (!queries || !queries.length) {\n      return of({\n        data: [],\n        state: LoadingState.Done,\n      });\n    }\n\n    if (options.app === CoreApp.Explore) {\n      return this.exploreQuery(queries, activeTargets, end);\n    }\n\n    return this.panelsQuery(queries, activeTargets, end, options.requestId, options.scopedVars);\n  }\n\n  private exploreQuery(queries: PromQueryRequest[], activeTargets: PromQuery[], end: number) {\n    let runningQueriesCount = queries.length;\n    const mixedQueries = activeTargets.some(t => t.range) && activeTargets.some(t => t.instant);\n\n    const subQueries = queries.map((query, index) => {\n      const target = activeTargets[index];\n\n      const filterAndMapResponse = pipe(\n        // Decrease the counter here. We assume that each request returns only single value and then completes\n        // (should hold until there is some streaming requests involved).\n        tap(() => runningQueriesCount--),\n        filter((response: any) => (response.cancelled ? false : true)),\n        map((response: any) => {\n          const data = transform(response, { query, target, responseListLength: queries.length, mixedQueries });\n          return {\n            data,\n            key: query.requestId,\n            state: runningQueriesCount === 0 ? LoadingState.Done : LoadingState.Loading,\n          } as DataQueryResponse;\n        })\n      );\n\n      if (query.instant) {\n        return this.performInstantQuery(query, end).pipe(filterAndMapResponse);\n      }\n\n      return this.performTimeSeriesQuery(query, query.start, query.end).pipe(filterAndMapResponse);\n    });\n\n    return merge(...subQueries);\n  }\n\n  private panelsQuery(\n    queries: PromQueryRequest[],\n    activeTargets: PromQuery[],\n    end: number,\n    requestId: string,\n    scopedVars: ScopedVars\n  ) {\n    const observables = queries.map((query, index) => {\n      const target = activeTargets[index];\n\n      const filterAndMapResponse = pipe(\n        filter((response: any) => (response.cancelled ? false : true)),\n        map((response: any) => {\n          const data = transform(response, { query, target, responseListLength: queries.length, scopedVars });\n          return data;\n        })\n      );\n\n      if (query.instant) {\n        return this.performInstantQuery(query, end).pipe(filterAndMapResponse);\n      }\n\n      return this.performTimeSeriesQuery(query, query.start, query.end).pipe(filterAndMapResponse);\n    });\n\n    return forkJoin(observables).pipe(\n      map(results => {\n        const data = results.reduce((result, current) => {\n          return [...result, ...current];\n        }, []);\n        return {\n          data,\n          key: requestId,\n          state: LoadingState.Done,\n        };\n      })\n    );\n  }\n\n  createQuery(target: PromQuery, options: DataQueryRequest<PromQuery>, start: number, end: number) {\n    const query: PromQueryRequest = {\n      hinting: target.hinting,\n      instant: target.instant,\n      step: 0,\n      expr: '',\n      requestId: target.requestId,\n      refId: target.refId,\n      start: 0,\n      end: 0,\n    };\n    const range = Math.ceil(end - start);\n\n    // options.interval is the dynamically calculated interval\n    let interval: number = rangeUtil.intervalToSeconds(options.interval);\n    // Minimum interval (\"Min step\"), if specified for the query, or same as interval otherwise.\n    const minInterval = rangeUtil.intervalToSeconds(\n      this.templateSrv.replace(target.interval || options.interval, options.scopedVars)\n    );\n    // Scrape interval as specified for the query (\"Min step\") or otherwise taken from the datasource.\n    // Min step field can have template variables in it, make sure to replace it.\n    const scrapeInterval = target.interval\n      ? rangeUtil.intervalToSeconds(this.templateSrv.replace(target.interval, options.scopedVars))\n      : rangeUtil.intervalToSeconds(this.interval);\n\n    const intervalFactor = target.intervalFactor || 1;\n    // Adjust the interval to take into account any specified minimum and interval factor plus Prometheus limits\n    const adjustedInterval = this.adjustInterval(interval, minInterval, range, intervalFactor);\n    let scopedVars = {\n      ...options.scopedVars,\n      ...this.getRangeScopedVars(options.range),\n      ...this.getRateIntervalScopedVariable(adjustedInterval, scrapeInterval),\n    };\n    // If the interval was adjusted, make a shallow copy of scopedVars with updated interval vars\n    if (interval !== adjustedInterval) {\n      interval = adjustedInterval;\n      scopedVars = Object.assign({}, options.scopedVars, {\n        __interval: { text: interval + 's', value: interval + 's' },\n        __interval_ms: { text: interval * 1000, value: interval * 1000 },\n        ...this.getRateIntervalScopedVariable(interval, scrapeInterval),\n        ...this.getRangeScopedVars(options.range),\n      });\n    }\n    query.step = interval;\n\n    let expr = target.expr;\n\n    // Apply adhoc filters\n    const adhocFilters = this.templateSrv.getAdhocFilters(this.name);\n    expr = adhocFilters.reduce((acc: string, filter: { key?: any; operator?: any; value?: any }) => {\n      const { key, operator } = filter;\n      let { value } = filter;\n      if (operator === '=~' || operator === '!~') {\n        value = prometheusRegularEscape(value);\n      }\n      return addLabelToQuery(acc, key, value, operator);\n    }, expr);\n\n    // Only replace vars in expression after having (possibly) updated interval vars\n    query.expr = this.templateSrv.replace(expr, scopedVars, this.interpolateQueryExpr);\n\n    // Align query interval with step to allow query caching and to ensure\n    // that about-same-time query results look the same.\n    const adjusted = alignRange(start, end, query.step, this.timeSrv.timeRange().to.utcOffset() * 60);\n    query.start = adjusted.start;\n    query.end = adjusted.end;\n    this._addTracingHeaders(query, options);\n\n    return query;\n  }\n\n  getRateIntervalScopedVariable(interval: number, scrapeInterval: number) {\n    // Fall back to the default scrape interval of 15s if scrapeInterval is 0 for some reason.\n    if (scrapeInterval === 0) {\n      scrapeInterval = 15;\n    }\n    const rateInterval = Math.max(interval + scrapeInterval, 4 * scrapeInterval);\n    return { __rate_interval: { text: rateInterval + 's', value: rateInterval + 's' } };\n  }\n\n  adjustInterval(interval: number, minInterval: number, range: number, intervalFactor: number) {\n    // Prometheus will drop queries that might return more than 11000 data points.\n    // Calculate a safe interval as an additional minimum to take into account.\n    // Fractional safeIntervals are allowed, however serve little purpose if the interval is greater than 1\n    // If this is the case take the ceil of the value.\n    let safeInterval = range / 11000;\n    if (safeInterval > 1) {\n      safeInterval = Math.ceil(safeInterval);\n    }\n    return Math.max(interval * intervalFactor, minInterval, safeInterval);\n  }\n\n  performTimeSeriesQuery(query: PromQueryRequest, start: number, end: number) {\n    if (start > end) {\n      throw { message: 'Invalid time range' };\n    }\n\n    const url = '/api/v1/query_range';\n    const data: any = {\n      query: query.expr,\n      start,\n      end,\n      step: query.step,\n    };\n\n    if (this.queryTimeout) {\n      data['timeout'] = this.queryTimeout;\n    }\n\n    for (const [key, value] of this.customQueryParameters) {\n      if (data[key] == null) {\n        data[key] = value;\n      }\n    }\n\n    return this._request<PromDataSuccessResponse<PromMatrixData>>(url, data, {\n      requestId: query.requestId,\n      headers: query.headers,\n    }).pipe(\n      catchError((err: FetchError<PromDataErrorResponse<PromMatrixData>>) => {\n        if (err.cancelled) {\n          return of(err);\n        }\n\n        return throwError(this.handleErrors(err, query));\n      })\n    );\n  }\n\n  performInstantQuery(query: PromQueryRequest, time: number) {\n    const url = '/api/v1/query';\n    const data: any = {\n      query: query.expr,\n      time,\n    };\n\n    if (this.queryTimeout) {\n      data['timeout'] = this.queryTimeout;\n    }\n\n    for (const [key, value] of this.customQueryParameters) {\n      if (data[key] == null) {\n        data[key] = value;\n      }\n    }\n\n    return this._request<PromDataSuccessResponse<PromVectorData | PromScalarData>>(url, data, {\n      requestId: query.requestId,\n      headers: query.headers,\n    }).pipe(\n      catchError((err: FetchError<PromDataErrorResponse<PromVectorData | PromScalarData>>) => {\n        if (err.cancelled) {\n          return of(err);\n        }\n\n        return throwError(this.handleErrors(err, query));\n      })\n    );\n  }\n\n  handleErrors = (err: any, target: PromQuery) => {\n    const error: DataQueryError = {\n      message: (err && err.statusText) || 'Unknown error during query transaction. Please check JS console logs.',\n      refId: target.refId,\n    };\n\n    if (err.data) {\n      if (typeof err.data === 'string') {\n        error.message = err.data;\n      } else if (err.data.error) {\n        error.message = safeStringifyValue(err.data.error);\n      }\n    } else if (err.message) {\n      error.message = err.message;\n    } else if (typeof err === 'string') {\n      error.message = err;\n    }\n\n    error.status = err.status;\n    error.statusText = err.statusText;\n\n    return error;\n  };\n\n  metricFindQuery(query: string) {\n    if (!query) {\n      return Promise.resolve([]);\n    }\n\n    const scopedVars = {\n      __interval: { text: this.interval, value: this.interval },\n      __interval_ms: { text: rangeUtil.intervalToMs(this.interval), value: rangeUtil.intervalToMs(this.interval) },\n      ...this.getRangeScopedVars(this.timeSrv.timeRange()),\n    };\n    const interpolated = this.templateSrv.replace(query, scopedVars, this.interpolateQueryExpr);\n    const metricFindQuery = new PrometheusMetricFindQuery(this, interpolated);\n    return metricFindQuery.process();\n  }\n\n  getRangeScopedVars(range: TimeRange = this.timeSrv.timeRange()) {\n    const msRange = range.to.diff(range.from);\n    const sRange = Math.round(msRange / 1000);\n    return {\n      __range_ms: { text: msRange, value: msRange },\n      __range_s: { text: sRange, value: sRange },\n      __range: { text: sRange + 's', value: sRange + 's' },\n    };\n  }\n\n  createAnnotationQueryOptions = (options: any): DataQueryRequest<PromQuery> => {\n    const annotation = options.annotation;\n    const interval =\n      annotation && annotation.step && typeof annotation.step === 'string'\n        ? annotation.step\n        : ANNOTATION_QUERY_STEP_DEFAULT;\n    return {\n      ...options,\n      interval,\n    };\n  };\n\n  async annotationQuery(options: any): Promise<AnnotationEvent[]> {\n    const annotation = options.annotation;\n    const { expr = '', tagKeys = '', titleFormat = '', textFormat = '' } = annotation;\n\n    if (!expr) {\n      return Promise.resolve([]);\n    }\n\n    const start = this.getPrometheusTime(options.range.from, false);\n    const end = this.getPrometheusTime(options.range.to, true);\n    const queryOptions = this.createAnnotationQueryOptions(options);\n\n    // Unsetting min interval for accurate event resolution\n    const minStep = '1s';\n    const queryModel = {\n      expr,\n      interval: minStep,\n      refId: 'X',\n      requestId: `prom-query-${annotation.name}`,\n    };\n\n    const query = this.createQuery(queryModel, queryOptions, start, end);\n    const response = await this.performTimeSeriesQuery(query, query.start, query.end).toPromise();\n    const eventList: AnnotationEvent[] = [];\n    const splitKeys = tagKeys.split(',');\n\n    if (isFetchErrorResponse(response) && response.cancelled) {\n      return [];\n    }\n\n    const step = Math.floor(query.step ?? 15) * 1000;\n\n    response?.data?.data?.result?.forEach(series => {\n      const tags = Object.entries(series.metric)\n        .filter(([k]) => splitKeys.includes(k))\n        .map(([_k, v]: [string, string]) => v);\n\n      series.values.forEach((value: any[]) => {\n        let timestampValue;\n        // rewrite timeseries to a common format\n        if (annotation.useValueForTime) {\n          timestampValue = Math.floor(parseFloat(value[1]));\n          value[1] = 1;\n        } else {\n          timestampValue = Math.floor(parseFloat(value[0])) * 1000;\n        }\n        value[0] = timestampValue;\n      });\n\n      const activeValues = series.values.filter(value => parseFloat(value[1]) >= 1);\n      const activeValuesTimestamps = activeValues.map(value => value[0]);\n\n      // Instead of creating singular annotation for each active event we group events into region if they are less\n      // then `step` apart.\n      let latestEvent: AnnotationEvent | null = null;\n\n      for (const timestamp of activeValuesTimestamps) {\n        // We already have event `open` and we have new event that is inside the `step` so we just update the end.\n        if (latestEvent && (latestEvent.timeEnd ?? 0) + step >= timestamp) {\n          latestEvent.timeEnd = timestamp;\n          continue;\n        }\n\n        // Event exists but new one is outside of the `step` so we \"finish\" the current region.\n        if (latestEvent) {\n          eventList.push(latestEvent);\n        }\n\n        // We start a new region.\n        latestEvent = {\n          time: timestamp,\n          timeEnd: timestamp,\n          annotation,\n          title: renderTemplate(titleFormat, series.metric),\n          tags,\n          text: renderTemplate(textFormat, series.metric),\n        };\n      }\n\n      if (latestEvent) {\n        // finish up last point if we have one\n        latestEvent.timeEnd = activeValuesTimestamps[activeValuesTimestamps.length - 1];\n        eventList.push(latestEvent);\n      }\n    });\n\n    return eventList;\n  }\n\n  async getTagKeys() {\n    const result = await this.metadataRequest('/api/v1/labels');\n    return result?.data?.data?.map((value: any) => ({ text: value })) ?? [];\n  }\n\n  async getTagValues(options: any = {}) {\n    const result = await this.metadataRequest(`/api/v1/label/${options.key}/values`);\n    return result?.data?.data?.map((value: any) => ({ text: value })) ?? [];\n  }\n\n  async testDatasource() {\n    const now = new Date().getTime();\n    const query = { expr: '1+1' } as PromQueryRequest;\n    const response = await this.performInstantQuery(query, now / 1000).toPromise();\n    return response.data.status === 'success'\n      ? { status: 'success', message: 'Data source is working' }\n      : { status: 'error', message: response.data.error };\n  }\n\n  interpolateVariablesInQueries(queries: PromQuery[], scopedVars: ScopedVars): PromQuery[] {\n    let expandedQueries = queries;\n    if (queries && queries.length) {\n      expandedQueries = queries.map(query => {\n        const expandedQuery = {\n          ...query,\n          datasource: this.name,\n          expr: this.templateSrv.replace(query.expr, scopedVars, this.interpolateQueryExpr),\n        };\n        return expandedQuery;\n      });\n    }\n    return expandedQueries;\n  }\n\n  getQueryHints(query: PromQuery, result: any[]) {\n    return getQueryHints(query.expr ?? '', result, this);\n  }\n\n  async loadRules() {\n    try {\n      const res = await this.metadataRequest('/api/v1/rules');\n      const groups = res.data?.data?.groups;\n\n      if (groups) {\n        this.ruleMappings = extractRuleMappingFromGroups(groups);\n      }\n    } catch (e) {\n      console.log('Rules API is experimental. Ignore next error.');\n      console.error(e);\n    }\n  }\n\n  modifyQuery(query: PromQuery, action: any): PromQuery {\n    let expression = query.expr ?? '';\n    switch (action.type) {\n      case 'ADD_FILTER': {\n        expression = addLabelToQuery(expression, action.key, action.value);\n        break;\n      }\n      case 'ADD_FILTER_OUT': {\n        expression = addLabelToQuery(expression, action.key, action.value, '!=');\n        break;\n      }\n      case 'ADD_HISTOGRAM_QUANTILE': {\n        expression = `histogram_quantile(0.95, sum(rate(${expression}[5m])) by (le))`;\n        break;\n      }\n      case 'ADD_RATE': {\n        expression = `rate(${expression}[5m])`;\n        break;\n      }\n      case 'ADD_SUM': {\n        expression = `sum(${expression.trim()}) by ($1)`;\n        break;\n      }\n      case 'EXPAND_RULES': {\n        if (action.mapping) {\n          expression = expandRecordingRules(expression, action.mapping);\n        }\n        break;\n      }\n      default:\n        break;\n    }\n    return { ...query, expr: expression };\n  }\n\n  getPrometheusTime(date: string | DateTime, roundUp: boolean) {\n    if (typeof date === 'string') {\n      date = dateMath.parse(date, roundUp)!;\n    }\n\n    return Math.ceil(date.valueOf() / 1000);\n  }\n\n  getTimeRange(): { start: number; end: number } {\n    const range = this.timeSrv.timeRange();\n    return {\n      start: this.getPrometheusTime(range.from, false),\n      end: this.getPrometheusTime(range.to, true),\n    };\n  }\n\n  getOriginalMetricName(labelData: { [key: string]: string }) {\n    return getOriginalMetricName(labelData);\n  }\n}\n\n/**\n * Align query range to step.\n * Rounds start and end down to a multiple of step.\n * @param start Timestamp marking the beginning of the range.\n * @param end Timestamp marking the end of the range.\n * @param step Interval to align start and end with.\n * @param utcOffsetSec Number of seconds current timezone is offset from UTC\n */\nexport function alignRange(\n  start: number,\n  end: number,\n  step: number,\n  utcOffsetSec: number\n): { end: number; start: number } {\n  const alignedEnd = Math.floor((end + utcOffsetSec) / step) * step - utcOffsetSec;\n  const alignedStart = Math.floor((start + utcOffsetSec) / step) * step - utcOffsetSec;\n  return {\n    end: alignedEnd,\n    start: alignedStart,\n  };\n}\n\nexport function extractRuleMappingFromGroups(groups: any[]) {\n  return groups.reduce(\n    (mapping, group) =>\n      group.rules\n        .filter((rule: any) => rule.type === 'recording')\n        .reduce(\n          (acc: { [key: string]: string }, rule: any) => ({\n            ...acc,\n            [rule.name]: rule.query,\n          }),\n          mapping\n        ),\n    {}\n  );\n}\n\nexport function prometheusRegularEscape(value: any) {\n  return typeof value === 'string' ? value.replace(/\\\\/g, '\\\\\\\\').replace(/'/g, \"\\\\\\\\'\") : value;\n}\n\nexport function prometheusSpecialRegexEscape(value: any) {\n  return typeof value === 'string' ? value.replace(/\\\\/g, '\\\\\\\\\\\\\\\\').replace(/[$^*{}\\[\\]\\'+?.()|]/g, '\\\\\\\\$&') : value;\n}\n","import _ from 'lodash';\nimport React, { ReactNode } from 'react';\n\nimport { Plugin } from 'slate';\nimport {\n  ButtonCascader,\n  CascaderOption,\n  SlatePrism,\n  TypeaheadInput,\n  TypeaheadOutput,\n  QueryField,\n  BracesPlugin,\n} from '@grafana/ui';\n\nimport Prism from 'prismjs';\n\n// dom also includes Element polyfills\nimport { PromQuery, PromOptions, PromMetricsMetadata } from '../types';\nimport { CancelablePromise, makePromiseCancelable } from 'app/core/utils/CancelablePromise';\nimport { ExploreQueryFieldProps, QueryHint, isDataFrame, toLegacyResponseData, HistoryItem } from '@grafana/data';\nimport { DOMUtil, SuggestionsState } from '@grafana/ui';\nimport { PrometheusDatasource } from '../datasource';\n\nconst HISTOGRAM_GROUP = '__histograms__';\nconst PRISM_SYNTAX = 'promql';\nexport const RECORDING_RULES_GROUP = '__recording_rules__';\n\nfunction getChooserText(metricsLookupDisabled: boolean, hasSyntax: boolean, metrics: string[]) {\n  if (metricsLookupDisabled) {\n    return '(Disabled)';\n  }\n\n  if (!hasSyntax) {\n    return 'Loading metrics...';\n  }\n\n  if (metrics && metrics.length === 0) {\n    return '(No metrics found)';\n  }\n\n  return 'Metrics';\n}\n\nfunction addMetricsMetadata(metric: string, metadata?: PromMetricsMetadata): CascaderOption {\n  const option: CascaderOption = { label: metric, value: metric };\n  if (metadata && metadata[metric]) {\n    const { type = '', help } = metadata[metric][0];\n    option.title = [metric, type.toUpperCase(), help].join('\\n');\n  }\n  return option;\n}\n\nexport function groupMetricsByPrefix(metrics: string[], metadata?: PromMetricsMetadata): CascaderOption[] {\n  // Filter out recording rules and insert as first option\n  const ruleRegex = /:\\w+:/;\n  const ruleNames = metrics.filter(metric => ruleRegex.test(metric));\n  const rulesOption = {\n    label: 'Recording rules',\n    value: RECORDING_RULES_GROUP,\n    children: ruleNames\n      .slice()\n      .sort()\n      .map(name => ({ label: name, value: name })),\n  };\n\n  const options = ruleNames.length > 0 ? [rulesOption] : [];\n\n  const delimiter = '_';\n  const metricsOptions = _.chain(metrics)\n    .filter((metric: string) => !ruleRegex.test(metric))\n    .groupBy((metric: string) => metric.split(delimiter)[0])\n    .map(\n      (metricsForPrefix: string[], prefix: string): CascaderOption => {\n        const prefixIsMetric = metricsForPrefix.length === 1 && metricsForPrefix[0] === prefix;\n        const children = prefixIsMetric ? [] : metricsForPrefix.sort().map(m => addMetricsMetadata(m, metadata));\n        return {\n          children,\n          label: prefix,\n          value: prefix,\n        };\n      }\n    )\n    .sortBy('label')\n    .value();\n\n  return [...options, ...metricsOptions];\n}\n\nexport function willApplySuggestion(suggestion: string, { typeaheadContext, typeaheadText }: SuggestionsState): string {\n  // Modify suggestion based on context\n  switch (typeaheadContext) {\n    case 'context-labels': {\n      const nextChar = DOMUtil.getNextCharacter();\n      if (!nextChar || nextChar === '}' || nextChar === ',') {\n        suggestion += '=';\n      }\n      break;\n    }\n\n    case 'context-label-values': {\n      // Always add quotes and remove existing ones instead\n      if (!typeaheadText.match(/^(!?=~?\"|\")/)) {\n        suggestion = `\"${suggestion}`;\n      }\n      if (DOMUtil.getNextCharacter() !== '\"') {\n        suggestion = `${suggestion}\"`;\n      }\n      break;\n    }\n\n    default:\n  }\n  return suggestion;\n}\n\ninterface PromQueryFieldProps extends ExploreQueryFieldProps<PrometheusDatasource, PromQuery, PromOptions> {\n  history: Array<HistoryItem<PromQuery>>;\n  ExtraFieldElement?: ReactNode;\n}\n\ninterface PromQueryFieldState {\n  metricsOptions: any[];\n  syntaxLoaded: boolean;\n  hint: QueryHint | null;\n}\n\nclass PromQueryField extends React.PureComponent<PromQueryFieldProps, PromQueryFieldState> {\n  plugins: Plugin[];\n  languageProviderInitializationPromise: CancelablePromise<any>;\n\n  constructor(props: PromQueryFieldProps, context: React.Context<any>) {\n    super(props, context);\n\n    this.plugins = [\n      BracesPlugin(),\n      SlatePrism({\n        onlyIn: (node: any) => node.type === 'code_block',\n        getSyntax: (node: any) => 'promql',\n      }),\n    ];\n\n    this.state = {\n      metricsOptions: [],\n      syntaxLoaded: false,\n      hint: null,\n    };\n  }\n\n  componentDidMount() {\n    if (this.props.datasource.languageProvider) {\n      this.refreshMetrics();\n    }\n    this.refreshHint();\n  }\n\n  componentWillUnmount() {\n    if (this.languageProviderInitializationPromise) {\n      this.languageProviderInitializationPromise.cancel();\n    }\n  }\n\n  componentDidUpdate(prevProps: PromQueryFieldProps) {\n    const {\n      data,\n      datasource: { languageProvider },\n      range,\n    } = this.props;\n\n    const rangeChanged =\n      range &&\n      prevProps.range &&\n      !_.isEqual(\n        { from: range.from.valueOf(), to: range.to.valueOf() },\n        {\n          from: prevProps.range.from.valueOf(),\n          to: prevProps.range.to.valueOf(),\n        }\n      );\n\n    if (languageProvider !== prevProps.datasource.languageProvider) {\n      // We reset this only on DS change so we do not flesh loading state on every rangeChange which happens on every\n      // query run if using relative range.\n      this.setState({\n        metricsOptions: [],\n        syntaxLoaded: false,\n      });\n    }\n\n    if (languageProvider !== prevProps.datasource.languageProvider || rangeChanged) {\n      this.refreshMetrics();\n    }\n\n    if (data && prevProps.data && prevProps.data.series !== data.series) {\n      this.refreshHint();\n    }\n  }\n\n  refreshHint = () => {\n    const { datasource, query, data } = this.props;\n\n    if (!data || data.series.length === 0) {\n      this.setState({ hint: null });\n      return;\n    }\n\n    const result = isDataFrame(data.series[0]) ? data.series.map(toLegacyResponseData) : data.series;\n    const hints = datasource.getQueryHints(query, result);\n    let hint = hints.length > 0 ? hints[0] : null;\n\n    // Hint for big disabled lookups\n    if (!hint && !datasource.lookupsDisabled && datasource.languageProvider.lookupsDisabled) {\n      hint = {\n        label: `Dynamic label lookup is disabled for datasources with more than ${datasource.languageProvider.lookupMetricsThreshold} metrics.`,\n        type: 'INFO',\n      };\n    }\n    this.setState({ hint });\n  };\n\n  refreshMetrics = async () => {\n    const {\n      datasource: { languageProvider },\n    } = this.props;\n\n    Prism.languages[PRISM_SYNTAX] = languageProvider.syntax;\n    this.languageProviderInitializationPromise = makePromiseCancelable(languageProvider.start());\n\n    try {\n      const remainingTasks = await this.languageProviderInitializationPromise.promise;\n      await Promise.all(remainingTasks);\n      this.onUpdateLanguage();\n    } catch (err) {\n      if (!err.isCanceled) {\n        throw err;\n      }\n    }\n  };\n\n  onChangeMetrics = (values: string[], selectedOptions: CascaderOption[]) => {\n    let query;\n    if (selectedOptions.length === 1) {\n      const selectedOption = selectedOptions[0];\n      if (!selectedOption.children || selectedOption.children.length === 0) {\n        query = selectedOption.value;\n      } else {\n        // Ignore click on group\n        return;\n      }\n    } else {\n      const prefix = selectedOptions[0].value;\n      const metric = selectedOptions[1].value;\n      if (prefix === HISTOGRAM_GROUP) {\n        query = `histogram_quantile(0.95, sum(rate(${metric}[5m])) by (le))`;\n      } else {\n        query = metric;\n      }\n    }\n    this.onChangeQuery(query, true);\n  };\n\n  onChangeQuery = (value: string, override?: boolean) => {\n    // Send text change to parent\n    const { query, onChange, onRunQuery } = this.props;\n    if (onChange) {\n      const nextQuery: PromQuery = { ...query, expr: value };\n      onChange(nextQuery);\n\n      if (override && onRunQuery) {\n        onRunQuery();\n      }\n    }\n  };\n\n  onClickHintFix = () => {\n    const { datasource, query, onChange, onRunQuery } = this.props;\n    const { hint } = this.state;\n\n    onChange(datasource.modifyQuery(query, hint!.fix!.action));\n    onRunQuery();\n  };\n\n  onUpdateLanguage = () => {\n    const {\n      datasource: { languageProvider },\n    } = this.props;\n    const { histogramMetrics, metrics, metricsMetadata } = languageProvider;\n\n    if (!metrics) {\n      return;\n    }\n\n    // Build metrics tree\n    const metricsByPrefix = groupMetricsByPrefix(metrics, metricsMetadata);\n    const histogramOptions = histogramMetrics.map((hm: any) => ({ label: hm, value: hm }));\n    const metricsOptions =\n      histogramMetrics.length > 0\n        ? [\n            { label: 'Histograms', value: HISTOGRAM_GROUP, children: histogramOptions, isLeaf: false },\n            ...metricsByPrefix,\n          ]\n        : metricsByPrefix;\n\n    this.setState({ metricsOptions, syntaxLoaded: true });\n  };\n\n  onTypeahead = async (typeahead: TypeaheadInput): Promise<TypeaheadOutput> => {\n    const {\n      datasource: { languageProvider },\n    } = this.props;\n\n    if (!languageProvider) {\n      return { suggestions: [] };\n    }\n\n    const { history } = this.props;\n    const { prefix, text, value, wrapperClasses, labelKey } = typeahead;\n\n    const result = await languageProvider.provideCompletionItems(\n      { text, value, prefix, wrapperClasses, labelKey },\n      { history }\n    );\n\n    return result;\n  };\n\n  render() {\n    const {\n      datasource,\n      datasource: { languageProvider },\n      query,\n      ExtraFieldElement,\n    } = this.props;\n    const { metricsOptions, syntaxLoaded, hint } = this.state;\n    const cleanText = languageProvider ? languageProvider.cleanText : undefined;\n    const chooserText = getChooserText(datasource.lookupsDisabled, syntaxLoaded, metricsOptions);\n    const buttonDisabled = !(syntaxLoaded && metricsOptions && metricsOptions.length > 0);\n\n    return (\n      <>\n        <div className=\"gf-form-inline gf-form-inline--xs-view-flex-column flex-grow-1\">\n          <div className=\"gf-form flex-shrink-0 min-width-5\">\n            <ButtonCascader options={metricsOptions} disabled={buttonDisabled} onChange={this.onChangeMetrics}>\n              {chooserText}\n            </ButtonCascader>\n          </div>\n          <div className=\"gf-form gf-form--grow flex-shrink-1 min-width-15\">\n            <QueryField\n              additionalPlugins={this.plugins}\n              cleanText={cleanText}\n              query={query.expr}\n              onTypeahead={this.onTypeahead}\n              onWillApplySuggestion={willApplySuggestion}\n              onBlur={this.props.onBlur}\n              onChange={this.onChangeQuery}\n              onRunQuery={this.props.onRunQuery}\n              placeholder=\"Enter a PromQL query (run with Shift+Enter)\"\n              portalOrigin=\"prometheus\"\n              syntaxLoaded={syntaxLoaded}\n            />\n          </div>\n        </div>\n        {ExtraFieldElement}\n        {hint ? (\n          <div className=\"query-row-break\">\n            <div className=\"prom-query-field-info text-warning\">\n              {hint.label}{' '}\n              {hint.fix ? (\n                <a className=\"text-link muted\" onClick={this.onClickHintFix}>\n                  {hint.fix.label}\n                </a>\n              ) : null}\n            </div>\n          </div>\n        ) : null}\n      </>\n    );\n  }\n}\n\nexport default PromQueryField;\n","import _ from 'lodash';\nimport React, { Component } from 'react';\n\nimport { PrometheusDatasource } from '../datasource';\nimport { PromQuery } from '../types';\nimport { DataQueryRequest, PanelData } from '@grafana/data';\n\ninterface Props {\n  datasource: PrometheusDatasource;\n  query: PromQuery;\n  panelData?: PanelData;\n}\n\ninterface State {\n  href: string;\n}\n\nexport default class PromLink extends Component<Props, State> {\n  state: State = { href: '' };\n\n  async componentDidUpdate(prevProps: Props) {\n    const { panelData } = this.props;\n\n    if (panelData && panelData.request && prevProps.panelData !== panelData) {\n      const href = await this.getExternalLink(panelData);\n      this.setState({ href });\n    }\n  }\n\n  async getExternalLink(panelData: PanelData): Promise<string> {\n    const { query, datasource } = this.props;\n    const { request } = panelData;\n\n    if (!request) {\n      return '';\n    }\n\n    const range = request.range;\n    const start = datasource.getPrometheusTime(range.from, false);\n    const end = datasource.getPrometheusTime(range.to, true);\n    const rangeDiff = Math.ceil(end - start);\n    const endTime = range.to.utc().format('YYYY-MM-DD HH:mm');\n\n    const options = {\n      interval: request.interval,\n    } as DataQueryRequest<PromQuery>;\n\n    const queryOptions = datasource.createQuery(query, options, start, end);\n    const expr = {\n      'g0.expr': queryOptions.expr,\n      'g0.range_input': rangeDiff + 's',\n      'g0.end_input': endTime,\n      'g0.step_input': queryOptions.step,\n      'g0.tab': 0,\n    };\n\n    const args = _.map(expr, (v: string, k: string) => {\n      return k + '=' + encodeURIComponent(v);\n    }).join('&');\n    return `${datasource.directUrl}/graph?${args}`;\n  }\n\n  render() {\n    const { href } = this.state;\n\n    return (\n      <a href={href} target=\"_blank\" rel=\"noopener\">\n        Prometheus\n      </a>\n    );\n  }\n}\n","import _ from 'lodash';\nimport React, { PureComponent } from 'react';\n\n// Types\nimport { InlineFormLabel, LegacyForms, Select } from '@grafana/ui';\nimport { SelectableValue, QueryEditorProps } from '@grafana/data';\n\nconst { Switch } = LegacyForms;\n\nimport { PrometheusDatasource } from '../datasource';\nimport { PromQuery, PromOptions } from '../types';\n\nimport PromQueryField from './PromQueryField';\nimport PromLink from './PromLink';\nexport type Props = QueryEditorProps<PrometheusDatasource, PromQuery, PromOptions>;\n\nconst FORMAT_OPTIONS: Array<SelectableValue<string>> = [\n  { label: 'Time series', value: 'time_series' },\n  { label: 'Table', value: 'table' },\n  { label: 'Heatmap', value: 'heatmap' },\n];\n\nconst INTERVAL_FACTOR_OPTIONS: Array<SelectableValue<number>> = _.map([1, 2, 3, 4, 5, 10], (value: number) => ({\n  value,\n  label: '1/' + value,\n}));\n\ninterface State {\n  legendFormat?: string;\n  formatOption: SelectableValue<string>;\n  interval?: string;\n  intervalFactorOption: SelectableValue<number>;\n  instant: boolean;\n}\n\nexport class PromQueryEditor extends PureComponent<Props, State> {\n  // Query target to be modified and used for queries\n  query: PromQuery;\n\n  constructor(props: Props) {\n    super(props);\n    // Use default query to prevent undefined input values\n    const defaultQuery: Partial<PromQuery> = { expr: '', legendFormat: '', interval: '' };\n    const query = Object.assign({}, defaultQuery, props.query);\n    this.query = query;\n    // Query target properties that are fully controlled inputs\n    this.state = {\n      // Fully controlled text inputs\n      interval: query.interval,\n      legendFormat: query.legendFormat,\n      // Select options\n      formatOption: FORMAT_OPTIONS.find(option => option.value === query.format) || FORMAT_OPTIONS[0],\n      intervalFactorOption:\n        INTERVAL_FACTOR_OPTIONS.find(option => option.value === query.intervalFactor) || INTERVAL_FACTOR_OPTIONS[0],\n      // Switch options\n      instant: Boolean(query.instant),\n    };\n  }\n\n  onFieldChange = (query: PromQuery, override?: any) => {\n    this.query.expr = query.expr;\n  };\n\n  onFormatChange = (option: SelectableValue<string>) => {\n    this.query.format = option.value;\n    this.setState({ formatOption: option }, this.onRunQuery);\n  };\n\n  onInstantChange = (e: React.ChangeEvent<HTMLInputElement>) => {\n    const instant = e.target.checked;\n    this.query.instant = instant;\n    this.setState({ instant }, this.onRunQuery);\n  };\n\n  onIntervalChange = (e: React.SyntheticEvent<HTMLInputElement>) => {\n    const interval = e.currentTarget.value;\n    this.query.interval = interval;\n    this.setState({ interval });\n  };\n\n  onIntervalFactorChange = (option: SelectableValue<number>) => {\n    this.query.intervalFactor = option.value;\n    this.setState({ intervalFactorOption: option }, this.onRunQuery);\n  };\n\n  onLegendChange = (e: React.SyntheticEvent<HTMLInputElement>) => {\n    const legendFormat = e.currentTarget.value;\n    this.query.legendFormat = legendFormat;\n    this.setState({ legendFormat });\n  };\n\n  onRunQuery = () => {\n    const { query } = this;\n    this.props.onChange(query);\n    this.props.onRunQuery();\n  };\n\n  render() {\n    const { datasource, query, range, data } = this.props;\n    const { formatOption, instant, interval, intervalFactorOption, legendFormat } = this.state;\n\n    return (\n      <div>\n        <PromQueryField\n          datasource={datasource}\n          query={query}\n          range={range}\n          onRunQuery={this.onRunQuery}\n          onChange={this.onFieldChange}\n          history={[]}\n          data={data}\n        />\n\n        <div className=\"gf-form-inline\">\n          <div className=\"gf-form\">\n            <InlineFormLabel\n              width={7}\n              tooltip=\"Controls the name of the time series, using name or pattern. For example\n        {{hostname}} will be replaced with label value for the label hostname.\"\n            >\n              Legend\n            </InlineFormLabel>\n            <input\n              type=\"text\"\n              className=\"gf-form-input\"\n              placeholder=\"legend format\"\n              value={legendFormat}\n              onChange={this.onLegendChange}\n              onBlur={this.onRunQuery}\n            />\n          </div>\n\n          <div className=\"gf-form\">\n            <InlineFormLabel\n              width={7}\n              tooltip={\n                <>\n                  An additional lower limit for the step parameter of the Prometheus query and for the{' '}\n                  <code>$__interval</code> and <code>$__rate_interval</code> variables. The limit is absolute and not\n                  modified by the \"Resolution\" setting.\n                </>\n              }\n            >\n              Min step\n            </InlineFormLabel>\n            <input\n              type=\"text\"\n              className=\"gf-form-input width-8\"\n              placeholder={interval}\n              onChange={this.onIntervalChange}\n              onBlur={this.onRunQuery}\n              value={interval}\n            />\n          </div>\n\n          <div className=\"gf-form\">\n            <div className=\"gf-form-label\">Resolution</div>\n            <Select\n              isSearchable={false}\n              menuPlacement=\"bottom\"\n              options={INTERVAL_FACTOR_OPTIONS}\n              onChange={this.onIntervalFactorChange}\n              value={intervalFactorOption}\n            />\n          </div>\n\n          <div className=\"gf-form\">\n            <div className=\"gf-form-label width-7\">Format</div>\n            <Select\n              width={16}\n              isSearchable={false}\n              options={FORMAT_OPTIONS}\n              onChange={this.onFormatChange}\n              value={formatOption}\n            />\n            <Switch label=\"Instant\" checked={instant} onChange={this.onInstantChange} />\n\n            <InlineFormLabel width={10} tooltip=\"Link to Graph in Prometheus\">\n              <PromLink\n                datasource={datasource}\n                query={this.query} // Use modified query\n                panelData={data}\n              />\n            </InlineFormLabel>\n          </div>\n        </div>\n      </div>\n    );\n  }\n}\n","import React from 'react';\nimport { ExploreStartPageProps, DataQuery } from '@grafana/data';\n\nconst CHEAT_SHEET_ITEMS = [\n  {\n    title: 'Request Rate',\n    expression: 'rate(http_request_total[5m])',\n    label:\n      'Given an HTTP request counter, this query calculates the per-second average request rate over the last 5 minutes.',\n  },\n  {\n    title: '95th Percentile of Request Latencies',\n    expression: 'histogram_quantile(0.95, sum(rate(prometheus_http_request_duration_seconds_bucket[5m])) by (le))',\n    label: 'Calculates the 95th percentile of HTTP request rate over 5 minute windows.',\n  },\n  {\n    title: 'Alerts Firing',\n    expression: 'sort_desc(sum(sum_over_time(ALERTS{alertstate=\"firing\"}[24h])) by (alertname))',\n    label: 'Sums up the alerts that have been firing over the last 24 hours.',\n  },\n  {\n    title: 'Step',\n    label:\n      'Defines the graph resolution using a duration format (15s, 1m, 3h, ...). Small steps create high-resolution graphs but can be slow over larger time ranges. Using a longer step lowers the resolution and smooths the graph by producing fewer datapoints. If no step is given the resolution is calculated automatically.',\n  },\n];\n\nexport default (props: ExploreStartPageProps) => (\n  <div>\n    <h2>PromQL Cheat Sheet</h2>\n    {CHEAT_SHEET_ITEMS.map((item, index) => (\n      <div className=\"cheat-sheet-item\" key={index}>\n        <div className=\"cheat-sheet-item__title\">{item.title}</div>\n        {item.expression ? (\n          <div\n            className=\"cheat-sheet-item__example\"\n            onClick={e => props.onClickExample({ refId: 'A', expr: item.expression } as DataQuery)}\n          >\n            <code>{item.expression}</code>\n          </div>\n        ) : null}\n        <div className=\"cheat-sheet-item__label\">{item.label}</div>\n      </div>\n    ))}\n  </div>\n);\n","// Libraries\nimport React, { memo } from 'react';\nimport { css, cx } from 'emotion';\n\n// Types\nimport { InlineFormLabel, RadioButtonGroup } from '@grafana/ui';\n\nexport interface PromExploreExtraFieldProps {\n  queryType: string;\n  stepValue: string;\n  onStepChange: (e: React.SyntheticEvent<HTMLInputElement>) => void;\n  onKeyDownFunc: (e: React.KeyboardEvent<HTMLInputElement>) => void;\n  onQueryTypeChange: (value: string) => void;\n}\n\nexport const PromExploreExtraField: React.FC<PromExploreExtraFieldProps> = memo(\n  ({ queryType, stepValue, onStepChange, onQueryTypeChange, onKeyDownFunc }) => {\n    const rangeOptions = [\n      { value: 'range', label: 'Range' },\n      { value: 'instant', label: 'Instant' },\n      { value: 'both', label: 'Both' },\n    ];\n\n    return (\n      <div aria-label=\"Prometheus extra field\" className=\"gf-form-inline\">\n        {/*QueryTypeField */}\n        <div\n          data-testid=\"queryTypeField\"\n          className={cx(\n            'gf-form explore-input-margin',\n            css`\n              flex-wrap: nowrap;\n            `\n          )}\n          aria-label=\"Query type field\"\n        >\n          <InlineFormLabel width={5}>Query type</InlineFormLabel>\n\n          <RadioButtonGroup options={rangeOptions} value={queryType} onChange={onQueryTypeChange} />\n        </div>\n        {/*Step field*/}\n        <div\n          data-testid=\"stepField\"\n          className={cx(\n            'gf-form',\n            css`\n              flex-wrap: nowrap;\n            `\n          )}\n          aria-label=\"Step field\"\n        >\n          <InlineFormLabel\n            width={5}\n            tooltip={\n              'Time units can be used here, for example: 5s, 1m, 3h, 1d, 1y (Default if no unit is specified: s)'\n            }\n          >\n            Step\n          </InlineFormLabel>\n          <input\n            type={'text'}\n            className=\"gf-form-input width-4\"\n            placeholder={'auto'}\n            onChange={onStepChange}\n            onKeyDown={onKeyDownFunc}\n            value={stepValue}\n          />\n        </div>\n      </div>\n    );\n  }\n);\n","import React, { memo, FC } from 'react';\n\n// Types\nimport { ExploreQueryFieldProps } from '@grafana/data';\n\nimport { PrometheusDatasource } from '../datasource';\nimport { PromQuery, PromOptions } from '../types';\n\nimport PromQueryField from './PromQueryField';\nimport { PromExploreExtraField } from './PromExploreExtraField';\n\nexport type Props = ExploreQueryFieldProps<PrometheusDatasource, PromQuery, PromOptions>;\n\nexport const PromExploreQueryEditor: FC<Props> = (props: Props) => {\n  const { range, query, data, datasource, history, onChange, onRunQuery } = props;\n\n  function onChangeQueryStep(value: string) {\n    const { query, onChange } = props;\n    const nextQuery = { ...query, interval: value };\n    onChange(nextQuery);\n  }\n\n  function onStepChange(e: React.SyntheticEvent<HTMLInputElement>) {\n    if (e.currentTarget.value !== query.interval) {\n      onChangeQueryStep(e.currentTarget.value);\n    }\n  }\n\n  function onReturnKeyDown(e: React.KeyboardEvent<HTMLInputElement>) {\n    if (e.key === 'Enter' && (e.shiftKey || e.ctrlKey)) {\n      onRunQuery();\n    }\n  }\n\n  function onQueryTypeChange(value: string) {\n    const { query, onChange } = props;\n    let nextQuery;\n    if (value === 'instant') {\n      nextQuery = { ...query, instant: true, range: false };\n    } else if (value === 'range') {\n      nextQuery = { ...query, instant: false, range: true };\n    } else {\n      nextQuery = { ...query, instant: true, range: true };\n    }\n    onChange(nextQuery);\n  }\n\n  return (\n    <PromQueryField\n      datasource={datasource}\n      query={query}\n      range={range}\n      onRunQuery={onRunQuery}\n      onChange={onChange}\n      onBlur={() => {}}\n      history={history}\n      data={data}\n      ExtraFieldElement={\n        <PromExploreExtraField\n          queryType={query.range && query.instant ? 'both' : query.instant ? 'instant' : 'range'}\n          stepValue={query.interval || ''}\n          onQueryTypeChange={onQueryTypeChange}\n          onStepChange={onStepChange}\n          onKeyDownFunc={onReturnKeyDown}\n        />\n      }\n    />\n  );\n};\n\nexport default memo(PromExploreQueryEditor);\n","import React, { SyntheticEvent } from 'react';\nimport { EventsWithValidation, InlineFormLabel, regexValidation, LegacyForms } from '@grafana/ui';\nconst { Select, Input, FormField, Switch } = LegacyForms;\nimport {\n  SelectableValue,\n  onUpdateDatasourceJsonDataOptionChecked,\n  DataSourcePluginOptionsEditorProps,\n} from '@grafana/data';\nimport { PromOptions } from '../types';\n\nconst httpOptions = [\n  { value: 'GET', label: 'GET' },\n  { value: 'POST', label: 'POST' },\n];\n\ntype Props = Pick<DataSourcePluginOptionsEditorProps<PromOptions>, 'options' | 'onOptionsChange'>;\n\nexport const PromSettings = (props: Props) => {\n  const { options, onOptionsChange } = props;\n\n  return (\n    <>\n      <div className=\"gf-form-group\">\n        <div className=\"gf-form-inline\">\n          <div className=\"gf-form\">\n            <FormField\n              label=\"Scrape interval\"\n              labelWidth={13}\n              inputEl={\n                <Input\n                  className=\"width-6\"\n                  value={options.jsonData.timeInterval}\n                  spellCheck={false}\n                  placeholder=\"15s\"\n                  onChange={onChangeHandler('timeInterval', options, onOptionsChange)}\n                  validationEvents={promSettingsValidationEvents}\n                />\n              }\n              tooltip=\"Set this to the typical scrape and evaluation interval configured in Prometheus. Defaults to 15s.\"\n            />\n          </div>\n        </div>\n        <div className=\"gf-form-inline\">\n          <div className=\"gf-form\">\n            <FormField\n              label=\"Query timeout\"\n              labelWidth={13}\n              inputEl={\n                <Input\n                  className=\"width-6\"\n                  value={options.jsonData.queryTimeout}\n                  onChange={onChangeHandler('queryTimeout', options, onOptionsChange)}\n                  spellCheck={false}\n                  placeholder=\"60s\"\n                  validationEvents={promSettingsValidationEvents}\n                />\n              }\n              tooltip=\"Set the Prometheus query timeout.\"\n            />\n          </div>\n        </div>\n        <div className=\"gf-form\">\n          <InlineFormLabel\n            width={13}\n            tooltip=\"Specify the HTTP Method to query Prometheus. (POST is only available in Prometheus >= v2.1.0)\"\n          >\n            HTTP Method\n          </InlineFormLabel>\n          <Select\n            options={httpOptions}\n            value={httpOptions.find(o => o.value === options.jsonData.httpMethod)}\n            onChange={onChangeHandler('httpMethod', options, onOptionsChange)}\n            width={7}\n          />\n        </div>\n      </div>\n      <h3 className=\"page-heading\">Misc</h3>\n      <div className=\"gf-form-group\">\n        <div className=\"gf-form\">\n          <Switch\n            checked={options.jsonData.disableMetricsLookup ?? false}\n            label=\"Disable metrics lookup\"\n            labelClass=\"width-14\"\n            onChange={onUpdateDatasourceJsonDataOptionChecked(props, 'disableMetricsLookup')}\n            tooltip=\"Checking this option will disable the metrics chooser and metric/label support in the query field's autocomplete. This helps if you have performance issues with bigger Prometheus instances.\"\n          />\n        </div>\n        <div className=\"gf-form-inline\">\n          <div className=\"gf-form max-width-30\">\n            <FormField\n              label=\"Custom query parameters\"\n              labelWidth={14}\n              tooltip=\"Add Custom parameters to Prometheus or Thanos queries.\"\n              inputEl={\n                <Input\n                  className=\"width-25\"\n                  value={options.jsonData.customQueryParameters}\n                  onChange={onChangeHandler('customQueryParameters', options, onOptionsChange)}\n                  spellCheck={false}\n                  placeholder=\"Example: max_source_resolution=5m&timeout=10\"\n                />\n              }\n            />\n          </div>\n        </div>\n      </div>\n    </>\n  );\n};\n\nexport const promSettingsValidationEvents = {\n  [EventsWithValidation.onBlur]: [\n    regexValidation(\n      /^$|^\\d+(ms|[Mwdhmsy])$/,\n      'Value is not valid, you can use number with time unit specifier: y, M, w, d, h, m, s'\n    ),\n  ],\n};\n\nexport const getValueFromEventItem = (eventItem: SyntheticEvent<HTMLInputElement> | SelectableValue<string>) => {\n  if (!eventItem) {\n    return '';\n  }\n\n  if (eventItem.hasOwnProperty('currentTarget')) {\n    return eventItem.currentTarget.value;\n  }\n\n  return (eventItem as SelectableValue<string>).value;\n};\n\nconst onChangeHandler = (\n  key: keyof PromOptions,\n  options: Props['options'],\n  onOptionsChange: Props['onOptionsChange']\n) => (eventItem: SyntheticEvent<HTMLInputElement> | SelectableValue<string>) => {\n  onOptionsChange({\n    ...options,\n    jsonData: {\n      ...options.jsonData,\n      [key]: getValueFromEventItem(eventItem),\n    },\n  });\n};\n","import { DataSourcePlugin } from '@grafana/data';\nimport { ANNOTATION_QUERY_STEP_DEFAULT, PrometheusDatasource } from './datasource';\n\nimport { PromQueryEditor } from './components/PromQueryEditor';\nimport PromCheatSheet from './components/PromCheatSheet';\nimport PromExploreQueryEditor from './components/PromExploreQueryEditor';\n\nimport { ConfigEditor } from './configuration/ConfigEditor';\n\nclass PrometheusAnnotationsQueryCtrl {\n  static templateUrl = 'partials/annotations.editor.html';\n  stepDefaultValuePlaceholder = ANNOTATION_QUERY_STEP_DEFAULT;\n}\n\nexport const plugin = new DataSourcePlugin(PrometheusDatasource)\n  .setQueryEditor(PromQueryEditor)\n  .setConfigEditor(ConfigEditor)\n  .setExploreMetricsQueryField(PromExploreQueryEditor)\n  .setAnnotationQueryCtrl(PrometheusAnnotationsQueryCtrl)\n  .setExploreStartPage(PromCheatSheet);\n","import React from 'react';\nimport { DataSourceHttpSettings } from '@grafana/ui';\nimport { DataSourcePluginOptionsEditorProps } from '@grafana/data';\nimport { PromSettings } from './PromSettings';\nimport { PromOptions } from '../types';\nimport { config } from 'app/core/config';\n\nexport type Props = DataSourcePluginOptionsEditorProps<PromOptions>;\nexport const ConfigEditor = (props: Props) => {\n  const { options, onOptionsChange } = props;\n  return (\n    <>\n      <DataSourceHttpSettings\n        defaultUrl=\"http://localhost:9090\"\n        dataSourceConfig={options}\n        showAccessOptions={true}\n        onChange={onOptionsChange}\n        sigV4AuthToggleEnabled={config.sigV4AuthEnabled}\n      />\n\n      <PromSettings options={options} onOptionsChange={onOptionsChange} />\n    </>\n  );\n};\n","// https://github.com/facebook/react/issues/5465\n\nexport interface CancelablePromise<T> {\n  promise: Promise<T>;\n  cancel: () => void;\n}\n\nexport const makePromiseCancelable = <T>(promise: Promise<T>): CancelablePromise<T> => {\n  let hasCanceled_ = false;\n\n  const wrappedPromise = new Promise<T>((resolve, reject) => {\n    promise.then(val => (hasCanceled_ ? reject({ isCanceled: true }) : resolve(val)));\n    promise.catch(error => (hasCanceled_ ? reject({ isCanceled: true }) : reject(error)));\n  });\n\n  return {\n    promise: wrappedPromise,\n    cancel() {\n      hasCanceled_ = true;\n    },\n  };\n};\n"],"sourceRoot":""}