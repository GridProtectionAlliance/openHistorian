{"version":3,"file":"8891.80b3b278e0fc66508502.js","mappings":"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","sources":["webpack://grafana/./public/app/plugins/panel/heatmap/utils.ts"],"sourcesContent":["import { RefObject } from 'react';\nimport uPlot, { Cursor } from 'uplot';\n\nimport {\n  DataFrameType,\n  formattedValueToString,\n  getValueFormat,\n  GrafanaTheme2,\n  incrRoundDn,\n  incrRoundUp,\n  TimeRange,\n  FieldType,\n} from '@grafana/data';\nimport { AxisPlacement, ScaleDirection, ScaleDistribution, ScaleOrientation, HeatmapCellLayout } from '@grafana/schema';\nimport { UPlotConfigBuilder } from '@grafana/ui';\nimport { isHeatmapCellsDense, readHeatmapRowsCustomMeta } from 'app/features/transformers/calculateHeatmap/heatmap';\n\nimport { pointWithin, Quadtree, Rect } from '../barchart/quadtree';\n\nimport { HeatmapData } from './fields';\nimport { FieldConfig, HeatmapSelectionMode, YAxisConfig } from './types';\n\ninterface PathbuilderOpts {\n  each: (u: uPlot, seriesIdx: number, dataIdx: number, lft: number, top: number, wid: number, hgt: number) => void;\n  gap?: number | null;\n  hideLE?: number;\n  hideGE?: number;\n  xAlign?: -1 | 0 | 1;\n  yAlign?: -1 | 0 | 1;\n  ySizeDivisor?: number;\n  disp: {\n    fill: {\n      values: (u: uPlot, seriesIndex: number) => number[];\n      index: Array<CanvasRenderingContext2D['fillStyle']>;\n    };\n  };\n}\n\ninterface PointsBuilderOpts {\n  each: (u: uPlot, seriesIdx: number, dataIdx: number, lft: number, top: number, wid: number, hgt: number) => void;\n}\n\ninterface PrepConfigOpts {\n  dataRef: RefObject<HeatmapData>;\n  theme: GrafanaTheme2;\n  timeZone: string;\n  getTimeRange: () => TimeRange;\n  exemplarColor: string;\n  cellGap?: number | null; // in css pixels\n  hideLE?: number;\n  hideGE?: number;\n  yAxisConfig: YAxisConfig;\n  ySizeDivisor?: number;\n  selectionMode?: HeatmapSelectionMode;\n}\n\nexport function prepConfig(opts: PrepConfigOpts) {\n  const {\n    dataRef,\n    theme,\n    timeZone,\n    getTimeRange,\n    cellGap,\n    hideLE,\n    hideGE,\n    yAxisConfig,\n    ySizeDivisor,\n    selectionMode = HeatmapSelectionMode.X,\n  } = opts;\n\n  const xScaleKey = 'x';\n  let isTime = true;\n\n  if (dataRef.current?.heatmap?.fields[0].type !== FieldType.time) {\n    isTime = false;\n  }\n\n  const pxRatio = devicePixelRatio;\n\n  let heatmapType = dataRef.current?.heatmap?.meta?.type;\n  const exemplarFillColor = theme.visualization.getColorByName(opts.exemplarColor);\n\n  let qt: Quadtree;\n  let hRect: Rect | null;\n\n  let builder = new UPlotConfigBuilder(timeZone);\n\n  builder.addHook('init', (u) => {\n    u.root.querySelectorAll<HTMLElement>('.u-cursor-pt').forEach((el) => {\n      Object.assign(el.style, {\n        borderRadius: '0',\n        border: '1px solid white',\n        background: 'transparent',\n      });\n    });\n  });\n\n  if (isTime) {\n    // this is a tmp hack because in mode: 2, uplot does not currently call scales.x.range() for setData() calls\n    // scales.x.range() typically reads back from drilled-down panelProps.timeRange via getTimeRange()\n    builder.addHook('setData', (u) => {\n      //let [min, max] = (u.scales!.x!.range! as uPlot.Range.Function)(u, 0, 100, xScaleKey);\n\n      let { min: xMin, max: xMax } = u.scales!.x;\n\n      let min = getTimeRange().from.valueOf();\n      let max = getTimeRange().to.valueOf();\n\n      if (xMin !== min || xMax !== max) {\n        queueMicrotask(() => {\n          u.setScale(xScaleKey, { min, max });\n        });\n      }\n    });\n  }\n\n  builder.addHook('drawClear', (u) => {\n    qt = qt || new Quadtree(0, 0, u.bbox.width, u.bbox.height);\n\n    qt.clear();\n\n    // force-clear the path cache to cause drawBars() to rebuild new quadtree\n    u.series.forEach((s, i) => {\n      if (i > 0) {\n        // @ts-ignore\n        s._paths = null;\n      }\n    });\n  });\n\n  builder.setMode(2);\n\n  builder.addScale({\n    scaleKey: xScaleKey,\n    isTime,\n    orientation: ScaleOrientation.Horizontal,\n    direction: ScaleDirection.Right,\n    // TODO: expand by x bucket size and layout\n    range: (u, dataMin, dataMax) => {\n      if (isTime) {\n        return [getTimeRange().from.valueOf(), getTimeRange().to.valueOf()];\n      } else {\n        if (dataRef.current?.xLayout === HeatmapCellLayout.le) {\n          return [dataMin - dataRef.current?.xBucketSize!, dataMax];\n        } else if (dataRef.current?.xLayout === HeatmapCellLayout.ge) {\n          return [dataMin, dataMax + dataRef.current?.xBucketSize!];\n        } else {\n          let offset = dataRef.current?.xBucketSize! / 2;\n\n          return [dataMin - offset, dataMax + offset];\n        }\n      }\n    },\n  });\n\n  let incrs;\n\n  if (!isTime) {\n    incrs = [];\n\n    for (let i = 0; i < 10; i++) {\n      incrs.push(i * dataRef.current?.xBucketSize!);\n    }\n  }\n\n  builder.addAxis({\n    scaleKey: xScaleKey,\n    placement: AxisPlacement.Bottom,\n    incrs,\n    isTime,\n    theme: theme,\n    timeZone,\n  });\n\n  const yField = dataRef.current?.heatmap?.fields[1]!;\n  if (!yField) {\n    return builder; // early abort (avoids error)\n  }\n\n  const yFieldConfig: FieldConfig | undefined = yField.config?.custom;\n  const yScale = yFieldConfig?.scaleDistribution ?? { type: ScaleDistribution.Linear };\n  const yAxisReverse = Boolean(yAxisConfig.reverse);\n  const isSparseHeatmap = heatmapType === DataFrameType.HeatmapCells && !isHeatmapCellsDense(dataRef.current?.heatmap!);\n  const shouldUseLogScale = yScale.type !== ScaleDistribution.Linear || isSparseHeatmap;\n  const isOrdinalY = readHeatmapRowsCustomMeta(dataRef.current?.heatmap).yOrdinalDisplay != null;\n\n  // random to prevent syncing y in other heatmaps\n  // TODO: try to match TimeSeries y keygen algo to sync with TimeSeries panels (when not isOrdinalY)\n  const yScaleKey = 'y_' + (Math.random() + 1).toString(36).substring(7);\n\n  builder.addScale({\n    scaleKey: yScaleKey,\n    isTime: false,\n    // distribution: ScaleDistribution.Ordinal, // does not work with facets/scatter yet\n    orientation: ScaleOrientation.Vertical,\n    direction: yAxisReverse ? ScaleDirection.Down : ScaleDirection.Up,\n    // should be tweakable manually\n    distribution: shouldUseLogScale ? ScaleDistribution.Log : ScaleDistribution.Linear,\n    log: yScale.log ?? 2,\n    range:\n      // sparse already accounts for le/ge by explicit yMin & yMax cell bounds, so no need to expand y range\n      isSparseHeatmap\n        ? (u, dataMin, dataMax) => {\n            // ...but uPlot currently only auto-ranges from the yMin facet data, so we have to grow by 1 extra factor\n            // @ts-ignore\n            let bucketFactor = u.data[1][2][0] / u.data[1][1][0];\n\n            dataMax *= bucketFactor;\n\n            let scaleMin: number | null, scaleMax: number | null;\n\n            [scaleMin, scaleMax] = shouldUseLogScale\n              ? uPlot.rangeLog(dataMin, dataMax, (yScale.log ?? 2) as unknown as uPlot.Scale.LogBase, true)\n              : [dataMin, dataMax];\n\n            if (shouldUseLogScale && !isOrdinalY) {\n              let yExp = u.scales[yScaleKey].log!;\n              let log = yExp === 2 ? Math.log2 : Math.log10;\n\n              let { min: explicitMin, max: explicitMax } = yAxisConfig;\n\n              // guard against <= 0\n              if (explicitMin != null && explicitMin > 0) {\n                // snap to magnitude\n                let minLog = log(explicitMin);\n                scaleMin = yExp ** incrRoundDn(minLog, 1);\n              }\n\n              if (explicitMax != null && explicitMax > 0) {\n                let maxLog = log(explicitMax);\n                scaleMax = yExp ** incrRoundUp(maxLog, 1);\n              }\n            }\n\n            return [scaleMin, scaleMax];\n          }\n        : // dense and ordinal only have one of yMin|yMax|y, so expand range by one cell in the direction of le/ge/unknown\n          (u, dataMin, dataMax) => {\n            let scaleMin = dataMin,\n              scaleMax = dataMax;\n\n            let { min: explicitMin, max: explicitMax } = yAxisConfig;\n\n            // logarithmic expansion\n            if (shouldUseLogScale) {\n              let yExp = u.scales[yScaleKey].log!;\n\n              let minExpanded = false;\n              let maxExpanded = false;\n\n              let log = yExp === 2 ? Math.log2 : Math.log10;\n\n              if (ySizeDivisor !== 1) {\n                let minLog = log(dataMin);\n                let maxLog = log(dataMax);\n\n                if (!Number.isInteger(minLog)) {\n                  scaleMin = yExp ** incrRoundDn(minLog, 1);\n                  minExpanded = true;\n                }\n\n                if (!Number.isInteger(maxLog)) {\n                  scaleMax = yExp ** incrRoundUp(maxLog, 1);\n                  maxExpanded = true;\n                }\n              }\n\n              if (dataRef.current?.yLayout === HeatmapCellLayout.le) {\n                if (!minExpanded) {\n                  scaleMin /= yExp;\n                }\n              } else if (dataRef.current?.yLayout === HeatmapCellLayout.ge) {\n                if (!maxExpanded) {\n                  scaleMax *= yExp;\n                }\n              } else {\n                scaleMin /= yExp / 2;\n                scaleMax *= yExp / 2;\n              }\n\n              if (!isOrdinalY) {\n                // guard against <= 0\n                if (explicitMin != null && explicitMin > 0) {\n                  // snap down to magnitude\n                  let minLog = log(explicitMin);\n                  scaleMin = yExp ** incrRoundDn(minLog, 1);\n                }\n\n                if (explicitMax != null && explicitMax > 0) {\n                  let maxLog = log(explicitMax);\n                  scaleMax = yExp ** incrRoundUp(maxLog, 1);\n                }\n              }\n            }\n            // linear expansion\n            else {\n              let bucketSize = dataRef.current?.yBucketSize;\n\n              if (bucketSize === 0) {\n                bucketSize = 1;\n              }\n\n              if (bucketSize) {\n                if (dataRef.current?.yLayout === HeatmapCellLayout.le) {\n                  scaleMin -= bucketSize!;\n                } else if (dataRef.current?.yLayout === HeatmapCellLayout.ge) {\n                  scaleMax += bucketSize!;\n                } else {\n                  scaleMin -= bucketSize! / 2;\n                  scaleMax += bucketSize! / 2;\n                }\n              } else {\n                // how to expand scale range if inferred non-regular or log buckets?\n              }\n\n              if (!isOrdinalY) {\n                scaleMin = explicitMin ?? scaleMin;\n                scaleMax = explicitMax ?? scaleMax;\n              }\n            }\n\n            return [scaleMin, scaleMax];\n          },\n  });\n\n  const dispY = yField.display ?? getValueFormat('short');\n\n  builder.addAxis({\n    scaleKey: yScaleKey,\n    show: yAxisConfig.axisPlacement !== AxisPlacement.Hidden,\n    placement: yAxisConfig.axisPlacement || AxisPlacement.Left,\n    size: yAxisConfig.axisWidth || null,\n    label: yAxisConfig.axisLabel,\n    theme: theme,\n    formatValue: (v, decimals) => formattedValueToString(dispY(v, decimals)),\n    splits: isOrdinalY\n      ? (self: uPlot) => {\n          const meta = readHeatmapRowsCustomMeta(dataRef.current?.heatmap);\n          if (!meta.yOrdinalDisplay) {\n            return [0, 1]; //?\n          }\n          let splits = meta.yOrdinalDisplay.map((v, idx) => idx);\n\n          switch (dataRef.current?.yLayout) {\n            case HeatmapCellLayout.le:\n              splits.unshift(-1);\n              break;\n            case HeatmapCellLayout.ge:\n              splits.push(splits.length);\n              break;\n          }\n\n          // Skip labels when the height is too small\n          if (self.height < 60) {\n            splits = [splits[0], splits[splits.length - 1]];\n          } else {\n            while (splits.length > 3 && (self.height - 15) / splits.length < 10) {\n              splits = splits.filter((v, idx) => idx % 2 === 0); // remove half the items\n            }\n          }\n          return splits;\n        }\n      : undefined,\n    values: isOrdinalY\n      ? (self: uPlot, splits) => {\n          const meta = readHeatmapRowsCustomMeta(dataRef.current?.heatmap);\n          if (meta.yOrdinalDisplay) {\n            return splits.map((v) =>\n              v < 0\n                ? (meta.yMinDisplay ?? '') // Check prometheus style labels\n                : (meta.yOrdinalDisplay[v] ?? '')\n            );\n          }\n          return splits;\n        }\n      : undefined,\n  });\n\n  const pathBuilder = isSparseHeatmap ? heatmapPathsSparse : heatmapPathsDense;\n\n  // heatmap layer\n  builder.addSeries({\n    facets: [\n      {\n        scale: xScaleKey,\n        auto: true,\n        sorted: 1,\n      },\n      {\n        scale: yScaleKey,\n        auto: true,\n      },\n    ],\n    pathBuilder: pathBuilder({\n      each: (u, seriesIdx, dataIdx, x, y, xSize, ySize) => {\n        qt.add({\n          x: x - u.bbox.left,\n          y: y - u.bbox.top,\n          w: xSize,\n          h: ySize,\n          sidx: seriesIdx,\n          didx: dataIdx,\n        });\n      },\n      gap: cellGap,\n      hideLE,\n      hideGE,\n      xAlign:\n        dataRef.current?.xLayout === HeatmapCellLayout.le\n          ? -1\n          : dataRef.current?.xLayout === HeatmapCellLayout.ge\n            ? 1\n            : 0,\n      yAlign: ((dataRef.current?.yLayout === HeatmapCellLayout.le\n        ? -1\n        : dataRef.current?.yLayout === HeatmapCellLayout.ge\n          ? 1\n          : 0) * (yAxisReverse ? -1 : 1)) as -1 | 0 | 1,\n      ySizeDivisor,\n      disp: {\n        fill: {\n          values: (u, seriesIdx) => dataRef.current?.heatmapColors?.values!,\n          index: dataRef.current?.heatmapColors?.palette!,\n        },\n      },\n    }),\n    theme,\n    scaleKey: '', // facets' scales used (above)\n  });\n\n  // exemplars layer\n  builder.addSeries({\n    facets: [\n      {\n        scale: xScaleKey,\n        auto: true,\n        sorted: 1,\n      },\n      {\n        scale: yScaleKey,\n        auto: true,\n      },\n    ],\n    pathBuilder: heatmapPathsPoints(\n      {\n        each: (u, seriesIdx, dataIdx, x, y, xSize, ySize) => {\n          qt.add({\n            x: x - u.bbox.left,\n            y: y - u.bbox.top,\n            w: xSize,\n            h: ySize,\n            sidx: seriesIdx,\n            didx: dataIdx,\n          });\n        },\n      },\n      exemplarFillColor,\n      dataRef.current.yLayout\n    ),\n    theme,\n    scaleKey: '', // facets' scales used (above)\n  });\n\n  const dragX = selectionMode === HeatmapSelectionMode.X || selectionMode === HeatmapSelectionMode.Xy;\n  const dragY = selectionMode === HeatmapSelectionMode.Y || selectionMode === HeatmapSelectionMode.Xy;\n\n  const cursor: Cursor = {\n    drag: {\n      x: dragX,\n      y: dragY,\n      setScale: false,\n    },\n    dataIdx: (u, seriesIdx) => {\n      if (seriesIdx === 1) {\n        hRect = null;\n\n        let cx = u.cursor.left! * pxRatio;\n        let cy = u.cursor.top! * pxRatio;\n\n        qt.get(cx, cy, 1, 1, (o) => {\n          if (pointWithin(cx, cy, o.x, o.y, o.x + o.w, o.y + o.h)) {\n            hRect = o;\n          }\n        });\n      }\n\n      return hRect && seriesIdx === hRect.sidx ? hRect.didx : null;\n    },\n    focus: {\n      prox: 1e3,\n      dist: (u, seriesIdx) => (hRect?.sidx === seriesIdx ? 0 : Infinity),\n    },\n    points: {\n      fill: 'rgba(255,255,255, 0.3)',\n      bbox: (u, seriesIdx) => {\n        let isHovered = hRect && seriesIdx === hRect.sidx;\n\n        return {\n          left: isHovered ? hRect!.x / pxRatio : -10,\n          top: isHovered ? hRect!.y / pxRatio : -10,\n          width: isHovered ? hRect!.w / pxRatio : 0,\n          height: isHovered ? hRect!.h / pxRatio : 0,\n        };\n      },\n    },\n  };\n\n  builder.setCursor(cursor);\n\n  return builder;\n}\n\nconst CRISP_EDGES_GAP_MIN = 4;\n\nexport function heatmapPathsDense(opts: PathbuilderOpts) {\n  const { disp, each, gap = 1, hideLE = -Infinity, hideGE = Infinity, xAlign = 1, yAlign = 1, ySizeDivisor = 1 } = opts;\n\n  const pxRatio = devicePixelRatio;\n\n  const round = gap! >= CRISP_EDGES_GAP_MIN ? Math.round : (v: number) => v;\n\n  const cellGap = Math.round(gap! * pxRatio);\n\n  return (u: uPlot, seriesIdx: number) => {\n    uPlot.orient(\n      u,\n      seriesIdx,\n      (\n        series,\n        dataX,\n        dataY,\n        scaleX,\n        scaleY,\n        valToPosX,\n        valToPosY,\n        xOff,\n        yOff,\n        xDim,\n        yDim,\n        moveTo,\n        lineTo,\n        rect,\n        arc\n      ) => {\n        let d = u.data[seriesIdx];\n        const xs = d[0] as unknown as number[];\n        const ys = d[1] as unknown as number[];\n        const counts = d[2] as unknown as number[];\n        const dlen = xs.length;\n\n        // fill colors are mapped from interpolating densities / counts along some gradient\n        // (should be quantized to 64 colors/levels max. e.g. 16)\n        let fills = disp.fill.values(u, seriesIdx);\n        let fillPalette = disp.fill.index ?? [...new Set(fills)];\n\n        let fillPaths = fillPalette.map((color) => new Path2D());\n\n        // detect x and y bin qtys by detecting layout repetition in x & y data\n        let yBinQty = dlen - ys.lastIndexOf(ys[0]);\n        let xBinQty = dlen / yBinQty;\n        let yBinIncr = ys[1] - ys[0] || scaleY.max! - scaleY.min!;\n        let xBinIncr = xs[yBinQty] - xs[0];\n\n        // uniform tile sizes based on zoom level\n        let xSize: number;\n        let ySize: number;\n\n        if (scaleX.distr === 3) {\n          xSize = Math.abs(valToPosX(xs[0] * scaleX.log!, scaleX, xDim, xOff) - valToPosX(xs[0], scaleX, xDim, xOff));\n        } else {\n          xSize = Math.abs(valToPosX(xBinIncr, scaleX, xDim, xOff) - valToPosX(0, scaleX, xDim, xOff));\n        }\n\n        if (scaleY.distr === 3) {\n          ySize =\n            Math.abs(valToPosY(ys[0] * scaleY.log!, scaleY, yDim, yOff) - valToPosY(ys[0], scaleY, yDim, yOff)) /\n            ySizeDivisor;\n        } else {\n          ySize = Math.abs(valToPosY(yBinIncr, scaleY, yDim, yOff) - valToPosY(0, scaleY, yDim, yOff)) / ySizeDivisor;\n        }\n\n        // clamp min tile size to 1px\n        xSize = Math.max(1, round(xSize - cellGap));\n        ySize = Math.max(1, round(ySize - cellGap));\n\n        // bucket agg direction\n        // let xCeil = false;\n        // let yCeil = false;\n\n        let xOffset = xAlign === -1 ? -xSize : xAlign === 0 ? -xSize / 2 : 0;\n        let yOffset = yAlign === 1 ? -ySize : yAlign === 0 ? -ySize / 2 : 0;\n\n        // pre-compute x and y offsets\n        let cys = ys.slice(0, yBinQty).map((y) => round(valToPosY(y, scaleY, yDim, yOff) + yOffset));\n        let cxs = Array.from({ length: xBinQty }, (v, i) =>\n          round(valToPosX(xs[i * yBinQty], scaleX, xDim, xOff) + xOffset)\n        );\n\n        for (let i = 0; i < dlen; i++) {\n          if (counts[i] != null && counts[i] > hideLE && counts[i] < hideGE) {\n            let cx = cxs[~~(i / yBinQty)];\n            let cy = cys[i % yBinQty];\n\n            let fillPath = fillPaths[fills[i]];\n\n            rect(fillPath, cx, cy, xSize, ySize);\n\n            each(u, 1, i, cx, cy, xSize, ySize);\n          }\n        }\n\n        u.ctx.save();\n        //\tu.ctx.globalAlpha = 0.8;\n        u.ctx.rect(u.bbox.left, u.bbox.top, u.bbox.width, u.bbox.height);\n        u.ctx.clip();\n        fillPaths.forEach((p, i) => {\n          u.ctx.fillStyle = fillPalette[i];\n          u.ctx.fill(p);\n        });\n        u.ctx.restore();\n\n        return null;\n      }\n    );\n\n    return null;\n  };\n}\n\nexport function heatmapPathsPoints(opts: PointsBuilderOpts, exemplarColor: string, yLayout?: HeatmapCellLayout) {\n  return (u: uPlot, seriesIdx: number) => {\n    uPlot.orient(\n      u,\n      seriesIdx,\n      (\n        series,\n        dataX,\n        dataY,\n        scaleX,\n        scaleY,\n        valToPosX,\n        valToPosY,\n        xOff,\n        yOff,\n        xDim,\n        yDim,\n        moveTo,\n        lineTo,\n        rect,\n        arc\n      ) => {\n        //console.time('heatmapPathsSparse');\n\n        let points = new Path2D();\n        let fillPaths = [points];\n        let fillPalette = [exemplarColor ?? 'rgba(255,0,255,0.7)'];\n\n        let yShift = yLayout === HeatmapCellLayout.le ? -0.5 : yLayout === HeatmapCellLayout.ge ? 0.5 : 0;\n\n        for (let i = 0; i < dataX.length; i++) {\n          let yVal = dataY[i]!;\n\n          // this is a hacky by-proxy check\n          // works okay since we have no exemplars in calculated heatmaps and...\n          //  - heatmap-rows has ordinal y\n          //  - heatmap-cells has log2 y\n          let isSparseHeatmap = scaleY.distr === 3 && scaleY.log === 2;\n\n          if (!isSparseHeatmap) {\n            yVal += yShift;\n          }\n\n          let x = valToPosX(dataX[i], scaleX, xDim, xOff);\n          let y = valToPosY(yVal, scaleY, yDim, yOff);\n          let w = 8;\n          let h = 8;\n\n          rect(points, x - w / 2, y - h / 2, w, h);\n\n          opts.each(u, seriesIdx, i, x - w / 2, y - h / 2, w, h);\n        }\n\n        u.ctx.save();\n        u.ctx.rect(u.bbox.left, u.bbox.top, u.bbox.width, u.bbox.height);\n        u.ctx.clip();\n        fillPaths.forEach((p, i) => {\n          u.ctx.fillStyle = fillPalette[i];\n          u.ctx.fill(p);\n        });\n        u.ctx.restore();\n      }\n    );\n\n    return null;\n  };\n}\n// accepts xMax, yMin, yMax, count\n// xbinsize? x tile sizes are uniform?\nexport function heatmapPathsSparse(opts: PathbuilderOpts) {\n  const { disp, each, gap = 1, hideLE = -Infinity, hideGE = Infinity } = opts;\n\n  const pxRatio = devicePixelRatio;\n\n  const round = gap! >= CRISP_EDGES_GAP_MIN ? Math.round : (v: number) => v;\n\n  const cellGap = Math.round(gap! * pxRatio);\n\n  return (u: uPlot, seriesIdx: number) => {\n    uPlot.orient(\n      u,\n      seriesIdx,\n      (\n        series,\n        dataX,\n        dataY,\n        scaleX,\n        scaleY,\n        valToPosX,\n        valToPosY,\n        xOff,\n        yOff,\n        xDim,\n        yDim,\n        moveTo,\n        lineTo,\n        rect,\n        arc\n      ) => {\n        //console.time('heatmapPathsSparse');\n\n        let d = u.data[seriesIdx];\n        const xMaxs = d[0] as unknown as number[]; // xMax, do we get interval?\n        const yMins = d[1] as unknown as number[];\n        const yMaxs = d[2] as unknown as number[];\n        const counts = d[3] as unknown as number[];\n        const dlen = xMaxs.length;\n\n        // fill colors are mapped from interpolating densities / counts along some gradient\n        // (should be quantized to 64 colors/levels max. e.g. 16)\n        let fills = disp.fill.values(u, seriesIdx);\n        let fillPalette = disp.fill.index ?? [...new Set(fills)];\n\n        let fillPaths = fillPalette.map((color) => new Path2D());\n\n        // cache all tile bounds\n        let xOffs = new Map();\n        let yOffs = new Map();\n\n        for (let i = 0; i < xMaxs.length; i++) {\n          let xMax = xMaxs[i];\n          let yMin = yMins[i];\n          let yMax = yMaxs[i];\n\n          if (!xOffs.has(xMax)) {\n            xOffs.set(xMax, round(valToPosX(xMax, scaleX, xDim, xOff)));\n          }\n\n          if (!yOffs.has(yMin)) {\n            yOffs.set(yMin, round(valToPosY(yMin, scaleY, yDim, yOff)));\n          }\n\n          if (!yOffs.has(yMax)) {\n            yOffs.set(yMax, round(valToPosY(yMax, scaleY, yDim, yOff)));\n          }\n        }\n\n        // uniform x size (interval, step)\n        let xSizeUniform = xOffs.get(xMaxs.find((v) => v !== xMaxs[0])) - xOffs.get(xMaxs[0]);\n\n        for (let i = 0; i < dlen; i++) {\n          if (counts[i] <= hideLE || counts[i] >= hideGE) {\n            continue;\n          }\n\n          let xMax = xMaxs[i];\n          let yMin = yMins[i];\n          let yMax = yMaxs[i];\n\n          let xMaxPx = xOffs.get(xMax); // xSize is from interval, or inferred delta?\n          let yMinPx = yOffs.get(yMin);\n          let yMaxPx = yOffs.get(yMax);\n\n          let xSize = xSizeUniform;\n          let ySize = yMinPx - yMaxPx;\n\n          // clamp min tile size to 1px\n          xSize = Math.max(1, xSize - cellGap);\n          ySize = Math.max(1, ySize - cellGap);\n\n          let x = xMaxPx - cellGap / 2 - xSize;\n          let y = yMaxPx + cellGap / 2;\n\n          let fillPath = fillPaths[fills[i]];\n\n          rect(fillPath, x, y, xSize, ySize);\n\n          each(u, 1, i, x, y, xSize, ySize);\n        }\n\n        u.ctx.save();\n        //\tu.ctx.globalAlpha = 0.8;\n        u.ctx.rect(u.bbox.left, u.bbox.top, u.bbox.width, u.bbox.height);\n        u.ctx.clip();\n        fillPaths.forEach((p, i) => {\n          u.ctx.fillStyle = fillPalette[i];\n          u.ctx.fill(p);\n        });\n        u.ctx.restore();\n\n        //console.timeEnd('heatmapPathsSparse');\n      }\n    );\n\n    return null;\n  };\n}\n\nexport const boundedMinMax = (\n  values: number[],\n  minValue?: number,\n  maxValue?: number,\n  hideLE = -Infinity,\n  hideGE = Infinity\n) => {\n  if (minValue == null) {\n    minValue = Infinity;\n\n    for (let i = 0; i < values.length; i++) {\n      if (values[i] != null && values[i] > hideLE && values[i] < hideGE) {\n        minValue = Math.min(minValue, values[i]);\n      }\n    }\n  }\n\n  if (maxValue == null) {\n    maxValue = -Infinity;\n\n    for (let i = 0; i < values.length; i++) {\n      if (values[i] != null && values[i] > hideLE && values[i] < hideGE) {\n        maxValue = Math.max(maxValue, values[i]);\n      }\n    }\n  }\n\n  return [minValue, maxValue];\n};\n\nexport const valuesToFills = (values: number[], palette: string[], minValue: number, maxValue: number): number[] => {\n  let range = maxValue - minValue || 1;\n\n  let paletteSize = palette.length;\n\n  let indexedFills = Array(values.length);\n\n  for (let i = 0; i < values.length; i++) {\n    indexedFills[i] =\n      values[i] < minValue\n        ? 0\n        : values[i] > maxValue\n          ? paletteSize - 1\n          : Math.min(paletteSize - 1, Math.floor((paletteSize * (values[i] - minValue)) / range));\n  }\n\n  return indexedFills;\n};\n"],"names":["prepConfig","opts","dataRef","theme","timeZone","getTimeRange","cellGap","hideLE","hideGE","yAxisConfig","ySizeDivisor","selectionMode","xScaleKey","isTime","pxRatio","heatmapType","exemplarFillColor","qt","hRect","builder","u","el","xMin","xMax","min","max","s","i","dataMin","dataMax","offset","incrs","yField","yScale","yAxisReverse","isSparseHeatmap","shouldUseLogScale","isOrdinalY","yScaleKey","bucketFactor","scaleMin","scaleMax","yExp","log","explicitMin","explicitMax","minLog","maxLog","minExpanded","maxExpanded","bucketSize","dispY","v","decimals","self","meta","splits","idx","pathBuilder","heatmapPathsSparse","heatmapPathsDense","seriesIdx","dataIdx","x","y","xSize","ySize","heatmapPathsPoints","dragX","dragY","cursor","cx","cy","o","isHovered","CRISP_EDGES_GAP_MIN","disp","each","gap","xAlign","yAlign","round","series","dataX","dataY","scaleX","scaleY","valToPosX","valToPosY","xOff","yOff","xDim","yDim","moveTo","lineTo","rect","arc","d","xs","ys","counts","dlen","fills","fillPalette","fillPaths","color","yBinQty","xBinQty","yBinIncr","xBinIncr","xOffset","yOffset","cys","cxs","fillPath","p","exemplarColor","yLayout","points","yShift","yVal","w","h","xMaxs","yMins","yMaxs","xOffs","yOffs","yMin","yMax","xSizeUniform","xMaxPx","yMinPx","yMaxPx","boundedMinMax","values","minValue","maxValue","valuesToFills","palette","range","paletteSize","indexedFills"],"sourceRoot":""}