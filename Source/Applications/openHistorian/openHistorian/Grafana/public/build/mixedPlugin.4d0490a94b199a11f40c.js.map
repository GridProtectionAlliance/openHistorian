{"version":3,"sources":["webpack:///./public/app/plugins/datasource/mixed/MixedDataSource.ts","webpack:///./public/app/plugins/datasource/mixed/module.ts"],"names":["MixedDataSource_MixedDatasource","_super","MixedDatasource","instanceSettings","call","this","Object","tslib_es6","prototype","query","request","queries","targets","filter","t","datasource","length","of","data","sets","groupBy_default","mixed","key","dsName","push","grafana_runtime_src","get","batchQueries","observables","runningSubRequests","i","observable","from","pipe","mergeMap","dataSourceApi","datasourceRequest","cloneDeep_default","requestId","hasCountedAsDone","tap","response","state","src","Streaming","Loading","map","Done","merge","apply","testDatasource","Promise","resolve","__webpack_require__","d","__webpack_exports__"],"mappings":"6PAuBAA,EAAA,SAAAC,GACE,SAAAC,EAAYC,UACVF,EAAAG,KAAAC,KAAMF,IAAiBE,KAwF3B,OA1FqCC,OAAAC,EAAA,UAAAD,CAAAJ,EAAAD,GAKnCC,EAAAM,UAAAC,MAAA,SAAMC,GAEJ,IAAMC,EAAUD,EAAQE,QAAQC,OAAO,SAAAC,GACrC,MAf+B,gBAexBA,EAAEC,aAGX,IAAKJ,EAAQK,OACX,OAAOV,OAAAW,EAAA,EAAAX,CAAG,CAAEY,KAAM,KAIpB,IAAMC,EAAuCC,IAAQT,EAAS,cACxDU,EAA0B,GAChC,IAAK,IAAMC,KAAOH,EAAM,CACtB,IAAMP,EAAUO,EAAKG,GACfC,EAASX,EAAQ,GAAGG,WAC1BM,EAAMG,KAAK,CACTT,WAAYT,OAAAmB,EAAA,iBAAAnB,GAAmBoB,IAAIH,GACnCX,QAAOA,IAGX,OAAOP,KAAKsB,aAAaN,EAAOX,IAGlCR,EAAAM,UAAAmB,aAAA,SAAaN,EAAyBX,GAIpC,IAHA,IAAMkB,EAAoD,GACtDC,EAAqB,aAEhBC,GACP,IAAMrB,EAAQY,EAAMS,GACpB,IAAKrB,EAAMG,UAAYH,EAAMG,QAAQI,wBAGrC,IAAMe,EAAazB,OAAA0B,EAAA,EAAA1B,CAAKG,EAAMM,YAAYkB,KACxC3B,OAAA4B,EAAA,EAAA5B,CAAS,SAAC6B,GACR,IAAMC,EAAoBC,IAAU3B,GAEpC0B,EAAkBE,UAAY,SAASR,EAAC,KAAIM,EAAkBE,WAAa,IAC3EF,EAAkBxB,QAAUH,EAAMG,QAElCiB,IACA,IAAIU,GAAmB,EAEvB,OAAOjC,OAAA0B,EAAA,EAAA1B,CAAK6B,EAAc1B,MAAM2B,IAAoBH,KAClD3B,OAAAkC,EAAA,EAAAlC,CACE,SAACmC,GAEGF,GACAE,EAASC,QAAUC,EAAA,aAAaC,WAChCH,EAASC,QAAUC,EAAA,aAAaE,UAIlChB,IACAU,GAAmB,IAErB,WACMA,IAGJA,GAAmB,EACnBV,OAGJvB,OAAAwC,EAAA,EAAAxC,CAAI,SAACmC,GACH,OAAOnC,OAAAC,EAAA,SAAAD,QAAAC,EAAA,SAAAD,CAAA,GACFmC,GAAQ,CACXvB,KAAMuB,EAASvB,MAAQ,GACvBwB,MAA8B,IAAvBb,EAA2Bc,EAAA,aAAaI,KAAOJ,EAAA,aAAaE,QACnEvB,IAAK,SAASQ,EAAC,KAAIW,EAASnB,KAAO,YAO7CM,EAAYJ,KAAKO,IAhDVD,EAAI,EAAGA,EAAIT,EAAML,OAAQc,MAAzBA,GAmDT,OAAOkB,EAAA,EAAKC,WAAA,EAAA3C,OAAAC,EAAA,SAAAD,CAAIsB,KAGlB1B,EAAAM,UAAA0C,eAAA,WACE,OAAOC,QAAQC,QAAQ,KAE3BlD,EA1FA,CAAqCyC,EAAA,eCvBrCU,EAAAC,EAAAC,EAAA,oCAAAvD,IAAAqD,EAAAC,EAAAC,EAAA,+BAAAvD","file":"mixedPlugin.4d0490a94b199a11f40c.js","sourcesContent":["import cloneDeep from 'lodash/cloneDeep';\nimport groupBy from 'lodash/groupBy';\nimport { from, of, Observable, merge } from 'rxjs';\nimport { tap } from 'rxjs/operators';\n\nimport {\n  LoadingState,\n  DataSourceApi,\n  DataQuery,\n  DataQueryRequest,\n  DataQueryResponse,\n  DataSourceInstanceSettings,\n} from '@grafana/data';\nimport { getDataSourceSrv } from '@grafana/runtime';\nimport { mergeMap, map } from 'rxjs/operators';\n\nexport const MIXED_DATASOURCE_NAME = '-- Mixed --';\n\nexport interface BatchedQueries {\n  datasource: Promise<DataSourceApi>;\n  targets: DataQuery[];\n}\n\nexport class MixedDatasource extends DataSourceApi<DataQuery> {\n  constructor(instanceSettings: DataSourceInstanceSettings) {\n    super(instanceSettings);\n  }\n\n  query(request: DataQueryRequest<DataQuery>): Observable<DataQueryResponse> {\n    // Remove any invalid queries\n    const queries = request.targets.filter(t => {\n      return t.datasource !== MIXED_DATASOURCE_NAME;\n    });\n\n    if (!queries.length) {\n      return of({ data: [] } as DataQueryResponse); // nothing\n    }\n\n    // Build groups of queries to run in parallel\n    const sets: { [key: string]: DataQuery[] } = groupBy(queries, 'datasource');\n    const mixed: BatchedQueries[] = [];\n    for (const key in sets) {\n      const targets = sets[key];\n      const dsName = targets[0].datasource;\n      mixed.push({\n        datasource: getDataSourceSrv().get(dsName),\n        targets,\n      });\n    }\n    return this.batchQueries(mixed, request);\n  }\n\n  batchQueries(mixed: BatchedQueries[], request: DataQueryRequest<DataQuery>): Observable<DataQueryResponse> {\n    const observables: Array<Observable<DataQueryResponse>> = [];\n    let runningSubRequests = 0;\n\n    for (let i = 0; i < mixed.length; i++) {\n      const query = mixed[i];\n      if (!query.targets || !query.targets.length) {\n        continue;\n      }\n      const observable = from(query.datasource).pipe(\n        mergeMap((dataSourceApi: DataSourceApi) => {\n          const datasourceRequest = cloneDeep(request);\n\n          datasourceRequest.requestId = `mixed-${i}-${datasourceRequest.requestId || ''}`;\n          datasourceRequest.targets = query.targets;\n\n          runningSubRequests++;\n          let hasCountedAsDone = false;\n\n          return from(dataSourceApi.query(datasourceRequest)).pipe(\n            tap(\n              (response: DataQueryResponse) => {\n                if (\n                  hasCountedAsDone ||\n                  response.state === LoadingState.Streaming ||\n                  response.state === LoadingState.Loading\n                ) {\n                  return;\n                }\n                runningSubRequests--;\n                hasCountedAsDone = true;\n              },\n              () => {\n                if (hasCountedAsDone) {\n                  return;\n                }\n                hasCountedAsDone = true;\n                runningSubRequests--;\n              }\n            ),\n            map((response: DataQueryResponse) => {\n              return {\n                ...response,\n                data: response.data || [],\n                state: runningSubRequests === 0 ? LoadingState.Done : LoadingState.Loading,\n                key: `mixed-${i}-${response.key || ''}`,\n              } as DataQueryResponse;\n            })\n          );\n        })\n      );\n\n      observables.push(observable);\n    }\n\n    return merge(...observables);\n  }\n\n  testDatasource() {\n    return Promise.resolve({});\n  }\n}\n","import { MixedDatasource } from './MixedDataSource';\nexport { MixedDatasource, MixedDatasource as Datasource };\n"],"sourceRoot":""}