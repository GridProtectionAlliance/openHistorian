{"version":3,"sources":["webpack:///./public/app/features/profile/state/selectors.ts","webpack:///./public/app/features/explore/state/selectors.ts","webpack:///./public/app/features/explore/utils/decorators.ts","webpack:///./public/app/features/explore/state/actions.ts","webpack:///./public/app/core/utils/richHistory.ts"],"names":["getTimeZone","state","timeZone","deduplicatedRowsSelector","createSelector","logsResult","rows","hiddenLogLevels","dedupStrategy","length","filteredRows","filterLogLevels","Set","dedupLogRows","getExploreDatasources","getDatasourceSrv","getExternal","map","ds","value","name","meta","decorateWithGraphLogsTraceAndTable","data","error","graphFrames","tableFrames","logsFrames","traceFrames","graphResult","tableResult","series","frame","preferredVisualisationType","push","isTimeSeries","decorateWithGraphResult","getGraphSeriesModel","request","timezone","showBars","showLines","showPoints","asTable","isVisible","placement","decorateWithTableResult","of","sort","frameA","frameB","frameARefId","refId","frameBRefId","every","df","pipe","standardTransformers","seriesToColumnsTransformer","operator","mergeTransformer","frames","fields","field","display","getDisplayProcessor","theme","config","grouped","groupBy","type","Boolean","Object","keys","FieldType","time","number","addQueryRow","exploreId","index","dispatch","getState","queries","explore","query","generateEmptyQuery","addQueryRowAction","changeDatasource","datasourceName","options","get","newDataSourceInstance","currentDataSourceInstance","datasourceInstance","orgId","user","updateDatasourceInstanceAction","importQueries","isLive","changeRefreshInterval","RefreshPicker","offOption","loadDatasource","runQueries","changeQuery","override","key","generateNewKeyAndAddRefIdIfMissing","changeQueryAction","changeSize","height","width","changeSizeAction","updateTimeRange","syncedTimes","updateTime","ExploreId","left","right","refreshInterval","changeRefreshIntervalAction","changeDedupStrategy","changeDedupStrategyAction","clearQueries","scanStopAction","clearQueriesAction","stateSave","cancelQueries","cancelQueriesAction","loadExploreDatasourcesAndSetDatasource","loadDatasourceMissingAction","initializeExplore","range","containerWidth","eventBridge","originPanelId","initializeExploreAction","richHistory","getRichHistory","richHistoryUpdatedAction","loadDatasourceReady","instance","historyKey","id","history","store","getObject","set","lastUsedDatasourceKeyForOrgId","loadDatasourceReadyAction","sourceDataSource","targetDataSource","queriesImportedAction","importedQueries","ensureQueries","nextQueries","loadDatasourcePendingAction","requestedDatasourceName","init","err","console","modifyQueries","modification","modifier","modifyQueriesAction","preventSubmit","exploreItemState","live","scanning","queryResponse","querySubscription","absoluteRange","hasNonEmptyQuery","minInterval","interval","stopQueryState","datasourceId","queryOptions","maxDataPoints","liveStreaming","transaction","buildQueryTransaction","firstResponse","changeLoadingStateAction","loadingState","LoadingState","Loading","newQuerySub","runRequest","throttleTime","identity","preProcessPanelData","intervalMs","newResults","dataFrameToLogsModel","sortOrder","refreshIntervalToSortOrder","sortedNewResults","sortLogsResult","decorateWithLogsResult","mergeMap","subscribe","nextHistory","updateHistory","nextRichHistory","addToRichHistory","historyUpdatedAction","queryStreamUpdatedAction","response","Done","getShiftedTimeRange","notifyApp","createErrorNotification","Error","queryStoreSubscriptionAction","updateRichHistory","ts","property","updatedProperty","updateStarredInRichHistory","updateCommentInRichHistory","deleteQueryInRichHistory","deleteRichHistory","deleteAllFromRichHistory","toRawTimeRange","from","raw","isDateTime","valueOf","toString","to","split","replace","urlReplaced","urlStates","leftUrlState","datasource","clearQueryKeys","serializeStateToUrlParam","rightUrlState","updateLocation","setUrlReplacedAction","absRange","actionRange","rawRange","itemState","dateTimeForTimeZone","getTimeRange","getTimeSrv","DashboardModel","refresh","changeRangeAction","scanStart","scanStartAction","setQueries","rawQueries","setQueriesAction","splitClose","itemId","splitCloseAction","splitOpen","leftState","rightState","queryState","location","urlState","parseUrlState","queryKeys","utc","toISOString","splitOpenAction","dataSourceSettings","getDataSourceSettingsByUid","datasourceUid","slice","syncTimes","isTimeSynced","syncTimesAction","refreshExplore","initialized","update","urlRange","refreshQueries","getTimeRangeFromUrl","initialQueries","navigateToExplore","panel","dependencies","getDataSourceSrv","getExploreUrl","openInNewWindow","datasourceSrv","panelTargets","targets","panelDatasource","timeSrv","path","SortOrder","RICH_HISTORY_KEY","RICH_HISTORY_SETTING_KEYS","retentionPeriod","starredTabAsFirstTab","activeDatasourceOnly","datasourceFilters","starred","comment","sessionName","Date","now","newQueriesToSave","filter","strippedQuery","_","omit","notEmptyQuery","retentionPeriodLastTs","createRetentionPeriodBoundary","queriesToKeep","q","newQueriesToCompare","lastQueriesToCompare","isEqual","updatedHistory","setObject","appEvents","emit","AppEvents","alertError","transformedQueries","individualQuery","string","JSON","parse","e","isParsable","expr","createDataQuery","migrateRichHistory","delete","isStarred","assign","newComment","createUrlFromRichHistory","exploreState","context","serializedState","baseUrl","exec","window","href","urlUtil","renderUrl","mapNumbertoTimeInSlider","num","str","days","isLastTs","today","date","setDate","getDate","setHours","createQueryHeading","heading","DatasourceAZ","DatasourceZA","dateTimeFormat","format","createQueryText","queryDsInstance","getQueryDisplayText","stringify","mapQueriesToHeadings","mappedQueriesToHeadings","forEach","createDatasourcesList","queriesDatasources","exploreDatasources","datasources","queryDsName","findIndex","exploreDs","label","imgUrl","info","logos","small","isRemoved","filterAndSortQueries","listOfDatasourceFilters","searchFilter","timeFilter","filteredQueriesByDsAndSearchFilter","includes","values","some","filterQueriesBySearchFilter","filterQueriesByDataSource","array","sortFunc","Ascending","a","b","Descending","sortQueries","filterQueriesByTime"],"mappings":"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","file":"default~DashboardPage~SoloPanelPage~explore.591ee81e63053ad31983.js","sourcesContent":["import { UserState } from 'app/types';\n\nexport const getTimeZone = (state: UserState) => state.timeZone;\n","import { createSelector } from 'reselect';\nimport { ExploreItemState } from 'app/types';\nimport { filterLogLevels, dedupLogRows } from 'app/core/logs_model';\nimport { getDatasourceSrv } from '../../plugins/datasource_srv';\nimport { DataSourceSelectItem } from '@grafana/data';\n\nconst logsRowsSelector = (state: ExploreItemState) => state.logsResult && state.logsResult.rows;\nconst hiddenLogLevelsSelector = (state: ExploreItemState) => state.hiddenLogLevels;\nconst dedupStrategySelector = (state: ExploreItemState) => state.dedupStrategy;\nexport const deduplicatedRowsSelector = createSelector(\n  logsRowsSelector,\n  hiddenLogLevelsSelector,\n  dedupStrategySelector,\n  function dedupRows(rows, hiddenLogLevels, dedupStrategy) {\n    if (!(rows && rows.length)) {\n      return rows;\n    }\n    const filteredRows = filterLogLevels(rows, new Set(hiddenLogLevels));\n    return dedupLogRows(filteredRows, dedupStrategy);\n  }\n);\n\nexport const getExploreDatasources = (): DataSourceSelectItem[] => {\n  return getDatasourceSrv()\n    .getExternal()\n    .map(\n      (ds: any) =>\n        ({\n          value: ds.name,\n          name: ds.name,\n          meta: ds.meta,\n        } as DataSourceSelectItem)\n    );\n};\n","import { Observable, of } from 'rxjs';\nimport { map } from 'rxjs/operators';\nimport {\n  AbsoluteTimeRange,\n  DataFrame,\n  FieldType,\n  getDisplayProcessor,\n  PanelData,\n  sortLogsResult,\n  standardTransformers,\n} from '@grafana/data';\nimport { config } from '@grafana/runtime';\nimport { groupBy } from 'lodash';\n\nimport { ExplorePanelData } from '../../../types';\nimport { getGraphSeriesModel } from '../../../plugins/panel/graph2/getGraphSeriesModel';\nimport { dataFrameToLogsModel } from '../../../core/logs_model';\nimport { refreshIntervalToSortOrder } from '../../../core/utils/explore';\n\n/**\n * When processing response first we try to determine what kind of dataframes we got as one query can return multiple\n * dataFrames with different type of data. This is later used for type specific processing. As we use this in\n * Observable pipeline, it decorates the existing panelData to pass the results to later processing stages.\n */\nexport const decorateWithGraphLogsTraceAndTable = (data: PanelData): ExplorePanelData => {\n  if (data.error) {\n    return {\n      ...data,\n      graphFrames: [],\n      tableFrames: [],\n      logsFrames: [],\n      traceFrames: [],\n      graphResult: null,\n      tableResult: null,\n      logsResult: null,\n    };\n  }\n\n  const graphFrames: DataFrame[] = [];\n  const tableFrames: DataFrame[] = [];\n  const logsFrames: DataFrame[] = [];\n  const traceFrames: DataFrame[] = [];\n\n  for (const frame of data.series) {\n    switch (frame.meta?.preferredVisualisationType) {\n      case 'logs':\n        logsFrames.push(frame);\n        break;\n      case 'graph':\n        graphFrames.push(frame);\n        break;\n      case 'trace':\n        traceFrames.push(frame);\n        break;\n      case 'table':\n        tableFrames.push(frame);\n        break;\n      default:\n        if (isTimeSeries(frame)) {\n          graphFrames.push(frame);\n          tableFrames.push(frame);\n        } else {\n          // We fallback to table if we do not have any better meta info about the dataframe.\n          tableFrames.push(frame);\n        }\n    }\n  }\n\n  return {\n    ...data,\n    graphFrames,\n    tableFrames,\n    logsFrames,\n    traceFrames,\n    graphResult: null,\n    tableResult: null,\n    logsResult: null,\n  };\n};\n\nexport const decorateWithGraphResult = (data: ExplorePanelData): ExplorePanelData => {\n  if (data.error) {\n    return { ...data, graphResult: null };\n  }\n\n  const graphResult =\n    data.graphFrames.length === 0\n      ? null\n      : getGraphSeriesModel(\n          data.graphFrames,\n          data.request?.timezone ?? 'browser',\n          {},\n          { showBars: false, showLines: true, showPoints: false },\n          { asTable: false, isVisible: true, placement: 'under' }\n        );\n\n  return { ...data, graphResult };\n};\n\n/**\n * This processing returns Observable because it uses Transformer internally which result type is also Observable.\n * In this case the transformer should return single result but it is possible that in the future it could return\n * multiple results and so this should be used with mergeMap or similar to unbox the internal observable.\n */\nexport const decorateWithTableResult = (data: ExplorePanelData): Observable<ExplorePanelData> => {\n  if (data.error) {\n    return of({ ...data, tableResult: null });\n  }\n\n  if (data.tableFrames.length === 0) {\n    return of({ ...data, tableResult: null });\n  }\n\n  data.tableFrames.sort((frameA: DataFrame, frameB: DataFrame) => {\n    const frameARefId = frameA.refId!;\n    const frameBRefId = frameB.refId!;\n\n    if (frameARefId > frameBRefId) {\n      return 1;\n    }\n    if (frameARefId < frameBRefId) {\n      return -1;\n    }\n    return 0;\n  });\n\n  const hasOnlyTimeseries = data.tableFrames.every(df => isTimeSeries(df));\n\n  // If we have only timeseries we do join on default time column which makes more sense. If we are showing\n  // non timeseries or some mix of data we are not trying to join on anything and just try to merge them in\n  // single table, which may not make sense in most cases, but it's up to the user to query something sensible.\n  const transformer = hasOnlyTimeseries\n    ? of(data.tableFrames).pipe(standardTransformers.seriesToColumnsTransformer.operator({}))\n    : of(data.tableFrames).pipe(standardTransformers.mergeTransformer.operator({}));\n\n  return transformer.pipe(\n    map(frames => {\n      const frame = frames[0];\n\n      // set display processor\n      for (const field of frame.fields) {\n        field.display =\n          field.display ??\n          getDisplayProcessor({\n            field,\n            theme: config.theme,\n            timeZone: data.request?.timezone ?? 'browser',\n          });\n      }\n\n      return { ...data, tableResult: frame };\n    })\n  );\n};\n\nexport const decorateWithLogsResult = (\n  options: { absoluteRange?: AbsoluteTimeRange; refreshInterval?: string } = {}\n) => (data: ExplorePanelData): ExplorePanelData => {\n  if (data.error) {\n    return { ...data, logsResult: null };\n  }\n\n  if (data.logsFrames.length === 0) {\n    return { ...data, logsResult: null };\n  }\n\n  const timeZone = data.request?.timezone ?? 'browser';\n  const intervalMs = data.request?.intervalMs;\n  const newResults = dataFrameToLogsModel(data.logsFrames, intervalMs, timeZone, options.absoluteRange);\n  const sortOrder = refreshIntervalToSortOrder(options.refreshInterval);\n  const sortedNewResults = sortLogsResult(newResults, sortOrder);\n  const rows = sortedNewResults.rows;\n  const series = sortedNewResults.series;\n  const logsResult = { ...sortedNewResults, rows, series };\n\n  return { ...data, logsResult };\n};\n\n/**\n * Check if frame contains time series, which for our purpose means 1 time column and 1 or more numeric columns.\n */\nfunction isTimeSeries(frame: DataFrame): boolean {\n  const grouped = groupBy(frame.fields, field => field.type);\n  return Boolean(\n    Object.keys(grouped).length === 2 && grouped[FieldType.time]?.length === 1 && grouped[FieldType.number]\n  );\n}\n","// Libraries\nimport { map, mergeMap, throttleTime } from 'rxjs/operators';\nimport { identity } from 'rxjs';\nimport { PayloadAction } from '@reduxjs/toolkit';\nimport { DataSourceSrv } from '@grafana/runtime';\nimport { RefreshPicker } from '@grafana/ui';\nimport {\n  AbsoluteTimeRange,\n  DataQuery,\n  DataSourceApi,\n  dateTimeForTimeZone,\n  ExploreUrlState,\n  isDateTime,\n  LoadingState,\n  LogsDedupStrategy,\n  PanelData,\n  QueryFixAction,\n  RawTimeRange,\n  TimeRange,\n} from '@grafana/data';\n// Services & Utils\nimport store from 'app/core/store';\nimport { getDatasourceSrv } from 'app/features/plugins/datasource_srv';\nimport { Emitter } from 'app/core/core';\nimport {\n  buildQueryTransaction,\n  clearQueryKeys,\n  ensureQueries,\n  generateEmptyQuery,\n  generateNewKeyAndAddRefIdIfMissing,\n  GetExploreUrlArguments,\n  getTimeRange,\n  getTimeRangeFromUrl,\n  hasNonEmptyQuery,\n  lastUsedDatasourceKeyForOrgId,\n  parseUrlState,\n  stopQueryState,\n  updateHistory,\n} from 'app/core/utils/explore';\nimport {\n  addToRichHistory,\n  deleteAllFromRichHistory,\n  deleteQueryInRichHistory,\n  getRichHistory,\n  updateCommentInRichHistory,\n  updateStarredInRichHistory,\n} from 'app/core/utils/richHistory';\n// Types\nimport { ThunkResult } from 'app/types';\n\nimport { ExploreId, ExploreItemState, QueryOptions } from 'app/types/explore';\nimport {\n  addQueryRowAction,\n  cancelQueriesAction,\n  changeDedupStrategyAction,\n  ChangeDedupStrategyPayload,\n  changeLoadingStateAction,\n  changeQueryAction,\n  changeRangeAction,\n  changeRefreshIntervalAction,\n  ChangeRefreshIntervalPayload,\n  changeSizeAction,\n  ChangeSizePayload,\n  clearQueriesAction,\n  historyUpdatedAction,\n  initializeExploreAction,\n  loadDatasourceMissingAction,\n  loadDatasourcePendingAction,\n  loadDatasourceReadyAction,\n  LoadDatasourceReadyPayload,\n  modifyQueriesAction,\n  queriesImportedAction,\n  queryStoreSubscriptionAction,\n  queryStreamUpdatedAction,\n  richHistoryUpdatedAction,\n  scanStartAction,\n  scanStopAction,\n  setQueriesAction,\n  setUrlReplacedAction,\n  splitCloseAction,\n  splitOpenAction,\n  syncTimesAction,\n  updateDatasourceInstanceAction,\n} from './actionTypes';\nimport { getTimeZone } from 'app/features/profile/state/selectors';\nimport { getShiftedTimeRange } from 'app/core/utils/timePicker';\nimport { notifyApp, updateLocation } from '../../../core/actions';\nimport { getTimeSrv, TimeSrv } from '../../dashboard/services/TimeSrv';\nimport { preProcessPanelData, runRequest } from '../../dashboard/state/runRequest';\nimport { DashboardModel, PanelModel } from 'app/features/dashboard/state';\nimport { getExploreDatasources } from './selectors';\nimport { serializeStateToUrlParam } from '@grafana/data/src/utils/url';\nimport {\n  decorateWithGraphLogsTraceAndTable,\n  decorateWithGraphResult,\n  decorateWithLogsResult,\n  decorateWithTableResult,\n} from '../utils/decorators';\nimport { createErrorNotification } from '../../../core/copy/appNotification';\n\n/**\n * Adds a query row after the row with the given index.\n */\nexport function addQueryRow(exploreId: ExploreId, index: number): ThunkResult<void> {\n  return (dispatch, getState) => {\n    const queries = getState().explore[exploreId].queries;\n    const query = generateEmptyQuery(queries, index);\n\n    dispatch(addQueryRowAction({ exploreId, index, query }));\n  };\n}\n\n/**\n * Loads a new datasource identified by the given name.\n */\nexport function changeDatasource(\n  exploreId: ExploreId,\n  datasourceName: string,\n  options?: { importQueries: boolean }\n): ThunkResult<void> {\n  return async (dispatch, getState) => {\n    let newDataSourceInstance: DataSourceApi;\n\n    if (!datasourceName) {\n      newDataSourceInstance = await getDatasourceSrv().get();\n    } else {\n      newDataSourceInstance = await getDatasourceSrv().get(datasourceName);\n    }\n\n    const currentDataSourceInstance = getState().explore[exploreId].datasourceInstance;\n    const queries = getState().explore[exploreId].queries;\n    const orgId = getState().user.orgId;\n\n    dispatch(\n      updateDatasourceInstanceAction({\n        exploreId,\n        datasourceInstance: newDataSourceInstance,\n      })\n    );\n\n    if (options?.importQueries) {\n      await dispatch(importQueries(exploreId, queries, currentDataSourceInstance, newDataSourceInstance));\n    }\n\n    if (getState().explore[exploreId].isLive) {\n      dispatch(changeRefreshInterval(exploreId, RefreshPicker.offOption.value));\n    }\n\n    await dispatch(loadDatasource(exploreId, newDataSourceInstance, orgId));\n\n    // Exception - we only want to run queries on data source change, if the queries were imported\n    if (options?.importQueries) {\n      dispatch(runQueries(exploreId));\n    }\n  };\n}\n\n/**\n * Query change handler for the query row with the given index.\n * If `override` is reset the query modifications and run the queries. Use this to set queries via a link.\n */\nexport function changeQuery(\n  exploreId: ExploreId,\n  query: DataQuery,\n  index: number,\n  override = false\n): ThunkResult<void> {\n  return (dispatch, getState) => {\n    // Null query means reset\n    if (query === null) {\n      const queries = getState().explore[exploreId].queries;\n      const { refId, key } = queries[index];\n      query = generateNewKeyAndAddRefIdIfMissing({ refId, key }, queries, index);\n    }\n\n    dispatch(changeQueryAction({ exploreId, query, index, override }));\n    if (override) {\n      dispatch(runQueries(exploreId));\n    }\n  };\n}\n\n/**\n * Keep track of the Explore container size, in particular the width.\n * The width will be used to calculate graph intervals (number of datapoints).\n */\nexport function changeSize(\n  exploreId: ExploreId,\n  { height, width }: { height: number; width: number }\n): PayloadAction<ChangeSizePayload> {\n  return changeSizeAction({ exploreId, height, width });\n}\n\nexport const updateTimeRange = (options: {\n  exploreId: ExploreId;\n  rawRange?: RawTimeRange;\n  absoluteRange?: AbsoluteTimeRange;\n}): ThunkResult<void> => {\n  return (dispatch, getState) => {\n    const { syncedTimes } = getState().explore;\n    if (syncedTimes) {\n      dispatch(updateTime({ ...options, exploreId: ExploreId.left }));\n      dispatch(runQueries(ExploreId.left));\n      dispatch(updateTime({ ...options, exploreId: ExploreId.right }));\n      dispatch(runQueries(ExploreId.right));\n    } else {\n      dispatch(updateTime({ ...options }));\n      dispatch(runQueries(options.exploreId));\n    }\n  };\n};\n/**\n * Change the refresh interval of Explore. Called from the Refresh picker.\n */\nexport function changeRefreshInterval(\n  exploreId: ExploreId,\n  refreshInterval: string\n): PayloadAction<ChangeRefreshIntervalPayload> {\n  return changeRefreshIntervalAction({ exploreId, refreshInterval });\n}\n\n/**\n * Change logs deduplication strategy.\n */\nexport const changeDedupStrategy = (\n  exploreId: ExploreId,\n  dedupStrategy: LogsDedupStrategy\n): PayloadAction<ChangeDedupStrategyPayload> => {\n  return changeDedupStrategyAction({ exploreId, dedupStrategy });\n};\n\n/**\n * Clear all queries and results.\n */\nexport function clearQueries(exploreId: ExploreId): ThunkResult<void> {\n  return dispatch => {\n    dispatch(scanStopAction({ exploreId }));\n    dispatch(clearQueriesAction({ exploreId }));\n    dispatch(stateSave());\n  };\n}\n\n/**\n * Cancel running queries\n */\nexport function cancelQueries(exploreId: ExploreId): ThunkResult<void> {\n  return dispatch => {\n    dispatch(scanStopAction({ exploreId }));\n    dispatch(cancelQueriesAction({ exploreId }));\n    dispatch(stateSave());\n  };\n}\n\n/**\n * Loads all explore data sources and sets the chosen datasource.\n * If there are no datasources a missing datasource action is dispatched.\n */\nexport function loadExploreDatasourcesAndSetDatasource(\n  exploreId: ExploreId,\n  datasourceName: string\n): ThunkResult<void> {\n  return async dispatch => {\n    const exploreDatasources = getExploreDatasources();\n\n    if (exploreDatasources.length >= 1) {\n      await dispatch(changeDatasource(exploreId, datasourceName, { importQueries: true }));\n    } else {\n      dispatch(loadDatasourceMissingAction({ exploreId }));\n    }\n  };\n}\n\n/**\n * Initialize Explore state with state from the URL and the React component.\n * Call this only on components for with the Explore state has not been initialized.\n */\nexport function initializeExplore(\n  exploreId: ExploreId,\n  datasourceName: string,\n  queries: DataQuery[],\n  range: TimeRange,\n  containerWidth: number,\n  eventBridge: Emitter,\n  originPanelId?: number | null\n): ThunkResult<void> {\n  return async (dispatch, getState) => {\n    dispatch(loadExploreDatasourcesAndSetDatasource(exploreId, datasourceName));\n    dispatch(\n      initializeExploreAction({\n        exploreId,\n        containerWidth,\n        eventBridge,\n        queries,\n        range,\n        originPanelId,\n      })\n    );\n    dispatch(updateTime({ exploreId }));\n    const richHistory = getRichHistory();\n    dispatch(richHistoryUpdatedAction({ richHistory }));\n  };\n}\n\n/**\n * Datasource loading was successfully completed.\n */\nexport const loadDatasourceReady = (\n  exploreId: ExploreId,\n  instance: DataSourceApi,\n  orgId: number\n): PayloadAction<LoadDatasourceReadyPayload> => {\n  const historyKey = `grafana.explore.history.${instance.meta?.id}`;\n  const history = store.getObject(historyKey, []);\n  // Save last-used datasource\n\n  store.set(lastUsedDatasourceKeyForOrgId(orgId), instance.name);\n\n  return loadDatasourceReadyAction({\n    exploreId,\n    history,\n  });\n};\n\n/**\n * Import queries from previous datasource if possible eg Loki and Prometheus have similar query language so the\n * labels part can be reused to get similar data.\n * @param exploreId\n * @param queries\n * @param sourceDataSource\n * @param targetDataSource\n */\nexport const importQueries = (\n  exploreId: ExploreId,\n  queries: DataQuery[],\n  sourceDataSource: DataSourceApi | undefined | null,\n  targetDataSource: DataSourceApi\n): ThunkResult<void> => {\n  return async dispatch => {\n    if (!sourceDataSource) {\n      // explore not initialized\n      dispatch(queriesImportedAction({ exploreId, queries }));\n      return;\n    }\n\n    let importedQueries = queries;\n    // Check if queries can be imported from previously selected datasource\n    if (sourceDataSource.meta?.id === targetDataSource.meta?.id) {\n      // Keep same queries if same type of datasource\n      importedQueries = [...queries];\n    } else if (targetDataSource.importQueries) {\n      // Datasource-specific importers\n      importedQueries = await targetDataSource.importQueries(queries, sourceDataSource.meta);\n    } else {\n      // Default is blank queries\n      importedQueries = ensureQueries();\n    }\n\n    const nextQueries = ensureQueries(importedQueries);\n\n    dispatch(queriesImportedAction({ exploreId, queries: nextQueries }));\n  };\n};\n\n/**\n * Main action to asynchronously load a datasource. Dispatches lots of smaller actions for feedback.\n */\nexport const loadDatasource = (exploreId: ExploreId, instance: DataSourceApi, orgId: number): ThunkResult<void> => {\n  return async (dispatch, getState) => {\n    const datasourceName = instance.name;\n\n    // Keep ID to track selection\n    dispatch(loadDatasourcePendingAction({ exploreId, requestedDatasourceName: datasourceName }));\n\n    if (instance.init) {\n      try {\n        instance.init();\n      } catch (err) {\n        console.error(err);\n      }\n    }\n\n    if (datasourceName !== getState().explore[exploreId].requestedDatasourceName) {\n      // User already changed datasource, discard results\n      return;\n    }\n\n    dispatch(loadDatasourceReady(exploreId, instance, orgId));\n  };\n};\n\n/**\n * Action to modify a query given a datasource-specific modifier action.\n * @param exploreId Explore area\n * @param modification Action object with a type, e.g., ADD_FILTER\n * @param index Optional query row index. If omitted, the modification is applied to all query rows.\n * @param modifier Function that executes the modification, typically `datasourceInstance.modifyQueries`.\n */\nexport function modifyQueries(\n  exploreId: ExploreId,\n  modification: QueryFixAction,\n  modifier: any,\n  index?: number\n): ThunkResult<void> {\n  return dispatch => {\n    dispatch(modifyQueriesAction({ exploreId, modification, index, modifier }));\n    if (!modification.preventSubmit) {\n      dispatch(runQueries(exploreId));\n    }\n  };\n}\n\n/**\n * Main action to run queries and dispatches sub-actions based on which result viewers are active\n */\nexport const runQueries = (exploreId: ExploreId): ThunkResult<void> => {\n  return (dispatch, getState) => {\n    dispatch(updateTime({ exploreId }));\n\n    const richHistory = getState().explore.richHistory;\n    const exploreItemState = getState().explore[exploreId];\n    const {\n      datasourceInstance,\n      queries,\n      containerWidth,\n      isLive: live,\n      range,\n      scanning,\n      queryResponse,\n      querySubscription,\n      history,\n      refreshInterval,\n      absoluteRange,\n    } = exploreItemState;\n\n    if (!hasNonEmptyQuery(queries)) {\n      dispatch(clearQueriesAction({ exploreId }));\n      dispatch(stateSave()); // Remember to save to state and update location\n      return;\n    }\n\n    if (!datasourceInstance) {\n      return;\n    }\n\n    // Some datasource's query builders allow per-query interval limits,\n    // but we're using the datasource interval limit for now\n    const minInterval = datasourceInstance?.interval;\n\n    stopQueryState(querySubscription);\n\n    const datasourceId = datasourceInstance?.meta.id;\n\n    const queryOptions: QueryOptions = {\n      minInterval,\n      // maxDataPoints is used in:\n      // Loki - used for logs streaming for buffer size, with undefined it falls back to datasource config if it supports that.\n      // Elastic - limits the number of datapoints for the counts query and for logs it has hardcoded limit.\n      // Influx - used to correctly display logs in graph\n      // TODO:unification\n      // maxDataPoints: mode === ExploreMode.Logs && datasourceId === 'loki' ? undefined : containerWidth,\n      maxDataPoints: containerWidth,\n      liveStreaming: live,\n    };\n\n    const datasourceName = exploreItemState.requestedDatasourceName;\n    const timeZone = getTimeZone(getState().user);\n    const transaction = buildQueryTransaction(queries, queryOptions, range, scanning, timeZone);\n\n    let firstResponse = true;\n    dispatch(changeLoadingStateAction({ exploreId, loadingState: LoadingState.Loading }));\n\n    const newQuerySub = runRequest(datasourceInstance, transaction.request)\n      .pipe(\n        // Simple throttle for live tailing, in case of > 1000 rows per interval we spend about 200ms on processing and\n        // rendering. In case this is optimized this can be tweaked, but also it should be only as fast as user\n        // actually can see what is happening.\n        live ? throttleTime(500) : identity,\n        map((data: PanelData) => preProcessPanelData(data, queryResponse)),\n        map(decorateWithGraphLogsTraceAndTable),\n        map(decorateWithGraphResult),\n        map(decorateWithLogsResult({ absoluteRange, refreshInterval })),\n        mergeMap(decorateWithTableResult)\n      )\n      .subscribe(\n        data => {\n          if (!data.error && firstResponse) {\n            // Side-effect: Saving history in localstorage\n            const nextHistory = updateHistory(history, datasourceId, queries);\n            const nextRichHistory = addToRichHistory(\n              richHistory || [],\n              datasourceId,\n              datasourceName,\n              queries,\n              false,\n              '',\n              ''\n            );\n            dispatch(historyUpdatedAction({ exploreId, history: nextHistory }));\n            dispatch(richHistoryUpdatedAction({ richHistory: nextRichHistory }));\n\n            // We save queries to the URL here so that only successfully run queries change the URL.\n            dispatch(stateSave());\n          }\n\n          firstResponse = false;\n\n          dispatch(queryStreamUpdatedAction({ exploreId, response: data }));\n\n          // Keep scanning for results if this was the last scanning transaction\n          if (getState().explore[exploreId].scanning) {\n            if (data.state === LoadingState.Done && data.series.length === 0) {\n              const range = getShiftedTimeRange(-1, getState().explore[exploreId].range);\n              dispatch(updateTime({ exploreId, absoluteRange: range }));\n              dispatch(runQueries(exploreId));\n            } else {\n              // We can stop scanning if we have a result\n              dispatch(scanStopAction({ exploreId }));\n            }\n          }\n        },\n        error => {\n          dispatch(notifyApp(createErrorNotification('Query processing error', error)));\n          dispatch(changeLoadingStateAction({ exploreId, loadingState: LoadingState.Error }));\n          console.error(error);\n        }\n      );\n\n    dispatch(queryStoreSubscriptionAction({ exploreId, querySubscription: newQuerySub }));\n  };\n};\n\nexport const updateRichHistory = (ts: number, property: string, updatedProperty?: string): ThunkResult<void> => {\n  return (dispatch, getState) => {\n    // Side-effect: Saving rich history in localstorage\n    let nextRichHistory;\n    if (property === 'starred') {\n      nextRichHistory = updateStarredInRichHistory(getState().explore.richHistory, ts);\n    }\n    if (property === 'comment') {\n      nextRichHistory = updateCommentInRichHistory(getState().explore.richHistory, ts, updatedProperty);\n    }\n    if (property === 'delete') {\n      nextRichHistory = deleteQueryInRichHistory(getState().explore.richHistory, ts);\n    }\n    dispatch(richHistoryUpdatedAction({ richHistory: nextRichHistory }));\n  };\n};\n\nexport const deleteRichHistory = (): ThunkResult<void> => {\n  return dispatch => {\n    deleteAllFromRichHistory();\n    dispatch(richHistoryUpdatedAction({ richHistory: [] }));\n  };\n};\n\nexport const toRawTimeRange = (range: TimeRange): RawTimeRange => {\n  let from = range.raw.from;\n  if (isDateTime(from)) {\n    from = from.valueOf().toString(10);\n  }\n\n  let to = range.raw.to;\n  if (isDateTime(to)) {\n    to = to.valueOf().toString(10);\n  }\n\n  return {\n    from,\n    to,\n  };\n};\n\n/**\n * Save local redux state back to the URL. Should be called when there is some change that should affect the URL.\n * Not all of the redux state is reflected in URL though.\n */\nexport const stateSave = (): ThunkResult<void> => {\n  return (dispatch, getState) => {\n    const { left, right, split } = getState().explore;\n    const orgId = getState().user.orgId.toString();\n    const replace = left && left.urlReplaced === false;\n    const urlStates: { [index: string]: string } = { orgId };\n    const leftUrlState: ExploreUrlState = {\n      datasource: left.datasourceInstance!.name,\n      queries: left.queries.map(clearQueryKeys),\n      range: toRawTimeRange(left.range),\n    };\n    urlStates.left = serializeStateToUrlParam(leftUrlState, true);\n    if (split) {\n      const rightUrlState: ExploreUrlState = {\n        datasource: right.datasourceInstance!.name,\n        queries: right.queries.map(clearQueryKeys),\n        range: toRawTimeRange(right.range),\n      };\n\n      urlStates.right = serializeStateToUrlParam(rightUrlState, true);\n    }\n\n    dispatch(updateLocation({ query: urlStates, replace }));\n    if (replace) {\n      dispatch(setUrlReplacedAction({ exploreId: ExploreId.left }));\n    }\n  };\n};\n\nexport const updateTime = (config: {\n  exploreId: ExploreId;\n  rawRange?: RawTimeRange;\n  absoluteRange?: AbsoluteTimeRange;\n}): ThunkResult<void> => {\n  return (dispatch, getState) => {\n    const { exploreId, absoluteRange: absRange, rawRange: actionRange } = config;\n    const itemState = getState().explore[exploreId];\n    const timeZone = getTimeZone(getState().user);\n    const { range: rangeInState } = itemState;\n    let rawRange: RawTimeRange = rangeInState.raw;\n\n    if (absRange) {\n      rawRange = {\n        from: dateTimeForTimeZone(timeZone, absRange.from),\n        to: dateTimeForTimeZone(timeZone, absRange.to),\n      };\n    }\n\n    if (actionRange) {\n      rawRange = actionRange;\n    }\n\n    const range = getTimeRange(timeZone, rawRange);\n    const absoluteRange: AbsoluteTimeRange = { from: range.from.valueOf(), to: range.to.valueOf() };\n\n    getTimeSrv().init(\n      new DashboardModel({\n        time: range.raw,\n        refresh: false,\n        timeZone,\n      })\n    );\n\n    dispatch(changeRangeAction({ exploreId, range, absoluteRange }));\n  };\n};\n\n/**\n * Start a scan for more results using the given scanner.\n * @param exploreId Explore area\n * @param scanner Function that a) returns a new time range and b) triggers a query run for the new range\n */\nexport function scanStart(exploreId: ExploreId): ThunkResult<void> {\n  return (dispatch, getState) => {\n    // Register the scanner\n    dispatch(scanStartAction({ exploreId }));\n    // Scanning must trigger query run, and return the new range\n    const range = getShiftedTimeRange(-1, getState().explore[exploreId].range);\n    // Set the new range to be displayed\n    dispatch(updateTime({ exploreId, absoluteRange: range }));\n    dispatch(runQueries(exploreId));\n  };\n}\n\n/**\n * Reset queries to the given queries. Any modifications will be discarded.\n * Use this action for clicks on query examples. Triggers a query run.\n */\nexport function setQueries(exploreId: ExploreId, rawQueries: DataQuery[]): ThunkResult<void> {\n  return (dispatch, getState) => {\n    // Inject react keys into query objects\n    const queries = getState().explore[exploreId].queries;\n    const nextQueries = rawQueries.map((query, index) => generateNewKeyAndAddRefIdIfMissing(query, queries, index));\n    dispatch(setQueriesAction({ exploreId, queries: nextQueries }));\n    dispatch(runQueries(exploreId));\n  };\n}\n\n/**\n * Close the split view and save URL state.\n */\nexport function splitClose(itemId: ExploreId): ThunkResult<void> {\n  return dispatch => {\n    dispatch(splitCloseAction({ itemId }));\n    dispatch(stateSave());\n  };\n}\n\n/**\n * Open the split view and the right state is automatically initialized.\n * If options are specified it initializes that pane with the datasource and query from options.\n * Otherwise it copies the left state to be the right state. The copy keeps all query modifications but wipes the query\n * results.\n */\nexport function splitOpen<T extends DataQuery = any>(options?: {\n  datasourceUid: string;\n  query: T;\n  // Don't use right now. It's used for Traces to Logs interaction but is hacky in how the range is actually handled.\n  range?: TimeRange;\n}): ThunkResult<void> {\n  return async (dispatch, getState) => {\n    // Clone left state to become the right state\n    const leftState: ExploreItemState = getState().explore[ExploreId.left];\n    const rightState: ExploreItemState = {\n      ...leftState,\n    };\n    const queryState = getState().location.query[ExploreId.left] as string;\n    const urlState = parseUrlState(queryState);\n\n    if (options) {\n      rightState.queries = [];\n      rightState.graphResult = null;\n      rightState.logsResult = null;\n      rightState.tableResult = null;\n      rightState.queryKeys = [];\n      urlState.queries = [];\n      rightState.urlState = urlState;\n      if (options.range) {\n        urlState.range = options.range.raw;\n        // This is super hacky. In traces to logs we want to create a link but also internally open split window.\n        // We use the same range object but the raw part is treated differently because it's parsed differently during\n        // init depending on whether we open split or new window.\n        rightState.range = {\n          ...options.range,\n          raw: {\n            from: options.range.from.utc().toISOString(),\n            to: options.range.to.utc().toISOString(),\n          },\n        };\n      }\n\n      dispatch(splitOpenAction({ itemState: rightState }));\n\n      const queries = [\n        {\n          ...options.query,\n          refId: 'A',\n        } as DataQuery,\n      ];\n\n      const dataSourceSettings = getDatasourceSrv().getDataSourceSettingsByUid(options.datasourceUid);\n\n      await dispatch(changeDatasource(ExploreId.right, dataSourceSettings!.name));\n      await dispatch(setQueriesAction({ exploreId: ExploreId.right, queries }));\n      await dispatch(runQueries(ExploreId.right));\n    } else {\n      rightState.queries = leftState.queries.slice();\n      rightState.urlState = urlState;\n      dispatch(splitOpenAction({ itemState: rightState }));\n    }\n\n    dispatch(stateSave());\n  };\n}\n\n/**\n * Syncs time interval, if they are not synced on both panels in a split mode.\n * Unsyncs time interval, if they are synced on both panels in a split mode.\n */\nexport function syncTimes(exploreId: ExploreId): ThunkResult<void> {\n  return (dispatch, getState) => {\n    if (exploreId === ExploreId.left) {\n      const leftState = getState().explore.left;\n      dispatch(updateTimeRange({ exploreId: ExploreId.right, rawRange: leftState.range.raw }));\n    } else {\n      const rightState = getState().explore.right;\n      dispatch(updateTimeRange({ exploreId: ExploreId.left, rawRange: rightState.range.raw }));\n    }\n    const isTimeSynced = getState().explore.syncedTimes;\n    dispatch(syncTimesAction({ syncedTimes: !isTimeSynced }));\n    dispatch(stateSave());\n  };\n}\n\n/**\n * Reacts to changes in URL state that we need to sync back to our redux state. Checks the internal update variable\n * to see which parts change and need to be synced.\n * @param exploreId\n */\nexport function refreshExplore(exploreId: ExploreId): ThunkResult<void> {\n  return (dispatch, getState) => {\n    const itemState = getState().explore[exploreId];\n    if (!itemState.initialized) {\n      return;\n    }\n\n    const { urlState, update, containerWidth, eventBridge } = itemState;\n\n    if (!urlState) {\n      return;\n    }\n\n    const { datasource, queries, range: urlRange, originPanelId } = urlState;\n    const refreshQueries: DataQuery[] = [];\n\n    for (let index = 0; index < queries.length; index++) {\n      const query = queries[index];\n      refreshQueries.push(generateNewKeyAndAddRefIdIfMissing(query, refreshQueries, index));\n    }\n\n    const timeZone = getTimeZone(getState().user);\n    const range = getTimeRangeFromUrl(urlRange, timeZone);\n\n    // need to refresh datasource\n    if (update.datasource) {\n      const initialQueries = ensureQueries(queries);\n      dispatch(\n        initializeExplore(exploreId, datasource, initialQueries, range, containerWidth, eventBridge, originPanelId)\n      );\n      return;\n    }\n\n    if (update.range) {\n      dispatch(updateTime({ exploreId, rawRange: range.raw }));\n    }\n\n    // need to refresh queries\n    if (update.queries) {\n      dispatch(setQueriesAction({ exploreId, queries: refreshQueries }));\n    }\n\n    // always run queries when refresh is needed\n    if (update.queries || update.range) {\n      dispatch(runQueries(exploreId));\n    }\n  };\n}\n\nexport interface NavigateToExploreDependencies {\n  getDataSourceSrv: () => DataSourceSrv;\n  getTimeSrv: () => TimeSrv;\n  getExploreUrl: (args: GetExploreUrlArguments) => Promise<string | undefined>;\n  openInNewWindow?: (url: string) => void;\n}\n\nexport const navigateToExplore = (\n  panel: PanelModel,\n  dependencies: NavigateToExploreDependencies\n): ThunkResult<void> => {\n  return async dispatch => {\n    const { getDataSourceSrv, getTimeSrv, getExploreUrl, openInNewWindow } = dependencies;\n    const datasourceSrv = getDataSourceSrv();\n    const datasource = await datasourceSrv.get(panel.datasource);\n    const path = await getExploreUrl({\n      panel,\n      panelTargets: panel.targets,\n      panelDatasource: datasource,\n      datasourceSrv,\n      timeSrv: getTimeSrv(),\n    });\n\n    if (openInNewWindow && path) {\n      openInNewWindow(path);\n      return;\n    }\n\n    const query = {}; // strips any angular query param\n    dispatch(updateLocation({ path, query }));\n  };\n};\n","// Libraries\nimport _ from 'lodash';\n\n// Services & Utils\nimport { DataQuery, DataSourceApi, dateTimeFormat, AppEvents, urlUtil, ExploreUrlState } from '@grafana/data';\nimport appEvents from 'app/core/app_events';\nimport store from 'app/core/store';\nimport { getExploreDatasources } from '../../features/explore/state/selectors';\n\n// Types\nimport { RichHistoryQuery } from 'app/types/explore';\nimport { serializeStateToUrlParam } from '@grafana/data/src/utils/url';\n\nconst RICH_HISTORY_KEY = 'grafana.explore.richHistory';\n\nexport const RICH_HISTORY_SETTING_KEYS = {\n  retentionPeriod: 'grafana.explore.richHistory.retentionPeriod',\n  starredTabAsFirstTab: 'grafana.explore.richHistory.starredTabAsFirstTab',\n  activeDatasourceOnly: 'grafana.explore.richHistory.activeDatasourceOnly',\n  datasourceFilters: 'grafana.explore.richHistory.datasourceFilters',\n};\n\nexport enum SortOrder {\n  Descending = 'Descending',\n  Ascending = 'Ascending',\n  DatasourceAZ = 'Datasource A-Z',\n  DatasourceZA = 'Datasource Z-A',\n}\n\n/*\n * Add queries to rich history. Save only queries within the retention period, or that are starred.\n * Side-effect: store history in local storage\n */\n\nexport function addToRichHistory(\n  richHistory: RichHistoryQuery[],\n  datasourceId: string,\n  datasourceName: string | null,\n  queries: DataQuery[],\n  starred: boolean,\n  comment: string | null,\n  sessionName: string\n): any {\n  const ts = Date.now();\n  /* Save only queries, that are not falsy (e.g. empty object, null, ...) */\n  const newQueriesToSave: DataQuery[] = queries && queries.filter(query => notEmptyQuery(query));\n  const retentionPeriod: number = store.getObject(RICH_HISTORY_SETTING_KEYS.retentionPeriod, 7);\n  const retentionPeriodLastTs = createRetentionPeriodBoundary(retentionPeriod, false);\n\n  /* Keep only queries, that are within the selected retention period or that are starred.\n   * If no queries, initialize with empty array\n   */\n  const queriesToKeep = richHistory.filter(q => q.ts > retentionPeriodLastTs || q.starred === true) || [];\n\n  if (newQueriesToSave.length > 0) {\n    /* Compare queries of a new query and last saved queries. If they are the same, (except selected properties,\n     * which can be different) don't save it in rich history.\n     */\n    const newQueriesToCompare = newQueriesToSave.map(q => _.omit(q, ['key', 'refId']));\n    const lastQueriesToCompare =\n      queriesToKeep.length > 0 &&\n      queriesToKeep[0].queries.map(q => {\n        return _.omit(q, ['key', 'refId']);\n      });\n\n    if (_.isEqual(newQueriesToCompare, lastQueriesToCompare)) {\n      return richHistory;\n    }\n\n    let updatedHistory = [\n      { queries: newQueriesToSave, ts, datasourceId, datasourceName, starred, comment, sessionName },\n      ...queriesToKeep,\n    ];\n\n    try {\n      store.setObject(RICH_HISTORY_KEY, updatedHistory);\n      return updatedHistory;\n    } catch (error) {\n      appEvents.emit(AppEvents.alertError, [error]);\n      return richHistory;\n    }\n  }\n\n  return richHistory;\n}\n\nexport function getRichHistory(): RichHistoryQuery[] {\n  const richHistory: RichHistoryQuery[] = store.getObject(RICH_HISTORY_KEY, []);\n  const transformedRichHistory = migrateRichHistory(richHistory);\n  return transformedRichHistory;\n}\n\nexport function deleteAllFromRichHistory() {\n  return store.delete(RICH_HISTORY_KEY);\n}\n\nexport function updateStarredInRichHistory(richHistory: RichHistoryQuery[], ts: number) {\n  const updatedHistory = richHistory.map(query => {\n    /* Timestamps are currently unique - we can use them to identify specific queries */\n    if (query.ts === ts) {\n      const isStarred = query.starred;\n      const updatedQuery = Object.assign({}, query, { starred: !isStarred });\n      return updatedQuery;\n    }\n    return query;\n  });\n\n  try {\n    store.setObject(RICH_HISTORY_KEY, updatedHistory);\n    return updatedHistory;\n  } catch (error) {\n    appEvents.emit(AppEvents.alertError, [error]);\n    return richHistory;\n  }\n}\n\nexport function updateCommentInRichHistory(\n  richHistory: RichHistoryQuery[],\n  ts: number,\n  newComment: string | undefined\n) {\n  const updatedHistory = richHistory.map(query => {\n    if (query.ts === ts) {\n      const updatedQuery = Object.assign({}, query, { comment: newComment });\n      return updatedQuery;\n    }\n    return query;\n  });\n\n  try {\n    store.setObject(RICH_HISTORY_KEY, updatedHistory);\n    return updatedHistory;\n  } catch (error) {\n    appEvents.emit(AppEvents.alertError, [error]);\n    return richHistory;\n  }\n}\n\nexport function deleteQueryInRichHistory(richHistory: RichHistoryQuery[], ts: number) {\n  const updatedHistory = richHistory.filter(query => query.ts !== ts);\n  try {\n    store.setObject(RICH_HISTORY_KEY, updatedHistory);\n    return updatedHistory;\n  } catch (error) {\n    appEvents.emit(AppEvents.alertError, [error]);\n    return richHistory;\n  }\n}\n\nexport const sortQueries = (array: RichHistoryQuery[], sortOrder: SortOrder) => {\n  let sortFunc;\n\n  if (sortOrder === SortOrder.Ascending) {\n    sortFunc = (a: RichHistoryQuery, b: RichHistoryQuery) => (a.ts < b.ts ? -1 : a.ts > b.ts ? 1 : 0);\n  }\n  if (sortOrder === SortOrder.Descending) {\n    sortFunc = (a: RichHistoryQuery, b: RichHistoryQuery) => (a.ts < b.ts ? 1 : a.ts > b.ts ? -1 : 0);\n  }\n\n  if (sortOrder === SortOrder.DatasourceZA) {\n    sortFunc = (a: RichHistoryQuery, b: RichHistoryQuery) =>\n      a.datasourceName < b.datasourceName ? -1 : a.datasourceName > b.datasourceName ? 1 : 0;\n  }\n\n  if (sortOrder === SortOrder.DatasourceAZ) {\n    sortFunc = (a: RichHistoryQuery, b: RichHistoryQuery) =>\n      a.datasourceName < b.datasourceName ? 1 : a.datasourceName > b.datasourceName ? -1 : 0;\n  }\n\n  return array.sort(sortFunc);\n};\n\nexport const createUrlFromRichHistory = (query: RichHistoryQuery) => {\n  const exploreState: ExploreUrlState = {\n    /* Default range, as we are not saving timerange in rich history */\n    range: { from: 'now-1h', to: 'now' },\n    datasource: query.datasourceName,\n    queries: query.queries,\n    context: 'explore',\n  };\n\n  const serializedState = serializeStateToUrlParam(exploreState, true);\n  const baseUrl = /.*(?=\\/explore)/.exec(`${window.location.href}`)![0];\n  const url = urlUtil.renderUrl(`${baseUrl}/explore`, { left: serializedState });\n  return url;\n};\n\n/* Needed for slider in Rich history to map numerical values to meaningful strings */\nexport const mapNumbertoTimeInSlider = (num: number) => {\n  let str;\n  switch (num) {\n    case 0:\n      str = 'today';\n      break;\n    case 1:\n      str = 'yesterday';\n      break;\n    case 7:\n      str = 'a week ago';\n      break;\n    case 14:\n      str = 'two weeks ago';\n      break;\n    default:\n      str = `${num} days ago`;\n  }\n\n  return str;\n};\n\nexport const createRetentionPeriodBoundary = (days: number, isLastTs: boolean) => {\n  const today = new Date();\n  const date = new Date(today.setDate(today.getDate() - days));\n  /*\n   * As a retention period boundaries, we consider:\n   * - The last timestamp equals to the 24:00 of the last day of retention\n   * - The first timestamp that equals to the 00:00 of the first day of retention\n   */\n  const boundary = isLastTs ? date.setHours(24, 0, 0, 0) : date.setHours(0, 0, 0, 0);\n  return boundary;\n};\n\nexport function createDateStringFromTs(ts: number) {\n  return dateTimeFormat(ts, {\n    format: 'MMMM D',\n  });\n}\n\nexport function getQueryDisplayText(query: DataQuery): string {\n  /* If datasource doesn't have getQueryDisplayText, create query display text by\n   * stringifying query that was stripped of key, refId and datasource for nicer\n   * formatting and improved readability\n   */\n  const strippedQuery = _.omit(query, ['key', 'refId', 'datasource']);\n  return JSON.stringify(strippedQuery);\n}\n\nexport function createQueryHeading(query: RichHistoryQuery, sortOrder: SortOrder) {\n  let heading = '';\n  if (sortOrder === SortOrder.DatasourceAZ || sortOrder === SortOrder.DatasourceZA) {\n    heading = query.datasourceName;\n  } else {\n    heading = createDateStringFromTs(query.ts);\n  }\n  return heading;\n}\n\nexport function createQueryText(query: DataQuery, queryDsInstance: DataSourceApi | undefined) {\n  /* query DatasourceInstance is necessary because we use its getQueryDisplayText method\n   * to format query text\n   */\n  if (queryDsInstance?.getQueryDisplayText) {\n    return queryDsInstance.getQueryDisplayText(query);\n  }\n\n  return getQueryDisplayText(query);\n}\n\nexport function mapQueriesToHeadings(query: RichHistoryQuery[], sortOrder: SortOrder) {\n  let mappedQueriesToHeadings: any = {};\n\n  query.forEach(q => {\n    let heading = createQueryHeading(q, sortOrder);\n    if (!(heading in mappedQueriesToHeadings)) {\n      mappedQueriesToHeadings[heading] = [q];\n    } else {\n      mappedQueriesToHeadings[heading] = [...mappedQueriesToHeadings[heading], q];\n    }\n  });\n\n  return mappedQueriesToHeadings;\n}\n\n/* Create datasource list with images. If specific datasource retrieved from Rich history is not part of\n * exploreDatasources add generic datasource image and add property isRemoved = true.\n */\nexport function createDatasourcesList(queriesDatasources: string[]) {\n  const exploreDatasources = getExploreDatasources();\n  const datasources: Array<{ label: string; value: string; imgUrl: string; isRemoved: boolean }> = [];\n\n  queriesDatasources.forEach(queryDsName => {\n    const index = exploreDatasources.findIndex(exploreDs => exploreDs.name === queryDsName);\n    if (index !== -1) {\n      datasources.push({\n        label: queryDsName,\n        value: queryDsName,\n        imgUrl: exploreDatasources[index].meta.info.logos.small,\n        isRemoved: false,\n      });\n    } else {\n      datasources.push({\n        label: queryDsName,\n        value: queryDsName,\n        imgUrl: 'public/img/icn-datasource.svg',\n        isRemoved: true,\n      });\n    }\n  });\n  return datasources;\n}\n\nexport function notEmptyQuery(query: DataQuery) {\n  /* Check if query has any other properties besides key, refId and datasource.\n   * If not, then we consider it empty query.\n   */\n  const strippedQuery = _.omit(query, ['key', 'refId', 'datasource']);\n  const queryKeys = Object.keys(strippedQuery);\n\n  if (queryKeys.length > 0) {\n    return true;\n  }\n\n  return false;\n}\n\nexport function filterQueriesBySearchFilter(queries: RichHistoryQuery[], searchFilter: string) {\n  return queries.filter(query => {\n    if (query.comment.includes(searchFilter)) {\n      return true;\n    }\n\n    const listOfMatchingQueries = query.queries.filter(query =>\n      // Remove fields in which we don't want to be searching\n      Object.values(_.omit(query, ['datasource', 'key', 'refId', 'hide', 'queryType'])).some((value: any) =>\n        value?.toString().includes(searchFilter)\n      )\n    );\n\n    return listOfMatchingQueries.length > 0;\n  });\n}\n\nexport function filterQueriesByDataSource(queries: RichHistoryQuery[], listOfDatasourceFilters: string[] | null) {\n  return listOfDatasourceFilters && listOfDatasourceFilters.length > 0\n    ? queries.filter(q => listOfDatasourceFilters.includes(q.datasourceName))\n    : queries;\n}\n\nexport function filterQueriesByTime(queries: RichHistoryQuery[], timeFilter: [number, number]) {\n  return queries.filter(\n    q =>\n      q.ts < createRetentionPeriodBoundary(timeFilter[0], true) &&\n      q.ts > createRetentionPeriodBoundary(timeFilter[1], false)\n  );\n}\n\nexport function filterAndSortQueries(\n  queries: RichHistoryQuery[],\n  sortOrder: SortOrder,\n  listOfDatasourceFilters: string[] | null,\n  searchFilter: string,\n  timeFilter?: [number, number]\n) {\n  const filteredQueriesByDs = filterQueriesByDataSource(queries, listOfDatasourceFilters);\n  const filteredQueriesByDsAndSearchFilter = filterQueriesBySearchFilter(filteredQueriesByDs, searchFilter);\n  const filteredQueriesToBeSorted = timeFilter\n    ? filterQueriesByTime(filteredQueriesByDsAndSearchFilter, timeFilter)\n    : filteredQueriesByDsAndSearchFilter;\n\n  return sortQueries(filteredQueriesToBeSorted, sortOrder);\n}\n\n/* These functions are created to migrate string queries (from 6.7 release) to DataQueries. They can be removed after 7.1 release. */\nfunction migrateRichHistory(richHistory: RichHistoryQuery[]) {\n  const transformedRichHistory = richHistory.map(query => {\n    const transformedQueries: DataQuery[] = query.queries.map((q, index) => createDataQuery(query, q, index));\n    return { ...query, queries: transformedQueries };\n  });\n\n  return transformedRichHistory;\n}\n\nfunction createDataQuery(query: RichHistoryQuery, individualQuery: DataQuery | string, index: number) {\n  const letters = 'ABCDEFGHIJKLMNOPQRSTUVXYZ';\n  if (typeof individualQuery === 'object') {\n    return individualQuery;\n  } else if (isParsable(individualQuery)) {\n    return JSON.parse(individualQuery);\n  }\n  return { expr: individualQuery, refId: letters[index] };\n}\n\nfunction isParsable(string: string) {\n  try {\n    JSON.parse(string);\n  } catch (e) {\n    return false;\n  }\n  return true;\n}\n"],"sourceRoot":""}