{"version":3,"file":"6291.cb5ce8837ec621d8b6a1.js","mappings":"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","sources":["webpack://grafana/./.yarn/__virtual__/@grafana-data-virtual-adf1e43f85/1/packages/grafana-data/src/field/fieldComparers.ts","webpack://grafana/./.yarn/__virtual__/@grafana-data-virtual-adf1e43f85/1/packages/grafana-data/src/transformations/matchers/compareValues.ts","webpack://grafana/./.yarn/__virtual__/@grafana-data-virtual-adf1e43f85/1/packages/grafana-data/src/transformations/matchers/fieldTypeMatcher.ts","webpack://grafana/./.yarn/__virtual__/@grafana-data-virtual-adf1e43f85/1/packages/grafana-data/src/transformations/matchers/fieldValueMatcher.ts","webpack://grafana/./.yarn/__virtual__/@grafana-data-virtual-adf1e43f85/1/packages/grafana-data/src/transformations/matchers/ids.ts","webpack://grafana/./.yarn/__virtual__/@grafana-data-virtual-adf1e43f85/1/packages/grafana-data/src/transformations/matchers/refIdMatcher.ts","webpack://grafana/./.yarn/__virtual__/@grafana-data-virtual-adf1e43f85/1/packages/grafana-data/src/transformations/matchers/simpleFieldMatcher.ts","webpack://grafana/./.yarn/__virtual__/@grafana-data-virtual-adf1e43f85/1/packages/grafana-data/src/transformations/matchers/valueMatchers/equalMatchers.ts","webpack://grafana/./.yarn/__virtual__/@grafana-data-virtual-adf1e43f85/1/packages/grafana-data/src/transformations/matchers/valueMatchers/nullMatchers.ts","webpack://grafana/./.yarn/__virtual__/@grafana-data-virtual-adf1e43f85/1/packages/grafana-data/src/transformations/matchers/valueMatchers/numericMatchers.ts","webpack://grafana/./.yarn/__virtual__/@grafana-data-virtual-adf1e43f85/1/packages/grafana-data/src/transformations/matchers/valueMatchers/rangeMatchers.ts","webpack://grafana/./.yarn/__virtual__/@grafana-data-virtual-adf1e43f85/1/packages/grafana-data/src/transformations/matchers/valueMatchers/regexMatchers.ts","webpack://grafana/./.yarn/__virtual__/@grafana-data-virtual-adf1e43f85/1/packages/grafana-data/src/transformations/transformers/ids.ts","webpack://grafana/./.yarn/__virtual__/@grafana-data-virtual-adf1e43f85/1/packages/grafana-data/src/utils/Registry.ts","webpack://grafana/./.yarn/__virtual__/@grafana-data-virtual-adf1e43f85/1/packages/grafana-data/src/vector/ArrayVector.ts","webpack://grafana/./.yarn/__virtual__/@grafana-data-virtual-adf1e43f85/1/packages/grafana-data/src/vector/SortedVector.ts","webpack://grafana/./.yarn/__virtual__/@grafana-data-virtual-adf1e43f85/1/packages/grafana-data/src/vector/vectorToArray.ts","webpack://grafana/./.yarn/__virtual__/@grafana-runtime-virtual-68c57d4c0c/1/packages/grafana-runtime/src/utils/toDataQueryError.ts","webpack://grafana/./public/app/plugins/datasource/prometheus/legend.ts"],"sourcesContent":["import { isNumber } from 'lodash';\n\nimport { dateTime, isDateTimeInput } from '../datetime';\nimport { Field, FieldType } from '../types/dataFrame';\nimport { Vector } from '../types/vector';\n\ntype IndexComparer = (a: number, b: number) => number;\n\n/** @public */\nexport const fieldIndexComparer = (field: Field, reverse = false): IndexComparer => {\n  const values = field.values;\n\n  switch (field.type) {\n    case FieldType.number:\n      return numericIndexComparer(values, reverse);\n    case FieldType.string:\n      return stringIndexComparer(values, reverse);\n    case FieldType.boolean:\n      return booleanIndexComparer(values, reverse);\n    case FieldType.time:\n      if (typeof field.values.get(0) === 'number') {\n        return timestampIndexComparer(values, reverse);\n      }\n      return timeIndexComparer(values, reverse);\n    default:\n      return naturalIndexComparer(reverse);\n  }\n};\n\n/** @public */\nexport const timeComparer = (a: unknown, b: unknown): number => {\n  if (!a || !b) {\n    return falsyComparer(a, b);\n  }\n\n  if (isNumber(a) && isNumber(b)) {\n    return numericComparer(a, b);\n  }\n\n  if (isDateTimeInput(a) && isDateTimeInput(b)) {\n    if (dateTime(a).isBefore(b)) {\n      return -1;\n    }\n\n    if (dateTime(b).isBefore(a)) {\n      return 1;\n    }\n  }\n\n  return 0;\n};\n\n/** @public */\nexport const numericComparer = (a: number, b: number): number => {\n  return a - b;\n};\n\n/** @public */\nexport const stringComparer = (a: string, b: string): number => {\n  if (!a || !b) {\n    return falsyComparer(a, b);\n  }\n  return a.localeCompare(b);\n};\n\nexport const booleanComparer = (a: boolean, b: boolean): number => {\n  return falsyComparer(a, b);\n};\n\nconst falsyComparer = (a: unknown, b: unknown): number => {\n  if (!a && b) {\n    return 1;\n  }\n\n  if (a && !b) {\n    return -1;\n  }\n\n  return 0;\n};\n\nconst timestampIndexComparer = (values: Vector<number>, reverse: boolean): IndexComparer => {\n  let vals = values.toArray();\n  let mult = reverse ? -1 : 1;\n  return (a: number, b: number): number => mult * (vals[a] - vals[b]);\n};\n\nconst timeIndexComparer = (values: Vector<unknown>, reverse: boolean): IndexComparer => {\n  return (a: number, b: number): number => {\n    const vA = values.get(a);\n    const vB = values.get(b);\n    return reverse ? timeComparer(vB, vA) : timeComparer(vA, vB);\n  };\n};\n\nconst booleanIndexComparer = (values: Vector<boolean>, reverse: boolean): IndexComparer => {\n  return (a: number, b: number): number => {\n    const vA = values.get(a);\n    const vB = values.get(b);\n    return reverse ? booleanComparer(vB, vA) : booleanComparer(vA, vB);\n  };\n};\n\nconst numericIndexComparer = (values: Vector<number>, reverse: boolean): IndexComparer => {\n  return (a: number, b: number): number => {\n    const vA = values.get(a);\n    const vB = values.get(b);\n    return reverse ? numericComparer(vB, vA) : numericComparer(vA, vB);\n  };\n};\n\nconst stringIndexComparer = (values: Vector<string>, reverse: boolean): IndexComparer => {\n  return (a: number, b: number): number => {\n    const vA = values.get(a);\n    const vB = values.get(b);\n    return reverse ? stringComparer(vB, vA) : stringComparer(vA, vB);\n  };\n};\n\nconst naturalIndexComparer = (reverse: boolean): IndexComparer => {\n  return (a: number, b: number): number => {\n    return reverse ? numericComparer(b, a) : numericComparer(a, b);\n  };\n};\n","import { ComparisonOperation } from '@grafana/schema';\n\n/**\n * Compare two values\n *\n * @internal -- not yet exported in `@grafana/data`\n */\nexport function compareValues(\n  left: string | number | boolean | null | undefined,\n  op: ComparisonOperation,\n  right: string | number | boolean | null | undefined\n) {\n  // Normalize null|undefined values\n  if (left == null || right == null) {\n    if (left == null) {\n      left = 'null';\n    }\n    if (right == null) {\n      right = 'null';\n    }\n    if (op === ComparisonOperation.GTE || op === ComparisonOperation.LTE) {\n      op = ComparisonOperation.EQ; // check for equality\n    }\n  }\n\n  switch (op) {\n    case ComparisonOperation.EQ:\n      return `${left}` === `${right}`;\n    case ComparisonOperation.NEQ:\n      return `${left}` !== `${right}`;\n    case ComparisonOperation.GT:\n      return left > right;\n    case ComparisonOperation.GTE:\n      return left >= right;\n    case ComparisonOperation.LT:\n      return left < right;\n    case ComparisonOperation.LTE:\n      return left <= right;\n    default:\n      return false;\n  }\n}\n","import { Field, FieldType, DataFrame } from '../../types/dataFrame';\nimport { FieldMatcherInfo } from '../../types/transformations';\n\nimport { FieldMatcherID } from './ids';\n\n// General Field matcher\nconst fieldTypeMatcher: FieldMatcherInfo<FieldType> = {\n  id: FieldMatcherID.byType,\n  name: 'Field Type',\n  description: 'match based on the field type',\n  defaultOptions: FieldType.number,\n\n  get: (type: FieldType) => {\n    return (field: Field, frame: DataFrame, allFrames: DataFrame[]) => {\n      return type === field.type;\n    };\n  },\n\n  getOptionsDisplayText: (type: FieldType) => {\n    return `Field type: ${type}`;\n  },\n};\n\n// Numeric Field matcher\n// This gets its own entry so it shows up in the dropdown\nconst numericMatcher: FieldMatcherInfo = {\n  id: FieldMatcherID.numeric,\n  name: 'Numeric Fields',\n  description: 'Fields with type number',\n\n  get: () => {\n    return fieldTypeMatcher.get(FieldType.number);\n  },\n\n  getOptionsDisplayText: () => {\n    return 'Numeric Fields';\n  },\n};\n\n// Time Field matcher\nconst timeMatcher: FieldMatcherInfo = {\n  id: FieldMatcherID.time,\n  name: 'Time Fields',\n  description: 'Fields with type time',\n\n  get: () => {\n    return fieldTypeMatcher.get(FieldType.time);\n  },\n\n  getOptionsDisplayText: () => {\n    return 'Time Fields';\n  },\n};\n\n/**\n * Registry Initialization\n */\nexport function getFieldTypeMatchers(): FieldMatcherInfo[] {\n  return [fieldTypeMatcher, numericMatcher, timeMatcher];\n}\n","import { ComparisonOperation } from '@grafana/schema';\n\nimport { Field, DataFrame } from '../../types/dataFrame';\nimport { FieldMatcherInfo } from '../../types/transformations';\nimport { reduceField, ReducerID } from '../fieldReducer';\n\nimport { compareValues } from './compareValues';\nimport { FieldMatcherID } from './ids';\n\nexport interface FieldValueMatcherConfig {\n  reducer: ReducerID;\n  op?: ComparisonOperation;\n  value?: number; // or string?\n}\n\n// This should move to a utility function on the reducer registry\nfunction isBooleanReducer(r: ReducerID) {\n  return r === ReducerID.allIsNull || r === ReducerID.allIsZero;\n}\n\nexport const fieldValueMatcherInfo: FieldMatcherInfo<FieldValueMatcherConfig> = {\n  id: FieldMatcherID.byValue,\n  name: 'By value (reducer)',\n  description: 'Reduce a field to a single value and test for inclusion',\n\n  // This is added to overrides by default\n  defaultOptions: {\n    reducer: ReducerID.allIsZero,\n    op: ComparisonOperation.GTE,\n    value: 0,\n  },\n\n  get: (props) => {\n    if (!props || !props.reducer) {\n      return () => false;\n    }\n    let { reducer, op, value } = props;\n    const isBoolean = isBooleanReducer(reducer);\n    if (!op) {\n      op = ComparisonOperation.EQ;\n    }\n    return (field: Field, frame: DataFrame, allFrames: DataFrame[]) => {\n      const left = reduceField({\n        field,\n        reducers: [reducer],\n      })[reducer];\n\n      if (isBoolean) {\n        return Boolean(left); // boolean\n      }\n      return compareValues(left, op!, value);\n    };\n  },\n\n  getOptionsDisplayText: (props) => {\n    return `By value (${props.reducer})`;\n  },\n};\n","// This needs to be in its own file to avoid circular references\n\n// Builtin Predicates\n// not using 'any' and 'never' since they are reserved keywords\nexport enum MatcherID {\n  anyMatch = 'anyMatch', // checks children\n  allMatch = 'allMatch', // checks children\n  invertMatch = 'invertMatch', // checks child\n  alwaysMatch = 'alwaysMatch',\n  neverMatch = 'neverMatch',\n}\n\nexport enum FieldMatcherID {\n  // Specific Types\n  numeric = 'numeric',\n  time = 'time', // Can be multiple times\n  first = 'first',\n  firstTimeField = 'firstTimeField', // Only the first fime field\n\n  // With arguments\n  byType = 'byType',\n  byName = 'byName',\n  byNames = 'byNames',\n  byRegexp = 'byRegexp',\n  byRegexpOrNames = 'byRegexpOrNames',\n  byFrameRefID = 'byFrameRefID',\n  byValue = 'byValue',\n  // byIndex = 'byIndex',\n  // byLabel = 'byLabel',\n}\n\n/**\n * Field name matchers\n */\nexport enum FrameMatcherID {\n  byName = 'byName',\n  byRefId = 'byRefId',\n  byIndex = 'byIndex',\n}\n\n/**\n * @public\n */\nexport enum ValueMatcherID {\n  regex = 'regex',\n  isNull = 'isNull',\n  isNotNull = 'isNotNull',\n  greater = 'greater',\n  greaterOrEqual = 'greaterOrEqual',\n  lower = 'lower',\n  lowerOrEqual = 'lowerOrEqual',\n  equal = 'equal',\n  notEqual = 'notEqual',\n  between = 'between',\n}\n","import { stringToJsRegex } from '../../text';\nimport { DataFrame } from '../../types/dataFrame';\nimport { FrameMatcherInfo } from '../../types/transformations';\n\nimport { FrameMatcherID } from './ids';\n\n// General Field matcher\nconst refIdMacher: FrameMatcherInfo<string> = {\n  id: FrameMatcherID.byRefId,\n  name: 'Query refId',\n  description: 'match the refId',\n  defaultOptions: 'A',\n\n  get: (pattern: string) => {\n    const regex = stringToJsRegex(pattern);\n    return (frame: DataFrame) => {\n      return regex.test(frame.refId || '');\n    };\n  },\n\n  getOptionsDisplayText: (pattern: string) => {\n    return `RefID: ${pattern}`;\n  },\n};\n\nexport function getRefIdMatchers(): FrameMatcherInfo[] {\n  return [refIdMacher];\n}\n","import { Field, FieldType, DataFrame } from '../../types/dataFrame';\nimport { FieldMatcherInfo } from '../../types/transformations';\n\nimport { FieldMatcherID } from './ids';\n\nconst firstFieldMatcher: FieldMatcherInfo = {\n  id: FieldMatcherID.first,\n  name: 'First Field',\n  description: 'The first field in the frame',\n\n  get: (type: FieldType) => {\n    return (field: Field, frame: DataFrame, allFrames: DataFrame[]) => {\n      return field === frame.fields[0];\n    };\n  },\n\n  getOptionsDisplayText: () => {\n    return `First field`;\n  },\n};\n\nconst firstTimeFieldMatcher: FieldMatcherInfo = {\n  id: FieldMatcherID.firstTimeField,\n  name: 'First time field',\n  description: 'The first field of type time in a frame',\n\n  get: (type: FieldType) => {\n    return (field: Field, frame: DataFrame, allFrames: DataFrame[]) => {\n      return field.type === FieldType.time && field === frame.fields.find((f) => f.type === FieldType.time);\n    };\n  },\n\n  getOptionsDisplayText: () => {\n    return `First time field`;\n  },\n};\n\n/**\n * Registry Initialization\n */\nexport function getSimpleFieldMatchers(): FieldMatcherInfo[] {\n  return [firstFieldMatcher, firstTimeFieldMatcher];\n}\n","import { Field } from '../../../types/dataFrame';\nimport { ValueMatcherInfo } from '../../../types/transformations';\nimport { ValueMatcherID } from '../ids';\n\nimport { BasicValueMatcherOptions } from './types';\n\nconst isEqualValueMatcher: ValueMatcherInfo<BasicValueMatcherOptions> = {\n  id: ValueMatcherID.equal,\n  name: 'Is equal',\n  description: 'Match where value for given field is equal to options value.',\n  get: (options) => {\n    return (valueIndex: number, field: Field) => {\n      const value = field.values.get(valueIndex);\n      // eslint-disable-next-line eqeqeq\n      return value == options.value;\n    };\n  },\n  getOptionsDisplayText: () => {\n    return `Matches all rows where field is null.`;\n  },\n  isApplicable: () => true,\n  getDefaultOptions: () => ({ value: '' }),\n};\n\nconst isNotEqualValueMatcher: ValueMatcherInfo<BasicValueMatcherOptions> = {\n  id: ValueMatcherID.notEqual,\n  name: 'Is not equal',\n  description: 'Match where value for given field is not equal to options value.',\n  get: (options) => {\n    return (valueIndex: number, field: Field) => {\n      const value = field.values.get(valueIndex);\n      // eslint-disable-next-line eqeqeq\n      return value != options.value;\n    };\n  },\n  getOptionsDisplayText: () => {\n    return `Matches all rows where field is not null.`;\n  },\n  isApplicable: () => true,\n  getDefaultOptions: () => ({ value: '' }),\n};\n\nexport const getEqualValueMatchers = (): ValueMatcherInfo[] => [isEqualValueMatcher, isNotEqualValueMatcher];\n","import { Field } from '../../../types/dataFrame';\nimport { ValueMatcherInfo } from '../../../types/transformations';\nimport { ValueMatcherID } from '../ids';\n\nimport { ValueMatcherOptions } from './types';\n\nconst isNullValueMatcher: ValueMatcherInfo<ValueMatcherOptions> = {\n  id: ValueMatcherID.isNull,\n  name: 'Is null',\n  description: 'Match where value for given field is null.',\n  get: () => {\n    return (valueIndex: number, field: Field) => {\n      const value = field.values.get(valueIndex);\n      return value == null;\n    };\n  },\n  getOptionsDisplayText: () => {\n    return `Matches all rows where field is null.`;\n  },\n  isApplicable: () => true,\n  getDefaultOptions: () => ({}),\n};\n\nconst isNotNullValueMatcher: ValueMatcherInfo<ValueMatcherOptions> = {\n  id: ValueMatcherID.isNotNull,\n  name: 'Is not null',\n  description: 'Match where value for given field is not null.',\n  get: () => {\n    return (valueIndex: number, field: Field) => {\n      const value = field.values.get(valueIndex);\n      return value != null;\n    };\n  },\n  getOptionsDisplayText: () => {\n    return `Matches all rows where field is not null.`;\n  },\n  isApplicable: () => true,\n  getDefaultOptions: () => ({}),\n};\n\nexport const getNullValueMatchers = (): ValueMatcherInfo[] => [isNullValueMatcher, isNotNullValueMatcher];\n","import { Field, FieldType } from '../../../types/dataFrame';\nimport { ValueMatcherInfo } from '../../../types/transformations';\nimport { ValueMatcherID } from '../ids';\n\nimport { BasicValueMatcherOptions } from './types';\n\nconst isGreaterValueMatcher: ValueMatcherInfo<BasicValueMatcherOptions<number>> = {\n  id: ValueMatcherID.greater,\n  name: 'Is greater',\n  description: 'Match when field value is greater than option.',\n  get: (options) => {\n    return (valueIndex: number, field: Field) => {\n      const value = field.values.get(valueIndex);\n      if (isNaN(value)) {\n        return false;\n      }\n      return value > options.value;\n    };\n  },\n  getOptionsDisplayText: (options) => {\n    return `Matches all rows where field value is greater than: ${options.value}.`;\n  },\n  isApplicable: (field) => field.type === FieldType.number,\n  getDefaultOptions: () => ({ value: 0 }),\n};\n\nconst isGreaterOrEqualValueMatcher: ValueMatcherInfo<BasicValueMatcherOptions<number>> = {\n  id: ValueMatcherID.greaterOrEqual,\n  name: 'Is greater or equal',\n  description: 'Match when field value is greater than or equal to option.',\n  get: (options) => {\n    return (valueIndex: number, field: Field) => {\n      const value = field.values.get(valueIndex);\n      if (isNaN(value)) {\n        return false;\n      }\n      return value >= options.value;\n    };\n  },\n  getOptionsDisplayText: (options) => {\n    return `Matches all rows where field value is greater than or equal to: ${options.value}.`;\n  },\n  isApplicable: (field) => field.type === FieldType.number,\n  getDefaultOptions: () => ({ value: 0 }),\n};\n\nconst isLowerValueMatcher: ValueMatcherInfo<BasicValueMatcherOptions<number>> = {\n  id: ValueMatcherID.lower,\n  name: 'Is lower',\n  description: 'Match when field value is lower than option.',\n  get: (options) => {\n    return (valueIndex: number, field: Field) => {\n      const value = field.values.get(valueIndex);\n      if (isNaN(value)) {\n        return false;\n      }\n      return value < options.value;\n    };\n  },\n  getOptionsDisplayText: (options) => {\n    return `Matches all rows where field value is lower than: ${options.value}.`;\n  },\n  isApplicable: (field) => field.type === FieldType.number,\n  getDefaultOptions: () => ({ value: 0 }),\n};\n\nconst isLowerOrEqualValueMatcher: ValueMatcherInfo<BasicValueMatcherOptions<number>> = {\n  id: ValueMatcherID.lowerOrEqual,\n  name: 'Is lower or equal',\n  description: 'Match when field value is lower or equal than option.',\n  get: (options) => {\n    return (valueIndex: number, field: Field) => {\n      const value = field.values.get(valueIndex);\n      if (isNaN(value)) {\n        return false;\n      }\n      return value <= options.value;\n    };\n  },\n  getOptionsDisplayText: (options) => {\n    return `Matches all rows where field value is lower or equal than: ${options.value}.`;\n  },\n  isApplicable: (field) => field.type === FieldType.number,\n  getDefaultOptions: () => ({ value: 0 }),\n};\n\nexport const getNumericValueMatchers = (): ValueMatcherInfo[] => [\n  isGreaterValueMatcher,\n  isGreaterOrEqualValueMatcher,\n  isLowerValueMatcher,\n  isLowerOrEqualValueMatcher,\n];\n","import { Field, FieldType } from '../../../types/dataFrame';\nimport { ValueMatcherInfo } from '../../../types/transformations';\nimport { ValueMatcherID } from '../ids';\n\nimport { RangeValueMatcherOptions } from './types';\n\nconst isBetweenValueMatcher: ValueMatcherInfo<RangeValueMatcherOptions<number>> = {\n  id: ValueMatcherID.between,\n  name: 'Is between',\n  description: 'Match when field value is between given option values.',\n  get: (options) => {\n    return (valueIndex: number, field: Field) => {\n      const value = field.values.get(valueIndex);\n      if (isNaN(value)) {\n        return false;\n      }\n      return value > options.from && value < options.to;\n    };\n  },\n  getOptionsDisplayText: (options) => {\n    return `Matches all rows where field value is between ${options.from} and ${options.to}.`;\n  },\n  isApplicable: (field) => field.type === FieldType.number,\n  getDefaultOptions: () => ({ from: 0, to: 100 }),\n};\n\nexport const getRangeValueMatchers = (): ValueMatcherInfo[] => [isBetweenValueMatcher];\n","import { Field } from '../../../types/dataFrame';\nimport { ValueMatcherInfo } from '../../../types/transformations';\nimport { ValueMatcherID } from '../ids';\n\nimport { BasicValueMatcherOptions } from './types';\n\nconst regexValueMatcher: ValueMatcherInfo<BasicValueMatcherOptions<string>> = {\n  id: ValueMatcherID.regex,\n  name: 'Regex',\n  description: 'Match when field value is matching regex.',\n  get: (options) => {\n    const regex = new RegExp(options.value);\n\n    return (valueIndex: number, field: Field) => {\n      const value = field.values.get(valueIndex);\n      return regex.test(value);\n    };\n  },\n  getOptionsDisplayText: (options) => {\n    return `Matches all rows where field value is matching regex: ${options.value}`;\n  },\n  isApplicable: () => true,\n  getDefaultOptions: () => ({ value: '.*' }),\n};\n\nexport const getRegexValueMatcher = (): ValueMatcherInfo[] => [regexValueMatcher];\n","export enum DataTransformerID {\n  append = 'append',\n  //  rotate = 'rotate', // Columns to rows\n  reduce = 'reduce',\n  order = 'order',\n  organize = 'organize',\n  rename = 'rename',\n  calculateField = 'calculateField',\n  /** @deprecated use joinByField */\n  seriesToColumns = 'seriesToColumns',\n  seriesToRows = 'seriesToRows',\n  merge = 'merge',\n  concatenate = 'concatenate',\n  labelsToFields = 'labelsToFields',\n  filterFields = 'filterFields',\n  filterFieldsByName = 'filterFieldsByName',\n  filterFrames = 'filterFrames',\n  filterByRefId = 'filterByRefId',\n  renameByRegex = 'renameByRegex',\n  filterByValue = 'filterByValue',\n  noop = 'noop',\n  ensureColumns = 'ensureColumns',\n  groupBy = 'groupBy',\n  sortBy = 'sortBy',\n  histogram = 'histogram',\n  configFromData = 'configFromData',\n  rowsToFields = 'rowsToFields',\n  prepareTimeSeries = 'prepareTimeSeries',\n  convertFieldType = 'convertFieldType',\n  fieldLookup = 'fieldLookup',\n  heatmap = 'heatmap',\n  spatial = 'spatial',\n  joinByField = 'joinByField',\n  joinByLabels = 'joinByLabels',\n  extractFields = 'extractFields',\n  groupingToMatrix = 'groupingToMatrix',\n  limit = 'limit',\n  partitionByValues = 'partitionByValues',\n  timeSeriesTable = 'timeSeriesTable',\n}\n","import { PluginState } from '../types';\nimport { SelectableValue } from '../types/select';\n\nexport interface RegistryItem {\n  id: string; // Unique Key -- saved in configs\n  name: string; // Display Name, can change without breaking configs\n  description?: string;\n  aliasIds?: string[]; // when the ID changes, we may want backwards compatibility ('current' => 'last')\n\n  /**\n   * Some extensions should not be user selectable\n   *  like: 'all' and 'any' matchers;\n   */\n  excludeFromPicker?: boolean;\n\n  /**\n   * Optional feature state\n   */\n  state?: PluginState;\n}\n\nexport interface RegistryItemWithOptions<TOptions = any> extends RegistryItem {\n  /**\n   * Convert the options to a string\n   */\n  getOptionsDisplayText?: (options: TOptions) => string;\n\n  /**\n   * Default options used if nothing else is specified\n   */\n  defaultOptions?: TOptions;\n}\n\ninterface RegistrySelectInfo {\n  options: Array<SelectableValue<string>>;\n  current: Array<SelectableValue<string>>;\n}\n\nexport class Registry<T extends RegistryItem> {\n  private ordered: T[] = [];\n  private byId = new Map<string, T>();\n  private initialized = false;\n\n  constructor(private init?: () => T[]) {\n    this.init = init;\n  }\n\n  setInit = (init: () => T[]) => {\n    if (this.initialized) {\n      throw new Error('Registry already initialized');\n    }\n    this.init = init;\n  };\n\n  getIfExists(id: string | undefined): T | undefined {\n    if (!this.initialized) {\n      this.initialize();\n    }\n\n    if (id) {\n      return this.byId.get(id);\n    }\n\n    return undefined;\n  }\n\n  private initialize() {\n    if (this.init) {\n      for (const ext of this.init()) {\n        this.register(ext);\n      }\n    }\n    this.sort();\n    this.initialized = true;\n  }\n\n  get(id: string): T {\n    const v = this.getIfExists(id);\n    if (!v) {\n      throw new Error(`\"${id}\" not found in: ${this.list().map((v) => v.id)}`);\n    }\n    return v;\n  }\n\n  selectOptions(current?: string[], filter?: (ext: T) => boolean): RegistrySelectInfo {\n    if (!this.initialized) {\n      this.initialize();\n    }\n\n    const select: RegistrySelectInfo = {\n      options: [],\n      current: [],\n    };\n\n    const currentOptions: Record<string, SelectableValue<string>> = {};\n    if (current) {\n      for (const id of current) {\n        currentOptions[id] = {};\n      }\n    }\n\n    for (const ext of this.ordered) {\n      if (ext.excludeFromPicker) {\n        continue;\n      }\n      if (filter && !filter(ext)) {\n        continue;\n      }\n\n      const option = {\n        value: ext.id,\n        label: ext.name,\n        description: ext.description,\n      };\n\n      if (ext.state === PluginState.alpha) {\n        option.label += ' (alpha)';\n      }\n\n      select.options.push(option);\n      if (currentOptions[ext.id]) {\n        currentOptions[ext.id] = option;\n      }\n    }\n\n    if (current) {\n      // this makes sure we preserve the order of ids\n      select.current = Object.values(currentOptions);\n    }\n\n    return select;\n  }\n\n  /**\n   * Return a list of values by ID, or all values if not specified\n   */\n  list(ids?: string[]): T[] {\n    if (!this.initialized) {\n      this.initialize();\n    }\n\n    if (ids) {\n      const found: T[] = [];\n      for (const id of ids) {\n        const v = this.getIfExists(id);\n        if (v) {\n          found.push(v);\n        }\n      }\n      return found;\n    }\n\n    return this.ordered;\n  }\n\n  isEmpty(): boolean {\n    if (!this.initialized) {\n      this.initialize();\n    }\n\n    return this.ordered.length === 0;\n  }\n\n  register(ext: T) {\n    if (this.byId.has(ext.id)) {\n      throw new Error('Duplicate Key:' + ext.id);\n    }\n\n    this.byId.set(ext.id, ext);\n    this.ordered.push(ext);\n\n    if (ext.aliasIds) {\n      for (const alias of ext.aliasIds) {\n        if (!this.byId.has(alias)) {\n          this.byId.set(alias, ext);\n        }\n      }\n    }\n\n    if (this.initialized) {\n      this.sort();\n    }\n  }\n\n  private sort() {\n    // TODO sort the list\n  }\n}\n","import { MutableVector } from '../types/vector';\n\nimport { FunctionalVector } from './FunctionalVector';\n\n/**\n * @public\n */\nexport class ArrayVector<T = any> extends FunctionalVector<T> implements MutableVector<T> {\n  buffer: T[];\n\n  constructor(buffer?: T[]) {\n    super();\n    this.buffer = buffer ? buffer : [];\n  }\n\n  get length() {\n    return this.buffer.length;\n  }\n\n  add(value: T) {\n    this.buffer.push(value);\n  }\n\n  get(index: number): T {\n    return this.buffer[index];\n  }\n\n  set(index: number, value: T) {\n    this.buffer[index] = value;\n  }\n\n  reverse() {\n    this.buffer.reverse();\n  }\n\n  toArray(): T[] {\n    return this.buffer;\n  }\n\n  toJSON(): T[] {\n    return this.buffer;\n  }\n}\n","import { Vector } from '../types/vector';\n\nimport { vectorToArray } from './vectorToArray';\n\n/**\n * Values are returned in the order defined by the input parameter\n */\nexport class SortedVector<T = any> implements Vector<T> {\n  constructor(private source: Vector<T>, private order: number[]) {}\n\n  get length(): number {\n    return this.source.length;\n  }\n\n  get(index: number): T {\n    return this.source.get(this.order[index]);\n  }\n\n  toArray(): T[] {\n    return vectorToArray(this);\n  }\n\n  toJSON(): T[] {\n    return vectorToArray(this);\n  }\n\n  getOrderArray(): number[] {\n    return this.order;\n  }\n}\n","import { Vector } from '../types/vector';\n\nexport function vectorToArray<T>(v: Vector<T>): T[] {\n  const arr: T[] = Array(v.length);\n  for (let i = 0; i < v.length; i++) {\n    arr[i] = v.get(i);\n  }\n  return arr;\n}\n","import { DataQueryError } from '@grafana/data';\n\n/**\n * Convert an object into a DataQueryError -- if this is an HTTP response,\n * it will put the correct values in the error field\n *\n * @public\n */\nexport function toDataQueryError(err: DataQueryError | string | unknown): DataQueryError {\n  const error: DataQueryError = err || {};\n\n  if (!error.message) {\n    if (typeof err === 'string') {\n      return { message: err };\n    }\n\n    let message = 'Query error';\n    if (error.message) {\n      message = error.message;\n    } else if (error.data && error.data.message && error.data?.message !== 'Query data error') {\n      message = error.data.message;\n    } else if (error?.data?.message === 'Query data error' && error?.data?.error) {\n      message = error.data.error;\n    } else if (error.data && error.data.error) {\n      message = error.data.error;\n    } else if (error.status) {\n      message = `Query error: ${error.status} ${error.statusText}`;\n    }\n    error.message = message;\n  }\n\n  return error;\n}\n","import { Labels } from '@grafana/data';\n\n/** replace labels in a string.  Used for loki+prometheus legend formats */\nexport function renderLegendFormat(aliasPattern: string, aliasData: Labels): string {\n  const aliasRegex = /\\{\\{\\s*(.+?)\\s*\\}\\}/g;\n  return aliasPattern.replace(aliasRegex, (_, g1) => (aliasData[g1] ? aliasData[g1] : g1));\n}\n"],"names":["fieldIndexComparer","field","reverse","values","numericIndexComparer","stringIndexComparer","booleanIndexComparer","timestampIndexComparer","timeIndexComparer","naturalIndexComparer","timeComparer","b","falsyComparer","numericComparer","stringComparer","booleanComparer","vals","mult","a","vA","vB","compareValues","left","op","right","fieldTypeMatcher","type","frame","allFrames","numericMatcher","timeMatcher","getFieldTypeMatchers","isBooleanReducer","r","fieldValueMatcherInfo","props","reducer","value","isBoolean","MatcherID","FieldMatcherID","FrameMatcherID","ValueMatcherID","refIdMacher","pattern","regex","getRefIdMatchers","firstFieldMatcher","firstTimeFieldMatcher","f","getSimpleFieldMatchers","isEqualValueMatcher","options","valueIndex","isNotEqualValueMatcher","getEqualValueMatchers","isNullValueMatcher","isNotNullValueMatcher","getNullValueMatchers","isGreaterValueMatcher","isGreaterOrEqualValueMatcher","isLowerValueMatcher","isLowerOrEqualValueMatcher","getNumericValueMatchers","isBetweenValueMatcher","getRangeValueMatchers","regexValueMatcher","getRegexValueMatcher","DataTransformerID","Registry","init","id","ext","v","current","filter","select","currentOptions","option","ids","found","alias","ArrayVector","buffer","index","SortedVector","source","order","vectorToArray","arr","toDataQueryError","err","error","message","renderLegendFormat","aliasPattern","aliasData","aliasRegex","_","g1"],"sourceRoot":""}