{"version":3,"file":"loki-query-field.238850b4efef64330a67.js","mappings":"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","sources":["webpack://grafana/./node_modules/@grafana/monaco-logql/index.js","webpack://grafana/./public/app/plugins/datasource/loki/components/monaco-query-field/getOverrideServices.ts","webpack://grafana/./public/app/plugins/datasource/loki/components/monaco-query-field/monaco-completion-provider/CompletionDataProvider.ts","webpack://grafana/./public/app/plugins/datasource/loki/components/monaco-query-field/monaco-completion-provider/NeverCaseError.ts","webpack://grafana/./public/app/plugins/datasource/loki/components/monaco-query-field/monaco-completion-provider/completions.ts","webpack://grafana/./public/app/plugins/datasource/loki/components/monaco-query-field/monaco-completion-provider/situation.ts","webpack://grafana/./public/app/plugins/datasource/loki/components/monaco-query-field/monaco-completion-provider/completionUtils.ts","webpack://grafana/./public/app/plugins/datasource/loki/components/monaco-query-field/MonacoQueryField.tsx"],"sourcesContent":["\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.monarchlanguage = exports.languageConfiguration = void 0;\nexports.languageConfiguration = {\n    // the default separators except `@$`\n    wordPattern: /(-?\\d*\\.\\d\\w*)|([^`~!#%^&*()\\-=+\\[{\\]}\\\\|;:'\",.<>\\/?\\s]+)/g,\n    comments: {\n        lineComment: \"#\",\n    },\n    brackets: [\n        [\"{\", \"}\"],\n        [\"[\", \"]\"],\n        [\"(\", \")\"],\n    ],\n    autoClosingPairs: [\n        { open: \"{\", close: \"}\" },\n        { open: \"[\", close: \"]\" },\n        { open: \"(\", close: \")\" },\n        { open: '\"', close: '\"' },\n        { open: \"'\", close: \"'\" },\n        { open: \"`\", close: \"`\" },\n    ],\n    surroundingPairs: [\n        { open: \"{\", close: \"}\" },\n        { open: \"[\", close: \"]\" },\n        { open: \"(\", close: \")\" },\n        { open: '\"', close: '\"' },\n        { open: \"'\", close: \"'\" },\n        { open: \"`\", close: \"`\" },\n        { open: \"<\", close: \">\" },\n    ],\n    folding: {},\n};\n// LogQL built-in aggregation operators\n// https://grafana.com/docs/loki/latest/logql/metric_queries/#built-in-aggregation-operators\nvar aggregations = [\n    \"sum\",\n    \"avg\",\n    \"min\",\n    \"max\",\n    \"stddev\",\n    \"stdvar\",\n    \"count\",\n    \"topk\",\n    \"bottomk\",\n];\n// LogQL parser expressions\n// https://grafana.com/docs/loki/latest/logql/log_queries/#parser-expression\nvar parsers = [\"json\", \"logfmt\", \"regexp\", \"unpack\", \"pattern\"];\n// LogQL format expressions\n// https://grafana.com/docs/loki/latest/logql/log_queries/#parser-expression\nvar format_expressions = [\"line_format\", \"label_format\"];\n// LogQL vector aggregations\n// https://grafana.com/docs/loki/latest/logql/metric_queries/#range-vector-aggregation\nvar vector_aggregations = [\n    \"count_over_time\",\n    \"rate\",\n    \"bytes_over_time\",\n    \"bytes_rate\",\n    \"avg_over_time\",\n    \"sum_over_time\",\n    \"min_over_time\",\n    \"max_over_time\",\n    \"stdvar_over_time\",\n    \"stddev_over_time\",\n    \"quantile_over_time\",\n    \"first_over_time\",\n    \"last_over_time\",\n    \"absent_over_time\",\n];\n// LogQL by and without clauses\nvar vector_matching = [\"by\", \"without\"];\n// Produce a regex matching elements : (by|without)\nvar vectorMatchingRegex = \"(\".concat(vector_matching.reduce(function (prev, curr) { return \"\".concat(prev, \"|\").concat(curr); }), \")\");\n// LogQL Operators\nvar operators = [\n    \"+\",\n    \"-\",\n    \"*\",\n    \"/\",\n    \"%\",\n    \"^\",\n    \"==\",\n    \"!=\",\n    \">\",\n    \"<\",\n    \">=\",\n    \"<=\",\n    \"|=\",\n    \"!=\",\n    \"|~\",\n    \"!~\",\n    \"and\",\n    \"or\",\n    \"unless\",\n    \"|\",\n];\n// Merging all the keywords in one list\nvar keywords = aggregations\n    .concat(parsers)\n    .concat(format_expressions)\n    .concat(vector_aggregations)\n    .concat(vector_matching);\nexports.monarchlanguage = {\n    ignoreCase: false,\n    defaultToken: \"\",\n    tokenPostfix: \".logql\",\n    keywords: keywords,\n    operators: operators,\n    vectorMatching: vectorMatchingRegex,\n    // we include these common regular expressions\n    symbols: /[=><!~?:&|+\\-*\\/^%]+/,\n    escapes: /\\\\(?:[abfnrtv\\\\\"']|x[0-9A-Fa-f]{1,4}|u[0-9A-Fa-f]{4}|U[0-9A-Fa-f]{8})/,\n    digits: /\\d+(_+\\d+)*/,\n    octaldigits: /[0-7]+(_+[0-7]+)*/,\n    binarydigits: /[0-1]+(_+[0-1]+)*/,\n    hexdigits: /[[0-9a-fA-F]+(_+[0-9a-fA-F]+)*/,\n    integersuffix: /(ll|LL|u|U|l|L)?(ll|LL|u|U|l|L)?/,\n    floatsuffix: /[fFlL]?/,\n    // The main tokenizer for our languages\n    tokenizer: {\n        root: [\n            // 'by', 'without' and vector matching\n            [/@vectorMatching\\s*(?=\\()/, \"type\", \"@clauses\"],\n            // labels\n            [/[a-z_]\\w*(?=\\s*(=|!=|=~|!~))/, \"tag\"],\n            // comments\n            [/(^#.*$)/, \"comment\"],\n            // all keywords have the same color\n            [\n                /[a-zA-Z_]\\w*/,\n                {\n                    cases: {\n                        \"@keywords\": \"type\",\n                        \"@default\": \"identifier\",\n                    },\n                },\n            ],\n            // strings\n            [/\"/, \"string\", \"@string_double\"],\n            [/'/, \"string\", \"@string_single\"],\n            [/`/, \"string\", \"@string_backtick\"],\n            // whitespace\n            { include: \"@whitespace\" },\n            // delimiters and operators\n            [/[{}()\\[\\]]/, \"@brackets\"],\n            [/[<>](?!@symbols)/, \"@brackets\"],\n            [\n                /@symbols/,\n                {\n                    cases: {\n                        \"@operators\": \"delimiter\",\n                        \"@default\": \"\",\n                    },\n                },\n            ],\n            // numbers\n            [/\\d+(?:ms|[smhdwy])/, \"number\"],\n            [/\\d*\\d+[eE]([\\-+]?\\d+)?(@floatsuffix)/, \"number.float\"],\n            [/\\d*\\.\\d+([eE][\\-+]?\\d+)?(@floatsuffix)/, \"number.float\"],\n            [/0[xX][0-9a-fA-F']*[0-9a-fA-F](@integersuffix)/, \"number.hex\"],\n            [/0[0-7']*[0-7](@integersuffix)/, \"number.octal\"],\n            [/0[bB][0-1']*[0-1](@integersuffix)/, \"number.binary\"],\n            [/\\d[\\d']*\\d(@integersuffix)/, \"number\"],\n            [/\\d(@integersuffix)/, \"number\"],\n        ],\n        string_double: [\n            // Set to token: number to differentiate color\n            [/\\{\\{(.*?)\\}\\}/, { token: 'number' }],\n            [/[^\\\\\"]/, \"string\"],\n            [/@escapes/, \"string.escape\"],\n            [/\\\\./, \"string.escape.invalid\"],\n            [/\"/, \"string\", \"@pop\"],\n        ],\n        string_single: [\n            [/[^\\\\']+/, \"string\"],\n            [/@escapes/, \"string.escape\"],\n            [/\\\\./, \"string.escape.invalid\"],\n            [/'/, \"string\", \"@pop\"],\n        ],\n        string_backtick: [\n            // Set to token: number to differentiate color\n            [/\\{\\{(.*?)\\}\\}/, { token: 'number' }],\n            [/[^\\\\`]/, \"string\"],\n            [/@escapes/, \"string.escape\"],\n            [/\\\\./, \"string.escape.invalid\"],\n            [/`/, \"string\", \"@pop\"],\n        ],\n        clauses: [\n            [/[^(,)]/, \"tag\"],\n            [/\\)/, \"identifier\", \"@pop\"],\n        ],\n        whitespace: [[/[ \\t\\r\\n]+/, \"white\"]],\n    },\n};\n","import { monacoTypes } from '@grafana/ui';\n\n// this thing here is a workaround in a way.\n// what we want to achieve, is that when the autocomplete-window\n// opens, the \"second, extra popup\" with the extra help,\n// also opens automatically.\n// but there is no API to achieve it.\n// the way to do it is to implement the `storageService`\n// interface, and provide our custom implementation,\n// which will default to `true` for the correct string-key.\n// unfortunately, while the typescript-interface exists,\n// it is not exported from monaco-editor,\n// so we cannot rely on typescript to make sure\n// we do it right. all we can do is to manually\n// lookup the interface, and make sure we code our code right.\n// our code is a \"best effort\" approach,\n// i am not 100% how the `scope` and `target` things work,\n// but so far it seems to work ok.\n// i would use an another approach, if there was one available.\n\nfunction makeStorageService() {\n  // we need to return an object that fulfills this interface:\n  // https://github.com/microsoft/vscode/blob/ff1e16eebb93af79fd6d7af1356c4003a120c563/src/vs/platform/storage/common/storage.ts#L37\n  // unfortunately it is not export from monaco-editor\n\n  const strings = new Map<string, string>();\n\n  // we want this to be true by default\n  strings.set('expandSuggestionDocs', true.toString());\n\n  return {\n    // we do not implement the on* handlers\n    onDidChangeValue: (data: unknown): void => undefined,\n    onDidChangeTarget: (data: unknown): void => undefined,\n    onWillSaveState: (data: unknown): void => undefined,\n\n    get: (key: string, scope: unknown, fallbackValue?: string): string | undefined => {\n      return strings.get(key) ?? fallbackValue;\n    },\n\n    getBoolean: (key: string, scope: unknown, fallbackValue?: boolean): boolean | undefined => {\n      const val = strings.get(key);\n      if (val !== undefined) {\n        // the interface docs say the value will be converted\n        // to a boolean but do not specify how, so we improvise\n        return val === 'true';\n      } else {\n        return fallbackValue;\n      }\n    },\n\n    getNumber: (key: string, scope: unknown, fallbackValue?: number): number | undefined => {\n      const val = strings.get(key);\n      if (val !== undefined) {\n        return parseInt(val, 10);\n      } else {\n        return fallbackValue;\n      }\n    },\n\n    store: (\n      key: string,\n      value: string | boolean | number | undefined | null,\n      scope: unknown,\n      target: unknown\n    ): void => {\n      // the interface docs say if the value is nullish, it should act as delete\n      if (value === null || value === undefined) {\n        strings.delete(key);\n      } else {\n        strings.set(key, value.toString());\n      }\n    },\n\n    remove: (key: string, scope: unknown): void => {\n      strings.delete(key);\n    },\n\n    keys: (scope: unknown, target: unknown): string[] => {\n      return Array.from(strings.keys());\n    },\n\n    logStorage: (): void => {\n      console.log('logStorage: not implemented');\n    },\n\n    migrate: (): Promise<void> => {\n      // we do not implement this\n      return Promise.resolve(undefined);\n    },\n\n    isNew: (scope: unknown): boolean => {\n      // we create a new storage for every session, we do not persist it,\n      // so we return `true`.\n      return true;\n    },\n\n    flush: (reason?: unknown): Promise<void> => {\n      // we do not implement this\n      return Promise.resolve(undefined);\n    },\n  };\n}\n\nlet overrideServices: monacoTypes.editor.IEditorOverrideServices = {\n  storageService: makeStorageService(),\n};\n\nexport function getOverrideServices(): monacoTypes.editor.IEditorOverrideServices {\n  // One instance of this for every query editor\n  return overrideServices;\n}\n","import { chain } from 'lodash';\n\nimport { HistoryItem, TimeRange } from '@grafana/data';\n\nimport LanguageProvider from '../../../LanguageProvider';\nimport { escapeLabelValueInExactSelector } from '../../../languageUtils';\nimport { ParserAndLabelKeysResult, LokiQuery } from '../../../types';\n\nimport { Label } from './situation';\n\ninterface HistoryRef {\n  current: Array<HistoryItem<LokiQuery>>;\n}\n\nexport class CompletionDataProvider {\n  constructor(\n    private languageProvider: LanguageProvider,\n    private historyRef: HistoryRef = { current: [] },\n    private timeRange: TimeRange | undefined\n  ) {\n    this.queryToLabelKeysCache = new Map();\n  }\n  private queryToLabelKeysCache: Map<string, ParserAndLabelKeysResult>;\n\n  private buildSelector(labels: Label[]): string {\n    const allLabelTexts = labels.map(\n      (label) => `${label.name}${label.op}\"${escapeLabelValueInExactSelector(label.value)}\"`\n    );\n\n    return `{${allLabelTexts.join(',')}}`;\n  }\n\n  setTimeRange(timeRange: TimeRange) {\n    this.timeRange = timeRange;\n    this.queryToLabelKeysCache.clear();\n  }\n\n  getHistory() {\n    return chain(this.historyRef.current)\n      .orderBy('ts', 'desc')\n      .map((history: HistoryItem<LokiQuery>) => history.query.expr.trim())\n      .filter()\n      .uniq()\n      .value();\n  }\n\n  async getLabelNames(otherLabels: Label[] = []) {\n    if (otherLabels.length === 0) {\n      // If there is no filtering, we use getLabelKeys because it has better caching\n      // and all labels should already be fetched\n      await this.languageProvider.start(this.timeRange);\n      return this.languageProvider.getLabelKeys();\n    }\n    const possibleLabelNames = await this.languageProvider.fetchLabels({\n      streamSelector: this.buildSelector(otherLabels),\n      timeRange: this.timeRange,\n    });\n    const usedLabelNames = new Set(otherLabels.map((l) => l.name)); // names used in the query\n    return possibleLabelNames.filter((label) => !usedLabelNames.has(label));\n  }\n\n  async getLabelValues(labelName: string, otherLabels: Label[]) {\n    return await this.languageProvider.fetchLabelValues(labelName, {\n      streamSelector: this.buildSelector(otherLabels),\n      timeRange: this.timeRange,\n    });\n  }\n\n  /**\n   * Runs a Loki query to extract label keys from the result.\n   * The result is cached for the query string.\n   *\n   * Since various \"situations\" in the monaco code editor trigger this function, it is prone to being called multiple times for the same query\n   * Here is a lightweight and simple cache to avoid calling the backend multiple times for the same query.\n   *\n   * @param logQuery\n   */\n  async getParserAndLabelKeys(logQuery: string): Promise<ParserAndLabelKeysResult> {\n    const EXTRACTED_LABEL_KEYS_MAX_CACHE_SIZE = 2;\n    const cachedLabelKeys = this.queryToLabelKeysCache.has(logQuery) ? this.queryToLabelKeysCache.get(logQuery) : null;\n    if (cachedLabelKeys) {\n      // cache hit! Serve stale result from cache\n      return cachedLabelKeys;\n    } else {\n      // If cache is larger than max size, delete the first (oldest) index\n      if (this.queryToLabelKeysCache.size >= EXTRACTED_LABEL_KEYS_MAX_CACHE_SIZE) {\n        // Make room in the cache for the fresh result by deleting the \"first\" index\n        const keys = this.queryToLabelKeysCache.keys();\n        const firstKey = keys.next().value;\n        if (firstKey !== undefined) {\n          this.queryToLabelKeysCache.delete(firstKey);\n        }\n      }\n      // Fetch a fresh result from the backend\n      const labelKeys = await this.languageProvider.getParserAndLabelKeys(logQuery, { timeRange: this.timeRange });\n      // Add the result to the cache\n      this.queryToLabelKeysCache.set(logQuery, labelKeys);\n      return labelKeys;\n    }\n  }\n}\n","// This helper class is used to make typescript warn you when you miss a case-block in a switch statement.\n// For example:\n//\n// const x:'A'|'B'|'C' = 'A';\n//\n// switch(x) {\n//   case 'A':\n//     // something\n//   case 'B':\n//     // something\n//   default:\n//     throw new NeverCaseError(x);\n// }\n//\n//\n// TypeScript detect the missing case and display an error.\n\nexport class NeverCaseError extends Error {\n  constructor(value: never) {\n    super(`Unexpected case in switch statement: ${JSON.stringify(value)}`);\n  }\n}\n","import { trimEnd } from 'lodash';\n\nimport { escapeLabelValueInExactSelector } from '../../../languageUtils';\nimport { isQueryWithParser } from '../../../queryUtils';\nimport { explainOperator } from '../../../querybuilder/operations';\nimport { LokiOperationId } from '../../../querybuilder/types';\nimport { AGGREGATION_OPERATORS, RANGE_VEC_FUNCTIONS, BUILT_IN_FUNCTIONS } from '../../../syntax';\n\nimport { CompletionDataProvider } from './CompletionDataProvider';\nimport { NeverCaseError } from './NeverCaseError';\nimport type { Situation, Label } from './situation';\n\nexport type CompletionType =\n  | 'HISTORY'\n  | 'FUNCTION'\n  | 'DURATION'\n  | 'LABEL_NAME'\n  | 'LABEL_VALUE'\n  | 'PATTERN'\n  | 'PARSER'\n  | 'LINE_FILTER'\n  | 'PIPE_OPERATION';\n\ntype Completion = {\n  type: CompletionType;\n  label: string;\n  insertText: string;\n  detail?: string;\n  documentation?: string;\n  triggerOnInsert?: boolean;\n  isSnippet?: boolean;\n};\n\nconst LOG_COMPLETIONS: Completion[] = [\n  {\n    type: 'PATTERN',\n    label: '{}',\n    insertText: '{$0}',\n    isSnippet: true,\n    triggerOnInsert: true,\n  },\n];\n\nconst AGGREGATION_COMPLETIONS: Completion[] = AGGREGATION_OPERATORS.map((f) => ({\n  type: 'FUNCTION',\n  label: f.label,\n  insertText: `${f.insertText ?? ''}($0)`, // i don't know what to do when this is nullish. it should not be.\n  isSnippet: true,\n  triggerOnInsert: true,\n  detail: f.detail,\n  documentation: f.documentation,\n}));\n\nconst FUNCTION_COMPLETIONS: Completion[] = RANGE_VEC_FUNCTIONS.map((f) => ({\n  type: 'FUNCTION',\n  label: f.label,\n  insertText: `${f.insertText ?? ''}({$0}[\\\\$__auto])`, // i don't know what to do when this is nullish. it should not be.\n  isSnippet: true,\n  triggerOnInsert: true,\n  detail: f.detail,\n  documentation: f.documentation,\n}));\n\nconst BUILT_IN_FUNCTIONS_COMPLETIONS: Completion[] = BUILT_IN_FUNCTIONS.map((f) => ({\n  type: 'FUNCTION',\n  label: f.label,\n  insertText: `${f.insertText ?? ''}($0)`,\n  isSnippet: true,\n  triggerOnInsert: true,\n  detail: f.detail,\n  documentation: f.documentation,\n}));\n\nconst DURATION_COMPLETIONS: Completion[] = ['$__auto', '1m', '5m', '10m', '30m', '1h', '1d'].map((text) => ({\n  type: 'DURATION',\n  label: text,\n  insertText: text,\n}));\n\nconst UNWRAP_FUNCTION_COMPLETIONS: Completion[] = [\n  {\n    type: 'FUNCTION',\n    label: 'duration_seconds',\n    documentation: 'Will convert the label value in seconds from the go duration format (e.g 5m, 24s30ms).',\n    insertText: 'duration_seconds()',\n  },\n  {\n    type: 'FUNCTION',\n    label: 'duration',\n    documentation: 'Short version of duration_seconds().',\n    insertText: 'duration()',\n  },\n  {\n    type: 'FUNCTION',\n    label: 'bytes',\n    documentation: 'Will convert the label value to raw bytes applying the bytes unit (e.g. 5 MiB, 3k, 1G).',\n    insertText: 'bytes()',\n  },\n];\n\nconst LOGFMT_ARGUMENT_COMPLETIONS: Completion[] = [\n  {\n    type: 'FUNCTION',\n    label: '--strict',\n    documentation:\n      'Strict parsing. The logfmt parser stops scanning the log line and returns early with an error when it encounters any poorly formatted key/value pair.',\n    insertText: '--strict',\n  },\n  {\n    type: 'FUNCTION',\n    label: '--keep-empty',\n    documentation:\n      'Retain standalone keys with empty value. The logfmt parser retains standalone keys (keys without a value) as labels with value set to empty string.',\n    insertText: '--keep-empty',\n  },\n];\n\nconst LINE_FILTER_COMPLETIONS = [\n  {\n    operator: '|=',\n    documentation: explainOperator(LokiOperationId.LineContains),\n    afterPipe: true,\n  },\n  {\n    operator: '!=',\n    documentation: explainOperator(LokiOperationId.LineContainsNot),\n  },\n  {\n    operator: '|~',\n    documentation: explainOperator(LokiOperationId.LineMatchesRegex),\n    afterPipe: true,\n  },\n  {\n    operator: '!~',\n    documentation: explainOperator(LokiOperationId.LineMatchesRegexNot),\n  },\n];\n\nfunction getLineFilterCompletions(afterPipe: boolean): Completion[] {\n  return LINE_FILTER_COMPLETIONS.filter((completion) => !afterPipe || completion.afterPipe).map(\n    ({ operator, documentation }) => ({\n      type: 'LINE_FILTER',\n      label: `${operator} \"\"`,\n      insertText: `${afterPipe ? operator.replace('|', '') : operator} \"$0\"`,\n      isSnippet: true,\n      documentation,\n    })\n  );\n}\n\nfunction getPipeOperationsCompletions(prefix = ''): Completion[] {\n  const completions: Completion[] = [];\n  completions.push({\n    type: 'PIPE_OPERATION',\n    label: 'line_format',\n    insertText: `${prefix}line_format \"{{.$0}}\"`,\n    isSnippet: true,\n    documentation: explainOperator(LokiOperationId.LineFormat),\n  });\n\n  completions.push({\n    type: 'PIPE_OPERATION',\n    label: 'label_format',\n    insertText: `${prefix}label_format`,\n    isSnippet: true,\n    documentation: explainOperator(LokiOperationId.LabelFormat),\n  });\n\n  completions.push({\n    type: 'PIPE_OPERATION',\n    label: 'unwrap',\n    insertText: `${prefix}unwrap`,\n    documentation: explainOperator(LokiOperationId.Unwrap),\n  });\n\n  completions.push({\n    type: 'PIPE_OPERATION',\n    label: 'decolorize',\n    insertText: `${prefix}decolorize`,\n    documentation: explainOperator(LokiOperationId.Decolorize),\n  });\n\n  completions.push({\n    type: 'PIPE_OPERATION',\n    label: 'drop',\n    insertText: `${prefix}drop`,\n    documentation: explainOperator(LokiOperationId.Drop),\n  });\n\n  completions.push({\n    type: 'PIPE_OPERATION',\n    label: 'keep',\n    insertText: `${prefix}keep`,\n    documentation: explainOperator(LokiOperationId.Keep),\n  });\n\n  return completions;\n}\n\nasync function getAllHistoryCompletions(dataProvider: CompletionDataProvider): Promise<Completion[]> {\n  const history = await dataProvider.getHistory();\n\n  return history.map((expr) => ({\n    type: 'HISTORY',\n    label: expr,\n    insertText: expr,\n  }));\n}\n\nasync function getLabelNamesForSelectorCompletions(\n  otherLabels: Label[],\n  dataProvider: CompletionDataProvider\n): Promise<Completion[]> {\n  const labelNames = await dataProvider.getLabelNames(otherLabels);\n\n  return labelNames.map((label) => ({\n    type: 'LABEL_NAME',\n    label,\n    insertText: `${label}=`,\n    triggerOnInsert: true,\n  }));\n}\n\nasync function getInGroupingCompletions(logQuery: string, dataProvider: CompletionDataProvider): Promise<Completion[]> {\n  const { extractedLabelKeys } = await dataProvider.getParserAndLabelKeys(logQuery);\n\n  return extractedLabelKeys.map((label) => ({\n    type: 'LABEL_NAME',\n    label,\n    insertText: label,\n    triggerOnInsert: false,\n  }));\n}\n\nconst PARSERS = ['json', 'logfmt', 'pattern', 'regexp', 'unpack'];\n\nasync function getParserCompletions(\n  prefix: string,\n  hasJSON: boolean,\n  hasLogfmt: boolean,\n  hasPack: boolean,\n  extractedLabelKeys: string[],\n  hasParserInQuery: boolean\n) {\n  const allParsers = new Set(PARSERS);\n  const completions: Completion[] = [];\n  // We use this to improve documentation specifically for level label as it is tied to showing color-coded logs volume\n  const hasLevelInExtractedLabels = extractedLabelKeys.some((key) => key === 'level');\n\n  if (hasJSON) {\n    // We show \"detected\" label only if there is no previous parser in the query\n    const extra = hasParserInQuery ? '' : ' (detected)';\n    if (hasPack) {\n      allParsers.delete('unpack');\n      completions.push({\n        type: 'PARSER',\n        label: `unpack${extra}`,\n        insertText: `${prefix}unpack`,\n        documentation: explainOperator(LokiOperationId.Unpack),\n      });\n    } else {\n      allParsers.delete('json');\n      completions.push({\n        type: 'PARSER',\n        label: `json${extra}`,\n        insertText: `${prefix}json`,\n        documentation: hasLevelInExtractedLabels\n          ? 'Use it to get log-levels in the histogram'\n          : explainOperator(LokiOperationId.Json),\n      });\n    }\n  }\n\n  if (hasLogfmt) {\n    allParsers.delete('logfmt');\n    // We show \"detected\" label only if there is no previous parser in the query\n    const extra = hasParserInQuery ? '' : ' (detected)';\n    completions.push({\n      type: 'PARSER',\n      label: `logfmt${extra}`,\n      insertText: `${prefix}logfmt`,\n      documentation: hasLevelInExtractedLabels\n        ? 'Get detected levels in the histogram'\n        : explainOperator(LokiOperationId.Logfmt),\n    });\n  }\n\n  const remainingParsers = Array.from(allParsers).sort();\n  remainingParsers.forEach((parser) => {\n    completions.push({\n      type: 'PARSER',\n      label: parser,\n      insertText: `${prefix}${parser}`,\n      documentation: explainOperator(parser),\n    });\n  });\n\n  return completions;\n}\n\nexport async function getAfterSelectorCompletions(\n  logQuery: string,\n  afterPipe: boolean,\n  hasSpace: boolean,\n  dataProvider: CompletionDataProvider\n): Promise<Completion[]> {\n  let query = logQuery;\n  if (afterPipe) {\n    query = trimEnd(logQuery, '| ');\n  }\n\n  const { extractedLabelKeys, structuredMetadataKeys, hasJSON, hasLogfmt, hasPack } =\n    await dataProvider.getParserAndLabelKeys(query);\n  const hasQueryParser = isQueryWithParser(query).queryWithParser;\n\n  const prefix = `${hasSpace ? '' : ' '}${afterPipe ? '' : '| '}`;\n\n  const parserCompletions = await getParserCompletions(\n    prefix,\n    hasJSON,\n    hasLogfmt,\n    hasPack,\n    extractedLabelKeys,\n    hasQueryParser\n  );\n  const pipeOperations = getPipeOperationsCompletions(prefix);\n\n  const completions = [...parserCompletions, ...pipeOperations];\n\n  structuredMetadataKeys.forEach((key) => {\n    completions.push({\n      type: 'LABEL_NAME',\n      label: `${key} (detected)`,\n      insertText: `${prefix}${key}`,\n      documentation: `\"${key}\" was suggested based on structured metadata attached to your loglines.`,\n    });\n  });\n\n  // Let's show label options only if query has parser\n  if (hasQueryParser) {\n    extractedLabelKeys.forEach((key) => {\n      completions.push({\n        type: 'LABEL_NAME',\n        label: `${key} (detected)`,\n        insertText: `${prefix}${key}`,\n        documentation: `\"${key}\" was suggested based on the content of your log lines for the label filter expression.`,\n      });\n    });\n  }\n\n  // If we have parser, we don't need to consider line filters\n  if (hasQueryParser) {\n    return [...completions];\n  }\n  // With a space between the pipe and the cursor, we omit line filters\n  // E.g. `{label=\"value\"} | `\n  const lineFilters = afterPipe && hasSpace ? [] : getLineFilterCompletions(afterPipe);\n  return [...lineFilters, ...completions];\n}\n\nexport async function getLogfmtCompletions(\n  logQuery: string,\n  flags: boolean,\n  trailingComma: boolean | undefined,\n  trailingSpace: boolean | undefined,\n  otherLabels: string[],\n  dataProvider: CompletionDataProvider\n): Promise<Completion[]> {\n  let completions: Completion[] = [];\n\n  if (trailingComma) {\n    // Remove the trailing comma, otherwise the sample query will fail.\n    logQuery = trimEnd(logQuery, ', ');\n  }\n  const { extractedLabelKeys, hasJSON, hasLogfmt, hasPack } = await dataProvider.getParserAndLabelKeys(logQuery);\n  const pipeOperations = getPipeOperationsCompletions('| ');\n\n  /**\n   * The user is not in the process of writing another label, and has not specified 2 flags.\n   * The current grammar doesn't allow us to know which flags were used (by node name), so we consider flags = true\n   * when 2 have been used.\n   * For example:\n   * - {label=\"value\"} | logfmt ^\n   * - {label=\"value\"} | logfmt --strict ^\n   * - {label=\"value\"} | logfmt --strict --keep-empty ^\n   */\n  if (!trailingComma && !flags) {\n    completions = [...LOGFMT_ARGUMENT_COMPLETIONS];\n  }\n\n  /**\n   * If the user has no trailing comma and has a trailing space it can mean that they finished writing the logfmt\n   * part and want to move on, for example, with other parsers or pipe operations.\n   * For example:\n   * - {label=\"value\"} | logfmt --flag ^\n   * - {label=\"value\"} | logfmt label, label2 ^\n   */\n  if (!trailingComma && trailingSpace) {\n    /**\n     * Don't offer parsers if there is no label argument: {label=\"value\"} | logfmt ^\n     * The reason is that it would be unusual that they would want to use another parser just after logfmt, and\n     * more likely that they would want a flag, labels, or continue with pipe operations.\n     *\n     * Offer parsers with at least one label argument: {label=\"value\"} | logfmt label ^\n     * The rationale here is to offer the same completions as getAfterSelectorCompletions().\n     */\n    const parserCompletions =\n      otherLabels.length > 0\n        ? await getParserCompletions('| ', hasJSON, hasLogfmt, hasPack, extractedLabelKeys, true)\n        : [];\n    completions = [...completions, ...parserCompletions, ...pipeOperations];\n  }\n\n  const labels = extractedLabelKeys.filter((label) => !otherLabels.includes(label));\n\n  /**\n   * We want to decide whether to use a trailing comma or not based on the data we have of the current\n   * situation. In particular, the following scenarios will not lead to a trailing comma:\n   * {label=\"value\"} | logfmt ^\n   * - trailingSpace: true, trailingComma: false, otherLabels: []\n   * {label=\"value\"} | logfmt lab^\n   * trailingSpace: false, trailignComma: false, otherLabels: [lab]\n   * {label=\"value\"} | logfmt label,^\n   * trailingSpace: false, trailingComma: true, otherLabels: [label]\n   * {label=\"value\"} | logfmt label, ^\n   * trailingSpace: true, trailingComma: true, otherLabels: [label]\n   */\n  let labelPrefix = '';\n  if (otherLabels.length > 0 && trailingSpace) {\n    labelPrefix = trailingComma ? '' : ', ';\n  }\n\n  const labelCompletions: Completion[] = labels.map((label) => ({\n    type: 'LABEL_NAME',\n    label,\n    insertText: labelPrefix + label,\n    triggerOnInsert: false,\n  }));\n\n  completions = [...completions, ...labelCompletions];\n\n  return completions;\n}\n\nasync function getLabelValuesForMetricCompletions(\n  labelName: string,\n  betweenQuotes: boolean,\n  otherLabels: Label[],\n  dataProvider: CompletionDataProvider\n): Promise<Completion[]> {\n  const values = await dataProvider.getLabelValues(labelName, otherLabels);\n  return values.map((text) => ({\n    type: 'LABEL_VALUE',\n    label: text,\n    insertText: betweenQuotes ? escapeLabelValueInExactSelector(text) : `\"${escapeLabelValueInExactSelector(text)}\"`,\n  }));\n}\n\nasync function getAfterUnwrapCompletions(\n  logQuery: string,\n  dataProvider: CompletionDataProvider\n): Promise<Completion[]> {\n  const { unwrapLabelKeys } = await dataProvider.getParserAndLabelKeys(logQuery);\n\n  const labelCompletions: Completion[] = unwrapLabelKeys.map((label) => ({\n    type: 'LABEL_NAME',\n    label,\n    insertText: label,\n    triggerOnInsert: false,\n  }));\n\n  return [...labelCompletions, ...UNWRAP_FUNCTION_COMPLETIONS];\n}\n\nasync function getAfterKeepAndDropCompletions(logQuery: string, dataProvider: CompletionDataProvider) {\n  const { extractedLabelKeys } = await dataProvider.getParserAndLabelKeys(logQuery);\n  const labelCompletions: Completion[] = extractedLabelKeys.map((label) => ({\n    type: 'LABEL_NAME',\n    label,\n    insertText: label,\n    triggerOnInsert: false,\n  }));\n\n  return [...labelCompletions];\n}\n\nexport async function getCompletions(\n  situation: Situation,\n  dataProvider: CompletionDataProvider\n): Promise<Completion[]> {\n  switch (situation.type) {\n    case 'EMPTY':\n    case 'AT_ROOT':\n      const historyCompletions = await getAllHistoryCompletions(dataProvider);\n      return [\n        ...historyCompletions,\n        ...LOG_COMPLETIONS,\n        ...AGGREGATION_COMPLETIONS,\n        ...BUILT_IN_FUNCTIONS_COMPLETIONS,\n        ...FUNCTION_COMPLETIONS,\n      ];\n    case 'IN_RANGE':\n      return DURATION_COMPLETIONS;\n    case 'IN_GROUPING':\n      return getInGroupingCompletions(situation.logQuery, dataProvider);\n    case 'IN_LABEL_SELECTOR_NO_LABEL_NAME':\n      return getLabelNamesForSelectorCompletions(situation.otherLabels, dataProvider);\n    case 'IN_LABEL_SELECTOR_WITH_LABEL_NAME':\n      return getLabelValuesForMetricCompletions(\n        situation.labelName,\n        situation.betweenQuotes,\n        situation.otherLabels,\n        dataProvider\n      );\n    case 'AFTER_SELECTOR':\n      return getAfterSelectorCompletions(situation.logQuery, situation.afterPipe, situation.hasSpace, dataProvider);\n    case 'AFTER_UNWRAP':\n      return getAfterUnwrapCompletions(situation.logQuery, dataProvider);\n    case 'IN_AGGREGATION':\n      return [...FUNCTION_COMPLETIONS, ...AGGREGATION_COMPLETIONS];\n    case 'AFTER_KEEP_AND_DROP':\n      return getAfterKeepAndDropCompletions(situation.logQuery, dataProvider);\n    case 'IN_LOGFMT':\n      return getLogfmtCompletions(\n        situation.logQuery,\n        situation.flags,\n        situation.trailingComma,\n        situation.trailingSpace,\n        situation.otherLabels,\n        dataProvider\n      );\n    default:\n      throw new NeverCaseError(situation);\n  }\n}\n","import type { SyntaxNode, TreeCursor } from '@lezer/common';\n\nimport {\n  parser,\n  VectorAggregationExpr,\n  String,\n  Selector,\n  RangeAggregationExpr,\n  Range,\n  PipelineExpr,\n  PipelineStage,\n  Matchers,\n  Matcher,\n  LogQL,\n  LogRangeExpr,\n  LogExpr,\n  Logfmt,\n  Identifier,\n  Grouping,\n  Expr,\n  LiteralExpr,\n  MetricExpr,\n  UnwrapExpr,\n  DropLabelsExpr,\n  KeepLabelsExpr,\n  DropLabels,\n  KeepLabels,\n  ParserFlag,\n  LabelExtractionExpression,\n  LabelExtractionExpressionList,\n  LogfmtExpressionParser,\n} from '@grafana/lezer-logql';\n\nimport { getLogQueryFromMetricsQueryAtPosition, getNodesFromQuery } from '../../../queryUtils';\n\ntype Direction = 'parent' | 'firstChild' | 'lastChild' | 'nextSibling';\ntype NodeType = number;\n\ntype Path = Array<[Direction, NodeType]>;\n\nfunction move(node: SyntaxNode, direction: Direction): SyntaxNode | null {\n  return node[direction];\n}\n\n/**\n * Iteratively calls walk with given path until it returns null, then we return the last non-null node.\n * @param node\n * @param path\n */\nfunction traverse(node: SyntaxNode, path: Path): SyntaxNode | null {\n  let current: SyntaxNode | null = node;\n  let next = walk(current, path);\n  while (next) {\n    let nextTmp = walk(next, path);\n    if (nextTmp) {\n      next = nextTmp;\n    } else {\n      return next;\n    }\n  }\n  return null;\n}\n\n/**\n * Walks a single step from the provided node, following the path.\n * @param node\n * @param path\n */\nfunction walk(node: SyntaxNode, path: Path): SyntaxNode | null {\n  let current: SyntaxNode | null = node;\n  for (const [direction, expectedNode] of path) {\n    current = move(current, direction);\n    if (current === null) {\n      // we could not move in the direction, we stop\n      return null;\n    }\n    if (current.type.id !== expectedNode) {\n      // the reached node has wrong type, we stop\n      return null;\n    }\n  }\n  return current;\n}\n\nfunction getNodeText(node: SyntaxNode, text: string): string {\n  return text.slice(node.from, node.to);\n}\n\nfunction parseStringLiteral(text: string): string {\n  // If it is a string-literal, it is inside quotes of some kind\n  const inside = text.slice(1, text.length - 1);\n\n  // Very simple un-escaping:\n\n  // Double quotes\n  if (text.startsWith('\"') && text.endsWith('\"')) {\n    // NOTE: this is not 100% perfect, we only unescape the double-quote,\n    // there might be other characters too\n    return inside.replace(/\\\\\"/gm, '\"');\n  }\n\n  // Single quotes\n  if (text.startsWith(\"'\") && text.endsWith(\"'\")) {\n    // NOTE: this is not 100% perfect, we only unescape the single-quote,\n    // there might be other characters too\n    return inside.replace(/\\\\'/gm, \"'\");\n  }\n\n  // Backticks\n  if (text.startsWith('`') && text.endsWith('`')) {\n    return inside;\n  }\n\n  throw new Error(`Invalid string literal: ${text}`);\n}\n\nexport type LabelOperator = '=' | '!=' | '=~' | '!~';\n\nexport type Label = {\n  name: string;\n  value: string;\n  op: LabelOperator;\n};\n\nexport type Situation =\n  | {\n      type: 'EMPTY';\n    }\n  | {\n      type: 'AT_ROOT';\n    }\n  | {\n      type: 'IN_LOGFMT';\n      otherLabels: string[];\n      flags: boolean;\n      trailingSpace: boolean;\n      trailingComma: boolean;\n      logQuery: string;\n    }\n  | {\n      type: 'IN_RANGE';\n    }\n  | {\n      type: 'IN_AGGREGATION';\n    }\n  | {\n      type: 'IN_GROUPING';\n      logQuery: string;\n    }\n  | {\n      type: 'IN_LABEL_SELECTOR_NO_LABEL_NAME';\n      otherLabels: Label[];\n    }\n  | {\n      type: 'IN_LABEL_SELECTOR_WITH_LABEL_NAME';\n      labelName: string;\n      betweenQuotes: boolean;\n      otherLabels: Label[];\n    }\n  | {\n      type: 'AFTER_SELECTOR';\n      afterPipe: boolean;\n      hasSpace: boolean;\n      logQuery: string;\n    }\n  | {\n      type: 'AFTER_UNWRAP';\n      logQuery: string;\n    }\n  | {\n      type: 'AFTER_KEEP_AND_DROP';\n      logQuery: string;\n    };\n\ntype Resolver = {\n  paths: NodeType[][];\n  fun: (node: SyntaxNode, text: string, pos: number) => Situation | null;\n};\n\nfunction isPathMatch(resolverPath: NodeType[], cursorPath: number[]): boolean {\n  return resolverPath.every((item, index) => item === cursorPath[index]);\n}\n\nconst ERROR_NODE_ID = 0;\n\nconst RESOLVERS: Resolver[] = [\n  {\n    paths: [[Selector], [Selector, Matchers], [Matchers], [ERROR_NODE_ID, Matchers, Selector]],\n    fun: resolveSelector,\n  },\n  {\n    paths: [\n      [LogQL],\n      [RangeAggregationExpr],\n      [ERROR_NODE_ID, LogRangeExpr, RangeAggregationExpr],\n      [ERROR_NODE_ID, LabelExtractionExpressionList],\n      [LogRangeExpr],\n      [ERROR_NODE_ID, LabelExtractionExpressionList],\n      [LabelExtractionExpressionList],\n      [LogfmtExpressionParser],\n    ],\n    fun: resolveLogfmtParser,\n  },\n  {\n    paths: [[LogQL], [ERROR_NODE_ID, Selector]],\n    fun: resolveTopLevel,\n  },\n  {\n    paths: [[String, Matcher]],\n    fun: resolveMatcher,\n  },\n  {\n    paths: [[Grouping]],\n    fun: resolveLabelsForGrouping,\n  },\n  {\n    paths: [[LogRangeExpr]],\n    fun: resolveLogRange,\n  },\n  {\n    paths: [\n      [ERROR_NODE_ID, Matcher],\n      [ERROR_NODE_ID, Matchers, Selector],\n    ],\n    fun: resolveMatcher,\n  },\n  {\n    paths: [[ERROR_NODE_ID, Range]],\n    fun: resolveDurations,\n  },\n  {\n    paths: [[ERROR_NODE_ID, LogRangeExpr]],\n    fun: resolveLogRangeFromError,\n  },\n  {\n    paths: [[ERROR_NODE_ID, LiteralExpr, MetricExpr, VectorAggregationExpr]],\n    fun: () => ({ type: 'IN_AGGREGATION' }),\n  },\n  {\n    paths: [\n      [ERROR_NODE_ID, PipelineStage, PipelineExpr],\n      [PipelineStage, PipelineExpr],\n    ],\n    fun: resolvePipeError,\n  },\n  {\n    paths: [[ERROR_NODE_ID, UnwrapExpr], [UnwrapExpr]],\n    fun: resolveAfterUnwrap,\n  },\n  {\n    paths: [\n      [ERROR_NODE_ID, DropLabelsExpr],\n      [ERROR_NODE_ID, DropLabels],\n      [ERROR_NODE_ID, KeepLabelsExpr],\n      [ERROR_NODE_ID, KeepLabels],\n    ],\n    fun: resolveAfterKeepAndDrop,\n  },\n];\n\nconst LABEL_OP_MAP = new Map<string, LabelOperator>([\n  ['Eq', '='],\n  ['Re', '=~'],\n  ['Neq', '!='],\n  ['Nre', '!~'],\n]);\n\nfunction getLabelOp(opNode: SyntaxNode): LabelOperator | null {\n  return LABEL_OP_MAP.get(opNode.name) ?? null;\n}\n\nfunction getLabel(matcherNode: SyntaxNode, text: string): Label | null {\n  if (matcherNode.type.id !== Matcher) {\n    return null;\n  }\n\n  const nameNode = walk(matcherNode, [['firstChild', Identifier]]);\n\n  if (nameNode === null) {\n    return null;\n  }\n\n  const opNode = nameNode.nextSibling;\n  if (opNode === null) {\n    return null;\n  }\n\n  const op = getLabelOp(opNode);\n  if (op === null) {\n    return null;\n  }\n\n  const valueNode = walk(matcherNode, [['lastChild', String]]);\n\n  if (valueNode === null) {\n    return null;\n  }\n\n  const name = getNodeText(nameNode, text);\n  const value = parseStringLiteral(getNodeText(valueNode, text));\n\n  return { name, value, op };\n}\n\nfunction getLabels(selectorNode: SyntaxNode, text: string): Label[] {\n  if (selectorNode.type.id !== Selector && selectorNode.type.id !== Matchers) {\n    return [];\n  }\n\n  let listNode: SyntaxNode | null = null;\n\n  // If parent node is selector, we want to start with the current Matcher node\n  if (selectorNode?.parent?.type.id === Selector) {\n    listNode = selectorNode;\n  } else {\n    // Parent node needs to be returned first because otherwise both of the other walks will return a non-null node and this function will return the labels on the left side of the current node, the other two walks should be mutually exclusive when the parent is null\n    listNode =\n      // Node in-between labels\n      traverse(selectorNode, [['parent', Matchers]]) ??\n      // Node after all other labels\n      walk(selectorNode, [['firstChild', Matchers]]) ??\n      // Node before all other labels\n      walk(selectorNode, [['lastChild', Matchers]]);\n  }\n\n  const labels: Label[] = [];\n\n  while (listNode !== null) {\n    const matcherNode = walk(listNode, [['lastChild', Matcher]]);\n    if (matcherNode !== null) {\n      const label = getLabel(matcherNode, text);\n      if (label !== null) {\n        labels.push(label);\n      }\n    }\n\n    // there might be more labels\n    listNode = walk(listNode, [['firstChild', Matchers]]);\n  }\n\n  // our labels-list is last-first, so we reverse it\n  labels.reverse();\n\n  return labels;\n}\n\nfunction resolveAfterUnwrap(node: SyntaxNode, text: string, pos: number): Situation | null {\n  return {\n    type: 'AFTER_UNWRAP',\n    logQuery: getLogQueryFromMetricsQueryAtPosition(text, pos).trim(),\n  };\n}\n\nfunction resolvePipeError(node: SyntaxNode, text: string, pos: number): Situation | null {\n  /**\n   * Examples:\n   * - {level=\"info\"} |^\n   * - count_over_time({level=\"info\"} |^ [4m])\n   */\n  let exprNode: SyntaxNode | null = null;\n  if (node.type.id === ERROR_NODE_ID) {\n    exprNode = walk(node, [\n      ['parent', PipelineStage],\n      ['parent', PipelineExpr],\n    ]);\n  } else if (node.type.id === PipelineStage) {\n    exprNode = walk(node, [['parent', PipelineExpr]]);\n  }\n\n  if (exprNode?.parent?.type.id === LogExpr || exprNode?.parent?.type.id === LogRangeExpr) {\n    return resolveLogOrLogRange(exprNode.parent, text, pos, true);\n  }\n\n  return null;\n}\n\nfunction resolveLabelsForGrouping(node: SyntaxNode, text: string, pos: number): Situation | null {\n  const aggrExpNode = walk(node, [['parent', VectorAggregationExpr]]);\n  if (aggrExpNode === null) {\n    return null;\n  }\n  const bodyNode = aggrExpNode.getChild('MetricExpr');\n  if (bodyNode === null) {\n    return null;\n  }\n\n  const selectorNode = walk(bodyNode, [\n    ['firstChild', RangeAggregationExpr],\n    ['lastChild', LogRangeExpr],\n    ['firstChild', Selector],\n  ]);\n\n  if (selectorNode === null) {\n    return null;\n  }\n\n  return {\n    type: 'IN_GROUPING',\n    logQuery: getLogQueryFromMetricsQueryAtPosition(text, pos).trim(),\n  };\n}\n\nfunction resolveMatcher(node: SyntaxNode, text: string, pos: number): Situation | null {\n  // we can arrive here for two reasons. `node` is either:\n  // - a StringNode (like in `{job=\"^\"}`)\n  // - or an error node (like in `{job=^}`)\n  const inStringNode = !node.type.isError;\n\n  const parent = walk(node, [['parent', Matcher]]);\n  if (parent === null) {\n    return null;\n  }\n\n  const labelNameNode = walk(parent, [['firstChild', Identifier]]);\n  if (labelNameNode === null) {\n    return null;\n  }\n\n  const labelName = getNodeText(labelNameNode, text);\n\n  // now we need to go up, to the parent of Matcher,\n  // there can be one or many `Matchers` parents, we have\n  // to go through all of them\n\n  const firstListNode = walk(parent, [['parent', Matchers]]);\n  if (firstListNode === null) {\n    return null;\n  }\n\n  let listNode = firstListNode;\n\n  // we keep going through the parent-nodes as long as they are Matchers.\n  // as soon as we reach Selector, we stop\n  let selectorNode: SyntaxNode | null = null;\n  while (selectorNode === null) {\n    const parent = listNode.parent;\n    if (parent === null) {\n      return null;\n    }\n\n    switch (parent.type.id) {\n      case Matchers:\n        //we keep looping\n        listNode = parent;\n        continue;\n      case Selector:\n        // we reached the end, we can stop the loop\n        selectorNode = parent;\n        continue;\n      default:\n        // we reached some other node, we stop\n        return null;\n    }\n  }\n\n  // now we need to find the other names\n  const allLabels = getLabels(selectorNode, text);\n\n  // we need to remove \"our\" label from all-labels, if it is in there\n  const otherLabels = allLabels.filter((label) => label.name !== labelName);\n\n  return {\n    type: 'IN_LABEL_SELECTOR_WITH_LABEL_NAME',\n    labelName,\n    betweenQuotes: inStringNode,\n    otherLabels,\n  };\n}\n\nfunction resolveLogfmtParser(_: SyntaxNode, text: string, cursorPosition: number): Situation | null {\n  // We want to know if the cursor if after a log query with logfmt parser.\n  // E.g. `{x=\"y\"} | logfmt ^`\n  /**\n   * Wait until the user adds a space to be sure of what the last identifier is. Otherwise\n   * it creates suggestion bugs with queries like {label=\"value\"} | parser^ suggest \"parser\"\n   * and it can be inserted with extra pipes or commas.\n   */\n  const tree = parser.parse(text);\n\n  // Adjust the cursor position if there are spaces at the end of the text.\n  const trimRightTextLen = text.substring(0, cursorPosition).trimEnd().length;\n  const position = trimRightTextLen < cursorPosition ? trimRightTextLen : cursorPosition;\n\n  const cursor = tree.cursorAt(position);\n\n  // Check if the user cursor is in any node that requires logfmt suggestions.\n  const expectedNodes = [Logfmt, ParserFlag, LabelExtractionExpression, LabelExtractionExpressionList];\n  let inLogfmt = false;\n  do {\n    const { node } = cursor;\n    if (!expectedNodes.includes(node.type.id)) {\n      continue;\n    }\n    if (cursor.from <= position && cursor.to >= position) {\n      inLogfmt = true;\n      break;\n    }\n  } while (cursor.next());\n\n  if (!inLogfmt) {\n    return null;\n  }\n\n  const flags = getNodesFromQuery(text, [ParserFlag]).length > 1;\n  const labelNodes = getNodesFromQuery(text, [LabelExtractionExpression]);\n  const otherLabels = labelNodes\n    .map((label: SyntaxNode) => label.getChild(Identifier))\n    .filter((label: SyntaxNode | null): label is SyntaxNode => label !== null)\n    .map((label: SyntaxNode) => getNodeText(label, text));\n\n  const logQuery = getLogQueryFromMetricsQueryAtPosition(text, position).trim();\n  const trailingSpace = text.charAt(cursorPosition - 1) === ' ';\n  const trailingComma = text.trimEnd().charAt(position - 1) === ',';\n\n  return {\n    type: 'IN_LOGFMT',\n    otherLabels,\n    flags,\n    trailingSpace,\n    trailingComma,\n    logQuery,\n  };\n}\n\nfunction resolveTopLevel(node: SyntaxNode, text: string, pos: number): Situation | null {\n  /**\n   * The following queries trigger resolveTopLevel().\n   * - Empty query\n   * - {label=\"value\"} ^\n   * - {label=\"value\"} | parser ^\n   * From here, we need to determine if the user is in a resolveLogOrLogRange() or simply at the root.\n   */\n  const logExprNode = walk(node, [\n    ['lastChild', Expr],\n    ['lastChild', LogExpr],\n  ]);\n\n  /**\n   * Wait until the user adds a space to be sure of what the last identifier is. Otherwise\n   * it creates suggestion bugs with queries like {label=\"value\"} | parser^ suggest \"parser\"\n   * and it can be inserted with extra pipes.\n   */\n  if (logExprNode != null && text.endsWith(' ')) {\n    return resolveLogOrLogRange(logExprNode, text, pos, false);\n  }\n\n  // `s` situation, with the cursor at the end.\n  // (basically, user enters a non-special characters as first\n  // character in query field)\n  const idNode = walk(node, [\n    ['firstChild', ERROR_NODE_ID],\n    ['firstChild', Identifier],\n  ]);\n\n  if (idNode != null) {\n    return {\n      type: 'AT_ROOT',\n    };\n  }\n\n  // no patterns match\n  return null;\n}\n\nfunction resolveDurations(node: SyntaxNode, text: string, pos: number): Situation {\n  return {\n    type: 'IN_RANGE',\n  };\n}\n\nfunction resolveLogRange(node: SyntaxNode, text: string, pos: number): Situation | null {\n  const partialQuery = text.substring(0, pos).trimEnd();\n  const afterPipe = partialQuery.endsWith('|');\n\n  return resolveLogOrLogRange(node, text, pos, afterPipe);\n}\n\nfunction resolveLogRangeFromError(node: SyntaxNode, text: string, pos: number): Situation | null {\n  const parent = walk(node, [['parent', LogRangeExpr]]);\n  if (parent === null) {\n    return null;\n  }\n\n  const partialQuery = text.substring(0, pos).trimEnd();\n  const afterPipe = partialQuery.endsWith('|');\n\n  return resolveLogOrLogRange(parent, text, pos, afterPipe);\n}\n\nfunction resolveLogOrLogRange(node: SyntaxNode, text: string, pos: number, afterPipe: boolean): Situation | null {\n  // Here the `node` is either a LogExpr or a LogRangeExpr\n  // We want to handle the case where we are next to a selector\n  const selectorNode = walk(node, [['firstChild', Selector]]);\n\n  // Check that the selector is before the cursor, not after it\n  if (!selectorNode || selectorNode.to > pos) {\n    return null;\n  }\n\n  return {\n    type: 'AFTER_SELECTOR',\n    afterPipe,\n    hasSpace: text.charAt(pos - 1) === ' ',\n    logQuery: getLogQueryFromMetricsQueryAtPosition(text, pos).trim(),\n  };\n}\n\nfunction resolveSelector(node: SyntaxNode, text: string, pos: number): Situation | null {\n  // for example `{^}`\n\n  // false positive:\n  // `{a=\"1\"^}`\n  const child = walk(node, [['firstChild', Matchers]]);\n  if (child !== null) {\n    // means the label-matching part contains at least one label already.\n    //\n    // in this case, we will need to have a `,` character at the end,\n    // to be able to suggest adding the next label.\n    // the area between the end-of-the-child-node and the cursor-pos\n    // must contain a `,` in this case.\n    const textToCheck = text.slice(child.from, pos);\n    if (!textToCheck.trim().endsWith(',')) {\n      return null;\n    }\n  }\n\n  const selectorNode =\n    node.type.id === ERROR_NODE_ID\n      ? walk(node, [\n          ['parent', Matchers],\n          ['parent', Selector],\n        ])\n      : node;\n  if (!selectorNode) {\n    return null;\n  }\n\n  const otherLabels = getLabels(selectorNode, text);\n\n  return {\n    type: 'IN_LABEL_SELECTOR_NO_LABEL_NAME',\n    otherLabels,\n  };\n}\n\nfunction resolveAfterKeepAndDrop(node: SyntaxNode, text: string, pos: number): Situation | null {\n  let logQuery = getLogQueryFromMetricsQueryAtPosition(text, pos).trim();\n  let keepAndDropParent: SyntaxNode | null = null;\n  let parent = node.parent;\n  while (parent !== null) {\n    if (parent.type.id === PipelineStage) {\n      keepAndDropParent = parent;\n      break;\n    }\n    parent = parent.parent;\n  }\n\n  if (keepAndDropParent?.type.id === PipelineStage) {\n    logQuery = logQuery.slice(0, keepAndDropParent.from);\n  }\n\n  return {\n    type: 'AFTER_KEEP_AND_DROP',\n    logQuery,\n  };\n}\n\n// If there is an error in the current cursor position, it's likely that the user is\n// in the middle of writing a query. If we can't find an error node, we use the node\n// at the cursor position to identify the situation.\nfunction resolveCursor(text: string, cursorPos: number): TreeCursor {\n  // Sometimes the cursor is a couple spaces after the end of the expression.\n  // To account for this situation, we \"move\" the cursor position back to the real end\n  // of the expression.\n  const trimRightTextLen = text.trimEnd().length;\n  const pos = trimRightTextLen < cursorPos ? trimRightTextLen : cursorPos;\n\n  const tree = parser.parse(text);\n  const cursor = tree.cursorAt(pos);\n\n  do {\n    if (cursor.from === pos && cursor.to === pos && cursor.node.type.isError) {\n      return cursor;\n    }\n  } while (cursor.next());\n\n  return tree.cursorAt(pos);\n}\n\nexport function getSituation(text: string, pos: number): Situation | null {\n  // there is a special case when we are at the start of writing text,\n  // so we handle that case first\n\n  if (text === '') {\n    return {\n      type: 'EMPTY',\n    };\n  }\n\n  const cursor = resolveCursor(text, pos);\n  const currentNode = cursor.node;\n\n  const ids = [cursor.type.id];\n  while (cursor.parent()) {\n    ids.push(cursor.type.id);\n  }\n\n  for (let resolver of RESOLVERS) {\n    for (let path of resolver.paths) {\n      if (isPathMatch(path, ids)) {\n        const situation = resolver.fun(currentNode, text, pos);\n        if (situation) {\n          return situation;\n        }\n      }\n    }\n  }\n\n  return null;\n}\n","import type { Monaco, monacoTypes } from '@grafana/ui';\n\nimport { CompletionDataProvider } from './CompletionDataProvider';\nimport { NeverCaseError } from './NeverCaseError';\nimport { CompletionType, getCompletions } from './completions';\nimport { getSituation, Situation } from './situation';\n\n// from: monacoTypes.languages.CompletionItemInsertTextRule.InsertAsSnippet\nconst INSERT_AS_SNIPPET_ENUM_VALUE = 4;\n\nexport function getSuggestOptions(): monacoTypes.editor.ISuggestOptions {\n  return {\n    // monaco-editor sometimes provides suggestions automatically, i am not\n    // sure based on what, seems to be by analyzing the words already\n    // written.\n    // to try it out:\n    // - enter `go_goroutines{job~`\n    // - have the cursor at the end of the string\n    // - press ctrl-enter\n    // - you will get two suggestions\n    // those were not provided by grafana, they are offered automatically.\n    // i want to remove those. the only way i found is:\n    // - every suggestion-item has a `kind` attribute,\n    //   that controls the icon to the left of the suggestion.\n    // - items auto-generated by monaco have `kind` set to `text`.\n    // - we make sure grafana-provided suggestions do not have `kind` set to `text`.\n    // - and then we tell monaco not to show suggestions of kind `text`\n    showWords: false,\n  };\n}\n\nfunction getMonacoCompletionItemKind(type: CompletionType, monaco: Monaco): monacoTypes.languages.CompletionItemKind {\n  switch (type) {\n    case 'DURATION':\n      return monaco.languages.CompletionItemKind.Unit;\n    case 'FUNCTION':\n      return monaco.languages.CompletionItemKind.Variable;\n    case 'HISTORY':\n      return monaco.languages.CompletionItemKind.Snippet;\n    case 'LABEL_NAME':\n      return monaco.languages.CompletionItemKind.Enum;\n    case 'LABEL_VALUE':\n      return monaco.languages.CompletionItemKind.EnumMember;\n    case 'PATTERN':\n      return monaco.languages.CompletionItemKind.Constructor;\n    case 'PARSER':\n      return monaco.languages.CompletionItemKind.Class;\n    case 'LINE_FILTER':\n      return monaco.languages.CompletionItemKind.TypeParameter;\n    case 'PIPE_OPERATION':\n      return monaco.languages.CompletionItemKind.Interface;\n    default:\n      throw new NeverCaseError(type);\n  }\n}\n\nexport function getCompletionProvider(\n  monaco: Monaco,\n  dataProvider: CompletionDataProvider\n): monacoTypes.languages.CompletionItemProvider {\n  const provideCompletionItems = (\n    model: monacoTypes.editor.ITextModel,\n    position: monacoTypes.Position\n  ): monacoTypes.languages.ProviderResult<monacoTypes.languages.CompletionList> => {\n    const word = model.getWordAtPosition(position);\n    const wordUntil = model.getWordUntilPosition(position);\n\n    // documentation says `position` will be \"adjusted\" in `getOffsetAt`\n    // i don't know what that means, to be sure i clone it\n    const positionClone = {\n      column: position.column,\n      lineNumber: position.lineNumber,\n    };\n    const offset = model.getOffsetAt(positionClone);\n    const situation = getSituation(model.getValue(), offset);\n    const range = calculateRange(situation, word, wordUntil, monaco, position);\n    const completionsPromise = situation != null ? getCompletions(situation, dataProvider) : Promise.resolve([]);\n    return completionsPromise.then((items) => {\n      // monaco by default alphabetically orders the items.\n      // to stop it, we use a number-as-string sortkey,\n      // so that monaco keeps the order we use\n      const maxIndexDigits = items.length.toString().length;\n      const suggestions: monacoTypes.languages.CompletionItem[] = items.map((item, index) => ({\n        kind: getMonacoCompletionItemKind(item.type, monaco),\n        label: item.label,\n        insertText: item.insertText,\n        insertTextRules: item.isSnippet ? INSERT_AS_SNIPPET_ENUM_VALUE : undefined,\n        detail: item.detail,\n        documentation: item.documentation,\n        sortText: index.toString().padStart(maxIndexDigits, '0'), // to force the order we have\n        range: range,\n        command: item.triggerOnInsert\n          ? {\n              id: 'editor.action.triggerSuggest',\n              title: '',\n            }\n          : undefined,\n      }));\n      return { suggestions };\n    });\n  };\n\n  return {\n    triggerCharacters: ['{', ',', '[', '(', '=', '~', ' ', '\"', '|'],\n    provideCompletionItems,\n  };\n}\n\nexport const calculateRange = (\n  situation: Situation | null,\n  word: monacoTypes.editor.IWordAtPosition | null,\n  wordUntil: monacoTypes.editor.IWordAtPosition,\n  monaco: Monaco,\n  position: monacoTypes.Position\n): monacoTypes.Range => {\n  if (\n    situation &&\n    situation?.type === 'IN_LABEL_SELECTOR_WITH_LABEL_NAME' &&\n    'betweenQuotes' in situation &&\n    situation.betweenQuotes\n  ) {\n    // Word until won't have second quote if they are between quotes\n    const indexOfFirstQuote = wordUntil?.word?.indexOf('\"') ?? 0;\n\n    const indexOfLastQuote = word?.word?.lastIndexOf('\"') ?? 0;\n\n    const indexOfEquals = word?.word.indexOf('=');\n    const indexOfLastEquals = word?.word.lastIndexOf('=');\n\n    // Just one equals \"=\" the cursor is somewhere within a label value\n    // e.g. value=\"labe^l-value\" or value=\"^label-value\" etc\n    // We want the word to include everything within the quotes, so the result from autocomplete overwrites the existing label value\n    if (\n      indexOfLastEquals === indexOfEquals &&\n      indexOfFirstQuote !== -1 &&\n      indexOfLastQuote !== -1 &&\n      indexOfLastEquals !== -1\n    ) {\n      return word != null\n        ? monaco.Range.lift({\n            startLineNumber: position.lineNumber,\n            endLineNumber: position.lineNumber,\n            startColumn: wordUntil.startColumn + indexOfFirstQuote + 1,\n            endColumn: wordUntil.startColumn + indexOfLastQuote,\n          })\n        : monaco.Range.fromPositions(position);\n    }\n  }\n\n  if (situation && situation.type === 'IN_LABEL_SELECTOR_WITH_LABEL_NAME') {\n    // Otherwise we want the range to be calculated as the cursor position, as we want to insert the autocomplete, instead of overwriting existing text\n    // The cursor position is the length of the wordUntil\n    return word != null\n      ? monaco.Range.lift({\n          startLineNumber: position.lineNumber,\n          endLineNumber: position.lineNumber,\n          startColumn: wordUntil.endColumn,\n          endColumn: wordUntil.endColumn,\n        })\n      : monaco.Range.fromPositions(position);\n  }\n\n  // And for all other non-label cases, we want to use the word start and end column\n  return word != null\n    ? monaco.Range.lift({\n        startLineNumber: position.lineNumber,\n        endLineNumber: position.lineNumber,\n        startColumn: word.startColumn,\n        endColumn: word.endColumn,\n      })\n    : monaco.Range.fromPositions(position);\n};\n","import { css } from '@emotion/css';\nimport { debounce } from 'lodash';\nimport { useRef, useEffect } from 'react';\nimport { useLatest } from 'react-use';\nimport { v4 as uuidv4 } from 'uuid';\n\nimport { GrafanaTheme2 } from '@grafana/data';\nimport { selectors } from '@grafana/e2e-selectors';\nimport { parser } from '@grafana/lezer-logql';\nimport { languageConfiguration, monarchlanguage } from '@grafana/monaco-logql';\nimport { useTheme2, ReactMonacoEditor, Monaco, monacoTypes, MonacoEditor } from '@grafana/ui';\n\nimport { Props } from './MonacoQueryFieldProps';\nimport { getOverrideServices } from './getOverrideServices';\nimport { CompletionDataProvider } from './monaco-completion-provider/CompletionDataProvider';\nimport { getCompletionProvider, getSuggestOptions } from './monaco-completion-provider/completionUtils';\nimport { placeHolderScopedVars, validateQuery } from './monaco-completion-provider/validation';\n\nconst options: monacoTypes.editor.IStandaloneEditorConstructionOptions = {\n  codeLens: false,\n  contextmenu: false,\n  // we need `fixedOverflowWidgets` because otherwise in grafana-dashboards\n  // the popup is clipped by the panel-visualizations.\n  fixedOverflowWidgets: true,\n  folding: false,\n  fontSize: 14,\n  lineDecorationsWidth: 8, // used as \"padding-left\"\n  lineNumbers: 'off',\n  minimap: { enabled: false },\n  overviewRulerBorder: false,\n  overviewRulerLanes: 0,\n  padding: {\n    // these numbers were picked so that visually this matches the previous version\n    // of the query-editor the best\n    top: 4,\n    bottom: 5,\n  },\n  renderLineHighlight: 'none',\n  scrollbar: {\n    vertical: 'hidden',\n    verticalScrollbarSize: 8, // used as \"padding-right\"\n    horizontal: 'hidden',\n    horizontalScrollbarSize: 0,\n    alwaysConsumeMouseWheel: false,\n  },\n  scrollBeyondLastLine: false,\n  suggest: getSuggestOptions(),\n  suggestFontSize: 12,\n  wordWrap: 'on',\n};\n\n// this number was chosen by testing various values. it might be necessary\n// because of the width of the border, not sure.\n//it needs to do 2 things:\n// 1. when the editor is single-line, it should make the editor height be visually correct\n// 2. when the editor is multi-line, the editor should not be \"scrollable\" (meaning,\n//    you do a scroll-movement in the editor, and it will scroll the content by a couple pixels\n//    up & down. this we want to avoid)\nconst EDITOR_HEIGHT_OFFSET = 2;\n\nconst LANG_ID = 'logql';\n\n// we must only run the lang-setup code once\nlet LANGUAGE_SETUP_STARTED = false;\n\nexport const defaultWordPattern = /(-?\\d*\\.\\d\\w*)|([^`~!#%^&*()\\-=+\\[{\\]}\\\\|;:'\",.<>\\/?\\s]+)/g;\n\nfunction ensureLogQL(monaco: Monaco) {\n  if (LANGUAGE_SETUP_STARTED === false) {\n    LANGUAGE_SETUP_STARTED = true;\n    monaco.languages.register({ id: LANG_ID });\n\n    monaco.languages.setMonarchTokensProvider(LANG_ID, monarchlanguage);\n    monaco.languages.setLanguageConfiguration(LANG_ID, {\n      ...languageConfiguration,\n      wordPattern: /(-?\\d*\\.\\d\\w*)|([^`~!#%^&*()+\\[{\\]}\\\\|;:',.<>\\/?\\s]+)/g,\n      // Default:  /(-?\\d*\\.\\d\\w*)|([^`~!#%^&*()\\-=+\\[{\\]}\\\\|;:'\",.<>\\/?\\s]+)/g\n      // Removed `\"`, `=`, and `-`, from the exclusion list, so now the completion provider can decide to overwrite any matching words, or just insert text at the cursor\n    });\n  }\n}\n\nconst getStyles = (theme: GrafanaTheme2, placeholder: string) => {\n  return {\n    container: css`\n      border-radius: ${theme.shape.radius.default};\n      border: 1px solid ${theme.components.input.borderColor};\n      width: 100%;\n      .monaco-editor .suggest-widget {\n        min-width: 50%;\n      }\n    `,\n    placeholder: css`\n      ::after {\n        content: '${placeholder}';\n        font-family: ${theme.typography.fontFamilyMonospace};\n        opacity: 0.3;\n      }\n    `,\n  };\n};\n\nconst MonacoQueryField = ({\n  history,\n  onBlur,\n  onRunQuery,\n  initialValue,\n  datasource,\n  placeholder,\n  onChange,\n  timeRange,\n}: Props) => {\n  const id = uuidv4();\n  // we need only one instance of `overrideServices` during the lifetime of the react component\n  const overrideServicesRef = useRef(getOverrideServices());\n  const containerRef = useRef<HTMLDivElement>(null);\n\n  const langProviderRef = useLatest(datasource.languageProvider);\n  const historyRef = useLatest(history);\n  const onRunQueryRef = useLatest(onRunQuery);\n  const onBlurRef = useLatest(onBlur);\n  const completionDataProviderRef = useRef<CompletionDataProvider | null>(null);\n\n  const autocompleteCleanupCallback = useRef<(() => void) | null>(null);\n\n  const theme = useTheme2();\n  const styles = getStyles(theme, placeholder);\n\n  useEffect(() => {\n    // when we unmount, we unregister the autocomplete-function, if it was registered\n    return () => {\n      autocompleteCleanupCallback.current?.();\n    };\n  }, []);\n\n  useEffect(() => {\n    if (completionDataProviderRef.current && timeRange) {\n      completionDataProviderRef.current.setTimeRange(timeRange);\n    }\n  }, [timeRange]);\n\n  const setPlaceholder = (monaco: Monaco, editor: MonacoEditor) => {\n    const placeholderDecorators = [\n      {\n        range: new monaco.Range(1, 1, 1, 1),\n        options: {\n          className: styles.placeholder,\n          isWholeLine: true,\n        },\n      },\n    ];\n\n    let decorators: string[] = [];\n\n    const checkDecorators: () => void = () => {\n      const model = editor.getModel();\n\n      if (!model) {\n        return;\n      }\n\n      const newDecorators = model.getValueLength() === 0 ? placeholderDecorators : [];\n      decorators = model.deltaDecorations(decorators, newDecorators);\n    };\n\n    checkDecorators();\n    editor.onDidChangeModelContent(checkDecorators);\n  };\n\n  const onTypeDebounced = debounce(async (query: string) => {\n    onChange(query);\n  }, 1000);\n\n  return (\n    <div\n      data-testid={selectors.components.QueryField.container}\n      className={styles.container}\n      // NOTE: we will be setting inline-style-width/height on this element\n      ref={containerRef}\n    >\n      <ReactMonacoEditor\n        overrideServices={overrideServicesRef.current}\n        options={options}\n        language={LANG_ID}\n        value={initialValue}\n        beforeMount={(monaco) => {\n          ensureLogQL(monaco);\n        }}\n        onMount={(editor, monaco) => {\n          // Monaco has a bug where it runs actions on all instances (https://github.com/microsoft/monaco-editor/issues/2947), so we ensure actions are executed on instance-level with this ContextKey.\n          const isEditorFocused = editor.createContextKey<boolean>('isEditorFocused' + id, false);\n          // we setup on-blur\n          editor.onDidBlurEditorWidget(() => {\n            isEditorFocused.set(false);\n            onBlurRef.current(editor.getValue());\n          });\n          editor.onDidChangeModelContent((e) => {\n            const model = editor.getModel();\n            if (!model) {\n              return;\n            }\n            const query = model.getValue();\n            const errors =\n              validateQuery(\n                query,\n                datasource.interpolateString(query, placeHolderScopedVars),\n                model.getLinesContent(),\n                parser\n              ) || [];\n\n            const markers = errors.map(({ error, ...boundary }) => ({\n              message: `${\n                error ? `Error parsing \"${error}\"` : 'Parse error'\n              }. The query appears to be incorrect and could fail to be executed.`,\n              severity: monaco.MarkerSeverity.Error,\n              ...boundary,\n            }));\n\n            onTypeDebounced(query);\n            monaco.editor.setModelMarkers(model, 'owner', markers);\n          });\n          const dataProvider = new CompletionDataProvider(langProviderRef.current, historyRef, timeRange);\n          completionDataProviderRef.current = dataProvider;\n          const completionProvider = getCompletionProvider(monaco, dataProvider);\n\n          // completion-providers in monaco are not registered directly to editor-instances,\n          // they are registered to languages. this makes it hard for us to have\n          // separate completion-providers for every query-field-instance\n          // (but we need that, because they might connect to different datasources).\n          // the trick we do is, we wrap the callback in a \"proxy\",\n          // and in the proxy, the first thing is, we check if we are called from\n          // \"our editor instance\", and if not, we just return nothing. if yes,\n          // we call the completion-provider.\n          const filteringCompletionProvider: monacoTypes.languages.CompletionItemProvider = {\n            ...completionProvider,\n            provideCompletionItems: (model, position, context, token) => {\n              // if the model-id does not match, then this call is from a different editor-instance,\n              // not \"our instance\", so return nothing\n              if (editor.getModel()?.id !== model.id) {\n                return { suggestions: [] };\n              }\n              return completionProvider.provideCompletionItems(model, position, context, token);\n            },\n          };\n\n          const { dispose } = monaco.languages.registerCompletionItemProvider(LANG_ID, filteringCompletionProvider);\n\n          autocompleteCleanupCallback.current = dispose;\n          // this code makes the editor resize itself so that the content fits\n          // (it will grow taller when necessary)\n          // FIXME: maybe move this functionality into CodeEditor, like:\n          // <CodeEditor resizingMode=\"single-line\"/>\n          const handleResize = () => {\n            const containerDiv = containerRef.current;\n            if (containerDiv !== null) {\n              const pixelHeight = editor.getContentHeight();\n              containerDiv.style.height = `${pixelHeight + EDITOR_HEIGHT_OFFSET}px`;\n              const pixelWidth = containerDiv.clientWidth;\n              editor.layout({ width: pixelWidth, height: pixelHeight });\n            }\n          };\n\n          editor.onDidContentSizeChange(handleResize);\n          handleResize();\n          // handle: shift + enter\n          // FIXME: maybe move this functionality into CodeEditor?\n          editor.addCommand(\n            monaco.KeyMod.Shift | monaco.KeyCode.Enter,\n            () => {\n              onRunQueryRef.current(editor.getValue());\n            },\n            'isEditorFocused' + id\n          );\n\n          // Fixes Monaco capturing the search key binding and displaying a useless search box within the Editor.\n          // See https://github.com/grafana/grafana/issues/85850\n          monaco.editor.addKeybindingRule({\n            keybinding: monaco.KeyMod.CtrlCmd | monaco.KeyCode.KeyF,\n            command: null,\n          });\n\n          editor.onDidFocusEditorText(() => {\n            isEditorFocused.set(true);\n            if (editor.getValue().trim() === '') {\n              editor.trigger('', 'editor.action.triggerSuggest', {});\n            }\n          });\n\n          setPlaceholder(monaco, editor);\n        }}\n      />\n    </div>\n  );\n};\n\n// Default export for lazy load.\nexport default MonacoQueryField;\n"],"names":["exports","aggregations","parsers","format_expressions","vector_aggregations","vector_matching","vectorMatchingRegex","prev","curr","operators","keywords","makeStorageService","strings","data","key","scope","fallbackValue","val","value","target","reason","overrideServices","getOverrideServices","CompletionDataProvider","languageProvider","historyRef","timeRange","labels","label","history","otherLabels","possibleLabelNames","usedLabelNames","l","labelName","logQuery","cachedLabelKeys","firstKey","labelKeys","NeverCaseError","LOG_COMPLETIONS","AGGREGATION_COMPLETIONS","f","FUNCTION_COMPLETIONS","BUILT_IN_FUNCTIONS_COMPLETIONS","DURATION_COMPLETIONS","text","UNWRAP_FUNCTION_COMPLETIONS","LOGFMT_ARGUMENT_COMPLETIONS","LINE_FILTER_COMPLETIONS","getLineFilterCompletions","afterPipe","completion","operator","documentation","getPipeOperationsCompletions","prefix","completions","getAllHistoryCompletions","dataProvider","expr","getLabelNamesForSelectorCompletions","getInGroupingCompletions","extractedLabelKeys","PARSERS","getParserCompletions","hasJSON","hasLogfmt","hasPack","hasParserInQuery","allParsers","hasLevelInExtractedLabels","extra","parser","getAfterSelectorCompletions","hasSpace","query","structuredMetadataKeys","hasQueryParser","parserCompletions","pipeOperations","getLogfmtCompletions","flags","trailingComma","trailingSpace","labelPrefix","labelCompletions","getLabelValuesForMetricCompletions","betweenQuotes","getAfterUnwrapCompletions","unwrapLabelKeys","getAfterKeepAndDropCompletions","getCompletions","situation","move","node","direction","traverse","path","next","walk","nextTmp","current","expectedNode","getNodeText","parseStringLiteral","inside","isPathMatch","resolverPath","cursorPath","item","index","ERROR_NODE_ID","RESOLVERS","resolveSelector","resolveLogfmtParser","resolveTopLevel","resolveMatcher","resolveLabelsForGrouping","resolveLogRange","resolveDurations","resolveLogRangeFromError","resolvePipeError","resolveAfterUnwrap","resolveAfterKeepAndDrop","LABEL_OP_MAP","getLabelOp","opNode","getLabel","matcherNode","nameNode","op","valueNode","name","getLabels","selectorNode","listNode","pos","exprNode","resolveLogOrLogRange","aggrExpNode","bodyNode","inStringNode","parent","labelNameNode","firstListNode","_","cursorPosition","tree","trimRightTextLen","position","cursor","expectedNodes","inLogfmt","logExprNode","child","keepAndDropParent","resolveCursor","cursorPos","getSituation","currentNode","ids","resolver","INSERT_AS_SNIPPET_ENUM_VALUE","getSuggestOptions","getMonacoCompletionItemKind","type","monaco","getCompletionProvider","model","word","wordUntil","positionClone","offset","range","calculateRange","items","maxIndexDigits","indexOfFirstQuote","indexOfLastQuote","indexOfEquals","indexOfLastEquals","options","EDITOR_HEIGHT_OFFSET","LANG_ID","LANGUAGE_SETUP_STARTED","defaultWordPattern","ensureLogQL","getStyles","theme","placeholder","onBlur","onRunQuery","initialValue","datasource","onChange","id","overrideServicesRef","containerRef","langProviderRef","useLatest","onRunQueryRef","onBlurRef","completionDataProviderRef","autocompleteCleanupCallback","styles","setPlaceholder","editor","placeholderDecorators","decorators","checkDecorators","newDecorators","onTypeDebounced","selectors","isEditorFocused","e","markers","error","boundary","completionProvider","filteringCompletionProvider","context","token","dispose","handleResize","containerDiv","pixelHeight","pixelWidth"],"sourceRoot":""}