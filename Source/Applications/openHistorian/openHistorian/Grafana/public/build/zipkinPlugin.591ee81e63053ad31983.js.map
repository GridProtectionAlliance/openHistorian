{"version":3,"sources":["webpack:///./public/app/plugins/datasource/zipkin/utils/transforms.ts","webpack:///./public/app/plugins/datasource/zipkin/datasource.ts","webpack:///./public/app/plugins/datasource/zipkin/constants.ts","webpack:///./node_modules/react-use/esm/useMount.js","webpack:///./public/app/plugins/datasource/zipkin/QueryField.tsx","webpack:///./public/app/plugins/datasource/zipkin/module.ts","webpack:///./public/app/plugins/datasource/zipkin/ConfigEditor.tsx","webpack:///./node_modules/react-use/esm/useEffectOnce.js"],"names":["transformSpan","span","jaegerSpan","duration","flags","logs","annotations","map","transformAnnotation","operationName","name","processID","localEndpoint","serviceName","remoteEndpoint","startTime","timestamp","spanID","id","traceID","traceId","warnings","tags","Object","keys","key","type","value","references","parentId","refType","kind","annotation","fields","gatherProcesses","zSpans","processes","reduce","acc","push","endpointToProcess","keyBy","endpoint","valueToTag","ipv4","ipv6","port","filter","identity","ZipkinDatasource","instanceSettings","options","targets","query","this","request","encodeURIComponent","pipe","responseToDataQueryResponse","of","emptyDataQueryResponse","url","params","hideFromInspector","toPromise","res","data","metadataRequest","apiUrl","baseUrl","serializeParams","req","length","from","getBackendSrv","datasourceRequest","DataSourceApi","response","MutableDataFrame","FieldType","trace","values","spans","meta","preferredVisualisationType","fn","useEffectOnce","noTracesFoundOptions","label","isLeaf","noTracesOptions","plugin","DataSourcePlugin","setConfigEditor","onOptionsChange","defaultUrl","dataSourceConfig","showAccessOptions","onChange","setExploreQueryField","onRunQuery","datasource","serviceOptions","useAsyncFn","services","sort","service","appEvents","emit","AppEvents","alertError","servicesOptions","fetch","useMount","useServices","isMounted","useMountedState","useState","allOptions","setAllOptions","fetchSpans","state","spanOptions","fromPairs","undefined","fetchTraces","spanName","search","traces","newTraces","rootSpan","find","Math","floor","onLoadOptions","useCallback","selectedOptions","useLoadOptions","onSelectTrace","cascaderOptions","useMemo","children","traceName","useMapToCascaderOptions","className","loadData","style","width","e","currentTarget","effect"],"mappings":"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","file":"zipkinPlugin.591ee81e63053ad31983.js","sourcesContent":["import { identity } from 'lodash';\nimport { keyBy } from 'lodash';\nimport { ZipkinAnnotation, ZipkinEndpoint, ZipkinSpan } from '../types';\nimport { TraceKeyValuePair, TraceLog, TraceProcess, TraceSpanData, TraceData } from '@grafana/data';\n\n/**\n * Transforms response to format similar to Jaegers as we use Jaeger ui on the frontend.\n */\nexport function transformResponse(zSpans: ZipkinSpan[]): TraceData & { spans: TraceSpanData[] } {\n  return {\n    processes: gatherProcesses(zSpans),\n    traceID: zSpans[0].traceId,\n    spans: zSpans.map(transformSpan),\n    warnings: null,\n  };\n}\n\nfunction transformSpan(span: ZipkinSpan): TraceSpanData {\n  const jaegerSpan: TraceSpanData = {\n    duration: span.duration,\n    // TODO: not sure what this is\n    flags: 1,\n    logs: span.annotations?.map(transformAnnotation) ?? [],\n    operationName: span.name,\n    processID: span.localEndpoint?.serviceName || span.remoteEndpoint?.serviceName || 'unknown',\n    startTime: span.timestamp,\n    spanID: span.id,\n    traceID: span.traceId,\n    warnings: null as any,\n    tags: Object.keys(span.tags || {}).map(key => {\n      // If tag is error we remap it to simple boolean so that the Jaeger ui will show an error icon.\n      return {\n        key,\n        type: key === 'error' ? 'bool' : 'string',\n        value: key === 'error' ? true : span.tags![key],\n      };\n    }),\n    references: span.parentId\n      ? [\n          {\n            refType: 'CHILD_OF',\n            spanID: span.parentId,\n            traceID: span.traceId,\n          },\n        ]\n      : [],\n  };\n  if (span.kind) {\n    jaegerSpan.tags = [\n      {\n        key: 'kind',\n        type: 'string',\n        value: span.kind,\n      },\n      ...jaegerSpan.tags,\n    ];\n  }\n\n  return jaegerSpan;\n}\n\n/**\n * Maps annotations as a Jaeger log as that seems to be the closest thing.\n * See https://zipkin.io/zipkin-api/#/default/get_trace__traceId_\n */\nfunction transformAnnotation(annotation: ZipkinAnnotation): TraceLog {\n  return {\n    timestamp: annotation.timestamp,\n    fields: [\n      {\n        key: 'annotation',\n        type: 'string',\n        value: annotation.value,\n      },\n    ],\n  };\n}\n\nfunction gatherProcesses(zSpans: ZipkinSpan[]): Record<string, TraceProcess> {\n  const processes = zSpans.reduce((acc, span) => {\n    if (span.localEndpoint) {\n      acc.push(endpointToProcess(span.localEndpoint));\n    }\n    if (span.remoteEndpoint) {\n      acc.push(endpointToProcess(span.remoteEndpoint));\n    }\n    return acc;\n  }, [] as TraceProcess[]);\n  return keyBy(processes, 'serviceName');\n}\n\nfunction endpointToProcess(endpoint: ZipkinEndpoint): TraceProcess {\n  return {\n    serviceName: endpoint.serviceName,\n    tags: [\n      valueToTag('ipv4', endpoint.ipv4, 'string'),\n      valueToTag('ipv6', endpoint.ipv6, 'string'),\n      valueToTag('port', endpoint.port, 'number'),\n    ].filter(identity) as TraceKeyValuePair[],\n  };\n}\n\nfunction valueToTag(key: string, value: string | number | undefined, type: string): TraceKeyValuePair | undefined {\n  if (!value) {\n    return undefined;\n  }\n  return {\n    key,\n    type,\n    value,\n  };\n}\n","import {\n  MutableDataFrame,\n  DataSourceApi,\n  DataSourceInstanceSettings,\n  DataQueryRequest,\n  DataQueryResponse,\n  DataQuery,\n  FieldType,\n} from '@grafana/data';\nimport { from, Observable, of } from 'rxjs';\nimport { serializeParams } from '../../../core/utils/fetch';\nimport { getBackendSrv, BackendSrvRequest } from '@grafana/runtime';\nimport { map } from 'rxjs/operators';\nimport { apiPrefix } from './constants';\nimport { ZipkinSpan } from './types';\nimport { transformResponse } from './utils/transforms';\n\nexport interface ZipkinQuery extends DataQuery {\n  query: string;\n}\n\nexport class ZipkinDatasource extends DataSourceApi<ZipkinQuery> {\n  constructor(private instanceSettings: DataSourceInstanceSettings) {\n    super(instanceSettings);\n  }\n\n  query(options: DataQueryRequest<ZipkinQuery>): Observable<DataQueryResponse> {\n    const traceId = options.targets[0]?.query;\n    if (traceId) {\n      return this.request<ZipkinSpan[]>(`${apiPrefix}/trace/${encodeURIComponent(traceId)}`).pipe(\n        map(responseToDataQueryResponse)\n      );\n    } else {\n      return of(emptyDataQueryResponse);\n    }\n  }\n\n  async metadataRequest(url: string, params?: Record<string, any>): Promise<any> {\n    const res = await this.request(url, params, { hideFromInspector: true }).toPromise();\n    return res.data;\n  }\n\n  async testDatasource(): Promise<any> {\n    await this.metadataRequest(`${apiPrefix}/services`);\n    return true;\n  }\n\n  getQueryDisplayText(query: ZipkinQuery) {\n    return query.query;\n  }\n\n  private request<T = any>(apiUrl: string, data?: any, options?: Partial<BackendSrvRequest>): Observable<{ data: T }> {\n    // Hack for proxying metadata requests\n    const baseUrl = `/api/datasources/proxy/${this.instanceSettings.id}`;\n    const params = data ? serializeParams(data) : '';\n    const url = `${baseUrl}${apiUrl}${params.length ? `?${params}` : ''}`;\n    const req = {\n      ...options,\n      url,\n    };\n\n    return from(getBackendSrv().datasourceRequest(req));\n  }\n}\n\nfunction responseToDataQueryResponse(response: { data: ZipkinSpan[] }): DataQueryResponse {\n  return {\n    data: [\n      new MutableDataFrame({\n        fields: [\n          {\n            name: 'trace',\n            type: FieldType.trace,\n            // There is probably better mapping than just putting everything in as a single value but that's how\n            // we do it with jaeger and is the simplest right now.\n            values: response?.data ? [transformResponse(response?.data)] : [],\n          },\n        ],\n        meta: {\n          preferredVisualisationType: 'trace',\n        },\n      }),\n    ],\n  };\n}\n\nconst emptyDataQueryResponse = {\n  data: [\n    new MutableDataFrame({\n      fields: [\n        {\n          name: 'trace',\n          type: FieldType.trace,\n          values: [],\n        },\n      ],\n      meta: {\n        preferredVisualisationType: 'trace',\n      },\n    }),\n  ],\n};\n","export const apiPrefix = '/api/v2';\n","import useEffectOnce from './useEffectOnce';\nvar useMount = function (fn) {\n    useEffectOnce(function () {\n        fn();\n    });\n};\nexport default useMount;\n","import React, { useCallback, useMemo, useState } from 'react';\nimport { ZipkinDatasource, ZipkinQuery } from './datasource';\nimport { AppEvents, ExploreQueryFieldProps } from '@grafana/data';\nimport { ButtonCascader, CascaderOption } from '@grafana/ui';\nimport { useAsyncFn, useMount, useMountedState } from 'react-use';\nimport { appEvents } from '../../../core/core';\nimport { apiPrefix } from './constants';\nimport { ZipkinSpan } from './types';\nimport { fromPairs } from 'lodash';\nimport { AsyncState } from 'react-use/lib/useAsyncFn';\n\ntype Props = ExploreQueryFieldProps<ZipkinDatasource, ZipkinQuery>;\n\nexport const QueryField = ({ query, onChange, onRunQuery, datasource }: Props) => {\n  const serviceOptions = useServices(datasource);\n  const { onLoadOptions, allOptions } = useLoadOptions(datasource);\n\n  const onSelectTrace = useCallback(\n    (values: string[], selectedOptions: CascaderOption[]) => {\n      if (selectedOptions.length === 3) {\n        const traceID = selectedOptions[2].value;\n        onChange({ ...query, query: traceID });\n        onRunQuery();\n      }\n    },\n    [onChange, onRunQuery, query]\n  );\n\n  let cascaderOptions = useMapToCascaderOptions(serviceOptions, allOptions);\n\n  return (\n    <>\n      <div className=\"gf-form-inline gf-form-inline--nowrap\">\n        <div className=\"gf-form flex-shrink-0\">\n          <ButtonCascader options={cascaderOptions} onChange={onSelectTrace} loadData={onLoadOptions}>\n            Traces\n          </ButtonCascader>\n        </div>\n        <div className=\"gf-form gf-form--grow flex-shrink-1\">\n          <div className={'slate-query-field__wrapper'}>\n            <div className=\"slate-query-field\">\n              <input\n                style={{ width: '100%' }}\n                value={query.query || ''}\n                onChange={e =>\n                  onChange({\n                    ...query,\n                    query: e.currentTarget.value,\n                  })\n                }\n              />\n            </div>\n          </div>\n        </div>\n      </div>\n    </>\n  );\n};\n\n// Exported for tests\nexport function useServices(datasource: ZipkinDatasource): AsyncState<CascaderOption[]> {\n  const url = `${apiPrefix}/services`;\n\n  const [servicesOptions, fetch] = useAsyncFn(async (): Promise<CascaderOption[]> => {\n    try {\n      const services: string[] | null = await datasource.metadataRequest(url);\n      if (services) {\n        return services.sort().map(service => ({\n          label: service,\n          value: service,\n          isLeaf: false,\n        }));\n      }\n      return [];\n    } catch (error) {\n      appEvents.emit(AppEvents.alertError, ['Failed to load services from Zipkin', error]);\n      throw error;\n    }\n  }, [datasource]);\n\n  useMount(() => {\n    // We should probably call this periodically to get new services after mount.\n    fetch();\n  });\n\n  return servicesOptions;\n}\n\ntype OptionsState = {\n  [serviceName: string]: {\n    [spanName: string]: {\n      [traceId: string]: string;\n    };\n  };\n};\n\n// Exported for tests\nexport function useLoadOptions(datasource: ZipkinDatasource) {\n  const isMounted = useMountedState();\n  const [allOptions, setAllOptions] = useState({} as OptionsState);\n\n  const [, fetchSpans] = useAsyncFn(\n    async function findSpans(service: string): Promise<void> {\n      const url = `${apiPrefix}/spans`;\n      try {\n        // The response of this should have been full ZipkinSpan objects based on API docs but is just list\n        // of span names.\n        // TODO: check if this is some issue of version used or something else\n        const response: string[] = await datasource.metadataRequest(url, { serviceName: service });\n        if (isMounted()) {\n          setAllOptions(state => {\n            const spanOptions = fromPairs(response.map((span: string) => [span, undefined]));\n            return {\n              ...state,\n              [service]: spanOptions as any,\n            };\n          });\n        }\n      } catch (error) {\n        appEvents.emit(AppEvents.alertError, ['Failed to load spans from Zipkin', error]);\n        throw error;\n      }\n    },\n    [datasource, allOptions]\n  );\n\n  const [, fetchTraces] = useAsyncFn(\n    async function findTraces(serviceName: string, spanName: string): Promise<void> {\n      const url = `${apiPrefix}/traces`;\n      const search = {\n        serviceName,\n        spanName,\n        // See other params and default here https://zipkin.io/zipkin-api/#/default/get_traces\n      };\n      try {\n        // This should return just root traces as there isn't any nesting\n        const traces: ZipkinSpan[][] = await datasource.metadataRequest(url, search);\n        if (isMounted()) {\n          const newTraces = traces.length\n            ? fromPairs(\n                traces.map(trace => {\n                  const rootSpan = trace.find(span => !span.parentId)!;\n\n                  return [`${rootSpan.name} [${Math.floor(rootSpan.duration / 1000)} ms]`, rootSpan.traceId];\n                })\n              )\n            : noTracesOptions;\n\n          setAllOptions(state => {\n            const spans = state[serviceName];\n            return {\n              ...state,\n              [serviceName]: {\n                ...spans,\n                [spanName]: newTraces,\n              },\n            };\n          });\n        }\n      } catch (error) {\n        appEvents.emit(AppEvents.alertError, ['Failed to load spans from Zipkin', error]);\n        throw error;\n      }\n    },\n    [datasource]\n  );\n\n  const onLoadOptions = useCallback(\n    (selectedOptions: CascaderOption[]) => {\n      const service = selectedOptions[0].value;\n      if (selectedOptions.length === 1) {\n        fetchSpans(service);\n      } else if (selectedOptions.length === 2) {\n        const spanName = selectedOptions[1].value;\n        fetchTraces(service, spanName);\n      }\n    },\n    [fetchSpans, fetchTraces]\n  );\n\n  return {\n    onLoadOptions,\n    allOptions,\n  };\n}\n\nfunction useMapToCascaderOptions(services: AsyncState<CascaderOption[]>, allOptions: OptionsState) {\n  return useMemo(() => {\n    let cascaderOptions: CascaderOption[] = [];\n\n    if (services.value && services.value.length) {\n      cascaderOptions = services.value.map(services => {\n        return {\n          ...services,\n          children:\n            allOptions[services.value] &&\n            Object.keys(allOptions[services.value]).map(spanName => {\n              return {\n                label: spanName,\n                value: spanName,\n                isLeaf: false,\n                children:\n                  allOptions[services.value][spanName] &&\n                  Object.keys(allOptions[services.value][spanName]).map(traceName => {\n                    return {\n                      label: traceName,\n                      value: allOptions[services.value][spanName][traceName],\n                    };\n                  }),\n              };\n            }),\n        };\n      });\n    } else if (services.value && !services.value.length) {\n      cascaderOptions = noTracesFoundOptions;\n    }\n\n    return cascaderOptions;\n  }, [services, allOptions]);\n}\n\nconst NO_TRACES_KEY = '__NO_TRACES__';\nconst noTracesFoundOptions = [\n  {\n    label: 'No traces found',\n    value: 'no_traces',\n    isLeaf: true,\n\n    // Cannot be disabled because then cascader shows 'loading' for some reason.\n    // disabled: true,\n  },\n];\n\nconst noTracesOptions = {\n  '[No traces in time range]': NO_TRACES_KEY,\n};\n","import { DataSourcePlugin } from '@grafana/data';\nimport { ZipkinDatasource } from './datasource';\nimport { QueryField } from './QueryField';\nimport { ConfigEditor } from './ConfigEditor';\n\nexport const plugin = new DataSourcePlugin(ZipkinDatasource)\n  .setConfigEditor(ConfigEditor)\n  .setExploreQueryField(QueryField);\n","import React from 'react';\nimport { DataSourcePluginOptionsEditorProps } from '@grafana/data';\nimport { DataSourceHttpSettings } from '@grafana/ui';\n\nexport type Props = DataSourcePluginOptionsEditorProps;\n\nexport const ConfigEditor: React.FC<Props> = ({ options, onOptionsChange }) => {\n  return (\n    <DataSourceHttpSettings\n      defaultUrl={'http://localhost:9411'}\n      dataSourceConfig={options}\n      showAccessOptions={true}\n      onChange={onOptionsChange}\n    />\n  );\n};\n","import { useEffect } from 'react';\nvar useEffectOnce = function (effect) {\n    useEffect(effect, []);\n};\nexport default useEffectOnce;\n"],"sourceRoot":""}