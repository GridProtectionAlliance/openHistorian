{"version":3,"sources":["webpack:///./public/app/plugins/datasource/opentsdb/datasource.ts","webpack:///./public/app/plugins/datasource/opentsdb/query_ctrl.ts","webpack:///./public/app/plugins/datasource/opentsdb/config_ctrl.ts","webpack:///./public/app/plugins/datasource/opentsdb/module.ts"],"names":["OpenTsDatasource","instanceSettings","$q","backendSrv","templateSrv","this","type","url","name","withCredentials","basicAuth","jsonData","tsdbVersion","tsdbResolution","tagKeys","aggregatorsPromise","filterTypesPromise","$inject","prototype","query","options","_this","start","convertToTSDBTime","rangeRaw","from","timezone","end","to","qs","a","each","targets","target","metric","push","convertTargetToQuery","queries","lodash_default","compact","isEmpty","d","defer","resolve","data","promise","groupByTags","filters","length","val","tagk","tags","key","filter","hide","performTimeSeriesQuery","then","response","metricToTargetMapping","mapMetricsToTargets","map","metricData","index","_saveTagKeys","transformMetricData","annotationQuery","eventList","aggregator","annotation","results","annotationObject","annotations","isGlobal","globalAnnotations","event","text","description","time","Math","floor","startTime","targetContainsTemplate","i","variableExists","Object","keys","tagKey","msResolution","reqBody","showQuery","method","_addCredentialOptions","datasourceRequest","suggestTagKeys","when","aggregateTags","tag","_performSuggestQuery","_get","q","max","result","_performMetricKeyValueLookup","keysArray","split","trim","keysQuery","splice","join","m","limit","tagvs","r","indexOf","_performMetricKeyLookup","tagks","tagv","relativeUrl","params","headers","Authorization","metricFindQuery","interpolated","replace","err","reject","responseTransform","value","metricsQuery","match","tagNamesQuery","tagValuesQuery","tagNamesSuggestQuery","tagValuesSuggestQuery","testDatasource","status","message","getAggregators","isArray","sort","getFilterTypes","md","metricLabel","createMetricLabel","dps","v","k","datapoints","alias","scopedVars_1","clone","scopedVars","label","tagData","toPairs","has","shouldComputeRate","rate","rateOptions","counter","isCounter","counterMax","parseInt","counterResetValue","resetValue","dropResets","ResetValue","disableDownsampling","interval","downsampleInterval","parseFloat","downsample","downsampleAggregator","downsampleFillPolicy","angular_default","copy","filterKey","explicitTags","metrics","interpolatedTagValue","arrTagV","findIndex","every","tagV","tagK","includes","date","roundUp","src","parse","valueOf","query_ctrl_OpenTsQueryCtrl","_super","OpenTsQueryCtrl","$scope","$injector","call","errors","validateTarget","aggregators","fillPolicies","filterTypes","datasource","aggs","callback","getTextValues","tslib_es6","targetBlur","refresh","metricFindResult","addTag","addTagMode","currentTagKey","currentTagValue","removeTag","editTag","closeAddTagMode","addFilter","size","addFilterMode","currentFilterType","currentFilterGroupBy","currentFilter","currentFilterKey","currentFilterValue","groupBy","removeFilter","editFilter","fil","closeAddFilterMode","errs","shouldDownsample","describe_interval","templateUrl","OpenTsConfigCtrl","tsdbVersions","tsdbResolutions","current","__webpack_require__","__webpack_exports__","AnnotationsQueryCtrl"],"mappings":"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","file":"opentsdbPlugin.3932bda029d2299a9d96.js","sourcesContent":["import angular, { IQService } from 'angular';\nimport _ from 'lodash';\nimport { dateMath } from '@grafana/data';\nimport { BackendSrv } from 'app/core/services/backend_srv';\nimport { TemplateSrv } from 'app/features/templating/template_srv';\nimport { DataQueryRequest } from '@grafana/ui';\n\nexport default class OpenTsDatasource {\n  type: any;\n  url: any;\n  name: any;\n  withCredentials: any;\n  basicAuth: any;\n  tsdbVersion: any;\n  tsdbResolution: any;\n  tagKeys: any;\n\n  aggregatorsPromise: any;\n  filterTypesPromise: any;\n\n  /** @ngInject */\n  constructor(\n    instanceSettings: any,\n    private $q: IQService,\n    private backendSrv: BackendSrv,\n    private templateSrv: TemplateSrv\n  ) {\n    this.type = 'opentsdb';\n    this.url = instanceSettings.url;\n    this.name = instanceSettings.name;\n    this.withCredentials = instanceSettings.withCredentials;\n    this.basicAuth = instanceSettings.basicAuth;\n    instanceSettings.jsonData = instanceSettings.jsonData || {};\n    this.tsdbVersion = instanceSettings.jsonData.tsdbVersion || 1;\n    this.tsdbResolution = instanceSettings.jsonData.tsdbResolution || 1;\n    this.tagKeys = {};\n\n    this.aggregatorsPromise = null;\n    this.filterTypesPromise = null;\n  }\n\n  // Called once per panel (graph)\n  query(options: DataQueryRequest) {\n    const start = this.convertToTSDBTime(options.rangeRaw.from, false, options.timezone);\n    const end = this.convertToTSDBTime(options.rangeRaw.to, true, options.timezone);\n    const qs: any[] = [];\n\n    _.each(options.targets, target => {\n      if (!target.metric) {\n        return;\n      }\n      qs.push(this.convertTargetToQuery(target, options, this.tsdbVersion));\n    });\n\n    const queries = _.compact(qs);\n\n    // No valid targets, return the empty result to save a round trip.\n    if (_.isEmpty(queries)) {\n      const d = this.$q.defer();\n      d.resolve({ data: [] });\n      return d.promise;\n    }\n\n    const groupByTags: any = {};\n    _.each(queries, query => {\n      if (query.filters && query.filters.length > 0) {\n        _.each(query.filters, val => {\n          groupByTags[val.tagk] = true;\n        });\n      } else {\n        _.each(query.tags, (val, key) => {\n          groupByTags[key] = true;\n        });\n      }\n    });\n\n    options.targets = _.filter(options.targets, query => {\n      return query.hide !== true;\n    });\n\n    return this.performTimeSeriesQuery(queries, start, end).then((response: any) => {\n      const metricToTargetMapping = this.mapMetricsToTargets(response.data, options, this.tsdbVersion);\n      const result = _.map(response.data, (metricData: any, index: number) => {\n        index = metricToTargetMapping[index];\n        if (index === -1) {\n          index = 0;\n        }\n        this._saveTagKeys(metricData);\n\n        return this.transformMetricData(metricData, groupByTags, options.targets[index], options, this.tsdbResolution);\n      });\n      return { data: result };\n    });\n  }\n\n  annotationQuery(options: any) {\n    const start = this.convertToTSDBTime(options.rangeRaw.from, false, options.timezone);\n    const end = this.convertToTSDBTime(options.rangeRaw.to, true, options.timezone);\n    const qs = [];\n    const eventList: any[] = [];\n\n    qs.push({ aggregator: 'sum', metric: options.annotation.target });\n\n    const queries = _.compact(qs);\n\n    return this.performTimeSeriesQuery(queries, start, end).then((results: any) => {\n      if (results.data[0]) {\n        let annotationObject = results.data[0].annotations;\n        if (options.annotation.isGlobal) {\n          annotationObject = results.data[0].globalAnnotations;\n        }\n        if (annotationObject) {\n          _.each(annotationObject, annotation => {\n            const event = {\n              text: annotation.description,\n              time: Math.floor(annotation.startTime) * 1000,\n              annotation: options.annotation,\n            };\n\n            eventList.push(event);\n          });\n        }\n      }\n      return eventList;\n    });\n  }\n\n  targetContainsTemplate(target: any) {\n    if (target.filters && target.filters.length > 0) {\n      for (let i = 0; i < target.filters.length; i++) {\n        if (this.templateSrv.variableExists(target.filters[i].filter)) {\n          return true;\n        }\n      }\n    }\n\n    if (target.tags && Object.keys(target.tags).length > 0) {\n      for (const tagKey in target.tags) {\n        if (this.templateSrv.variableExists(target.tags[tagKey])) {\n          return true;\n        }\n      }\n    }\n\n    return false;\n  }\n\n  performTimeSeriesQuery(queries: any[], start: any, end: any) {\n    let msResolution = false;\n    if (this.tsdbResolution === 2) {\n      msResolution = true;\n    }\n    const reqBody: any = {\n      start: start,\n      queries: queries,\n      msResolution: msResolution,\n      globalAnnotations: true,\n    };\n    if (this.tsdbVersion === 3) {\n      reqBody.showQuery = true;\n    }\n\n    // Relative queries (e.g. last hour) don't include an end time\n    if (end) {\n      reqBody.end = end;\n    }\n\n    const options = {\n      method: 'POST',\n      url: this.url + '/api/query',\n      data: reqBody,\n    };\n\n    this._addCredentialOptions(options);\n    return this.backendSrv.datasourceRequest(options);\n  }\n\n  suggestTagKeys(metric: string | number) {\n    return this.$q.when(this.tagKeys[metric] || []);\n  }\n\n  _saveTagKeys(metricData: { tags: {}; aggregateTags: any; metric: string | number }) {\n    const tagKeys = Object.keys(metricData.tags);\n    _.each(metricData.aggregateTags, tag => {\n      tagKeys.push(tag);\n    });\n\n    this.tagKeys[metricData.metric] = tagKeys;\n  }\n\n  _performSuggestQuery(query: string, type: string) {\n    return this._get('/api/suggest', { type, q: query, max: 1000 }).then((result: any) => {\n      return result.data;\n    });\n  }\n\n  _performMetricKeyValueLookup(metric: string, keys: any) {\n    if (!metric || !keys) {\n      return this.$q.when([]);\n    }\n\n    const keysArray = keys.split(',').map((key: any) => {\n      return key.trim();\n    });\n    const key = keysArray[0];\n    let keysQuery = key + '=*';\n\n    if (keysArray.length > 1) {\n      keysQuery += ',' + keysArray.splice(1).join(',');\n    }\n\n    const m = metric + '{' + keysQuery + '}';\n\n    return this._get('/api/search/lookup', { m: m, limit: 3000 }).then((result: any) => {\n      result = result.data.results;\n      const tagvs: any[] = [];\n      _.each(result, r => {\n        if (tagvs.indexOf(r.tags[key]) === -1) {\n          tagvs.push(r.tags[key]);\n        }\n      });\n      return tagvs;\n    });\n  }\n\n  _performMetricKeyLookup(metric: any) {\n    if (!metric) {\n      return this.$q.when([]);\n    }\n\n    return this._get('/api/search/lookup', { m: metric, limit: 1000 }).then((result: any) => {\n      result = result.data.results;\n      const tagks: any[] = [];\n      _.each(result, r => {\n        _.each(r.tags, (tagv, tagk) => {\n          if (tagks.indexOf(tagk) === -1) {\n            tagks.push(tagk);\n          }\n        });\n      });\n      return tagks;\n    });\n  }\n\n  _get(relativeUrl: string, params?: { type?: string; q?: string; max?: number; m?: any; limit?: number }) {\n    const options = {\n      method: 'GET',\n      url: this.url + relativeUrl,\n      params: params,\n    };\n\n    this._addCredentialOptions(options);\n\n    return this.backendSrv.datasourceRequest(options);\n  }\n\n  _addCredentialOptions(options: any) {\n    if (this.basicAuth || this.withCredentials) {\n      options.withCredentials = true;\n    }\n    if (this.basicAuth) {\n      options.headers = { Authorization: this.basicAuth };\n    }\n  }\n\n  metricFindQuery(query: string) {\n    if (!query) {\n      return this.$q.when([]);\n    }\n\n    let interpolated;\n    try {\n      interpolated = this.templateSrv.replace(query, {}, 'distributed');\n    } catch (err) {\n      return this.$q.reject(err);\n    }\n\n    const responseTransform = (result: any) => {\n      return _.map(result, value => {\n        return { text: value };\n      });\n    };\n\n    const metricsRegex = /metrics\\((.*)\\)/;\n    const tagNamesRegex = /tag_names\\((.*)\\)/;\n    const tagValuesRegex = /tag_values\\((.*?),\\s?(.*)\\)/;\n    const tagNamesSuggestRegex = /suggest_tagk\\((.*)\\)/;\n    const tagValuesSuggestRegex = /suggest_tagv\\((.*)\\)/;\n\n    const metricsQuery = interpolated.match(metricsRegex);\n    if (metricsQuery) {\n      return this._performSuggestQuery(metricsQuery[1], 'metrics').then(responseTransform);\n    }\n\n    const tagNamesQuery = interpolated.match(tagNamesRegex);\n    if (tagNamesQuery) {\n      return this._performMetricKeyLookup(tagNamesQuery[1]).then(responseTransform);\n    }\n\n    const tagValuesQuery = interpolated.match(tagValuesRegex);\n    if (tagValuesQuery) {\n      return this._performMetricKeyValueLookup(tagValuesQuery[1], tagValuesQuery[2]).then(responseTransform);\n    }\n\n    const tagNamesSuggestQuery = interpolated.match(tagNamesSuggestRegex);\n    if (tagNamesSuggestQuery) {\n      return this._performSuggestQuery(tagNamesSuggestQuery[1], 'tagk').then(responseTransform);\n    }\n\n    const tagValuesSuggestQuery = interpolated.match(tagValuesSuggestRegex);\n    if (tagValuesSuggestQuery) {\n      return this._performSuggestQuery(tagValuesSuggestQuery[1], 'tagv').then(responseTransform);\n    }\n\n    return this.$q.when([]);\n  }\n\n  testDatasource() {\n    return this._performSuggestQuery('cpu', 'metrics').then(() => {\n      return { status: 'success', message: 'Data source is working' };\n    });\n  }\n\n  getAggregators() {\n    if (this.aggregatorsPromise) {\n      return this.aggregatorsPromise;\n    }\n\n    this.aggregatorsPromise = this._get('/api/aggregators').then((result: any) => {\n      if (result.data && _.isArray(result.data)) {\n        return result.data.sort();\n      }\n      return [];\n    });\n    return this.aggregatorsPromise;\n  }\n\n  getFilterTypes() {\n    if (this.filterTypesPromise) {\n      return this.filterTypesPromise;\n    }\n\n    this.filterTypesPromise = this._get('/api/config/filters').then((result: any) => {\n      if (result.data) {\n        return Object.keys(result.data).sort();\n      }\n      return [];\n    });\n    return this.filterTypesPromise;\n  }\n\n  transformMetricData(md: { dps: any }, groupByTags: any, target: any, options: any, tsdbResolution: number) {\n    const metricLabel = this.createMetricLabel(md, target, groupByTags, options);\n    const dps: any[] = [];\n\n    // TSDB returns datapoints has a hash of ts => value.\n    // Can't use _.pairs(invert()) because it stringifies keys/values\n    _.each(md.dps, (v: any, k: number) => {\n      if (tsdbResolution === 2) {\n        dps.push([v, k * 1]);\n      } else {\n        dps.push([v, k * 1000]);\n      }\n    });\n\n    return { target: metricLabel, datapoints: dps };\n  }\n\n  createMetricLabel(\n    md: { dps?: any; tags?: any; metric?: any },\n    target: { alias: string },\n    groupByTags: any,\n    options: { scopedVars: any }\n  ) {\n    if (target.alias) {\n      const scopedVars = _.clone(options.scopedVars || {});\n      _.each(md.tags, (value, key) => {\n        scopedVars['tag_' + key] = { value: value };\n      });\n      return this.templateSrv.replace(target.alias, scopedVars);\n    }\n\n    let label = md.metric;\n    const tagData: any[] = [];\n\n    if (!_.isEmpty(md.tags)) {\n      _.each(_.toPairs(md.tags), tag => {\n        if (_.has(groupByTags, tag[0])) {\n          tagData.push(tag[0] + '=' + tag[1]);\n        }\n      });\n    }\n\n    if (!_.isEmpty(tagData)) {\n      label += '{' + tagData.join(', ') + '}';\n    }\n\n    return label;\n  }\n\n  convertTargetToQuery(target: any, options: any, tsdbVersion: number) {\n    if (!target.metric || target.hide) {\n      return null;\n    }\n\n    const query: any = {\n      metric: this.templateSrv.replace(target.metric, options.scopedVars, 'pipe'),\n      aggregator: 'avg',\n    };\n\n    if (target.aggregator) {\n      query.aggregator = this.templateSrv.replace(target.aggregator);\n    }\n\n    if (target.shouldComputeRate) {\n      query.rate = true;\n      query.rateOptions = {\n        counter: !!target.isCounter,\n      };\n\n      if (target.counterMax && target.counterMax.length) {\n        query.rateOptions.counterMax = parseInt(target.counterMax, 10);\n      }\n\n      if (target.counterResetValue && target.counterResetValue.length) {\n        query.rateOptions.resetValue = parseInt(target.counterResetValue, 10);\n      }\n\n      if (tsdbVersion >= 2) {\n        query.rateOptions.dropResets =\n          !query.rateOptions.counterMax && (!query.rateOptions.ResetValue || query.rateOptions.ResetValue === 0);\n      }\n    }\n\n    if (!target.disableDownsampling) {\n      let interval = this.templateSrv.replace(target.downsampleInterval || options.interval);\n\n      if (interval.match(/\\.[0-9]+s/)) {\n        interval = parseFloat(interval) * 1000 + 'ms';\n      }\n\n      query.downsample = interval + '-' + target.downsampleAggregator;\n\n      if (target.downsampleFillPolicy && target.downsampleFillPolicy !== 'none') {\n        query.downsample += '-' + target.downsampleFillPolicy;\n      }\n    }\n\n    if (target.filters && target.filters.length > 0) {\n      query.filters = angular.copy(target.filters);\n      if (query.filters) {\n        for (const filterKey in query.filters) {\n          query.filters[filterKey].filter = this.templateSrv.replace(\n            query.filters[filterKey].filter,\n            options.scopedVars,\n            'pipe'\n          );\n        }\n      }\n    } else {\n      query.tags = angular.copy(target.tags);\n      if (query.tags) {\n        for (const tagKey in query.tags) {\n          query.tags[tagKey] = this.templateSrv.replace(query.tags[tagKey], options.scopedVars, 'pipe');\n        }\n      }\n    }\n\n    if (target.explicitTags) {\n      query.explicitTags = true;\n    }\n\n    return query;\n  }\n\n  mapMetricsToTargets(metrics: any, options: any, tsdbVersion: number) {\n    let interpolatedTagValue, arrTagV;\n    return _.map(metrics, metricData => {\n      if (tsdbVersion === 3) {\n        return metricData.query.index;\n      } else {\n        return _.findIndex(options.targets as any[], target => {\n          if (target.filters && target.filters.length > 0) {\n            return target.metric === metricData.metric;\n          } else {\n            return (\n              target.metric === metricData.metric &&\n              _.every(target.tags, (tagV, tagK) => {\n                interpolatedTagValue = this.templateSrv.replace(tagV, options.scopedVars, 'pipe');\n                arrTagV = interpolatedTagValue.split('|');\n                return _.includes(arrTagV, metricData.tags[tagK]) || interpolatedTagValue === '*';\n              })\n            );\n          }\n        });\n      }\n    });\n  }\n\n  convertToTSDBTime(date: any, roundUp: any, timezone: any) {\n    if (date === 'now') {\n      return null;\n    }\n\n    date = dateMath.parse(date, roundUp, timezone);\n    return date.valueOf();\n  }\n}\n","import _ from 'lodash';\nimport kbn from 'app/core/utils/kbn';\nimport { QueryCtrl } from 'app/plugins/sdk';\nimport { auto } from 'angular';\n\nexport class OpenTsQueryCtrl extends QueryCtrl {\n  static templateUrl = 'partials/query.editor.html';\n  aggregators: any;\n  fillPolicies: any;\n  filterTypes: any;\n  tsdbVersion: any;\n  aggregator: any;\n  downsampleInterval: any;\n  downsampleAggregator: any;\n  downsampleFillPolicy: any;\n  errors: any;\n  suggestMetrics: any;\n  suggestTagKeys: any;\n  suggestTagValues: any;\n  addTagMode: boolean;\n  addFilterMode: boolean;\n\n  /** @ngInject */\n  constructor($scope: any, $injector: auto.IInjectorService) {\n    super($scope, $injector);\n\n    this.errors = this.validateTarget();\n    this.aggregators = ['avg', 'sum', 'min', 'max', 'dev', 'zimsum', 'mimmin', 'mimmax'];\n    this.fillPolicies = ['none', 'nan', 'null', 'zero'];\n    this.filterTypes = [\n      'wildcard',\n      'iliteral_or',\n      'not_iliteral_or',\n      'not_literal_or',\n      'iwildcard',\n      'literal_or',\n      'regexp',\n    ];\n\n    this.tsdbVersion = this.datasource.tsdbVersion;\n\n    if (!this.target.aggregator) {\n      this.target.aggregator = 'sum';\n    }\n\n    if (!this.target.downsampleAggregator) {\n      this.target.downsampleAggregator = 'avg';\n    }\n\n    if (!this.target.downsampleFillPolicy) {\n      this.target.downsampleFillPolicy = 'none';\n    }\n\n    this.datasource.getAggregators().then((aggs: { length: number }) => {\n      if (aggs.length !== 0) {\n        this.aggregators = aggs;\n      }\n    });\n\n    this.datasource.getFilterTypes().then((filterTypes: { length: number }) => {\n      if (filterTypes.length !== 0) {\n        this.filterTypes = filterTypes;\n      }\n    });\n\n    // needs to be defined here as it is called from typeahead\n    this.suggestMetrics = (query: string, callback: any) => {\n      this.datasource\n        .metricFindQuery('metrics(' + query + ')')\n        .then(this.getTextValues)\n        .then(callback);\n    };\n\n    this.suggestTagKeys = (query: any, callback: any) => {\n      this.datasource.suggestTagKeys(this.target.metric).then(callback);\n    };\n\n    this.suggestTagValues = (query: string, callback: any) => {\n      this.datasource\n        .metricFindQuery('suggest_tagv(' + query + ')')\n        .then(this.getTextValues)\n        .then(callback);\n    };\n  }\n\n  targetBlur() {\n    this.errors = this.validateTarget();\n    this.refresh();\n  }\n\n  getTextValues(metricFindResult: any) {\n    return _.map(metricFindResult, value => {\n      return value.text;\n    });\n  }\n\n  addTag() {\n    if (this.target.filters && this.target.filters.length > 0) {\n      this.errors.tags = 'Please remove filters to use tags, tags and filters are mutually exclusive.';\n    }\n\n    if (!this.addTagMode) {\n      this.addTagMode = true;\n      return;\n    }\n\n    if (!this.target.tags) {\n      this.target.tags = {};\n    }\n\n    this.errors = this.validateTarget();\n\n    if (!this.errors.tags) {\n      this.target.tags[this.target.currentTagKey] = this.target.currentTagValue;\n      this.target.currentTagKey = '';\n      this.target.currentTagValue = '';\n      this.targetBlur();\n    }\n\n    this.addTagMode = false;\n  }\n\n  removeTag(key: string | number) {\n    delete this.target.tags[key];\n    this.targetBlur();\n  }\n\n  editTag(key: string | number, value: any) {\n    this.removeTag(key);\n    this.target.currentTagKey = key;\n    this.target.currentTagValue = value;\n    this.addTag();\n  }\n\n  closeAddTagMode() {\n    this.addTagMode = false;\n    return;\n  }\n\n  addFilter() {\n    if (this.target.tags && _.size(this.target.tags) > 0) {\n      this.errors.filters = 'Please remove tags to use filters, tags and filters are mutually exclusive.';\n    }\n\n    if (!this.addFilterMode) {\n      this.addFilterMode = true;\n      return;\n    }\n\n    if (!this.target.filters) {\n      this.target.filters = [];\n    }\n\n    if (!this.target.currentFilterType) {\n      this.target.currentFilterType = 'iliteral_or';\n    }\n\n    if (!this.target.currentFilterGroupBy) {\n      this.target.currentFilterGroupBy = false;\n    }\n\n    this.errors = this.validateTarget();\n\n    if (!this.errors.filters) {\n      const currentFilter = {\n        type: this.target.currentFilterType,\n        tagk: this.target.currentFilterKey,\n        filter: this.target.currentFilterValue,\n        groupBy: this.target.currentFilterGroupBy,\n      };\n      this.target.filters.push(currentFilter);\n      this.target.currentFilterType = 'literal_or';\n      this.target.currentFilterKey = '';\n      this.target.currentFilterValue = '';\n      this.target.currentFilterGroupBy = false;\n      this.targetBlur();\n    }\n\n    this.addFilterMode = false;\n  }\n\n  removeFilter(index: number) {\n    this.target.filters.splice(index, 1);\n    this.targetBlur();\n  }\n\n  editFilter(fil: { tagk: any; filter: any; type: any; groupBy: any }, index: number) {\n    this.removeFilter(index);\n    this.target.currentFilterKey = fil.tagk;\n    this.target.currentFilterValue = fil.filter;\n    this.target.currentFilterType = fil.type;\n    this.target.currentFilterGroupBy = fil.groupBy;\n    this.addFilter();\n  }\n\n  closeAddFilterMode() {\n    this.addFilterMode = false;\n    return;\n  }\n\n  validateTarget() {\n    const errs: any = {};\n\n    if (this.target.shouldDownsample) {\n      try {\n        if (this.target.downsampleInterval) {\n          kbn.describe_interval(this.target.downsampleInterval);\n        } else {\n          errs.downsampleInterval = \"You must supply a downsample interval (e.g. '1m' or '1h').\";\n        }\n      } catch (err) {\n        errs.downsampleInterval = err.message;\n      }\n    }\n\n    if (this.target.tags && _.has(this.target.tags, this.target.currentTagKey)) {\n      errs.tags = \"Duplicate tag key '\" + this.target.currentTagKey + \"'.\";\n    }\n\n    return errs;\n  }\n}\n","export class OpenTsConfigCtrl {\n  static templateUrl = 'public/app/plugins/datasource/opentsdb/partials/config.html';\n  current: any;\n\n  /** @ngInject */\n  constructor($scope: any) {\n    this.current.jsonData = this.current.jsonData || {};\n    this.current.jsonData.tsdbVersion = this.current.jsonData.tsdbVersion || 1;\n    this.current.jsonData.tsdbResolution = this.current.jsonData.tsdbResolution || 1;\n  }\n\n  tsdbVersions = [{ name: '<=2.1', value: 1 }, { name: '==2.2', value: 2 }, { name: '==2.3', value: 3 }];\n\n  tsdbResolutions = [{ name: 'second', value: 1 }, { name: 'millisecond', value: 2 }];\n}\n","import OpenTsDatasource from './datasource';\nimport { OpenTsQueryCtrl } from './query_ctrl';\nimport { OpenTsConfigCtrl } from './config_ctrl';\n\nclass AnnotationsQueryCtrl {\n  static templateUrl = 'partials/annotations.editor.html';\n}\n\nexport {\n  OpenTsDatasource as Datasource,\n  OpenTsQueryCtrl as QueryCtrl,\n  OpenTsConfigCtrl as ConfigCtrl,\n  AnnotationsQueryCtrl,\n};\n"],"sourceRoot":""}