{"version":3,"file":"94.6acbb36fede37ba2a793.js","mappings":"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","sources":["webpack://grafana/./public/app/core/components/GraphNG/GraphNG.tsx","webpack://grafana/./packages/grafana-data/src/transformations/transformers/nulls/nullToUndefThreshold.ts","webpack://grafana/./public/app/core/components/GraphNG/utils.ts","webpack://grafana/./public/app/core/components/TimeSeries/utils.ts","webpack://grafana/./public/app/core/components/TimeSeries/TimeSeries.tsx","webpack://grafana/./public/app/plugins/panel/timeseries/TimeSeriesTooltip.tsx","webpack://grafana/./public/app/plugins/panel/xychart/utils.ts"],"sourcesContent":["import { Component } from 'react';\nimport * as React from 'react';\nimport uPlot, { AlignedData } from 'uplot';\n\nimport {\n  DataFrame,\n  DataLinkPostProcessor,\n  Field,\n  FieldMatcherID,\n  fieldMatchers,\n  FieldType,\n  getLinksSupplier,\n  InterpolateFunction,\n  TimeRange,\n  TimeZone,\n} from '@grafana/data';\nimport { DashboardCursorSync, VizLegendOptions } from '@grafana/schema';\nimport { Themeable2, VizLayout } from '@grafana/ui';\nimport { UPlotChart } from '@grafana/ui/src/components/uPlot/Plot';\nimport { AxisProps } from '@grafana/ui/src/components/uPlot/config/UPlotAxisBuilder';\nimport { Renderers, UPlotConfigBuilder } from '@grafana/ui/src/components/uPlot/config/UPlotConfigBuilder';\nimport { ScaleProps } from '@grafana/ui/src/components/uPlot/config/UPlotScaleBuilder';\nimport { pluginLog } from '@grafana/ui/src/components/uPlot/utils';\n\nimport { GraphNGLegendEvent, XYFieldMatchers } from './types';\nimport { preparePlotFrame as defaultPreparePlotFrame } from './utils';\n\n/**\n * @internal -- not a public API\n */\nexport type PropDiffFn<T extends any = any> = (prev: T, next: T) => boolean;\n\nexport interface GraphNGProps extends Themeable2 {\n  frames: DataFrame[];\n  structureRev?: number; // a number that will change when the frames[] structure changes\n  width: number;\n  height: number;\n  timeRange: TimeRange;\n  timeZone: TimeZone[] | TimeZone;\n  legend: VizLegendOptions;\n  fields?: XYFieldMatchers; // default will assume timeseries data\n  renderers?: Renderers;\n  tweakScale?: (opts: ScaleProps, forField: Field) => ScaleProps;\n  tweakAxis?: (opts: AxisProps, forField: Field) => AxisProps;\n  onLegendClick?: (event: GraphNGLegendEvent) => void;\n  children?: (builder: UPlotConfigBuilder, alignedFrame: DataFrame) => React.ReactNode;\n  prepConfig: (alignedFrame: DataFrame, allFrames: DataFrame[], getTimeRange: () => TimeRange) => UPlotConfigBuilder;\n  propsToDiff?: Array<string | PropDiffFn>;\n  preparePlotFrame?: (frames: DataFrame[], dimFields: XYFieldMatchers) => DataFrame | null;\n  renderLegend: (config: UPlotConfigBuilder) => React.ReactElement | null;\n  replaceVariables: InterpolateFunction;\n  dataLinkPostProcessor?: DataLinkPostProcessor;\n  cursorSync?: DashboardCursorSync;\n\n  /**\n   * needed for propsToDiff to re-init the plot & config\n   * this is a generic approach to plot re-init, without having to specify which panel-level options\n   * should cause invalidation. we can drop this in favor of something like panelOptionsRev that gets passed in\n   * similar to structureRev. then we can drop propsToDiff entirely.\n   */\n  options?: Record<string, any>;\n}\n\nfunction sameProps(prevProps: any, nextProps: any, propsToDiff: Array<string | PropDiffFn> = []) {\n  for (const propName of propsToDiff) {\n    if (typeof propName === 'function') {\n      if (!propName(prevProps, nextProps)) {\n        return false;\n      }\n    } else if (nextProps[propName] !== prevProps[propName]) {\n      return false;\n    }\n  }\n\n  return true;\n}\n\n/**\n * @internal -- not a public API\n */\nexport interface GraphNGState {\n  alignedFrame: DataFrame;\n  alignedData?: AlignedData;\n  config?: UPlotConfigBuilder;\n}\n\nconst defaultMatchers = {\n  x: fieldMatchers.get(FieldMatcherID.firstTimeField).get({}),\n  y: fieldMatchers.get(FieldMatcherID.byTypes).get(new Set([FieldType.number, FieldType.enum])),\n};\n\n/**\n * \"Time as X\" core component, expects ascending x\n */\nexport class GraphNG extends Component<GraphNGProps, GraphNGState> {\n  private plotInstance: React.RefObject<uPlot>;\n\n  constructor(props: GraphNGProps) {\n    super(props);\n    let state = this.prepState(props);\n    state.alignedData = state.config!.prepData!([state.alignedFrame]) as AlignedData;\n    this.state = state;\n    this.plotInstance = React.createRef();\n  }\n\n  getTimeRange = () => this.props.timeRange;\n\n  prepState(props: GraphNGProps, withConfig = true) {\n    let state: GraphNGState = null as any;\n\n    const { frames, fields = defaultMatchers, preparePlotFrame, replaceVariables, dataLinkPostProcessor } = props;\n\n    const preparePlotFrameFn = preparePlotFrame ?? defaultPreparePlotFrame;\n\n    const withLinks = frames.some((frame) => frame.fields.some((field) => (field.config.links?.length ?? 0) > 0));\n\n    const alignedFrame = preparePlotFrameFn(\n      frames,\n      {\n        ...fields,\n        // if there are data links, keep all fields during join so they're index-matched\n        y: withLinks ? () => true : fields.y,\n      },\n      props.timeRange\n    );\n\n    pluginLog('GraphNG', false, 'data aligned', alignedFrame);\n\n    if (alignedFrame) {\n      let alignedFrameFinal = alignedFrame;\n\n      if (withLinks) {\n        const timeZone = Array.isArray(this.props.timeZone) ? this.props.timeZone[0] : this.props.timeZone;\n\n        // for links gen we need to use original frames but with the aligned/joined data values\n        let linkFrames = frames.map((frame, frameIdx) => ({\n          ...frame,\n          fields: alignedFrame.fields.filter(\n            (field, fieldIdx) => fieldIdx === 0 || field.state?.origin?.frameIndex === frameIdx\n          ),\n          length: alignedFrame.length,\n        }));\n\n        linkFrames.forEach((linkFrame, frameIndex) => {\n          linkFrame.fields.forEach((field) => {\n            field.getLinks = getLinksSupplier(\n              linkFrame,\n              field,\n              {\n                ...field.state?.scopedVars,\n                __dataContext: {\n                  value: {\n                    data: linkFrames,\n                    field: field,\n                    frame: linkFrame,\n                    frameIndex,\n                  },\n                },\n              },\n              replaceVariables,\n              timeZone,\n              dataLinkPostProcessor\n            );\n          });\n        });\n\n        // filter join field and fields.y\n        alignedFrameFinal = {\n          ...alignedFrame,\n          fields: alignedFrame.fields.filter((field, i) => i === 0 || fields.y(field, alignedFrame, [alignedFrame])),\n        };\n      }\n\n      let config = this.state?.config;\n\n      if (withConfig) {\n        config = props.prepConfig(alignedFrameFinal, this.props.frames, this.getTimeRange);\n        pluginLog('GraphNG', false, 'config prepared', config);\n      }\n\n      state = {\n        alignedFrame: alignedFrameFinal,\n        config,\n      };\n\n      pluginLog('GraphNG', false, 'data prepared', state.alignedData);\n    }\n\n    return state;\n  }\n\n  componentDidUpdate(prevProps: GraphNGProps) {\n    const { frames, structureRev, timeZone, cursorSync, propsToDiff } = this.props;\n\n    const propsChanged = !sameProps(prevProps, this.props, propsToDiff);\n\n    if (\n      frames !== prevProps.frames ||\n      propsChanged ||\n      timeZone !== prevProps.timeZone ||\n      cursorSync !== prevProps.cursorSync\n    ) {\n      let newState = this.prepState(this.props, false);\n\n      if (newState) {\n        const shouldReconfig =\n          this.state.config === undefined ||\n          timeZone !== prevProps.timeZone ||\n          cursorSync !== prevProps.cursorSync ||\n          structureRev !== prevProps.structureRev ||\n          !structureRev ||\n          propsChanged;\n\n        if (shouldReconfig) {\n          newState.config = this.props.prepConfig(newState.alignedFrame, this.props.frames, this.getTimeRange);\n          pluginLog('GraphNG', false, 'config recreated', newState.config);\n        }\n\n        newState.alignedData = newState.config!.prepData!([newState.alignedFrame]) as AlignedData;\n\n        this.setState(newState);\n      }\n    }\n  }\n\n  render() {\n    const { width, height, children, renderLegend } = this.props;\n    const { config, alignedFrame, alignedData } = this.state;\n\n    if (!config) {\n      return null;\n    }\n\n    return (\n      <VizLayout width={width} height={height} legend={renderLegend(config)}>\n        {(vizWidth: number, vizHeight: number) => (\n          <UPlotChart\n            config={config}\n            data={alignedData!}\n            width={vizWidth}\n            height={vizHeight}\n            plotRef={(u) => ((this.plotInstance as React.MutableRefObject<uPlot>).current = u)}\n          >\n            {children ? children(config, alignedFrame) : null}\n          </UPlotChart>\n        )}\n      </VizLayout>\n    );\n  }\n}\n","// mutates all nulls -> undefineds in the fieldValues array for value-less refValues ranges below maxThreshold\n// refValues is typically a time array and maxThreshold is the allowable distance between in time\nexport function nullToUndefThreshold(refValues: number[], fieldValues: unknown[], maxThreshold: number) {\n  let prevRef;\n  let nullIdx;\n\n  for (let i = 0; i < fieldValues.length; i++) {\n    let fieldVal = fieldValues[i];\n\n    if (fieldVal == null) {\n      if (nullIdx == null && prevRef != null) {\n        nullIdx = i;\n      }\n    } else {\n      if (nullIdx != null && prevRef != null) {\n        if (refValues[i] - prevRef < maxThreshold) {\n          while (nullIdx < i) {\n            fieldValues[nullIdx++] = undefined;\n          }\n        }\n\n        nullIdx = null;\n      }\n\n      prevRef = refValues[i];\n    }\n  }\n\n  return fieldValues;\n}\n","import { DataFrame, Field, FieldType, outerJoinDataFrames, TimeRange } from '@grafana/data';\nimport { NULL_EXPAND, NULL_REMOVE, NULL_RETAIN } from '@grafana/data/src/transformations/transformers/joinDataFrames';\nimport { applyNullInsertThreshold } from '@grafana/data/src/transformations/transformers/nulls/nullInsertThreshold';\nimport { nullToUndefThreshold } from '@grafana/data/src/transformations/transformers/nulls/nullToUndefThreshold';\nimport { GraphDrawStyle } from '@grafana/schema';\n\nimport { XYFieldMatchers } from './types';\n\nfunction isVisibleBarField(f: Field) {\n  return (\n    f.type === FieldType.number && f.config.custom?.drawStyle === GraphDrawStyle.Bars && !f.config.custom?.hideFrom?.viz\n  );\n}\n\nexport function getRefField(frame: DataFrame, refFieldName?: string | null) {\n  return frame.fields.find((field) => {\n    // note: getFieldDisplayName() would require full DF[]\n    return refFieldName != null ? field.name === refFieldName : field.type === FieldType.time;\n  });\n}\n\n// will mutate the DataFrame's fields' values\nfunction applySpanNullsThresholds(frame: DataFrame, refFieldName?: string | null) {\n  const refField = getRefField(frame, refFieldName);\n\n  let refValues = refField?.values;\n\n  for (let i = 0; i < frame.fields.length; i++) {\n    let field = frame.fields[i];\n\n    if (field === refField || isVisibleBarField(field)) {\n      continue;\n    }\n\n    let spanNulls = field.config.custom?.spanNulls;\n\n    if (typeof spanNulls === 'number') {\n      if (spanNulls !== -1 && refValues) {\n        field.values = nullToUndefThreshold(refValues, field.values, spanNulls);\n      }\n    }\n  }\n\n  return frame;\n}\n\nexport function preparePlotFrame(frames: DataFrame[], dimFields: XYFieldMatchers, timeRange?: TimeRange | null) {\n  let xField: Field;\n  loop: for (let frame of frames) {\n    for (let field of frame.fields) {\n      if (dimFields.x(field, frame, frames)) {\n        xField = field;\n        break loop;\n      }\n    }\n  }\n\n  // apply null insertions at interval\n  frames = frames.map((frame) => {\n    if (!xField?.state?.nullThresholdApplied) {\n      return applyNullInsertThreshold({\n        frame,\n        refFieldName: xField.name,\n        refFieldPseudoMin: timeRange?.from.valueOf(),\n        refFieldPseudoMax: timeRange?.to.valueOf(),\n      });\n    } else {\n      return frame;\n    }\n  });\n\n  let numBarSeries = frames.reduce(\n    (acc, frame) => acc + frame.fields.reduce((acc, field) => acc + (isVisibleBarField(field) ? 1 : 0), 0),\n    0\n  );\n\n  // to make bar widths of all series uniform (equal to narrowest bar series), find smallest distance between x points\n  let minXDelta = Infinity;\n\n  if (numBarSeries > 1) {\n    frames.forEach((frame) => {\n      if (!frame.fields.some(isVisibleBarField)) {\n        return;\n      }\n\n      const xVals = xField.values;\n\n      for (let i = 0; i < xVals.length; i++) {\n        if (i > 0) {\n          minXDelta = Math.min(minXDelta, xVals[i] - xVals[i - 1]);\n        }\n      }\n    });\n  }\n\n  let alignedFrame = outerJoinDataFrames({\n    frames,\n    joinBy: dimFields.x,\n    keep: dimFields.y,\n    keepOriginIndices: true,\n\n    // the join transformer force-deletes our state.displayName cache unless keepDisplayNames: true\n    // https://github.com/grafana/grafana/pull/31121\n    // https://github.com/grafana/grafana/pull/71806\n    keepDisplayNames: true,\n\n    // prevent minesweeper-expansion of nulls (gaps) when joining bars\n    // since bar width is determined from the minimum distance between non-undefined values\n    // (this strategy will still retain any original pre-join nulls, though)\n    nullMode: (field) => {\n      if (isVisibleBarField(field)) {\n        return NULL_RETAIN;\n      }\n\n      let spanNulls = field.config.custom?.spanNulls;\n      return spanNulls === true ? NULL_REMOVE : spanNulls === -1 ? NULL_RETAIN : NULL_EXPAND;\n    },\n  });\n\n  if (alignedFrame) {\n    alignedFrame = applySpanNullsThresholds(alignedFrame, xField!.name);\n\n    // append 2 null vals at minXDelta to bar series\n    if (minXDelta !== Infinity) {\n      alignedFrame.fields.forEach((f, fi) => {\n        let vals = f.values;\n\n        if (fi === 0) {\n          let lastVal = vals[vals.length - 1];\n          vals.push(lastVal + minXDelta, lastVal + 2 * minXDelta);\n        } else if (isVisibleBarField(f)) {\n          vals.push(null, null);\n        } else {\n          vals.push(undefined, undefined);\n        }\n      });\n\n      alignedFrame.length += 2;\n    }\n\n    return alignedFrame;\n  }\n\n  return null;\n}\n","import { isNumber } from 'lodash';\nimport uPlot from 'uplot';\n\nimport {\n  DataFrame,\n  FieldConfig,\n  FieldType,\n  formattedValueToString,\n  getFieldColorModeForField,\n  getFieldSeriesColor,\n  getFieldDisplayName,\n  getDisplayProcessor,\n  FieldColorModeId,\n  DecimalCount,\n} from '@grafana/data';\n// eslint-disable-next-line import/order\nimport {\n  AxisPlacement,\n  GraphDrawStyle,\n  GraphFieldConfig,\n  GraphThresholdsStyleMode,\n  VisibilityMode,\n  ScaleDirection,\n  ScaleOrientation,\n  StackingMode,\n  GraphTransform,\n  AxisColorMode,\n  GraphGradientMode,\n  VizOrientation,\n} from '@grafana/schema';\n\n// unit lookup needed to determine if we want power-of-2 or power-of-10 axis ticks\n// see categories.ts is @grafana/data\nconst IEC_UNITS = new Set([\n  'bytes',\n  'bits',\n  'kbytes',\n  'mbytes',\n  'gbytes',\n  'tbytes',\n  'pbytes',\n  'binBps',\n  'binbps',\n  'KiBs',\n  'Kibits',\n  'MiBs',\n  'Mibits',\n  'GiBs',\n  'Gibits',\n  'TiBs',\n  'Tibits',\n  'PiBs',\n  'Pibits',\n]);\n\nconst BIN_INCRS = Array(53);\n\nfor (let i = 0; i < BIN_INCRS.length; i++) {\n  BIN_INCRS[i] = 2 ** i;\n}\n\nimport { UPlotConfigBuilder, UPlotConfigPrepFn } from '@grafana/ui/src/components/uPlot/config/UPlotConfigBuilder';\nimport { getScaleGradientFn } from '@grafana/ui/src/components/uPlot/config/gradientFills';\nimport { buildScaleKey } from '@grafana/ui/src/components/uPlot/internal';\nimport { getStackingGroups, preparePlotData2 } from '@grafana/ui/src/components/uPlot/utils';\n\nconst defaultFormatter = (v: any, decimals: DecimalCount = 1) => (v == null ? '-' : v.toFixed(decimals));\n\nconst defaultConfig: GraphFieldConfig = {\n  drawStyle: GraphDrawStyle.Line,\n  showPoints: VisibilityMode.Auto,\n  axisPlacement: AxisPlacement.Auto,\n};\n\nexport const preparePlotConfigBuilder: UPlotConfigPrepFn = ({\n  frame,\n  theme,\n  timeZones,\n  getTimeRange,\n  allFrames,\n  renderers,\n  tweakScale = (opts) => opts,\n  tweakAxis = (opts) => opts,\n  hoverProximity,\n  orientation = VizOrientation.Horizontal,\n}) => {\n  // we want the Auto and Horizontal orientation to default to Horizontal\n  const isHorizontal = orientation !== VizOrientation.Vertical;\n  const builder = new UPlotConfigBuilder(timeZones[0]);\n\n  let alignedFrame: DataFrame;\n\n  builder.setPrepData((frames) => {\n    // cache alignedFrame\n    alignedFrame = frames[0];\n\n    return preparePlotData2(frames[0], builder.getStackingGroups());\n  });\n\n  // X is the first field in the aligned frame\n  const xField = frame.fields[0];\n  if (!xField) {\n    return builder; // empty frame with no options\n  }\n\n  const xScaleKey = 'x';\n  let yScaleKey = '';\n\n  const xFieldAxisPlacement =\n    xField.config.custom?.axisPlacement === AxisPlacement.Hidden\n      ? AxisPlacement.Hidden\n      : isHorizontal\n        ? AxisPlacement.Bottom\n        : AxisPlacement.Left;\n  const xFieldAxisShow = xField.config.custom?.axisPlacement !== AxisPlacement.Hidden;\n\n  if (xField.type === FieldType.time) {\n    builder.addScale({\n      scaleKey: xScaleKey,\n      orientation: isHorizontal ? ScaleOrientation.Horizontal : ScaleOrientation.Vertical,\n      direction: isHorizontal ? ScaleDirection.Right : ScaleDirection.Up,\n      isTime: true,\n      range: () => {\n        const r = getTimeRange();\n        return [r.from.valueOf(), r.to.valueOf()];\n      },\n    });\n\n    // filters first 2 ticks to make space for timezone labels\n    const filterTicks: uPlot.Axis.Filter | undefined =\n      timeZones.length > 1\n        ? (u, splits) => {\n            if (isHorizontal) {\n              return splits.map((v, i) => (i < 2 ? null : v));\n            }\n            return splits;\n          }\n        : undefined;\n\n    for (let i = 0; i < timeZones.length; i++) {\n      const timeZone = timeZones[i];\n      builder.addAxis({\n        scaleKey: xScaleKey,\n        isTime: true,\n        placement: xFieldAxisPlacement,\n        show: xFieldAxisShow,\n        label: xField.config.custom?.axisLabel,\n        timeZone,\n        theme,\n        grid: { show: i === 0 && xField.config.custom?.axisGridShow },\n        filter: filterTicks,\n      });\n    }\n\n    // render timezone labels\n    if (timeZones.length > 1) {\n      builder.addHook('drawAxes', (u: uPlot) => {\n        u.ctx.save();\n\n        let i = 0;\n        u.axes.forEach((a) => {\n          if (isHorizontal && a.side === 2) {\n            u.ctx.fillStyle = theme.colors.text.primary;\n            u.ctx.textAlign = 'left';\n            u.ctx.textBaseline = 'bottom';\n            //@ts-ignore\n            let cssBaseline: number = a._pos + a._size;\n            u.ctx.fillText(timeZones[i], u.bbox.left, cssBaseline * uPlot.pxRatio);\n            i++;\n          }\n        });\n\n        u.ctx.restore();\n      });\n    }\n  } else {\n    builder.addScale({\n      scaleKey: xScaleKey,\n      orientation: isHorizontal ? ScaleOrientation.Horizontal : ScaleOrientation.Vertical,\n      direction: isHorizontal ? ScaleDirection.Right : ScaleDirection.Up,\n      range: (u, dataMin, dataMax) => [xField.config.min ?? dataMin, xField.config.max ?? dataMax],\n    });\n\n    builder.addAxis({\n      scaleKey: xScaleKey,\n      placement: xFieldAxisPlacement,\n      show: xFieldAxisShow,\n      label: xField.config.custom?.axisLabel,\n      theme,\n      grid: { show: xField.config.custom?.axisGridShow },\n      formatValue: (v, decimals) => formattedValueToString(xField.display!(v, decimals)),\n    });\n  }\n\n  let customRenderedFields =\n    renderers?.flatMap((r) => Object.values(r.fieldMap).filter((name) => r.indicesOnly.indexOf(name) === -1)) ?? [];\n\n  let indexByName: Map<string, number> | undefined;\n\n  for (let i = 1; i < frame.fields.length; i++) {\n    const field = frame.fields[i];\n\n    const config: FieldConfig<GraphFieldConfig> = {\n      ...field.config,\n      custom: {\n        ...defaultConfig,\n        ...field.config.custom,\n      },\n    };\n\n    const customConfig: GraphFieldConfig = config.custom!;\n\n    if (field === xField || (field.type !== FieldType.number && field.type !== FieldType.enum)) {\n      continue;\n    }\n\n    let fmt = field.display ?? defaultFormatter;\n    if (field.config.custom?.stacking?.mode === StackingMode.Percent) {\n      fmt = getDisplayProcessor({\n        field: {\n          ...field,\n          config: {\n            ...field.config,\n            unit: 'percentunit',\n          },\n        },\n        theme,\n      });\n    }\n    const scaleKey = buildScaleKey(config, field.type);\n    const colorMode = getFieldColorModeForField(field);\n    const scaleColor = getFieldSeriesColor(field, theme);\n    const seriesColor = scaleColor.color;\n\n    // The builder will manage unique scaleKeys and combine where appropriate\n    builder.addScale(\n      tweakScale(\n        {\n          scaleKey,\n          orientation: isHorizontal ? ScaleOrientation.Vertical : ScaleOrientation.Horizontal,\n          direction: isHorizontal ? ScaleDirection.Up : ScaleDirection.Right,\n          distribution: customConfig.scaleDistribution?.type,\n          log: customConfig.scaleDistribution?.log,\n          linearThreshold: customConfig.scaleDistribution?.linearThreshold,\n          min: field.config.min,\n          max: field.config.max,\n          softMin: customConfig.axisSoftMin,\n          softMax: customConfig.axisSoftMax,\n          centeredZero: customConfig.axisCenteredZero,\n          stackingMode: customConfig.stacking?.mode,\n          range:\n            field.type === FieldType.enum\n              ? (u: uPlot, dataMin: number, dataMax: number) => {\n                  // this is the exhaustive enum (stable)\n                  let len = field.config.type!.enum!.text!.length;\n\n                  return [-1, len];\n\n                  // these are only values that are present\n                  // return [dataMin - 1, dataMax + 1]\n                }\n              : undefined,\n          decimals: field.config.decimals,\n        },\n        field\n      )\n    );\n\n    if (!yScaleKey) {\n      yScaleKey = scaleKey;\n    }\n\n    if (customConfig.axisPlacement !== AxisPlacement.Hidden) {\n      let axisColor: uPlot.Axis.Stroke | undefined;\n\n      if (customConfig.axisColorMode === AxisColorMode.Series) {\n        if (\n          colorMode.isByValue &&\n          field.config.custom?.gradientMode === GraphGradientMode.Scheme &&\n          colorMode.id === FieldColorModeId.Thresholds\n        ) {\n          axisColor = getScaleGradientFn(1, theme, colorMode, field.config.thresholds);\n        } else {\n          axisColor = seriesColor;\n        }\n      }\n\n      const axisDisplayOptions = {\n        border: {\n          show: customConfig.axisBorderShow || false,\n          width: 1 / devicePixelRatio,\n          stroke: axisColor || theme.colors.text.primary,\n        },\n        ticks: {\n          show: customConfig.axisBorderShow || false,\n          stroke: axisColor || theme.colors.text.primary,\n        },\n        color: axisColor || theme.colors.text.primary,\n      };\n\n      let incrs: uPlot.Axis.Incrs | undefined;\n\n      // TODO: these will be dynamic with frame updates, so need to accept getYTickLabels()\n      let values: uPlot.Axis.Values | undefined;\n      let splits: uPlot.Axis.Splits | undefined;\n\n      if (IEC_UNITS.has(config.unit!)) {\n        incrs = BIN_INCRS;\n      } else if (field.type === FieldType.enum) {\n        let text = field.config.type!.enum!.text!;\n        splits = text.map((v: string, i: number) => i);\n        values = text;\n      }\n\n      builder.addAxis(\n        tweakAxis(\n          {\n            scaleKey,\n            label: customConfig.axisLabel,\n            size: customConfig.axisWidth,\n            placement: isHorizontal ? (customConfig.axisPlacement ?? AxisPlacement.Auto) : AxisPlacement.Bottom,\n            formatValue: (v, decimals) => formattedValueToString(fmt(v, decimals)),\n            theme,\n            grid: { show: customConfig.axisGridShow },\n            decimals: field.config.decimals,\n            distr: customConfig.scaleDistribution?.type,\n            splits,\n            values,\n            incrs,\n            ...axisDisplayOptions,\n          },\n          field\n        )\n      );\n    }\n\n    const showPoints =\n      customConfig.drawStyle === GraphDrawStyle.Points ? VisibilityMode.Always : customConfig.showPoints;\n\n    let pointsFilter: uPlot.Series.Points.Filter = () => null;\n\n    if (customConfig.spanNulls !== true) {\n      pointsFilter = (u, seriesIdx, show, gaps) => {\n        let filtered = [];\n\n        let series = u.series[seriesIdx];\n\n        if (!show && gaps && gaps.length) {\n          const [firstIdx, lastIdx] = series.idxs!;\n          const xData = u.data[0];\n          const yData = u.data[seriesIdx];\n          const firstPos = Math.round(u.valToPos(xData[firstIdx], 'x', true));\n          const lastPos = Math.round(u.valToPos(xData[lastIdx], 'x', true));\n\n          if (gaps[0][0] === firstPos) {\n            filtered.push(firstIdx);\n          }\n\n          // show single points between consecutive gaps that share end/start\n          for (let i = 0; i < gaps.length; i++) {\n            let thisGap = gaps[i];\n            let nextGap = gaps[i + 1];\n\n            if (nextGap && thisGap[1] === nextGap[0]) {\n              // approx when data density is > 1pt/px, since gap start/end pixels are rounded\n              let approxIdx = u.posToIdx(thisGap[1], true);\n\n              if (yData[approxIdx] == null) {\n                // scan left/right alternating to find closest index with non-null value\n                for (let j = 1; j < 100; j++) {\n                  if (yData[approxIdx + j] != null) {\n                    approxIdx += j;\n                    break;\n                  }\n                  if (yData[approxIdx - j] != null) {\n                    approxIdx -= j;\n                    break;\n                  }\n                }\n              }\n\n              filtered.push(approxIdx);\n            }\n          }\n\n          if (gaps[gaps.length - 1][1] === lastPos) {\n            filtered.push(lastIdx);\n          }\n        }\n\n        return filtered.length ? filtered : null;\n      };\n    }\n\n    let { fillOpacity } = customConfig;\n\n    let pathBuilder: uPlot.Series.PathBuilder | null = null;\n    let pointsBuilder: uPlot.Series.Points.Show | null = null;\n\n    if (field.state?.origin) {\n      if (!indexByName) {\n        indexByName = getNamesToFieldIndex(frame, allFrames);\n      }\n\n      const originFrame = allFrames[field.state.origin.frameIndex];\n      const originField = originFrame?.fields[field.state.origin.fieldIndex];\n\n      const dispName = getFieldDisplayName(originField ?? field, originFrame, allFrames);\n\n      // disable default renderers\n      if (customRenderedFields.indexOf(dispName) >= 0) {\n        pathBuilder = () => null;\n        pointsBuilder = () => undefined;\n      } else if (customConfig.transform === GraphTransform.Constant) {\n        // patch some monkeys!\n        const defaultBuilder = uPlot.paths!.linear!();\n\n        pathBuilder = (u, seriesIdx) => {\n          //eslint-disable-next-line\n          const _data: any[] = (u as any)._data; // uplot.AlignedData not exposed in types\n\n          // the data we want the line renderer to pull is x at each plot edge with paired flat y values\n\n          const r = getTimeRange();\n          let xData = [r.from.valueOf(), r.to.valueOf()];\n          let firstY = _data[seriesIdx].find((v: number | null | undefined) => v != null);\n          let yData = [firstY, firstY];\n          let fauxData = _data.slice();\n          fauxData[0] = xData;\n          fauxData[seriesIdx] = yData;\n\n          //eslint-disable-next-line\n          return defaultBuilder(\n            {\n              ...u,\n              _data: fauxData,\n            } as any,\n            seriesIdx,\n            0,\n            1\n          );\n        };\n      }\n\n      if (customConfig.fillBelowTo) {\n        const fillBelowToField = frame.fields.find(\n          (f) =>\n            customConfig.fillBelowTo === f.name ||\n            customConfig.fillBelowTo === f.config?.displayNameFromDS ||\n            customConfig.fillBelowTo === getFieldDisplayName(f, frame, allFrames)\n        );\n\n        const fillBelowDispName = fillBelowToField\n          ? getFieldDisplayName(fillBelowToField, frame, allFrames)\n          : customConfig.fillBelowTo;\n\n        const t = indexByName.get(dispName);\n        const b = indexByName.get(fillBelowDispName);\n        if (isNumber(b) && isNumber(t)) {\n          builder.addBand({\n            series: [t, b],\n            fill: undefined, // using null will have the band use fill options from `t`\n          });\n\n          if (!fillOpacity) {\n            fillOpacity = 35; // default from flot\n          }\n        } else {\n          fillOpacity = 0;\n        }\n      }\n    }\n\n    let dynamicSeriesColor: ((seriesIdx: number) => string | undefined) | undefined = undefined;\n\n    if (colorMode.id === FieldColorModeId.Thresholds) {\n      dynamicSeriesColor = (seriesIdx) => getFieldSeriesColor(alignedFrame.fields[seriesIdx], theme).color;\n    }\n\n    builder.addSeries({\n      pathBuilder,\n      pointsBuilder,\n      scaleKey,\n      showPoints,\n      pointsFilter,\n      colorMode,\n      fillOpacity,\n      theme,\n      dynamicSeriesColor,\n      drawStyle: customConfig.drawStyle!,\n      lineColor: customConfig.lineColor ?? seriesColor,\n      lineWidth: customConfig.lineWidth,\n      lineInterpolation: customConfig.lineInterpolation,\n      lineStyle: customConfig.lineStyle,\n      barAlignment: customConfig.barAlignment,\n      barWidthFactor: customConfig.barWidthFactor,\n      barMaxWidth: customConfig.barMaxWidth,\n      pointSize: customConfig.pointSize,\n      spanNulls: customConfig.spanNulls || false,\n      show: !customConfig.hideFrom?.viz,\n      gradientMode: customConfig.gradientMode,\n      thresholds: config.thresholds,\n      hardMin: field.config.min,\n      hardMax: field.config.max,\n      softMin: customConfig.axisSoftMin,\n      softMax: customConfig.axisSoftMax,\n      // The following properties are not used in the uPlot config, but are utilized as transport for legend config\n      dataFrameFieldIndex: field.state?.origin,\n    });\n\n    // Render thresholds in graph\n    if (customConfig.thresholdsStyle && config.thresholds) {\n      const thresholdDisplay = customConfig.thresholdsStyle.mode ?? GraphThresholdsStyleMode.Off;\n      if (thresholdDisplay !== GraphThresholdsStyleMode.Off) {\n        builder.addThresholds({\n          config: customConfig.thresholdsStyle,\n          thresholds: config.thresholds,\n          scaleKey,\n          theme,\n          hardMin: field.config.min,\n          hardMax: field.config.max,\n          softMin: customConfig.axisSoftMin,\n          softMax: customConfig.axisSoftMax,\n        });\n      }\n    }\n  }\n\n  let stackingGroups = getStackingGroups(frame);\n\n  builder.setStackingGroups(stackingGroups);\n\n  // hook up custom/composite renderers\n  renderers?.forEach((r) => {\n    if (!indexByName) {\n      indexByName = getNamesToFieldIndex(frame, allFrames);\n    }\n    let fieldIndices: Record<string, number> = {};\n\n    for (let key in r.fieldMap) {\n      let dispName = r.fieldMap[key];\n      fieldIndices[key] = indexByName.get(dispName)!;\n    }\n\n    r.init(builder, fieldIndices);\n  });\n\n  // if hovered value is null, how far we may scan left/right to hover nearest non-null\n  const DEFAULT_HOVER_NULL_PROXIMITY = 15;\n  const DEFAULT_FOCUS_PROXIMITY = 30;\n\n  let cursor: Partial<uPlot.Cursor> = {\n    // horizontal proximity / point hover behavior\n    hover: {\n      prox: (self, seriesIdx, hoveredIdx) => {\n        if (hoverProximity != null) {\n          return hoverProximity;\n        }\n\n        // when hovering null values, scan data left/right up to 15px\n        const yVal = self.data[seriesIdx][hoveredIdx];\n        if (yVal === null) {\n          return DEFAULT_HOVER_NULL_PROXIMITY;\n        }\n\n        // no proximity limit\n        return null;\n      },\n      skip: [null],\n    },\n    // vertical proximity / series focus behavior\n    focus: {\n      prox: hoverProximity ?? DEFAULT_FOCUS_PROXIMITY,\n    },\n  };\n\n  builder.setCursor(cursor);\n\n  return builder;\n};\n\nfunction getNamesToFieldIndex(frame: DataFrame, allFrames: DataFrame[]): Map<string, number> {\n  const originNames = new Map<string, number>();\n  frame.fields.forEach((field, i) => {\n    const origin = field.state?.origin;\n    if (origin) {\n      const origField = allFrames[origin.frameIndex]?.fields[origin.fieldIndex];\n      if (origField) {\n        originNames.set(getFieldDisplayName(origField, allFrames[origin.frameIndex], allFrames), i);\n      }\n    }\n  });\n  return originNames;\n}\n","import { Component } from 'react';\n\nimport { DataFrame, TimeRange } from '@grafana/data';\nimport { hasVisibleLegendSeries, PlotLegend } from '@grafana/ui/src/components/uPlot/PlotLegend';\nimport { UPlotConfigBuilder } from '@grafana/ui/src/components/uPlot/config/UPlotConfigBuilder';\nimport { withTheme2 } from '@grafana/ui/src/themes/ThemeContext';\n\nimport { GraphNG, GraphNGProps, PropDiffFn } from '../GraphNG/GraphNG';\n\nimport { preparePlotConfigBuilder } from './utils';\n\nconst propsToDiff: Array<string | PropDiffFn> = ['legend', 'options', 'theme'];\n\ntype TimeSeriesProps = Omit<GraphNGProps, 'prepConfig' | 'propsToDiff' | 'renderLegend'>;\n\nexport class UnthemedTimeSeries extends Component<TimeSeriesProps> {\n  prepConfig = (alignedFrame: DataFrame, allFrames: DataFrame[], getTimeRange: () => TimeRange) => {\n    const { theme, timeZone, options, renderers, tweakAxis, tweakScale } = this.props;\n\n    return preparePlotConfigBuilder({\n      frame: alignedFrame,\n      theme,\n      timeZones: Array.isArray(timeZone) ? timeZone : [timeZone],\n      getTimeRange,\n      allFrames,\n      renderers,\n      tweakScale,\n      tweakAxis,\n      hoverProximity: options?.tooltip?.hoverProximity,\n      orientation: options?.orientation,\n    });\n  };\n\n  renderLegend = (config: UPlotConfigBuilder) => {\n    const { legend, frames } = this.props;\n\n    if (!config || (legend && !legend.showLegend) || !hasVisibleLegendSeries(config, frames)) {\n      return null;\n    }\n\n    return <PlotLegend data={frames} config={config} {...legend} />;\n  };\n\n  render() {\n    return (\n      <GraphNG\n        {...this.props}\n        prepConfig={this.prepConfig}\n        propsToDiff={propsToDiff}\n        renderLegend={this.renderLegend}\n      />\n    );\n  }\n}\n\nexport const TimeSeries = withTheme2(UnthemedTimeSeries);\nTimeSeries.displayName = 'TimeSeries';\n","import { ReactNode } from 'react';\n\nimport { DataFrame, Field, FieldType, formattedValueToString, InterpolateFunction } from '@grafana/data';\nimport { SortOrder, TooltipDisplayMode } from '@grafana/schema/dist/esm/common/common.gen';\nimport { VizTooltipContent } from '@grafana/ui/src/components/VizTooltip/VizTooltipContent';\nimport { VizTooltipFooter } from '@grafana/ui/src/components/VizTooltip/VizTooltipFooter';\nimport { VizTooltipHeader } from '@grafana/ui/src/components/VizTooltip/VizTooltipHeader';\nimport { VizTooltipWrapper } from '@grafana/ui/src/components/VizTooltip/VizTooltipWrapper';\nimport { VizTooltipItem } from '@grafana/ui/src/components/VizTooltip/types';\nimport { getContentItems } from '@grafana/ui/src/components/VizTooltip/utils';\n\nimport { getDataLinks, getFieldActions } from '../status-history/utils';\nimport { fmt } from '../xychart/utils';\n\nimport { isTooltipScrollable } from './utils';\n\n// exemplar / annotation / time region hovering?\n// add annotation UI / alert dismiss UI?\n\nexport interface TimeSeriesTooltipProps {\n  // aligned series frame\n  series: DataFrame;\n\n  // aligned fields that are not series\n  _rest?: Field[];\n\n  // hovered points\n  dataIdxs: Array<number | null>;\n  // closest/hovered series\n  seriesIdx?: number | null;\n  mode?: TooltipDisplayMode;\n  sortOrder?: SortOrder;\n\n  isPinned: boolean;\n\n  annotate?: () => void;\n  maxHeight?: number;\n\n  replaceVariables?: InterpolateFunction;\n}\n\nexport const TimeSeriesTooltip = ({\n  series,\n  _rest,\n  dataIdxs,\n  seriesIdx,\n  mode = TooltipDisplayMode.Single,\n  sortOrder = SortOrder.None,\n  isPinned,\n  annotate,\n  maxHeight,\n  replaceVariables,\n}: TimeSeriesTooltipProps) => {\n  const xField = series.fields[0];\n  const xVal = formattedValueToString(xField.display!(xField.values[dataIdxs[0]!]));\n\n  const contentItems = getContentItems(\n    series.fields,\n    xField,\n    dataIdxs,\n    seriesIdx,\n    mode,\n    sortOrder,\n    (field) => field.type === FieldType.number || field.type === FieldType.enum\n  );\n\n  _rest?.forEach((field) => {\n    if (!field.config.custom?.hideFrom?.tooltip) {\n      contentItems.push({\n        label: field.state?.displayName ?? field.name,\n        value: fmt(field, field.values[dataIdxs[0]!]),\n      });\n    }\n  });\n\n  let footer: ReactNode;\n\n  if (isPinned && seriesIdx != null) {\n    const field = series.fields[seriesIdx];\n    const dataIdx = dataIdxs[seriesIdx]!;\n    const links = getDataLinks(field, dataIdx);\n    const actions = getFieldActions(series, field, replaceVariables!, dataIdx);\n\n    footer = <VizTooltipFooter dataLinks={links} actions={actions} annotate={annotate} />;\n  }\n\n  const headerItem: VizTooltipItem | null = xField.config.custom?.hideFrom?.tooltip\n    ? null\n    : {\n        label: xField.type === FieldType.time ? '' : (xField.state?.displayName ?? xField.name),\n        value: xVal,\n      };\n\n  return (\n    <VizTooltipWrapper>\n      {headerItem != null && <VizTooltipHeader item={headerItem} isPinned={isPinned} />}\n      <VizTooltipContent\n        items={contentItems}\n        isPinned={isPinned}\n        scrollable={isTooltipScrollable({ mode, maxHeight })}\n        maxHeight={maxHeight}\n      />\n      {footer}\n    </VizTooltipWrapper>\n  );\n};\n","import { Field, formattedValueToString } from '@grafana/data';\n\nexport function fmt(field: Field, val: number): string {\n  if (field.display) {\n    return formattedValueToString(field.display(val));\n  }\n\n  return `${val}`;\n}\n"],"names":["sameProps","prevProps","nextProps","propsToDiff","propName","defaultMatchers","GraphNG","props","state","withConfig","frames","fields","preparePlotFrame","replaceVariables","dataLinkPostProcessor","preparePlotFrameFn","withLinks","frame","field","alignedFrame","alignedFrameFinal","timeZone","linkFrames","frameIdx","fieldIdx","linkFrame","frameIndex","i","config","structureRev","cursorSync","propsChanged","newState","width","height","children","renderLegend","alignedData","vizWidth","vizHeight","u","nullToUndefThreshold","refValues","fieldValues","maxThreshold","prevRef","nullIdx","isVisibleBarField","f","getRefField","refFieldName","applySpanNullsThresholds","refField","spanNulls","dimFields","timeRange","xField","loop","numBarSeries","acc","minXDelta","xVals","fi","vals","lastVal","IEC_UNITS","BIN_INCRS","defaultFormatter","v","decimals","defaultConfig","preparePlotConfigBuilder","theme","timeZones","getTimeRange","allFrames","renderers","tweakScale","opts","tweakAxis","hoverProximity","orientation","isHorizontal","builder","UPlotConfigBuilder","xScaleKey","yScaleKey","xFieldAxisPlacement","xFieldAxisShow","r","filterTicks","splits","a","cssBaseline","dataMin","dataMax","customRenderedFields","name","indexByName","customConfig","fmt","scaleKey","colorMode","seriesColor","axisColor","axisDisplayOptions","incrs","values","text","showPoints","pointsFilter","seriesIdx","show","gaps","filtered","series","firstIdx","lastIdx","xData","yData","firstPos","lastPos","thisGap","nextGap","approxIdx","j","fillOpacity","pathBuilder","pointsBuilder","getNamesToFieldIndex","originFrame","originField","dispName","defaultBuilder","_data","firstY","fauxData","fillBelowToField","fillBelowDispName","t","b","dynamicSeriesColor","stackingGroups","fieldIndices","key","DEFAULT_HOVER_NULL_PROXIMITY","cursor","self","hoveredIdx","originNames","origin","origField","UnthemedTimeSeries","options","legend","PlotLegend","TimeSeries","TimeSeriesTooltip","_rest","dataIdxs","mode","sortOrder","isPinned","annotate","maxHeight","xVal","contentItems","footer","dataIdx","links","actions","headerItem","val"],"sourceRoot":""}