{"version":3,"sources":["webpack:///./public/app/plugins/datasource/elasticsearch/query_def.ts","webpack:///./public/app/plugins/datasource/elasticsearch/elastic_response.ts","webpack:///./public/app/plugins/datasource/elasticsearch/index_pattern.ts","webpack:///./public/app/plugins/datasource/elasticsearch/query_builder.ts","webpack:///./public/app/plugins/datasource/elasticsearch/datasource.ts","webpack:///./public/app/plugins/datasource/elasticsearch/bucket_agg.ts","webpack:///./public/app/plugins/datasource/elasticsearch/metric_agg.ts","webpack:///./public/app/plugins/datasource/elasticsearch/pipeline_variables.ts","webpack:///./public/app/plugins/datasource/elasticsearch/query_ctrl.ts","webpack:///./public/app/plugins/datasource/elasticsearch/components/ElasticsearchQueryField.tsx","webpack:///./public/app/plugins/datasource/elasticsearch/configuration/ElasticDetails.tsx","webpack:///./public/app/plugins/datasource/elasticsearch/configuration/LogsConfig.tsx","webpack:///./public/app/plugins/datasource/elasticsearch/configuration/DataLinks.tsx","webpack:///./public/app/plugins/datasource/elasticsearch/configuration/ConfigEditor.tsx","webpack:///./public/app/plugins/datasource/elasticsearch/configuration/DataLink.tsx","webpack:///./public/app/plugins/datasource/elasticsearch/module.ts"],"names":["query_def_metricAggTypes","text","value","requiresField","supportsInlineScript","supportsMissing","isPipelineAgg","minVersion","supportsMultipleBucketPaths","query_def_bucketAggTypes","orderByOptions","orderOptions","sizeOptions","extendedStats","intervalOptions","movingAvgModelOptions","query_def_pipelineOptions","moving_avg","default","undefined","derivative","bucket_script","movingAvgModelSettings","simple","linear","ewma","holt","holt_winters","isCheckbox","getMetricAggTypes","esVersion","lodash_default","a","filter","f","metricType","po","isPipelineAggWithMultipleBucketPaths","find","t","getMovingAvgSettings","model","filtered","filteredResult","each","setting","push","describeMetric","metric","def","type","field","findMetricById","metrics","id","hasMetricOfType","target","some","m","elastic_response_ElasticResponse","ElasticResponse","targets","response","this","prototype","processMetrics","esAgg","seriesList","props","y","i","newSeries","bucket","length","hide","datapoints","buckets","doc_count","key","percentiles","values","percentileName","statName","meta","stats","std_deviation_bounds_upper","std_deviation_bounds","upper","std_deviation_bounds_lower","lower","metricId","normalized_value","processAggregationDocs","aggDef","table","columns","_e","Object","tslib_es6","keys","_f","next","done","propKey","addColumn","filterable","addMetricValue","metricName","_g","_h","_j","e_3","_k","propValues","_l","e_4","_m","getMetricName","rows","processBuckets","aggs","depth","aggId","maxDepth","bucketAggs","nameIndex","clone","key_as_string","metricDef","getSeriesName","series","metricTypeCount","alias","replace","match","g1","g2","group","indexOf","substring","agg","settings","script","_b","pipelineVariables","_c","pv","appliedAgg","pipelineAgg","name","propName","trim","nameSeries","uniq","map","processHits","hits","hit","doc","total","_id","_type","_index","_source","fields","trimDatapoints","aggregations","histogram","trimEdges","prop","points","slice","getErrorFromElasticResponse","err","result","data","JSON","stringify","root_cause","reason","message","$$config","config","getTimeSeries","responses","error","tmpSeriesList","table_model","getLogs","logMessageField","logLevelField","dataFrame","n","flattenHits","propNames","docs","createEmptyDataFrame","timeField","docs_1","e_6","docs_1_1","add","src","hits_1","hits_1_1","flattened","flatten","e_8","_d","sort","addField","time","string","parse","v","fieldNames","propNames_1","propNames_1_1","includes","intervalMap","Hourly","startOf","amount","Daily","Weekly","Monthly","Yearly","index_pattern_IndexPattern","IndexPattern","pattern","interval","getIndexForToday","format","getIndexList","from","to","intervalInfo","start","utc","endEpoch","valueOf","indexList","query_builder_ElasticQueryBuilder","ElasticQueryBuilder","options","getRangeFilter","gte","lte","buildTermsAgg","queryNode","metricRef","terms","size","parseInt","orderBy","order","isNaN","min_doc_count","missing","getDateHistogramAgg","extended_bounds","min","max","offset","getHistogramAgg","getFiltersAgg","filterObj","filters","query","label","query_string","analyze_wildcard","documentQuery","unmapped_type","script_fields","addAdhocFilters","adhocFilters","condition","queryCondition","operator","bool","must","match_phrase","must_not","lt","range","gt","regexp","build","queryString","j","nestedAggs","precision","aggField","metricAgg","buckets_path","test","hasOwnProperty","getTermsQuery","queryDef","1","_a","keyname","getLogsQuery","querystring","datasource_ElasticDatasource","_super","ElasticDatasource","instanceSettings","backendSrv","templateSrv","timeSrv","_this","call","basicAuth","withCredentials","url","index","database","settingsData","jsonData","indexPattern","timeInterval","maxConcurrentShardRequests","queryBuilder","dataLinks","$inject","request","method","headers","Authorization","datasourceRequest","get","timeRange","isArray","then","results","post","catch","annotationQuery","annotation","timeEndField","tagsField","textField","dateRanges","rangeStart","rangeEnd","should","minimum_should_match","header","search_type","ignore_unavailable","payload","angular_default","toJson","res","list","getFieldFromSource","source","fieldName","split","fieldValue","console","log","isString","isNumber","event","tags","timeEnd","titleField","title","interpolateVariablesInQueries","queries","scopedVars","expandedQueries","datasource","testDatasource","getFields","dateFields","status","getQueryHeader","searchType","timeFrom","timeTo","queryHeader","e_1","cloneDeep","sentTargets","targets_1","targets_1_1","queryObj","isLogsQuery","esQuery","Promise","resolve","toString","getMultiSearchUrl","e_2","er","enhanceDataFrame","configuredEsVersion","typeMap","float","double","integer","long","date","scaled_float","nested","shouldAddField","obj","fieldNameParts","getFieldsRecursively","subObj","isObject","properties","concat","join","pop","indexName","mappings","typeName","getTerms","metricFindQuery","fromJson","getTagKeys","getTagValues","variableExists","bucketAgg","objectContainsTemplate","e_5","_loop_1","dataLink","this_1","links","isPrimitive","e_7","item","bucket_agg_ElasticBucketAggCtrl","ElasticBucketAggCtrl","$scope","uiSegmentSrv","$rootScope","getBucketAggTypes","getOrderOptions","getSizeOptions","onAppEvent","types","elasticQueryUpdated","validateModel","init","onChangeInternal","onChange","onTypeChanged","showOptions","isFirst","bucketAggCount","settingsLinkText","describeOrderBy","reduce","memo","substr","defaultTo","Math","addFiltersQuery","removeFiltersQuery","without","toggleOptions","getOrderByOptions","metricRefs","$fieldType","getIntervalOptions","transformToSegments","addBucketAgg","lastBucket","addIndex","val","splice","fake","removeBucketAgg","templateUrl","controller","metric_agg_ElasticMetricAggCtrl","ElasticMetricAggCtrl","metricAggs","metricAggTypes","pipelineAggOptions","modelSettingsValues","updatePipelineAggOptions","isSingle","variablesLinkText","RegExp","pipelineOptions","opt","precisionThreshold","precision_threshold","percents","movingAvgModelTypes","modelSettings","updateMovingAvgModelSettings","inlineScript","inline","toggleVariables","showVariables","modelSettingsKeys","onChangeClearInternal","minimize","onTypeChange","getFieldsInternal","removeMetricAgg","core_module","directive","ElasticPipelineVariablesCtrl","variables","newVariable","remove","ElasticQueryCtrl","$injector","refresh","queryUpdated","jsonStr","handleQueryError","bind","newJson","rawQueryOld","appEvent","getCollapsedText","bucketAggTypes","__webpack_require__","grafana_ui_src","components_ElasticsearchQueryField","ElasticsearchQueryField","context","override","onRunQuery","plugins","onlyIn","node","getSyntax","state","syntaxLoaded","componentDidMount","onChangeQuery","componentWillUnmount","componentDidUpdate","prevProps","render","react_default","createElement","Fragment","className","additionalPlugins","placeholder","portalOrigin","PureComponent","indexPatternTypes","example","esVersions","labelWidth","inputWidth","ElasticDetails_changeHandler","required","inputEl","intervalHandler","jsonDataChangeHandler","option","version","getMaxConcurrenShardRequestOrDefault","aria-label","onBlur","tooltip","currentTarget","startsWith","newInterval","newDatabase","templateObject_1","templateObject_2","templateObject_3","templateObject_4","DataLinks_templateObject_1","DataLinks_templateObject_2","DataLinks_templateObject_3","LogsConfig","changeHandler","index_esm","getStyles","firstRow","nameField","regexField","onDelete","suggestions","styles","variant","icon","onClick","preventDefault","DataLinks_getStyles","theme","infoText","spacing","md","colors","textWeak","sm","DataLink","newField","newDataLinks","valueRaw","documentation","origin","Value","d","__webpack_exports__","module_plugin","ElasticAnnotationsQueryCtrl","onOptionsChange","react","defaultMaxConcurrentShardRequests","defaultUrl","dataSourceConfig","showAccessOptions","ElasticDetails","newValue"],"mappings":"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","file":"elasticsearchPlugin.4d0490a94b199a11f40c.js","sourcesContent":["import _ from 'lodash';\n\nexport const metricAggTypes = [\n  { text: 'Count', value: 'count', requiresField: false },\n  {\n    text: 'Average',\n    value: 'avg',\n    requiresField: true,\n    supportsInlineScript: true,\n    supportsMissing: true,\n  },\n  {\n    text: 'Sum',\n    value: 'sum',\n    requiresField: true,\n    supportsInlineScript: true,\n    supportsMissing: true,\n  },\n  {\n    text: 'Max',\n    value: 'max',\n    requiresField: true,\n    supportsInlineScript: true,\n    supportsMissing: true,\n  },\n  {\n    text: 'Min',\n    value: 'min',\n    requiresField: true,\n    supportsInlineScript: true,\n    supportsMissing: true,\n  },\n  {\n    text: 'Extended Stats',\n    value: 'extended_stats',\n    requiresField: true,\n    supportsMissing: true,\n    supportsInlineScript: true,\n  },\n  {\n    text: 'Percentiles',\n    value: 'percentiles',\n    requiresField: true,\n    supportsMissing: true,\n    supportsInlineScript: true,\n  },\n  {\n    text: 'Unique Count',\n    value: 'cardinality',\n    requiresField: true,\n    supportsMissing: true,\n  },\n  {\n    text: 'Moving Average',\n    value: 'moving_avg',\n    requiresField: false,\n    isPipelineAgg: true,\n    minVersion: 2,\n  },\n  {\n    text: 'Derivative',\n    value: 'derivative',\n    requiresField: false,\n    isPipelineAgg: true,\n    minVersion: 2,\n  },\n  {\n    text: 'Bucket Script',\n    value: 'bucket_script',\n    requiresField: false,\n    isPipelineAgg: true,\n    supportsMultipleBucketPaths: true,\n    minVersion: 2,\n  },\n  { text: 'Raw Document', value: 'raw_document', requiresField: false },\n  { text: 'Logs', value: 'logs', requiresField: false },\n];\n\nexport const bucketAggTypes = [\n  { text: 'Terms', value: 'terms', requiresField: true },\n  { text: 'Filters', value: 'filters' },\n  { text: 'Geo Hash Grid', value: 'geohash_grid', requiresField: true },\n  { text: 'Date Histogram', value: 'date_histogram', requiresField: true },\n  { text: 'Histogram', value: 'histogram', requiresField: true },\n];\n\nexport const orderByOptions = [\n  { text: 'Doc Count', value: '_count' },\n  { text: 'Term value', value: '_term' },\n];\n\nexport const orderOptions = [\n  { text: 'Top', value: 'desc' },\n  { text: 'Bottom', value: 'asc' },\n];\n\nexport const sizeOptions = [\n  { text: 'No limit', value: '0' },\n  { text: '1', value: '1' },\n  { text: '2', value: '2' },\n  { text: '3', value: '3' },\n  { text: '5', value: '5' },\n  { text: '10', value: '10' },\n  { text: '15', value: '15' },\n  { text: '20', value: '20' },\n];\n\nexport const extendedStats = [\n  { text: 'Avg', value: 'avg' },\n  { text: 'Min', value: 'min' },\n  { text: 'Max', value: 'max' },\n  { text: 'Sum', value: 'sum' },\n  { text: 'Count', value: 'count' },\n  { text: 'Std Dev', value: 'std_deviation' },\n  { text: 'Std Dev Upper', value: 'std_deviation_bounds_upper' },\n  { text: 'Std Dev Lower', value: 'std_deviation_bounds_lower' },\n];\n\nexport const intervalOptions = [\n  { text: 'auto', value: 'auto' },\n  { text: '10s', value: '10s' },\n  { text: '1m', value: '1m' },\n  { text: '5m', value: '5m' },\n  { text: '10m', value: '10m' },\n  { text: '20m', value: '20m' },\n  { text: '1h', value: '1h' },\n  { text: '1d', value: '1d' },\n];\n\nexport const movingAvgModelOptions = [\n  { text: 'Simple', value: 'simple' },\n  { text: 'Linear', value: 'linear' },\n  { text: 'Exponentially Weighted', value: 'ewma' },\n  { text: 'Holt Linear', value: 'holt' },\n  { text: 'Holt Winters', value: 'holt_winters' },\n];\n\nexport const pipelineOptions: any = {\n  moving_avg: [\n    { text: 'window', default: 5 },\n    { text: 'model', default: 'simple' },\n    { text: 'predict', default: undefined },\n    { text: 'minimize', default: false },\n  ],\n  derivative: [{ text: 'unit', default: undefined }],\n  bucket_script: [],\n};\n\nexport const movingAvgModelSettings: any = {\n  simple: [],\n  linear: [],\n  ewma: [{ text: 'Alpha', value: 'alpha', default: undefined }],\n  holt: [\n    { text: 'Alpha', value: 'alpha', default: undefined },\n    { text: 'Beta', value: 'beta', default: undefined },\n  ],\n  holt_winters: [\n    { text: 'Alpha', value: 'alpha', default: undefined },\n    { text: 'Beta', value: 'beta', default: undefined },\n    { text: 'Gamma', value: 'gamma', default: undefined },\n    { text: 'Period', value: 'period', default: undefined },\n    { text: 'Pad', value: 'pad', default: undefined, isCheckbox: true },\n  ],\n};\n\nexport function getMetricAggTypes(esVersion: any) {\n  return _.filter(metricAggTypes, f => {\n    if (f.minVersion) {\n      return f.minVersion <= esVersion;\n    } else {\n      return true;\n    }\n  });\n}\n\nexport function getPipelineOptions(metric: any) {\n  if (!isPipelineAgg(metric.type)) {\n    return [];\n  }\n\n  return pipelineOptions[metric.type];\n}\n\nexport function isPipelineAgg(metricType: any) {\n  if (metricType) {\n    const po = pipelineOptions[metricType];\n    return po !== null && po !== undefined;\n  }\n\n  return false;\n}\n\nexport function isPipelineAggWithMultipleBucketPaths(metricType: any) {\n  if (metricType) {\n    return metricAggTypes.find(t => t.value === metricType && t.supportsMultipleBucketPaths) !== undefined;\n  }\n\n  return false;\n}\n\nexport function getPipelineAggOptions(targets: any) {\n  const result: any[] = [];\n  _.each(targets.metrics, metric => {\n    if (!isPipelineAgg(metric.type)) {\n      result.push({ text: describeMetric(metric), value: metric.id });\n    }\n  });\n\n  return result;\n}\n\nexport function getMovingAvgSettings(model: any, filtered: boolean) {\n  const filteredResult: any[] = [];\n  if (filtered) {\n    _.each(movingAvgModelSettings[model], setting => {\n      if (!setting.isCheckbox) {\n        filteredResult.push(setting);\n      }\n    });\n    return filteredResult;\n  }\n  return movingAvgModelSettings[model];\n}\n\nexport function getOrderByOptions(target: any) {\n  const metricRefs: any[] = [];\n  _.each(target.metrics, metric => {\n    if (metric.type !== 'count') {\n      metricRefs.push({ text: describeMetric(metric), value: metric.id });\n    }\n  });\n\n  return orderByOptions.concat(metricRefs);\n}\n\nexport function describeOrder(order: string) {\n  const def: any = _.find(orderOptions, { value: order });\n  return def.text;\n}\n\nexport function describeMetric(metric: { type: string; field: string }) {\n  const def: any = _.find(metricAggTypes, { value: metric.type });\n  if (!def.requiresField && !isPipelineAgg(metric.type)) {\n    return def.text;\n  }\n  return def.text + ' ' + metric.field;\n}\n\nexport function describeOrderBy(orderBy: any, target: any) {\n  const def: any = _.find(orderByOptions, { value: orderBy });\n  if (def) {\n    return def.text;\n  }\n  const metric: any = _.find(target.metrics, { id: orderBy });\n  if (metric) {\n    return describeMetric(metric);\n  } else {\n    return 'metric not found';\n  }\n}\n\nexport function defaultMetricAgg() {\n  return { type: 'count', id: '1' };\n}\n\nexport function defaultBucketAgg() {\n  return { type: 'date_histogram', id: '2', settings: { interval: 'auto' } };\n}\n\nexport const findMetricById = (metrics: any[], id: any) => {\n  return _.find(metrics, { id: id });\n};\n\nexport function hasMetricOfType(target: any, type: string): boolean {\n  return target && target.metrics && target.metrics.some((m: any) => m.type === type);\n}\n","import _ from 'lodash';\nimport flatten from 'app/core/utils/flatten';\nimport * as queryDef from './query_def';\nimport TableModel from 'app/core/table_model';\nimport { DataQueryResponse, DataFrame, toDataFrame, FieldType, MutableDataFrame } from '@grafana/data';\nimport { ElasticsearchAggregation } from './types';\n\nexport class ElasticResponse {\n  constructor(private targets: any, private response: any) {\n    this.targets = targets;\n    this.response = response;\n  }\n\n  processMetrics(esAgg: any, target: any, seriesList: any, props: any) {\n    let metric, y, i, newSeries, bucket, value;\n\n    for (y = 0; y < target.metrics.length; y++) {\n      metric = target.metrics[y];\n      if (metric.hide) {\n        continue;\n      }\n\n      switch (metric.type) {\n        case 'count': {\n          newSeries = { datapoints: [], metric: 'count', props: props };\n          for (i = 0; i < esAgg.buckets.length; i++) {\n            bucket = esAgg.buckets[i];\n            value = bucket.doc_count;\n            newSeries.datapoints.push([value, bucket.key]);\n          }\n          seriesList.push(newSeries);\n          break;\n        }\n        case 'percentiles': {\n          if (esAgg.buckets.length === 0) {\n            break;\n          }\n\n          const firstBucket = esAgg.buckets[0];\n          const percentiles = firstBucket[metric.id].values;\n\n          for (const percentileName in percentiles) {\n            newSeries = {\n              datapoints: [],\n              metric: 'p' + percentileName,\n              props: props,\n              field: metric.field,\n            };\n\n            for (i = 0; i < esAgg.buckets.length; i++) {\n              bucket = esAgg.buckets[i];\n              const values = bucket[metric.id].values;\n              newSeries.datapoints.push([values[percentileName], bucket.key]);\n            }\n            seriesList.push(newSeries);\n          }\n\n          break;\n        }\n        case 'extended_stats': {\n          for (const statName in metric.meta) {\n            if (!metric.meta[statName]) {\n              continue;\n            }\n\n            newSeries = {\n              datapoints: [],\n              metric: statName,\n              props: props,\n              field: metric.field,\n            };\n\n            for (i = 0; i < esAgg.buckets.length; i++) {\n              bucket = esAgg.buckets[i];\n              const stats = bucket[metric.id];\n\n              // add stats that are in nested obj to top level obj\n              stats.std_deviation_bounds_upper = stats.std_deviation_bounds.upper;\n              stats.std_deviation_bounds_lower = stats.std_deviation_bounds.lower;\n\n              newSeries.datapoints.push([stats[statName], bucket.key]);\n            }\n\n            seriesList.push(newSeries);\n          }\n\n          break;\n        }\n        default: {\n          newSeries = {\n            datapoints: [],\n            metric: metric.type,\n            field: metric.field,\n            metricId: metric.id,\n            props: props,\n          };\n          for (i = 0; i < esAgg.buckets.length; i++) {\n            bucket = esAgg.buckets[i];\n\n            value = bucket[metric.id];\n            if (value !== undefined) {\n              if (value.normalized_value) {\n                newSeries.datapoints.push([value.normalized_value, bucket.key]);\n              } else {\n                newSeries.datapoints.push([value.value, bucket.key]);\n              }\n            }\n          }\n          seriesList.push(newSeries);\n          break;\n        }\n      }\n    }\n  }\n\n  processAggregationDocs(esAgg: any, aggDef: ElasticsearchAggregation, target: any, table: any, props: any) {\n    // add columns\n    if (table.columns.length === 0) {\n      for (const propKey of _.keys(props)) {\n        table.addColumn({ text: propKey, filterable: true });\n      }\n      table.addColumn({ text: aggDef.field, filterable: true });\n    }\n\n    // helper func to add values to value array\n    const addMetricValue = (values: any[], metricName: string, value: any) => {\n      table.addColumn({ text: metricName });\n      values.push(value);\n    };\n\n    for (const bucket of esAgg.buckets) {\n      const values = [];\n\n      for (const propValues of _.values(props)) {\n        values.push(propValues);\n      }\n\n      // add bucket key (value)\n      values.push(bucket.key);\n\n      for (const metric of target.metrics) {\n        switch (metric.type) {\n          case 'count': {\n            addMetricValue(values, this.getMetricName(metric.type), bucket.doc_count);\n            break;\n          }\n          case 'extended_stats': {\n            for (const statName in metric.meta) {\n              if (!metric.meta[statName]) {\n                continue;\n              }\n\n              const stats = bucket[metric.id];\n              // add stats that are in nested obj to top level obj\n              stats.std_deviation_bounds_upper = stats.std_deviation_bounds.upper;\n              stats.std_deviation_bounds_lower = stats.std_deviation_bounds.lower;\n\n              addMetricValue(values, this.getMetricName(statName), stats[statName]);\n            }\n            break;\n          }\n          case 'percentiles': {\n            const percentiles = bucket[metric.id].values;\n\n            for (const percentileName in percentiles) {\n              addMetricValue(values, `p${percentileName} ${metric.field}`, percentiles[percentileName]);\n            }\n            break;\n          }\n          default: {\n            let metricName = this.getMetricName(metric.type);\n            const otherMetrics = _.filter(target.metrics, { type: metric.type });\n\n            // if more of the same metric type include field field name in property\n            if (otherMetrics.length > 1) {\n              metricName += ' ' + metric.field;\n            }\n\n            addMetricValue(values, metricName, bucket[metric.id].value);\n            break;\n          }\n        }\n      }\n\n      table.rows.push(values);\n    }\n  }\n\n  // This is quite complex\n  // need to recurse down the nested buckets to build series\n  processBuckets(aggs: any, target: any, seriesList: any, table: any, props: any, depth: any) {\n    let bucket, aggDef: any, esAgg, aggId;\n    const maxDepth = target.bucketAggs.length - 1;\n\n    for (aggId in aggs) {\n      aggDef = _.find(target.bucketAggs, { id: aggId });\n      esAgg = aggs[aggId];\n\n      if (!aggDef) {\n        continue;\n      }\n\n      if (depth === maxDepth) {\n        if (aggDef.type === 'date_histogram') {\n          this.processMetrics(esAgg, target, seriesList, props);\n        } else {\n          this.processAggregationDocs(esAgg, aggDef, target, table, props);\n        }\n      } else {\n        for (const nameIndex in esAgg.buckets) {\n          bucket = esAgg.buckets[nameIndex];\n          props = _.clone(props);\n          if (bucket.key !== void 0) {\n            props[aggDef.field] = bucket.key;\n          } else {\n            props['filter'] = nameIndex;\n          }\n          if (bucket.key_as_string) {\n            props[aggDef.field] = bucket.key_as_string;\n          }\n          this.processBuckets(bucket, target, seriesList, table, props, depth + 1);\n        }\n      }\n    }\n  }\n\n  private getMetricName(metric: any) {\n    let metricDef: any = _.find(queryDef.metricAggTypes, { value: metric });\n    if (!metricDef) {\n      metricDef = _.find(queryDef.extendedStats, { value: metric });\n    }\n\n    return metricDef ? metricDef.text : metric;\n  }\n\n  private getSeriesName(series: any, target: any, metricTypeCount: any) {\n    let metricName = this.getMetricName(series.metric);\n\n    if (target.alias) {\n      const regex = /\\{\\{([\\s\\S]+?)\\}\\}/g;\n\n      return target.alias.replace(regex, (match: any, g1: any, g2: any) => {\n        const group = g1 || g2;\n\n        if (group.indexOf('term ') === 0) {\n          return series.props[group.substring(5)];\n        }\n        if (series.props[group] !== void 0) {\n          return series.props[group];\n        }\n        if (group === 'metric') {\n          return metricName;\n        }\n        if (group === 'field') {\n          return series.field || '';\n        }\n\n        return match;\n      });\n    }\n\n    if (series.field && queryDef.isPipelineAgg(series.metric)) {\n      if (series.metric && queryDef.isPipelineAggWithMultipleBucketPaths(series.metric)) {\n        const agg: any = _.find(target.metrics, { id: series.metricId });\n        if (agg && agg.settings.script) {\n          metricName = agg.settings.script;\n\n          for (const pv of agg.pipelineVariables) {\n            const appliedAgg: any = _.find(target.metrics, { id: pv.pipelineAgg });\n            if (appliedAgg) {\n              metricName = metricName.replace('params.' + pv.name, queryDef.describeMetric(appliedAgg));\n            }\n          }\n        } else {\n          metricName = 'Unset';\n        }\n      } else {\n        const appliedAgg: any = _.find(target.metrics, { id: series.field });\n        if (appliedAgg) {\n          metricName += ' ' + queryDef.describeMetric(appliedAgg);\n        } else {\n          metricName = 'Unset';\n        }\n      }\n    } else if (series.field) {\n      metricName += ' ' + series.field;\n    }\n\n    const propKeys = _.keys(series.props);\n    if (propKeys.length === 0) {\n      return metricName;\n    }\n\n    let name = '';\n    for (const propName in series.props) {\n      name += series.props[propName] + ' ';\n    }\n\n    if (metricTypeCount === 1) {\n      return name.trim();\n    }\n\n    return name.trim() + ' ' + metricName;\n  }\n\n  nameSeries(seriesList: any, target: any) {\n    const metricTypeCount = _.uniq(_.map(seriesList, 'metric')).length;\n\n    for (let i = 0; i < seriesList.length; i++) {\n      const series = seriesList[i];\n      series.target = this.getSeriesName(series, target, metricTypeCount);\n    }\n  }\n\n  processHits(hits: { total: { value: any }; hits: any[] }, seriesList: any[]) {\n    const hitsTotal = typeof hits.total === 'number' ? hits.total : hits.total.value; // <- Works with Elasticsearch 7.0+\n\n    const series: any = {\n      target: 'docs',\n      type: 'docs',\n      datapoints: [],\n      total: hitsTotal,\n      filterable: true,\n    };\n    let propName, hit, doc: any, i;\n\n    for (i = 0; i < hits.hits.length; i++) {\n      hit = hits.hits[i];\n      doc = {\n        _id: hit._id,\n        _type: hit._type,\n        _index: hit._index,\n      };\n\n      if (hit._source) {\n        for (propName in hit._source) {\n          doc[propName] = hit._source[propName];\n        }\n      }\n\n      for (propName in hit.fields) {\n        doc[propName] = hit.fields[propName];\n      }\n      series.datapoints.push(doc);\n    }\n\n    seriesList.push(series);\n  }\n\n  trimDatapoints(aggregations: any, target: any) {\n    const histogram: any = _.find(target.bucketAggs, { type: 'date_histogram' });\n\n    const shouldDropFirstAndLast = histogram && histogram.settings && histogram.settings.trimEdges;\n    if (shouldDropFirstAndLast) {\n      const trim = histogram.settings.trimEdges;\n      for (const prop in aggregations) {\n        const points = aggregations[prop];\n        if (points.datapoints.length > trim * 2) {\n          points.datapoints = points.datapoints.slice(trim, points.datapoints.length - trim);\n        }\n      }\n    }\n  }\n\n  getErrorFromElasticResponse(response: any, err: any) {\n    const result: any = {};\n    result.data = JSON.stringify(err, null, 4);\n    if (err.root_cause && err.root_cause.length > 0 && err.root_cause[0].reason) {\n      result.message = err.root_cause[0].reason;\n    } else {\n      result.message = err.reason || 'Unkown elastic error response';\n    }\n\n    if (response.$$config) {\n      result.config = response.$$config;\n    }\n\n    return result;\n  }\n\n  getTimeSeries() {\n    const seriesList = [];\n\n    for (let i = 0; i < this.response.responses.length; i++) {\n      const response = this.response.responses[i];\n      if (response.error) {\n        throw this.getErrorFromElasticResponse(this.response, response.error);\n      }\n\n      if (response.hits && response.hits.hits.length > 0) {\n        this.processHits(response.hits, seriesList);\n      }\n\n      if (response.aggregations) {\n        const aggregations = response.aggregations;\n        const target = this.targets[i];\n        const tmpSeriesList: any[] = [];\n        const table = new TableModel();\n\n        this.processBuckets(aggregations, target, tmpSeriesList, table, {}, 0);\n        this.trimDatapoints(tmpSeriesList, target);\n        this.nameSeries(tmpSeriesList, target);\n\n        for (let y = 0; y < tmpSeriesList.length; y++) {\n          seriesList.push(tmpSeriesList[y]);\n        }\n\n        if (table.rows.length > 0) {\n          seriesList.push(table);\n        }\n      }\n    }\n\n    return { data: seriesList };\n  }\n\n  getLogs(logMessageField?: string, logLevelField?: string): DataQueryResponse {\n    const dataFrame: DataFrame[] = [];\n\n    for (let n = 0; n < this.response.responses.length; n++) {\n      const response = this.response.responses[n];\n      if (response.error) {\n        throw this.getErrorFromElasticResponse(this.response, response.error);\n      }\n\n      const { propNames, docs } = flattenHits(response.hits.hits);\n      if (docs.length > 0) {\n        const series = createEmptyDataFrame(propNames, this.targets[0].timeField, logMessageField, logLevelField);\n\n        // Add a row for each document\n        for (const doc of docs) {\n          if (logLevelField) {\n            // Remap level field based on the datasource config. This field is then used in explore to figure out the\n            // log level. We may rewrite some actual data in the level field if they are different.\n            doc['level'] = doc[logLevelField];\n          }\n\n          series.add(doc);\n        }\n\n        dataFrame.push(series);\n      }\n\n      if (response.aggregations) {\n        const aggregations = response.aggregations;\n        const target = this.targets[n];\n        const tmpSeriesList: any[] = [];\n        const table = new TableModel();\n\n        this.processBuckets(aggregations, target, tmpSeriesList, table, {}, 0);\n        this.trimDatapoints(tmpSeriesList, target);\n        this.nameSeries(tmpSeriesList, target);\n\n        for (let y = 0; y < tmpSeriesList.length; y++) {\n          const series = toDataFrame(tmpSeriesList[y]);\n          dataFrame.push(series);\n        }\n      }\n    }\n\n    return { data: dataFrame };\n  }\n}\n\ntype Doc = {\n  _id: string;\n  _type: string;\n  _index: string;\n  _source?: any;\n};\n\n/**\n * Flatten the docs from response mainly the _source part which can be nested. This flattens it so that it is one level\n * deep and the keys are: `level1Name.level2Name...`. Also returns list of all properties from all the docs (not all\n * docs have to have the same keys).\n * @param hits\n */\nconst flattenHits = (hits: Doc[]): { docs: Array<Record<string, any>>; propNames: string[] } => {\n  const docs: any[] = [];\n  // We keep a list of all props so that we can create all the fields in the dataFrame, this can lead\n  // to wide sparse dataframes in case the scheme is different per document.\n  const propNames: string[] = [];\n\n  for (const hit of hits) {\n    const flattened = hit._source ? flatten(hit._source, null) : {};\n    const doc = {\n      _id: hit._id,\n      _type: hit._type,\n      _index: hit._index,\n      _source: { ...flattened },\n      ...flattened,\n    };\n\n    for (const propName of Object.keys(doc)) {\n      if (propNames.indexOf(propName) === -1) {\n        propNames.push(propName);\n      }\n    }\n\n    docs.push(doc);\n  }\n\n  propNames.sort();\n  return { docs, propNames };\n};\n\n/**\n * Create empty dataframe but with created fields. Fields are based from propNames (should be from the response) and\n * also from configuration specified fields for message, time, and level.\n * @param propNames\n * @param timeField\n * @param logMessageField\n * @param logLevelField\n */\nconst createEmptyDataFrame = (\n  propNames: string[],\n  timeField: string,\n  logMessageField?: string,\n  logLevelField?: string\n): MutableDataFrame => {\n  const series = new MutableDataFrame({ fields: [] });\n\n  series.addField({\n    name: timeField,\n    type: FieldType.time,\n  });\n\n  if (logMessageField) {\n    series.addField({\n      name: logMessageField,\n      type: FieldType.string,\n    }).parse = (v: any) => {\n      return v || '';\n    };\n  } else {\n    series.addField({\n      name: '_source',\n      type: FieldType.string,\n    }).parse = (v: any) => {\n      return JSON.stringify(v, null, 2);\n    };\n  }\n\n  if (logLevelField) {\n    series.addField({\n      name: 'level',\n      type: FieldType.string,\n    }).parse = (v: any) => {\n      return v || '';\n    };\n  }\n\n  const fieldNames = series.fields.map(field => field.name);\n\n  for (const propName of propNames) {\n    // Do not duplicate fields. This can mean that we will shadow some fields.\n    if (fieldNames.includes(propName)) {\n      continue;\n    }\n\n    series.addField({\n      name: propName,\n      type: FieldType.string,\n    }).parse = (v: any) => {\n      return v || '';\n    };\n  }\n\n  return series;\n};\n","import { toUtc, dateTime } from '@grafana/data';\n\nconst intervalMap: any = {\n  Hourly: { startOf: 'hour', amount: 'hours' },\n  Daily: { startOf: 'day', amount: 'days' },\n  Weekly: { startOf: 'isoWeek', amount: 'weeks' },\n  Monthly: { startOf: 'month', amount: 'months' },\n  Yearly: { startOf: 'year', amount: 'years' },\n};\n\nexport class IndexPattern {\n  constructor(private pattern: any, private interval: string | null) {}\n\n  getIndexForToday() {\n    if (this.interval) {\n      return toUtc().format(this.pattern);\n    } else {\n      return this.pattern;\n    }\n  }\n\n  getIndexList(from: any, to: any) {\n    if (!this.interval) {\n      return this.pattern;\n    }\n\n    const intervalInfo = intervalMap[this.interval];\n    const start = dateTime(from)\n      .utc()\n      .startOf(intervalInfo.startOf);\n    const endEpoch = dateTime(to)\n      .utc()\n      .startOf(intervalInfo.startOf)\n      .valueOf();\n    const indexList = [];\n\n    while (start.valueOf() <= endEpoch) {\n      indexList.push(start.format(this.pattern));\n      start.add(1, intervalInfo.amount);\n    }\n\n    return indexList;\n  }\n}\n","import * as queryDef from './query_def';\nimport { ElasticsearchAggregation } from './types';\n\nexport class ElasticQueryBuilder {\n  timeField: string;\n  esVersion: number;\n\n  constructor(options: { timeField: string; esVersion: number }) {\n    this.timeField = options.timeField;\n    this.esVersion = options.esVersion;\n  }\n\n  getRangeFilter() {\n    const filter: any = {};\n    filter[this.timeField] = {\n      gte: '$timeFrom',\n      lte: '$timeTo',\n      format: 'epoch_millis',\n    };\n\n    return filter;\n  }\n\n  buildTermsAgg(aggDef: ElasticsearchAggregation, queryNode: { terms?: any; aggs?: any }, target: { metrics: any[] }) {\n    let metricRef, metric, y;\n    queryNode.terms = { field: aggDef.field };\n\n    if (!aggDef.settings) {\n      return queryNode;\n    }\n\n    queryNode.terms.size = parseInt(aggDef.settings.size, 10) === 0 ? 500 : parseInt(aggDef.settings.size, 10);\n    if (aggDef.settings.orderBy !== void 0) {\n      queryNode.terms.order = {};\n      if (aggDef.settings.orderBy === '_term' && this.esVersion >= 60) {\n        queryNode.terms.order['_key'] = aggDef.settings.order;\n      } else {\n        queryNode.terms.order[aggDef.settings.orderBy] = aggDef.settings.order;\n      }\n\n      // if metric ref, look it up and add it to this agg level\n      metricRef = parseInt(aggDef.settings.orderBy, 10);\n      if (!isNaN(metricRef)) {\n        for (y = 0; y < target.metrics.length; y++) {\n          metric = target.metrics[y];\n          if (metric.id === aggDef.settings.orderBy) {\n            queryNode.aggs = {};\n            queryNode.aggs[metric.id] = {};\n            queryNode.aggs[metric.id][metric.type] = { field: metric.field };\n            break;\n          }\n        }\n      }\n    }\n\n    if (aggDef.settings.min_doc_count !== void 0) {\n      queryNode.terms.min_doc_count = parseInt(aggDef.settings.min_doc_count, 10);\n    }\n\n    if (aggDef.settings.missing) {\n      queryNode.terms.missing = aggDef.settings.missing;\n    }\n\n    return queryNode;\n  }\n\n  getDateHistogramAgg(aggDef: ElasticsearchAggregation) {\n    const esAgg: any = {};\n    const settings = aggDef.settings || {};\n    esAgg.interval = settings.interval;\n    esAgg.field = this.timeField;\n    esAgg.min_doc_count = settings.min_doc_count || 0;\n    esAgg.extended_bounds = { min: '$timeFrom', max: '$timeTo' };\n    esAgg.format = 'epoch_millis';\n\n    if (settings.offset !== '') {\n      esAgg.offset = settings.offset;\n    }\n\n    if (esAgg.interval === 'auto') {\n      esAgg.interval = '$__interval';\n    }\n\n    if (settings.missing) {\n      esAgg.missing = settings.missing;\n    }\n\n    return esAgg;\n  }\n\n  getHistogramAgg(aggDef: ElasticsearchAggregation) {\n    const esAgg: any = {};\n    const settings = aggDef.settings || {};\n    esAgg.interval = settings.interval;\n    esAgg.field = aggDef.field;\n    esAgg.min_doc_count = settings.min_doc_count || 0;\n\n    if (settings.missing) {\n      esAgg.missing = settings.missing;\n    }\n    return esAgg;\n  }\n\n  getFiltersAgg(aggDef: ElasticsearchAggregation) {\n    const filterObj: any = {};\n    for (let i = 0; i < aggDef.settings.filters.length; i++) {\n      const query = aggDef.settings.filters[i].query;\n      let label = aggDef.settings.filters[i].label;\n      label = label === '' || label === undefined ? query : label;\n      filterObj[label] = {\n        query_string: {\n          query: query,\n          analyze_wildcard: true,\n        },\n      };\n    }\n\n    return filterObj;\n  }\n\n  documentQuery(query: any, size: number) {\n    query.size = size;\n    query.sort = {};\n    query.sort[this.timeField] = { order: 'desc', unmapped_type: 'boolean' };\n\n    // fields field not supported on ES 5.x\n    if (this.esVersion < 5) {\n      query.fields = ['*', '_source'];\n    }\n\n    query.script_fields = {};\n    return query;\n  }\n\n  addAdhocFilters(query: any, adhocFilters: any) {\n    if (!adhocFilters) {\n      return;\n    }\n\n    let i, filter, condition: any, queryCondition: any;\n\n    for (i = 0; i < adhocFilters.length; i++) {\n      filter = adhocFilters[i];\n      condition = {};\n      condition[filter.key] = filter.value;\n      queryCondition = {};\n      queryCondition[filter.key] = { query: filter.value };\n\n      switch (filter.operator) {\n        case '=':\n          if (!query.query.bool.must) {\n            query.query.bool.must = [];\n          }\n          query.query.bool.must.push({ match_phrase: queryCondition });\n          break;\n        case '!=':\n          if (!query.query.bool.must_not) {\n            query.query.bool.must_not = [];\n          }\n          query.query.bool.must_not.push({ match_phrase: queryCondition });\n          break;\n        case '<':\n          condition[filter.key] = { lt: filter.value };\n          query.query.bool.filter.push({ range: condition });\n          break;\n        case '>':\n          condition[filter.key] = { gt: filter.value };\n          query.query.bool.filter.push({ range: condition });\n          break;\n        case '=~':\n          query.query.bool.filter.push({ regexp: condition });\n          break;\n        case '!~':\n          query.query.bool.filter.push({\n            bool: { must_not: { regexp: condition } },\n          });\n          break;\n      }\n    }\n  }\n\n  build(target: any, adhocFilters?: any, queryString?: string) {\n    // make sure query has defaults;\n    target.metrics = target.metrics || [queryDef.defaultMetricAgg()];\n    target.bucketAggs = target.bucketAggs || [queryDef.defaultBucketAgg()];\n    target.timeField = this.timeField;\n\n    let i, j, pv, nestedAggs, metric;\n    const query = {\n      size: 0,\n      query: {\n        bool: {\n          filter: [\n            { range: this.getRangeFilter() },\n            {\n              query_string: {\n                analyze_wildcard: true,\n                query: queryString,\n              },\n            },\n          ],\n        },\n      },\n    };\n\n    this.addAdhocFilters(query, adhocFilters);\n\n    // handle document query\n    if (target.bucketAggs.length === 0) {\n      metric = target.metrics[0];\n      if (!metric || metric.type !== 'raw_document') {\n        throw { message: 'Invalid query' };\n      }\n\n      const size = (metric.settings && metric.settings.size) || 500;\n      return this.documentQuery(query, size);\n    }\n\n    nestedAggs = query;\n\n    for (i = 0; i < target.bucketAggs.length; i++) {\n      const aggDef: any = target.bucketAggs[i];\n      const esAgg: any = {};\n\n      switch (aggDef.type) {\n        case 'date_histogram': {\n          esAgg['date_histogram'] = this.getDateHistogramAgg(aggDef);\n          break;\n        }\n        case 'histogram': {\n          esAgg['histogram'] = this.getHistogramAgg(aggDef);\n          break;\n        }\n        case 'filters': {\n          esAgg['filters'] = { filters: this.getFiltersAgg(aggDef) };\n          break;\n        }\n        case 'terms': {\n          this.buildTermsAgg(aggDef, esAgg, target);\n          break;\n        }\n        case 'geohash_grid': {\n          esAgg['geohash_grid'] = {\n            field: aggDef.field,\n            precision: aggDef.settings.precision,\n          };\n          break;\n        }\n      }\n\n      nestedAggs.aggs = nestedAggs.aggs || {};\n      nestedAggs.aggs[aggDef.id] = esAgg;\n      nestedAggs = esAgg;\n    }\n\n    nestedAggs.aggs = {};\n\n    for (i = 0; i < target.metrics.length; i++) {\n      metric = target.metrics[i];\n      if (metric.type === 'count') {\n        continue;\n      }\n\n      const aggField: any = {};\n      let metricAgg: any = null;\n\n      if (queryDef.isPipelineAgg(metric.type)) {\n        if (queryDef.isPipelineAggWithMultipleBucketPaths(metric.type)) {\n          if (metric.pipelineVariables) {\n            metricAgg = {\n              buckets_path: {},\n            };\n\n            for (j = 0; j < metric.pipelineVariables.length; j++) {\n              pv = metric.pipelineVariables[j];\n\n              if (pv.name && pv.pipelineAgg && /^\\d*$/.test(pv.pipelineAgg)) {\n                const appliedAgg = queryDef.findMetricById(target.metrics, pv.pipelineAgg);\n                if (appliedAgg) {\n                  if (appliedAgg.type === 'count') {\n                    metricAgg.buckets_path[pv.name] = '_count';\n                  } else {\n                    metricAgg.buckets_path[pv.name] = pv.pipelineAgg;\n                  }\n                }\n              }\n            }\n          } else {\n            continue;\n          }\n        } else {\n          if (metric.pipelineAgg && /^\\d*$/.test(metric.pipelineAgg)) {\n            const appliedAgg = queryDef.findMetricById(target.metrics, metric.pipelineAgg);\n            if (appliedAgg) {\n              if (appliedAgg.type === 'count') {\n                metricAgg = { buckets_path: '_count' };\n              } else {\n                metricAgg = { buckets_path: metric.pipelineAgg };\n              }\n            }\n          } else {\n            continue;\n          }\n        }\n      } else {\n        metricAgg = { field: metric.field };\n      }\n\n      for (const prop in metric.settings) {\n        if (metric.settings.hasOwnProperty(prop) && metric.settings[prop] !== null) {\n          metricAgg[prop] = metric.settings[prop];\n        }\n      }\n\n      aggField[metric.type] = metricAgg;\n      nestedAggs.aggs[metric.id] = aggField;\n    }\n\n    return query;\n  }\n\n  getTermsQuery(queryDef: any) {\n    const query: any = {\n      size: 0,\n      query: {\n        bool: {\n          filter: [{ range: this.getRangeFilter() }],\n        },\n      },\n    };\n\n    if (queryDef.query) {\n      query.query.bool.filter.push({\n        query_string: {\n          analyze_wildcard: true,\n          query: queryDef.query,\n        },\n      });\n    }\n\n    let size = 500;\n    if (queryDef.size) {\n      size = queryDef.size;\n    }\n\n    query.aggs = {\n      '1': {\n        terms: {\n          field: queryDef.field,\n          size: size,\n          order: {},\n        },\n      },\n    };\n\n    // Default behaviour is to order results by { _key: asc }\n    // queryDef.order allows selection of asc/desc\n    // queryDef.orderBy allows selection of doc_count ordering (defaults desc)\n\n    const { orderBy = 'key', order = orderBy === 'doc_count' ? 'desc' : 'asc' } = queryDef;\n\n    if (['asc', 'desc'].indexOf(order) < 0) {\n      throw { message: `Invalid query sort order ${order}` };\n    }\n\n    switch (orderBy) {\n      case 'key':\n      case 'term':\n        const keyname = this.esVersion >= 60 ? '_key' : '_term';\n        query.aggs['1'].terms.order[keyname] = order;\n        break;\n      case 'doc_count':\n        query.aggs['1'].terms.order['_count'] = order;\n        break;\n      default:\n        throw { message: `Invalid query sort type ${orderBy}` };\n    }\n\n    return query;\n  }\n\n  getLogsQuery(target: any, adhocFilters?: any, querystring?: string) {\n    let query: any = {\n      size: 0,\n      query: {\n        bool: {\n          filter: [{ range: this.getRangeFilter() }],\n        },\n      },\n    };\n\n    this.addAdhocFilters(query, adhocFilters);\n\n    if (target.query) {\n      query.query.bool.filter.push({\n        query_string: {\n          analyze_wildcard: true,\n          query: querystring,\n        },\n      });\n    }\n\n    query = this.documentQuery(query, 500);\n\n    return {\n      ...query,\n      aggs: this.build(target, null, querystring).aggs,\n    };\n  }\n}\n","import angular from 'angular';\nimport _ from 'lodash';\nimport {\n  DataSourceApi,\n  DataSourceInstanceSettings,\n  DataQueryRequest,\n  DataQueryResponse,\n  DataFrame,\n  ScopedVars,\n} from '@grafana/data';\nimport { ElasticResponse } from './elastic_response';\nimport { IndexPattern } from './index_pattern';\nimport { ElasticQueryBuilder } from './query_builder';\nimport { toUtc } from '@grafana/data';\nimport * as queryDef from './query_def';\nimport { BackendSrv } from 'app/core/services/backend_srv';\nimport { TemplateSrv } from 'app/features/templating/template_srv';\nimport { TimeSrv } from 'app/features/dashboard/services/TimeSrv';\nimport { DataLinkConfig, ElasticsearchOptions, ElasticsearchQuery } from './types';\n\nexport class ElasticDatasource extends DataSourceApi<ElasticsearchQuery, ElasticsearchOptions> {\n  basicAuth: string;\n  withCredentials: boolean;\n  url: string;\n  name: string;\n  index: string;\n  timeField: string;\n  esVersion: number;\n  interval: string;\n  maxConcurrentShardRequests: number;\n  queryBuilder: ElasticQueryBuilder;\n  indexPattern: IndexPattern;\n  logMessageField?: string;\n  logLevelField?: string;\n  dataLinks: DataLinkConfig[];\n\n  /** @ngInject */\n  constructor(\n    instanceSettings: DataSourceInstanceSettings<ElasticsearchOptions>,\n    private backendSrv: BackendSrv,\n    private templateSrv: TemplateSrv,\n    private timeSrv: TimeSrv\n  ) {\n    super(instanceSettings);\n    this.basicAuth = instanceSettings.basicAuth;\n    this.withCredentials = instanceSettings.withCredentials;\n    this.url = instanceSettings.url;\n    this.name = instanceSettings.name;\n    this.index = instanceSettings.database;\n    const settingsData = instanceSettings.jsonData || ({} as ElasticsearchOptions);\n\n    this.timeField = settingsData.timeField;\n    this.esVersion = settingsData.esVersion;\n    this.indexPattern = new IndexPattern(this.index, settingsData.interval);\n    this.interval = settingsData.timeInterval;\n    this.maxConcurrentShardRequests = settingsData.maxConcurrentShardRequests;\n    this.queryBuilder = new ElasticQueryBuilder({\n      timeField: this.timeField,\n      esVersion: this.esVersion,\n    });\n    this.logMessageField = settingsData.logMessageField || '';\n    this.logLevelField = settingsData.logLevelField || '';\n    this.dataLinks = settingsData.dataLinks || [];\n\n    if (this.logMessageField === '') {\n      this.logMessageField = null;\n    }\n\n    if (this.logLevelField === '') {\n      this.logLevelField = null;\n    }\n  }\n\n  private request(method: string, url: string, data?: undefined) {\n    const options: any = {\n      url: this.url + '/' + url,\n      method: method,\n      data: data,\n    };\n\n    if (this.basicAuth || this.withCredentials) {\n      options.withCredentials = true;\n    }\n    if (this.basicAuth) {\n      options.headers = {\n        Authorization: this.basicAuth,\n      };\n    }\n\n    return this.backendSrv.datasourceRequest(options);\n  }\n\n  private get(url: string) {\n    const range = this.timeSrv.timeRange();\n    const indexList = this.indexPattern.getIndexList(range.from.valueOf(), range.to.valueOf());\n    if (_.isArray(indexList) && indexList.length) {\n      return this.request('GET', indexList[0] + url).then((results: any) => {\n        results.data.$$config = results.config;\n        return results.data;\n      });\n    } else {\n      return this.request('GET', this.indexPattern.getIndexForToday() + url).then((results: any) => {\n        results.data.$$config = results.config;\n        return results.data;\n      });\n    }\n  }\n\n  private post(url: string, data: any) {\n    return this.request('POST', url, data)\n      .then((results: any) => {\n        results.data.$$config = results.config;\n        return results.data;\n      })\n      .catch((err: any) => {\n        if (err.data && err.data.error) {\n          throw {\n            message: 'Elasticsearch error: ' + err.data.error.reason,\n            error: err.data.error,\n          };\n        }\n\n        throw err;\n      });\n  }\n\n  annotationQuery(options: any) {\n    const annotation = options.annotation;\n    const timeField = annotation.timeField || '@timestamp';\n    const timeEndField = annotation.timeEndField || null;\n    const queryString = annotation.query || '*';\n    const tagsField = annotation.tagsField || 'tags';\n    const textField = annotation.textField || null;\n\n    const dateRanges = [];\n    const rangeStart: any = {};\n    rangeStart[timeField] = {\n      from: options.range.from.valueOf(),\n      to: options.range.to.valueOf(),\n      format: 'epoch_millis',\n    };\n    dateRanges.push({ range: rangeStart });\n\n    if (timeEndField) {\n      const rangeEnd: any = {};\n      rangeEnd[timeEndField] = {\n        from: options.range.from.valueOf(),\n        to: options.range.to.valueOf(),\n        format: 'epoch_millis',\n      };\n      dateRanges.push({ range: rangeEnd });\n    }\n\n    const queryInterpolated = this.templateSrv.replace(queryString, {}, 'lucene');\n    const query = {\n      bool: {\n        filter: [\n          {\n            bool: {\n              should: dateRanges,\n              minimum_should_match: 1,\n            },\n          },\n          {\n            query_string: {\n              query: queryInterpolated,\n            },\n          },\n        ],\n      },\n    };\n\n    const data: any = {\n      query,\n      size: 10000,\n    };\n\n    // fields field not supported on ES 5.x\n    if (this.esVersion < 5) {\n      data['fields'] = [timeField, '_source'];\n    }\n\n    const header: any = {\n      search_type: 'query_then_fetch',\n      ignore_unavailable: true,\n    };\n\n    // old elastic annotations had index specified on them\n    if (annotation.index) {\n      header.index = annotation.index;\n    } else {\n      header.index = this.indexPattern.getIndexList(options.range.from, options.range.to);\n    }\n\n    const payload = angular.toJson(header) + '\\n' + angular.toJson(data) + '\\n';\n\n    return this.post('_msearch', payload).then((res: any) => {\n      const list = [];\n      const hits = res.responses[0].hits.hits;\n\n      const getFieldFromSource = (source: any, fieldName: any) => {\n        if (!fieldName) {\n          return;\n        }\n\n        const fieldNames = fieldName.split('.');\n        let fieldValue = source;\n\n        for (let i = 0; i < fieldNames.length; i++) {\n          fieldValue = fieldValue[fieldNames[i]];\n          if (!fieldValue) {\n            console.log('could not find field in annotation: ', fieldName);\n            return '';\n          }\n        }\n\n        return fieldValue;\n      };\n\n      for (let i = 0; i < hits.length; i++) {\n        const source = hits[i]._source;\n        let time = getFieldFromSource(source, timeField);\n        if (typeof hits[i].fields !== 'undefined') {\n          const fields = hits[i].fields;\n          if (_.isString(fields[timeField]) || _.isNumber(fields[timeField])) {\n            time = fields[timeField];\n          }\n        }\n\n        const event: {\n          annotation: any;\n          time: number;\n          timeEnd?: number;\n          text: string;\n          tags: string | string[];\n        } = {\n          annotation: annotation,\n          time: toUtc(time).valueOf(),\n          text: getFieldFromSource(source, textField),\n          tags: getFieldFromSource(source, tagsField),\n        };\n\n        if (timeEndField) {\n          const timeEnd = getFieldFromSource(source, timeEndField);\n          if (timeEnd) {\n            event.timeEnd = toUtc(timeEnd).valueOf();\n          }\n        }\n\n        // legacy support for title tield\n        if (annotation.titleField) {\n          const title = getFieldFromSource(source, annotation.titleField);\n          if (title) {\n            event.text = title + '\\n' + event.text;\n          }\n        }\n\n        if (typeof event.tags === 'string') {\n          event.tags = event.tags.split(',');\n        }\n\n        list.push(event);\n      }\n      return list;\n    });\n  }\n\n  interpolateVariablesInQueries(queries: ElasticsearchQuery[], scopedVars: ScopedVars): ElasticsearchQuery[] {\n    let expandedQueries = queries;\n    if (queries && queries.length > 0) {\n      expandedQueries = queries.map(query => {\n        const expandedQuery = {\n          ...query,\n          datasource: this.name,\n          query: this.templateSrv.replace(query.query, scopedVars, 'lucene'),\n        };\n        return expandedQuery;\n      });\n    }\n    return expandedQueries;\n  }\n\n  testDatasource() {\n    // validate that the index exist and has date field\n    return this.getFields({ type: 'date' }).then(\n      (dateFields: any) => {\n        const timeField: any = _.find(dateFields, { text: this.timeField });\n        if (!timeField) {\n          return {\n            status: 'error',\n            message: 'No date field named ' + this.timeField + ' found',\n          };\n        }\n        return { status: 'success', message: 'Index OK. Time field name OK.' };\n      },\n      (err: any) => {\n        console.log(err);\n        if (err.data && err.data.error) {\n          let message = angular.toJson(err.data.error);\n          if (err.data.error.reason) {\n            message = err.data.error.reason;\n          }\n          return { status: 'error', message: message };\n        } else {\n          return { status: 'error', message: err.status };\n        }\n      }\n    );\n  }\n\n  getQueryHeader(searchType: any, timeFrom: any, timeTo: any) {\n    const queryHeader: any = {\n      search_type: searchType,\n      ignore_unavailable: true,\n      index: this.indexPattern.getIndexList(timeFrom, timeTo),\n    };\n    if (this.esVersion >= 56 && this.esVersion < 70) {\n      queryHeader['max_concurrent_shard_requests'] = this.maxConcurrentShardRequests;\n    }\n    return angular.toJson(queryHeader);\n  }\n\n  query(options: DataQueryRequest<ElasticsearchQuery>): Promise<DataQueryResponse> {\n    let payload = '';\n    const targets = _.cloneDeep(options.targets);\n    const sentTargets: ElasticsearchQuery[] = [];\n\n    // add global adhoc filters to timeFilter\n    const adhocFilters = this.templateSrv.getAdhocFilters(this.name);\n\n    for (const target of targets) {\n      if (target.hide) {\n        continue;\n      }\n\n      let queryString = this.templateSrv.replace(target.query, options.scopedVars, 'lucene');\n      // Elasticsearch queryString should always be '*' if empty string\n      if (!queryString || queryString === '') {\n        queryString = '*';\n      }\n\n      let queryObj;\n      if (target.isLogsQuery || queryDef.hasMetricOfType(target, 'logs')) {\n        target.bucketAggs = [queryDef.defaultBucketAgg()];\n        target.metrics = [queryDef.defaultMetricAgg()];\n        // Setting this for metrics queries that are typed as logs\n        target.isLogsQuery = true;\n        queryObj = this.queryBuilder.getLogsQuery(target, adhocFilters, queryString);\n      } else {\n        if (target.alias) {\n          target.alias = this.templateSrv.replace(target.alias, options.scopedVars, 'lucene');\n        }\n\n        queryObj = this.queryBuilder.build(target, adhocFilters, queryString);\n      }\n\n      const esQuery = angular.toJson(queryObj);\n\n      const searchType = queryObj.size === 0 && this.esVersion < 5 ? 'count' : 'query_then_fetch';\n      const header = this.getQueryHeader(searchType, options.range.from, options.range.to);\n      payload += header + '\\n';\n\n      payload += esQuery + '\\n';\n\n      sentTargets.push(target);\n    }\n\n    if (sentTargets.length === 0) {\n      return Promise.resolve({ data: [] });\n    }\n\n    // We replace the range here for actual values. We need to replace it together with enclosing \"\" so that we replace\n    // it as an integer not as string with digits. This is because elastic will convert the string only if the time\n    // field is specified as type date (which probably should) but can also be specified as integer (millisecond epoch)\n    // and then sending string will error out.\n    payload = payload.replace(/\"\\$timeFrom\"/g, options.range.from.valueOf().toString());\n    payload = payload.replace(/\"\\$timeTo\"/g, options.range.to.valueOf().toString());\n    payload = this.templateSrv.replace(payload, options.scopedVars);\n\n    const url = this.getMultiSearchUrl();\n\n    return this.post(url, payload).then((res: any) => {\n      const er = new ElasticResponse(sentTargets, res);\n      if (sentTargets.some(target => target.isLogsQuery)) {\n        const response = er.getLogs(this.logMessageField, this.logLevelField);\n        for (const dataFrame of response.data) {\n          this.enhanceDataFrame(dataFrame);\n        }\n        return response;\n      }\n\n      return er.getTimeSeries();\n    });\n  }\n\n  getFields(query: any) {\n    const configuredEsVersion = this.esVersion;\n    return this.get('/_mapping').then((result: any) => {\n      const typeMap: any = {\n        float: 'number',\n        double: 'number',\n        integer: 'number',\n        long: 'number',\n        date: 'date',\n        string: 'string',\n        text: 'string',\n        scaled_float: 'number',\n        nested: 'nested',\n      };\n\n      function shouldAddField(obj: any, key: any, query: any) {\n        if (key[0] === '_') {\n          return false;\n        }\n\n        if (!query.type) {\n          return true;\n        }\n\n        // equal query type filter, or via typemap translation\n        return query.type === obj.type || query.type === typeMap[obj.type];\n      }\n\n      // Store subfield names: [system, process, cpu, total] -> system.process.cpu.total\n      const fieldNameParts: any = [];\n      const fields: any = {};\n\n      function getFieldsRecursively(obj: any) {\n        for (const key in obj) {\n          const subObj = obj[key];\n\n          // Check mapping field for nested fields\n          if (_.isObject(subObj.properties)) {\n            fieldNameParts.push(key);\n            getFieldsRecursively(subObj.properties);\n          }\n\n          if (_.isObject(subObj.fields)) {\n            fieldNameParts.push(key);\n            getFieldsRecursively(subObj.fields);\n          }\n\n          if (_.isString(subObj.type)) {\n            const fieldName = fieldNameParts.concat(key).join('.');\n\n            // Hide meta-fields and check field type\n            if (shouldAddField(subObj, key, query)) {\n              fields[fieldName] = {\n                text: fieldName,\n                type: subObj.type,\n              };\n            }\n          }\n        }\n        fieldNameParts.pop();\n      }\n\n      for (const indexName in result) {\n        const index = result[indexName];\n        if (index && index.mappings) {\n          const mappings = index.mappings;\n\n          if (configuredEsVersion < 70) {\n            for (const typeName in mappings) {\n              const properties = mappings[typeName].properties;\n              getFieldsRecursively(properties);\n            }\n          } else {\n            const properties = mappings.properties;\n            getFieldsRecursively(properties);\n          }\n        }\n      }\n\n      // transform to array\n      return _.map(fields, value => {\n        return value;\n      });\n    });\n  }\n\n  getTerms(queryDef: any) {\n    const range = this.timeSrv.timeRange();\n    const searchType = this.esVersion >= 5 ? 'query_then_fetch' : 'count';\n    const header = this.getQueryHeader(searchType, range.from, range.to);\n    let esQuery = angular.toJson(this.queryBuilder.getTermsQuery(queryDef));\n\n    esQuery = esQuery.replace(/\\$timeFrom/g, range.from.valueOf().toString());\n    esQuery = esQuery.replace(/\\$timeTo/g, range.to.valueOf().toString());\n    esQuery = header + '\\n' + esQuery + '\\n';\n\n    const url = this.getMultiSearchUrl();\n\n    return this.post(url, esQuery).then((res: any) => {\n      if (!res.responses[0].aggregations) {\n        return [];\n      }\n\n      const buckets = res.responses[0].aggregations['1'].buckets;\n      return _.map(buckets, bucket => {\n        return {\n          text: bucket.key_as_string || bucket.key,\n          value: bucket.key,\n        };\n      });\n    });\n  }\n\n  getMultiSearchUrl() {\n    if (this.esVersion >= 70 && this.maxConcurrentShardRequests) {\n      return `_msearch?max_concurrent_shard_requests=${this.maxConcurrentShardRequests}`;\n    }\n\n    return '_msearch';\n  }\n\n  metricFindQuery(query: any) {\n    query = angular.fromJson(query);\n    if (!query) {\n      return Promise.resolve([]);\n    }\n\n    if (query.find === 'fields') {\n      query.field = this.templateSrv.replace(query.field, {}, 'lucene');\n      return this.getFields(query);\n    }\n\n    if (query.find === 'terms') {\n      query.field = this.templateSrv.replace(query.field, {}, 'lucene');\n      query.query = this.templateSrv.replace(query.query || '*', {}, 'lucene');\n      return this.getTerms(query);\n    }\n  }\n\n  getTagKeys() {\n    return this.getFields({});\n  }\n\n  getTagValues(options: any) {\n    return this.getTerms({ field: options.key, query: '*' });\n  }\n\n  targetContainsTemplate(target: any) {\n    if (this.templateSrv.variableExists(target.query) || this.templateSrv.variableExists(target.alias)) {\n      return true;\n    }\n\n    for (const bucketAgg of target.bucketAggs) {\n      if (this.templateSrv.variableExists(bucketAgg.field) || this.objectContainsTemplate(bucketAgg.settings)) {\n        return true;\n      }\n    }\n\n    for (const metric of target.metrics) {\n      if (\n        this.templateSrv.variableExists(metric.field) ||\n        this.objectContainsTemplate(metric.settings) ||\n        this.objectContainsTemplate(metric.meta)\n      ) {\n        return true;\n      }\n    }\n\n    return false;\n  }\n\n  enhanceDataFrame(dataFrame: DataFrame) {\n    if (this.dataLinks.length) {\n      for (const field of dataFrame.fields) {\n        const dataLink = this.dataLinks.find(dataLink => field.name && field.name.match(dataLink.field));\n        if (dataLink) {\n          field.config = field.config || {};\n          field.config.links = [\n            ...(field.config.links || []),\n            {\n              url: dataLink.url,\n              title: '',\n            },\n          ];\n        }\n      }\n    }\n  }\n\n  private isPrimitive(obj: any) {\n    if (obj === null || obj === undefined) {\n      return true;\n    }\n    if (['string', 'number', 'boolean'].some(type => type === typeof true)) {\n      return true;\n    }\n\n    return false;\n  }\n\n  private objectContainsTemplate(obj: any) {\n    if (!obj) {\n      return false;\n    }\n\n    for (const key of Object.keys(obj)) {\n      if (this.isPrimitive(obj[key])) {\n        if (this.templateSrv.variableExists(obj[key])) {\n          return true;\n        }\n      } else if (Array.isArray(obj[key])) {\n        for (const item of obj[key]) {\n          if (this.objectContainsTemplate(item)) {\n            return true;\n          }\n        }\n      } else {\n        if (this.objectContainsTemplate(obj[key])) {\n          return true;\n        }\n      }\n    }\n\n    return false;\n  }\n}\n","import coreModule from 'app/core/core_module';\nimport _ from 'lodash';\nimport * as queryDef from './query_def';\nimport { GrafanaRootScope } from 'app/routes/GrafanaCtrl';\nimport { CoreEvents } from 'app/types';\n\nexport class ElasticBucketAggCtrl {\n  /** @ngInject */\n  constructor($scope: any, uiSegmentSrv: any, $rootScope: GrafanaRootScope) {\n    const bucketAggs = $scope.target.bucketAggs;\n\n    $scope.orderByOptions = [];\n\n    $scope.getBucketAggTypes = () => {\n      return queryDef.bucketAggTypes;\n    };\n\n    $scope.getOrderOptions = () => {\n      return queryDef.orderOptions;\n    };\n\n    $scope.getSizeOptions = () => {\n      return queryDef.sizeOptions;\n    };\n\n    $rootScope.onAppEvent(\n      CoreEvents.elasticQueryUpdated,\n      () => {\n        $scope.validateModel();\n      },\n      $scope\n    );\n\n    $scope.init = () => {\n      $scope.agg = bucketAggs[$scope.index];\n      $scope.validateModel();\n    };\n\n    $scope.onChangeInternal = () => {\n      $scope.onChange();\n    };\n\n    $scope.onTypeChanged = () => {\n      $scope.agg.settings = {};\n      $scope.showOptions = false;\n\n      switch ($scope.agg.type) {\n        case 'date_histogram':\n        case 'histogram':\n        case 'terms': {\n          delete $scope.agg.query;\n          $scope.agg.field = 'select field';\n          break;\n        }\n        case 'filters': {\n          delete $scope.agg.field;\n          $scope.agg.query = '*';\n          break;\n        }\n        case 'geohash_grid': {\n          $scope.agg.settings.precision = 3;\n          break;\n        }\n      }\n\n      $scope.validateModel();\n      $scope.onChange();\n    };\n\n    $scope.validateModel = () => {\n      $scope.index = _.indexOf(bucketAggs, $scope.agg);\n      $scope.isFirst = $scope.index === 0;\n      $scope.bucketAggCount = bucketAggs.length;\n\n      let settingsLinkText = '';\n      const settings = $scope.agg.settings || {};\n\n      switch ($scope.agg.type) {\n        case 'terms': {\n          settings.order = settings.order || 'desc';\n          settings.size = settings.size || '10';\n          settings.min_doc_count = settings.min_doc_count || 1;\n          settings.orderBy = settings.orderBy || '_term';\n\n          if (settings.size !== '0') {\n            settingsLinkText = queryDef.describeOrder(settings.order) + ' ' + settings.size + ', ';\n          }\n\n          if (settings.min_doc_count > 0) {\n            settingsLinkText += 'Min Doc Count: ' + settings.min_doc_count + ', ';\n          }\n\n          settingsLinkText += 'Order by: ' + queryDef.describeOrderBy(settings.orderBy, $scope.target);\n\n          if (settings.size === '0') {\n            settingsLinkText += ' (' + settings.order + ')';\n          }\n\n          break;\n        }\n        case 'filters': {\n          settings.filters = settings.filters || [{ query: '*' }];\n          settingsLinkText = _.reduce(\n            settings.filters,\n            (memo, value, index) => {\n              memo += 'Q' + (index + 1) + '  = ' + value.query + ' ';\n              return memo;\n            },\n            ''\n          );\n          if (settingsLinkText.length > 50) {\n            settingsLinkText = settingsLinkText.substr(0, 50) + '...';\n          }\n          settingsLinkText = 'Filter Queries (' + settings.filters.length + ')';\n          break;\n        }\n        case 'date_histogram': {\n          settings.interval = settings.interval || 'auto';\n          settings.min_doc_count = settings.min_doc_count || 0;\n          $scope.agg.field = $scope.target.timeField;\n          settingsLinkText = 'Interval: ' + settings.interval;\n\n          if (settings.min_doc_count > 0) {\n            settingsLinkText += ', Min Doc Count: ' + settings.min_doc_count;\n          }\n\n          if (settings.trimEdges === undefined || settings.trimEdges < 0) {\n            settings.trimEdges = 0;\n          }\n\n          if (settings.trimEdges && settings.trimEdges > 0) {\n            settingsLinkText += ', Trim edges: ' + settings.trimEdges;\n          }\n          break;\n        }\n        case 'histogram': {\n          settings.interval = settings.interval || 1000;\n          settings.min_doc_count = _.defaultTo(settings.min_doc_count, 1);\n          settingsLinkText = 'Interval: ' + settings.interval;\n\n          if (settings.min_doc_count > 0) {\n            settingsLinkText += ', Min Doc Count: ' + settings.min_doc_count;\n          }\n          break;\n        }\n        case 'geohash_grid': {\n          // limit precision to 7\n          settings.precision = Math.max(Math.min(settings.precision, 7), 1);\n          settingsLinkText = 'Precision: ' + settings.precision;\n          break;\n        }\n      }\n\n      $scope.settingsLinkText = settingsLinkText;\n      $scope.agg.settings = settings;\n      return true;\n    };\n\n    $scope.addFiltersQuery = () => {\n      $scope.agg.settings.filters.push({ query: '*' });\n    };\n\n    $scope.removeFiltersQuery = (filter: any) => {\n      $scope.agg.settings.filters = _.without($scope.agg.settings.filters, filter);\n    };\n\n    $scope.toggleOptions = () => {\n      $scope.showOptions = !$scope.showOptions;\n    };\n\n    $scope.getOrderByOptions = () => {\n      return queryDef.getOrderByOptions($scope.target);\n    };\n\n    $scope.getFieldsInternal = () => {\n      if ($scope.agg.type === 'date_histogram') {\n        return $scope.getFields({ $fieldType: 'date' });\n      } else {\n        return $scope.getFields();\n      }\n    };\n\n    $scope.getIntervalOptions = () => {\n      return Promise.resolve(uiSegmentSrv.transformToSegments(true, 'interval')(queryDef.intervalOptions));\n    };\n\n    $scope.addBucketAgg = () => {\n      // if last is date histogram add it before\n      const lastBucket = bucketAggs[bucketAggs.length - 1];\n      let addIndex = bucketAggs.length - 1;\n\n      if (lastBucket && lastBucket.type === 'date_histogram') {\n        addIndex -= 1;\n      }\n\n      const id = _.reduce(\n        $scope.target.bucketAggs.concat($scope.target.metrics),\n        (max, val) => {\n          return parseInt(val.id, 10) > max ? parseInt(val.id, 10) : max;\n        },\n        0\n      );\n\n      bucketAggs.splice(addIndex, 0, { type: 'terms', field: 'select field', id: (id + 1).toString(), fake: true });\n      $scope.onChange();\n    };\n\n    $scope.removeBucketAgg = () => {\n      bucketAggs.splice($scope.index, 1);\n      $scope.onChange();\n    };\n\n    $scope.init();\n  }\n}\n\nexport function elasticBucketAgg() {\n  return {\n    templateUrl: 'public/app/plugins/datasource/elasticsearch/partials/bucket_agg.html',\n    controller: ElasticBucketAggCtrl,\n    restrict: 'E',\n    scope: {\n      target: '=',\n      index: '=',\n      onChange: '&',\n      getFields: '&',\n    },\n  };\n}\n\ncoreModule.directive('elasticBucketAgg', elasticBucketAgg);\n","import coreModule from 'app/core/core_module';\nimport _ from 'lodash';\nimport * as queryDef from './query_def';\nimport { ElasticsearchAggregation } from './types';\nimport { GrafanaRootScope } from 'app/routes/GrafanaCtrl';\nimport { CoreEvents } from 'app/types';\n\nexport class ElasticMetricAggCtrl {\n  /** @ngInject */\n  constructor($scope: any, uiSegmentSrv: any, $rootScope: GrafanaRootScope) {\n    const metricAggs: ElasticsearchAggregation[] = $scope.target.metrics;\n    $scope.metricAggTypes = queryDef.getMetricAggTypes($scope.esVersion);\n    $scope.extendedStats = queryDef.extendedStats;\n    $scope.pipelineAggOptions = [];\n    $scope.modelSettingsValues = {};\n\n    $scope.init = () => {\n      $scope.agg = metricAggs[$scope.index];\n      $scope.validateModel();\n      $scope.updatePipelineAggOptions();\n    };\n\n    $scope.updatePipelineAggOptions = () => {\n      $scope.pipelineAggOptions = queryDef.getPipelineAggOptions($scope.target);\n    };\n\n    $rootScope.onAppEvent(\n      CoreEvents.elasticQueryUpdated,\n      () => {\n        $scope.index = _.indexOf(metricAggs, $scope.agg);\n        $scope.updatePipelineAggOptions();\n        $scope.validateModel();\n      },\n      $scope\n    );\n\n    $scope.validateModel = () => {\n      $scope.isFirst = $scope.index === 0;\n      $scope.isSingle = metricAggs.length === 1;\n      $scope.settingsLinkText = '';\n      $scope.variablesLinkText = '';\n      $scope.aggDef = _.find($scope.metricAggTypes, { value: $scope.agg.type });\n\n      if (queryDef.isPipelineAgg($scope.agg.type)) {\n        if (queryDef.isPipelineAggWithMultipleBucketPaths($scope.agg.type)) {\n          $scope.variablesLinkText = 'Options';\n\n          if ($scope.agg.settings.script) {\n            $scope.variablesLinkText = 'Script: ' + $scope.agg.settings.script.replace(new RegExp('params.', 'g'), '');\n          }\n        } else {\n          $scope.agg.pipelineAgg = $scope.agg.pipelineAgg || 'select metric';\n          $scope.agg.field = $scope.agg.pipelineAgg;\n        }\n\n        const pipelineOptions = queryDef.getPipelineOptions($scope.agg);\n        if (pipelineOptions.length > 0) {\n          _.each(pipelineOptions, opt => {\n            $scope.agg.settings[opt.text] = $scope.agg.settings[opt.text] || opt.default;\n          });\n          $scope.settingsLinkText = 'Options';\n        }\n      } else if (!$scope.agg.field) {\n        $scope.agg.field = 'select field';\n      }\n      switch ($scope.agg.type) {\n        case 'cardinality': {\n          const precisionThreshold = $scope.agg.settings.precision_threshold || '';\n          $scope.settingsLinkText = 'Precision threshold: ' + precisionThreshold;\n          break;\n        }\n        case 'percentiles': {\n          $scope.agg.settings.percents = $scope.agg.settings.percents || [25, 50, 75, 95, 99];\n          $scope.settingsLinkText = 'Values: ' + $scope.agg.settings.percents.join(',');\n          break;\n        }\n        case 'extended_stats': {\n          if (_.keys($scope.agg.meta).length === 0) {\n            $scope.agg.meta.std_deviation_bounds_lower = true;\n            $scope.agg.meta.std_deviation_bounds_upper = true;\n          }\n\n          const stats = _.reduce(\n            $scope.agg.meta,\n            (memo, val, key) => {\n              if (val) {\n                const def: any = _.find($scope.extendedStats, { value: key });\n                memo.push(def.text);\n              }\n              return memo;\n            },\n            []\n          );\n\n          $scope.settingsLinkText = 'Stats: ' + stats.join(', ');\n          break;\n        }\n        case 'moving_avg': {\n          $scope.movingAvgModelTypes = queryDef.movingAvgModelOptions;\n          $scope.modelSettings = queryDef.getMovingAvgSettings($scope.agg.settings.model, true);\n          $scope.updateMovingAvgModelSettings();\n          break;\n        }\n        case 'raw_document': {\n          $scope.agg.settings.size = $scope.agg.settings.size || 500;\n          $scope.settingsLinkText = 'Size: ' + $scope.agg.settings.size;\n          $scope.target.metrics.splice(0, $scope.target.metrics.length, $scope.agg);\n\n          $scope.target.bucketAggs = [];\n          break;\n        }\n      }\n      if ($scope.aggDef.supportsInlineScript) {\n        // I know this stores the inline script twice\n        // but having it like this simplifes the query_builder\n        const inlineScript = $scope.agg.inlineScript;\n        if (inlineScript) {\n          $scope.agg.settings.script = { inline: inlineScript };\n        } else {\n          delete $scope.agg.settings.script;\n        }\n\n        if ($scope.settingsLinkText === '') {\n          $scope.settingsLinkText = 'Options';\n        }\n      }\n    };\n\n    $scope.toggleOptions = () => {\n      $scope.showOptions = !$scope.showOptions;\n      $scope.updatePipelineAggOptions();\n    };\n\n    $scope.toggleVariables = () => {\n      $scope.showVariables = !$scope.showVariables;\n    };\n\n    $scope.onChangeInternal = () => {\n      $scope.onChange();\n    };\n\n    $scope.updateMovingAvgModelSettings = () => {\n      const modelSettingsKeys = [];\n      const modelSettings = queryDef.getMovingAvgSettings($scope.agg.settings.model, false);\n      for (let i = 0; i < modelSettings.length; i++) {\n        modelSettingsKeys.push(modelSettings[i].value);\n      }\n\n      for (const key in $scope.agg.settings.settings) {\n        if ($scope.agg.settings.settings[key] === null || modelSettingsKeys.indexOf(key) === -1) {\n          delete $scope.agg.settings.settings[key];\n        }\n      }\n    };\n\n    $scope.onChangeClearInternal = () => {\n      delete $scope.agg.settings.minimize;\n      $scope.onChange();\n    };\n\n    $scope.onTypeChange = () => {\n      $scope.agg.settings = {};\n      $scope.agg.meta = {};\n      $scope.showOptions = false;\n\n      // reset back to metric/group by query\n      if ($scope.target.bucketAggs.length === 0 && $scope.agg.type !== 'raw_document') {\n        $scope.target.bucketAggs = [queryDef.defaultBucketAgg()];\n      }\n\n      $scope.showVariables = queryDef.isPipelineAggWithMultipleBucketPaths($scope.agg.type);\n      $scope.updatePipelineAggOptions();\n      $scope.onChange();\n    };\n\n    $scope.getFieldsInternal = () => {\n      if ($scope.agg.type === 'cardinality') {\n        return $scope.getFields();\n      }\n      return $scope.getFields({ $fieldType: 'number' });\n    };\n\n    $scope.addMetricAgg = () => {\n      const addIndex = metricAggs.length;\n\n      const id = _.reduce(\n        $scope.target.bucketAggs.concat($scope.target.metrics),\n        (max, val) => {\n          return parseInt(val.id, 10) > max ? parseInt(val.id, 10) : max;\n        },\n        0\n      );\n\n      metricAggs.splice(addIndex, 0, { type: 'count', field: 'select field', id: (id + 1).toString() });\n      $scope.onChange();\n    };\n\n    $scope.removeMetricAgg = () => {\n      metricAggs.splice($scope.index, 1);\n      $scope.onChange();\n    };\n\n    $scope.toggleShowMetric = () => {\n      $scope.agg.hide = !$scope.agg.hide;\n      if (!$scope.agg.hide) {\n        delete $scope.agg.hide;\n      }\n      $scope.onChange();\n    };\n\n    $scope.init();\n  }\n}\n\nexport function elasticMetricAgg() {\n  return {\n    templateUrl: 'public/app/plugins/datasource/elasticsearch/partials/metric_agg.html',\n    controller: ElasticMetricAggCtrl,\n    restrict: 'E',\n    scope: {\n      target: '=',\n      index: '=',\n      onChange: '&',\n      getFields: '&',\n      esVersion: '=',\n    },\n  };\n}\n\ncoreModule.directive('elasticMetricAgg', elasticMetricAgg);\n","import coreModule from 'app/core/core_module';\nimport _ from 'lodash';\n\nexport function elasticPipelineVariables() {\n  return {\n    templateUrl: 'public/app/plugins/datasource/elasticsearch/partials/pipeline_variables.html',\n    controller: 'ElasticPipelineVariablesCtrl',\n    restrict: 'E',\n    scope: {\n      onChange: '&',\n      variables: '=',\n      options: '=',\n    },\n  };\n}\n\nconst newVariable = (index: any) => {\n  return {\n    name: 'var' + index,\n    pipelineAgg: 'select metric',\n  };\n};\n\nexport class ElasticPipelineVariablesCtrl {\n  /** @ngInject */\n  constructor($scope: any) {\n    $scope.variables = $scope.variables || [newVariable(1)];\n\n    $scope.onChangeInternal = () => {\n      $scope.onChange();\n    };\n\n    $scope.add = () => {\n      $scope.variables.push(newVariable($scope.variables.length + 1));\n      $scope.onChange();\n    };\n\n    $scope.remove = (index: number) => {\n      $scope.variables.splice(index, 1);\n      $scope.onChange();\n    };\n  }\n}\n\ncoreModule.directive('elasticPipelineVariables', elasticPipelineVariables);\ncoreModule.controller('ElasticPipelineVariablesCtrl', ElasticPipelineVariablesCtrl);\n","import './bucket_agg';\nimport './metric_agg';\nimport './pipeline_variables';\n\nimport angular, { auto } from 'angular';\nimport _ from 'lodash';\nimport * as queryDef from './query_def';\nimport { QueryCtrl } from 'app/plugins/sdk';\nimport { ElasticsearchAggregation } from './types';\nimport { GrafanaRootScope } from 'app/routes/GrafanaCtrl';\nimport { CoreEvents } from 'app/types';\n\nexport class ElasticQueryCtrl extends QueryCtrl {\n  static templateUrl = 'partials/query.editor.html';\n\n  esVersion: any;\n  rawQueryOld: string;\n\n  /** @ngInject */\n  constructor(\n    $scope: any,\n    $injector: auto.IInjectorService,\n    private $rootScope: GrafanaRootScope,\n    private uiSegmentSrv: any\n  ) {\n    super($scope, $injector);\n\n    this.esVersion = this.datasource.esVersion;\n\n    this.target = this.target || {};\n    this.target.metrics = this.target.metrics || [queryDef.defaultMetricAgg()];\n    this.target.bucketAggs = this.target.bucketAggs || [queryDef.defaultBucketAgg()];\n\n    if (this.target.bucketAggs.length === 0) {\n      const metric = this.target.metrics[0];\n      if (!metric || metric.type !== 'raw_document') {\n        this.target.bucketAggs = [queryDef.defaultBucketAgg()];\n      }\n      this.refresh();\n    }\n\n    this.queryUpdated();\n  }\n\n  getFields(type: any) {\n    const jsonStr = angular.toJson({ find: 'fields', type: type });\n    return this.datasource\n      .metricFindQuery(jsonStr)\n      .then(this.uiSegmentSrv.transformToSegments(false))\n      .catch(this.handleQueryError.bind(this));\n  }\n\n  queryUpdated() {\n    const newJson = angular.toJson(this.datasource.queryBuilder.build(this.target), true);\n    if (this.rawQueryOld && newJson !== this.rawQueryOld) {\n      this.refresh();\n    }\n\n    this.rawQueryOld = newJson;\n    this.$rootScope.appEvent(CoreEvents.elasticQueryUpdated);\n  }\n\n  getCollapsedText() {\n    const metricAggs: ElasticsearchAggregation[] = this.target.metrics;\n    const bucketAggs = this.target.bucketAggs;\n    const metricAggTypes = queryDef.getMetricAggTypes(this.esVersion);\n    const bucketAggTypes = queryDef.bucketAggTypes;\n    let text = '';\n\n    if (this.target.query) {\n      text += 'Query: ' + this.target.query + ', ';\n    }\n\n    text += 'Metrics: ';\n\n    _.each(metricAggs, (metric, index) => {\n      const aggDef: any = _.find(metricAggTypes, { value: metric.type });\n      text += aggDef.text + '(';\n      if (aggDef.requiresField) {\n        text += metric.field;\n      }\n      if (aggDef.supportsMultipleBucketPaths) {\n        text += metric.settings.script.replace(new RegExp('params.', 'g'), '');\n      }\n      text += '), ';\n    });\n\n    _.each(bucketAggs, (bucketAgg: any, index: number) => {\n      if (index === 0) {\n        text += ' Group by: ';\n      }\n\n      const aggDef: any = _.find(bucketAggTypes, { value: bucketAgg.type });\n      text += aggDef.text + '(';\n      if (aggDef.requiresField) {\n        text += bucketAgg.field;\n      }\n      text += '), ';\n    });\n\n    if (this.target.alias) {\n      text += 'Alias: ' + this.target.alias;\n    }\n\n    return text;\n  }\n\n  handleQueryError(err: any): any[] {\n    this.error = err.message || 'Failed to issue metric query';\n    return [];\n  }\n}\n","import _ from 'lodash';\nimport React from 'react';\n\nimport { QueryField, SlatePrism } from '@grafana/ui';\nimport { ExploreQueryFieldProps } from '@grafana/data';\nimport { ElasticDatasource } from '../datasource';\nimport { ElasticsearchOptions, ElasticsearchQuery } from '../types';\n\ninterface Props extends ExploreQueryFieldProps<ElasticDatasource, ElasticsearchQuery, ElasticsearchOptions> {}\n\ninterface State {\n  syntaxLoaded: boolean;\n}\n\nclass ElasticsearchQueryField extends React.PureComponent<Props, State> {\n  plugins: any[];\n\n  constructor(props: Props, context: React.Context<any>) {\n    super(props, context);\n\n    this.plugins = [\n      SlatePrism({\n        onlyIn: (node: any) => node.type === 'code_block',\n        getSyntax: (node: any) => 'lucene',\n      }),\n    ];\n\n    this.state = {\n      syntaxLoaded: false,\n    };\n  }\n\n  componentDidMount() {\n    if (!this.props.query.isLogsQuery) {\n      this.onChangeQuery('', true);\n    }\n  }\n\n  componentWillUnmount() {}\n\n  componentDidUpdate(prevProps: Props) {\n    // if query changed from the outside (i.e. cleared via explore toolbar)\n    if (!this.props.query.isLogsQuery) {\n      this.onChangeQuery('', true);\n    }\n  }\n\n  onChangeQuery = (value: string, override?: boolean) => {\n    // Send text change to parent\n    const { query, onChange, onRunQuery } = this.props;\n    if (onChange) {\n      const nextQuery: ElasticsearchQuery = { ...query, query: value, isLogsQuery: true };\n      onChange(nextQuery);\n\n      if (override && onRunQuery) {\n        onRunQuery();\n      }\n    }\n  };\n\n  render() {\n    const { data, query } = this.props;\n    const { syntaxLoaded } = this.state;\n\n    return (\n      <>\n        <div className=\"gf-form-inline gf-form-inline--nowrap\">\n          <div className=\"gf-form gf-form--grow flex-shrink-1\">\n            <QueryField\n              additionalPlugins={this.plugins}\n              query={query.query}\n              onChange={this.onChangeQuery}\n              onRunQuery={this.props.onRunQuery}\n              placeholder=\"Enter a Lucene query\"\n              portalOrigin=\"elasticsearch\"\n              syntaxLoaded={syntaxLoaded}\n            />\n          </div>\n        </div>\n        {data && data.error ? <div className=\"prom-query-field-info text-error\">{data.error.message}</div> : null}\n      </>\n    );\n  }\n}\n\nexport default ElasticsearchQueryField;\n","import React from 'react';\nimport { EventsWithValidation, FormField, Input, regexValidation, Select } from '@grafana/ui';\nimport { ElasticsearchOptions } from '../types';\nimport { DataSourceSettings, SelectableValue } from '@grafana/data';\n\nconst indexPatternTypes = [\n  { label: 'No pattern', value: 'none' },\n  { label: 'Hourly', value: 'Hourly', example: '[logstash-]YYYY.MM.DD.HH' },\n  { label: 'Daily', value: 'Daily', example: '[logstash-]YYYY.MM.DD' },\n  { label: 'Weekly', value: 'Weekly', example: '[logstash-]GGGG.WW' },\n  { label: 'Monthly', value: 'Monthly', example: '[logstash-]YYYY.MM' },\n  { label: 'Yearly', value: 'Yearly', example: '[logstash-]YYYY' },\n];\n\nconst esVersions = [\n  { label: '2.x', value: 2 },\n  { label: '5.x', value: 5 },\n  { label: '5.6+', value: 56 },\n  { label: '6.0+', value: 60 },\n  { label: '7.0+', value: 70 },\n];\n\ntype Props = {\n  value: DataSourceSettings<ElasticsearchOptions>;\n  onChange: (value: DataSourceSettings<ElasticsearchOptions>) => void;\n};\nexport const ElasticDetails = (props: Props) => {\n  const { value, onChange } = props;\n\n  return (\n    <>\n      <h3 className=\"page-heading\">Elasticsearch details</h3>\n\n      <div className=\"gf-form-group\">\n        <div className=\"gf-form-inline\">\n          <div className=\"gf-form max-width-25\">\n            <FormField\n              labelWidth={10}\n              inputWidth={15}\n              label=\"Index name\"\n              value={value.database || ''}\n              onChange={changeHandler('database', value, onChange)}\n              placeholder={'es-index-name'}\n              required\n            />\n          </div>\n\n          <div className=\"gf-form width-14\">\n            <FormField\n              labelWidth={10}\n              label=\"Pattern\"\n              inputEl={\n                <Select\n                  options={indexPatternTypes}\n                  onChange={intervalHandler(value, onChange)}\n                  value={indexPatternTypes.find(\n                    pattern =>\n                      pattern.value === (value.jsonData.interval === undefined ? 'none' : value.jsonData.interval)\n                  )}\n                />\n              }\n            />\n          </div>\n        </div>\n\n        <div className=\"gf-form max-width-25\">\n          <FormField\n            labelWidth={10}\n            inputWidth={15}\n            label=\"Time field name\"\n            value={value.jsonData.timeField || ''}\n            onChange={jsonDataChangeHandler('timeField', value, onChange)}\n            required\n          />\n        </div>\n\n        <div className=\"gf-form\">\n          <span className=\"gf-form-select-wrapper\">\n            <FormField\n              labelWidth={10}\n              label=\"Version\"\n              inputEl={\n                <Select\n                  options={esVersions}\n                  onChange={option => {\n                    const maxConcurrentShardRequests = getMaxConcurrenShardRequestOrDefault(\n                      value.jsonData.maxConcurrentShardRequests,\n                      option.value\n                    );\n                    onChange({\n                      ...value,\n                      jsonData: {\n                        ...value.jsonData,\n                        esVersion: option.value,\n                        maxConcurrentShardRequests,\n                      },\n                    });\n                  }}\n                  value={esVersions.find(version => version.value === value.jsonData.esVersion)}\n                />\n              }\n            />\n          </span>\n        </div>\n        {value.jsonData.esVersion >= 56 && (\n          <div className=\"gf-form max-width-30\">\n            <FormField\n              aria-label={'Max concurrent Shard Requests input'}\n              labelWidth={15}\n              label=\"Max concurrent Shard Requests\"\n              value={value.jsonData.maxConcurrentShardRequests || ''}\n              onChange={jsonDataChangeHandler('maxConcurrentShardRequests', value, onChange)}\n            />\n          </div>\n        )}\n        <div className=\"gf-form-inline\">\n          <div className=\"gf-form\">\n            <FormField\n              labelWidth={10}\n              label=\"Min time interval\"\n              inputEl={\n                <Input\n                  className={'width-6'}\n                  value={value.jsonData.timeInterval || ''}\n                  onChange={jsonDataChangeHandler('timeInterval', value, onChange)}\n                  placeholder=\"10s\"\n                  validationEvents={{\n                    [EventsWithValidation.onBlur]: [\n                      regexValidation(\n                        /^\\d+(ms|[Mwdhmsy])$/,\n                        'Value is not valid, you can use number with time unit specifier: y, M, w, d, h, m, s'\n                      ),\n                    ],\n                  }}\n                />\n              }\n              tooltip={\n                <>\n                  A lower limit for the auto group by time interval. Recommended to be set to write frequency, for\n                  example <code>1m</code> if your data is written every minute.\n                </>\n              }\n            />\n          </div>\n        </div>\n      </div>\n    </>\n  );\n};\n\nconst changeHandler = (\n  key: keyof DataSourceSettings<ElasticsearchOptions>,\n  value: Props['value'],\n  onChange: Props['onChange']\n) => (event: React.SyntheticEvent<HTMLInputElement | HTMLSelectElement>) => {\n  onChange({\n    ...value,\n    [key]: event.currentTarget.value,\n  });\n};\n\nconst jsonDataChangeHandler = (key: keyof ElasticsearchOptions, value: Props['value'], onChange: Props['onChange']) => (\n  event: React.SyntheticEvent<HTMLInputElement | HTMLSelectElement>\n) => {\n  onChange({\n    ...value,\n    jsonData: {\n      ...value.jsonData,\n      [key]: event.currentTarget.value,\n    },\n  });\n};\n\nconst intervalHandler = (value: Props['value'], onChange: Props['onChange']) => (option: SelectableValue<string>) => {\n  const { database } = value;\n  // If option value is undefined it will send its label instead so we have to convert made up value to undefined here.\n  const newInterval = option.value === 'none' ? undefined : option.value;\n\n  if (!database || database.length === 0 || database.startsWith('[logstash-]')) {\n    let newDatabase = '';\n    if (newInterval !== undefined) {\n      const pattern = indexPatternTypes.find(pattern => pattern.value === newInterval);\n      if (pattern) {\n        newDatabase = pattern.example;\n      }\n    }\n\n    onChange({\n      ...value,\n      database: newDatabase,\n      jsonData: {\n        ...value.jsonData,\n        interval: newInterval,\n      },\n    });\n  } else {\n    onChange({\n      ...value,\n      jsonData: {\n        ...value.jsonData,\n        interval: newInterval,\n      },\n    });\n  }\n};\n\nfunction getMaxConcurrenShardRequestOrDefault(maxConcurrentShardRequests: number, version: number): number {\n  if (maxConcurrentShardRequests === 5 && version < 70) {\n    return 256;\n  }\n\n  if (maxConcurrentShardRequests === 256 && version >= 70) {\n    return 5;\n  }\n\n  return maxConcurrentShardRequests || defaultMaxConcurrentShardRequests(version);\n}\n\nexport function defaultMaxConcurrentShardRequests(version: number) {\n  return version >= 70 ? 5 : 256;\n}\n","import React from 'react';\nimport { FormField } from '@grafana/ui';\nimport { ElasticsearchOptions } from '../types';\n\ntype Props = {\n  value: ElasticsearchOptions;\n  onChange: (value: ElasticsearchOptions) => void;\n};\nexport const LogsConfig = (props: Props) => {\n  const { value, onChange } = props;\n  const changeHandler = (key: keyof ElasticsearchOptions) => (\n    event: React.SyntheticEvent<HTMLInputElement | HTMLSelectElement>\n  ) => {\n    onChange({\n      ...value,\n      [key]: event.currentTarget.value,\n    });\n  };\n\n  return (\n    <>\n      <h3 className=\"page-heading\">Logs</h3>\n\n      <div className=\"gf-form-group\">\n        <div className=\"gf-form max-width-30\">\n          <FormField\n            labelWidth={11}\n            label=\"Message field name\"\n            value={value.logMessageField}\n            onChange={changeHandler('logMessageField')}\n            placeholder=\"_source\"\n          />\n        </div>\n        <div className=\"gf-form max-width-30\">\n          <FormField\n            labelWidth={11}\n            label=\"Level field name\"\n            value={value.logLevelField}\n            onChange={changeHandler('logLevelField')}\n          />\n        </div>\n      </div>\n    </>\n  );\n};\n","import React from 'react';\nimport { css } from 'emotion';\nimport { Button, DataLinkBuiltInVars, stylesFactory, useTheme, VariableOrigin } from '@grafana/ui';\nimport { GrafanaTheme } from '@grafana/data';\nimport { DataLinkConfig } from '../types';\nimport { DataLink } from './DataLink';\n\nconst getStyles = stylesFactory((theme: GrafanaTheme) => ({\n  infoText: css`\n    padding-bottom: ${theme.spacing.md};\n    color: ${theme.colors.textWeak};\n  `,\n  dataLink: css`\n    margin-bottom: ${theme.spacing.sm};\n  `,\n}));\n\ntype Props = {\n  value?: DataLinkConfig[];\n  onChange: (value: DataLinkConfig[]) => void;\n};\nexport const DataLinks = (props: Props) => {\n  const { value, onChange } = props;\n  const theme = useTheme();\n  const styles = getStyles(theme);\n\n  return (\n    <>\n      <h3 className=\"page-heading\">Data links</h3>\n\n      <div className={styles.infoText}>\n        Add links to existing fields. Links will be shown in log row details next to the field value.\n      </div>\n\n      <div className=\"gf-form-group\">\n        {value &&\n          value.map((field, index) => {\n            return (\n              <DataLink\n                className={styles.dataLink}\n                key={index}\n                value={field}\n                onChange={newField => {\n                  const newDataLinks = [...value];\n                  newDataLinks.splice(index, 1, newField);\n                  onChange(newDataLinks);\n                }}\n                onDelete={() => {\n                  const newDataLinks = [...value];\n                  newDataLinks.splice(index, 1);\n                  onChange(newDataLinks);\n                }}\n                suggestions={[\n                  {\n                    value: DataLinkBuiltInVars.valueRaw,\n                    label: 'Raw value',\n                    documentation: 'Raw value of the field',\n                    origin: VariableOrigin.Value,\n                  },\n                ]}\n              />\n            );\n          })}\n        <div>\n          <Button\n            variant={'inverse'}\n            className={css`\n              margin-right: 10px;\n            `}\n            icon=\"fa fa-plus\"\n            onClick={event => {\n              event.preventDefault();\n              const newDataLinks = [...(value || []), { field: '', url: '' }];\n              onChange(newDataLinks);\n            }}\n          >\n            Add\n          </Button>\n        </div>\n      </div>\n    </>\n  );\n};\n","import React, { useEffect } from 'react';\nimport { DataSourceHttpSettings } from '@grafana/ui';\nimport { DataSourcePluginOptionsEditorProps } from '@grafana/data';\nimport { ElasticsearchOptions } from '../types';\nimport { defaultMaxConcurrentShardRequests, ElasticDetails } from './ElasticDetails';\nimport { LogsConfig } from './LogsConfig';\nimport { DataLinks } from './DataLinks';\n\nexport type Props = DataSourcePluginOptionsEditorProps<ElasticsearchOptions>;\nexport const ConfigEditor = (props: Props) => {\n  const { options, onOptionsChange } = props;\n\n  // Apply some defaults on initial render\n  useEffect(() => {\n    const esVersion = options.jsonData.esVersion || 5;\n    onOptionsChange({\n      ...options,\n      jsonData: {\n        ...options.jsonData,\n        timeField: options.jsonData.timeField || '@timestamp',\n        esVersion,\n        maxConcurrentShardRequests:\n          options.jsonData.maxConcurrentShardRequests || defaultMaxConcurrentShardRequests(esVersion),\n        logMessageField: options.jsonData.logMessageField || '',\n        logLevelField: options.jsonData.logLevelField || '',\n      },\n    });\n  }, []);\n\n  return (\n    <>\n      <DataSourceHttpSettings\n        defaultUrl={'http://localhost:9200'}\n        dataSourceConfig={options}\n        showAccessOptions={true}\n        onChange={onOptionsChange}\n      />\n\n      <ElasticDetails value={options} onChange={onOptionsChange} />\n\n      <LogsConfig\n        value={options.jsonData}\n        onChange={newValue =>\n          onOptionsChange({\n            ...options,\n            jsonData: newValue,\n          })\n        }\n      />\n\n      <DataLinks\n        value={options.jsonData.dataLinks}\n        onChange={newValue => {\n          onOptionsChange({\n            ...options,\n            jsonData: {\n              ...options.jsonData,\n              dataLinks: newValue,\n            },\n          });\n        }}\n      />\n    </>\n  );\n};\n","import React from 'react';\nimport { css } from 'emotion';\nimport { Button, FormField, VariableSuggestion, DataLinkInput, stylesFactory } from '@grafana/ui';\nimport { DataLinkConfig } from '../types';\n\nconst getStyles = stylesFactory(() => ({\n  firstRow: css`\n    display: flex;\n  `,\n  nameField: css`\n    flex: 2;\n  `,\n  regexField: css`\n    flex: 3;\n  `,\n}));\n\ntype Props = {\n  value: DataLinkConfig;\n  onChange: (value: DataLinkConfig) => void;\n  onDelete: () => void;\n  suggestions: VariableSuggestion[];\n  className?: string;\n};\nexport const DataLink = (props: Props) => {\n  const { value, onChange, onDelete, suggestions, className } = props;\n  const styles = getStyles();\n\n  const handleChange = (field: keyof typeof value) => (event: React.ChangeEvent<HTMLInputElement>) => {\n    onChange({\n      ...value,\n      [field]: event.currentTarget.value,\n    });\n  };\n\n  return (\n    <div className={className}>\n      <div className={styles.firstRow}>\n        <FormField\n          className={styles.nameField}\n          labelWidth={6}\n          // A bit of a hack to prevent using default value for the width from FormField\n          inputWidth={null}\n          label=\"Field\"\n          type=\"text\"\n          value={value.field}\n          tooltip={'Can be exact field name or a regex pattern that will match on the field name.'}\n          onChange={handleChange('field')}\n        />\n        <Button\n          variant={'inverse'}\n          title=\"Remove field\"\n          icon={'fa fa-times'}\n          onClick={event => {\n            event.preventDefault();\n            onDelete();\n          }}\n        />\n      </div>\n\n      <FormField\n        label=\"URL\"\n        labelWidth={6}\n        inputEl={\n          <DataLinkInput\n            placeholder={'http://example.com/${__value.raw}'}\n            value={value.url || ''}\n            onChange={newValue =>\n              onChange({\n                ...value,\n                url: newValue,\n              })\n            }\n            suggestions={suggestions}\n          />\n        }\n        className={css`\n          width: 100%;\n        `}\n      />\n    </div>\n  );\n};\n","import { DataSourcePlugin } from '@grafana/data';\nimport { ElasticDatasource } from './datasource';\nimport { ElasticQueryCtrl } from './query_ctrl';\nimport ElasticsearchQueryField from './components/ElasticsearchQueryField';\nimport { ConfigEditor } from './configuration/ConfigEditor';\n\nclass ElasticAnnotationsQueryCtrl {\n  static templateUrl = 'partials/annotations.editor.html';\n}\n\nexport const plugin = new DataSourcePlugin(ElasticDatasource)\n  .setQueryCtrl(ElasticQueryCtrl)\n  .setConfigEditor(ConfigEditor)\n  .setExploreLogsQueryField(ElasticsearchQueryField)\n  .setAnnotationQueryCtrl(ElasticAnnotationsQueryCtrl);\n"],"sourceRoot":""}