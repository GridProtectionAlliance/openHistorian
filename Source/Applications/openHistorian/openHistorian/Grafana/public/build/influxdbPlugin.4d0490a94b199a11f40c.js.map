{"version":3,"sources":["webpack:///./public/app/plugins/datasource/influxdb/influx_series.ts","webpack:///./public/app/plugins/datasource/influxdb/query_part.ts","webpack:///./public/app/plugins/datasource/influxdb/influx_query_model.ts","webpack:///./public/app/plugins/datasource/influxdb/response_parser.ts","webpack:///./public/app/features/explore/AdHocFilter.tsx","webpack:///./public/app/plugins/datasource/influxdb/query_builder.ts","webpack:///./public/app/plugins/datasource/influxdb/datasource.ts","webpack:///./public/app/plugins/datasource/influxdb/query_ctrl.ts","webpack:///./public/app/features/explore/AdHocFilterField.tsx","webpack:///./public/app/plugins/datasource/influxdb/components/InfluxLogsQueryField.tsx","webpack:///./public/app/plugins/datasource/influxdb/components/InfluxCheatSheet.tsx","webpack:///./public/app/plugins/datasource/influxdb/components/InfluxStartPage.tsx","webpack:///./public/app/plugins/datasource/influxdb/components/ConfigEditor.tsx","webpack:///./public/app/plugins/datasource/influxdb/module.ts"],"names":["InfluxSeries","options","this","series","alias","annotation","prototype","getTimeSeries","i","j","_this","output","length","lodash_default","a","each","columns","tags","map","value","key","seriesName","name","columnName","_getSeriesName","join","datapoints","values","push","target","index","segments","split","replace","match","g1","g2","group","segIndex","parseInt","isNaN","indexOf","tag","getAnnotations","list","titleCol","timeCol","tagsCol","textCol","column","titleColumn","includes","tagsColumn","textColumn","data","time","Date","title","flatten","filter","t","text","getTable","table","table_model","seriesIndex","type","src","keys","reordered","hasOwnProperty","rows","query_part_index","query_part_categories","Aggregations","Selectors","Transformations","Predictors","Math","Aliasing","Fields","createPart","part","def","message","query_part","register","category","groupByTimeFunctions","fieldRenderer","innerExpr","params","replaceAggregationAddStrategy","selectParts","partModel","morePartsAvailable","splice","addTransformationStrategy","addStrategy","query","parts","clone","selectModels","dynamicLookup","defaultParams","renderer","partCount","quote","renderMode","influxdb_query_part","create","getCategories","replaceAggregationAdd","InfluxQueryModel","templateSrv","scopedVars","policy","resultFormat","orderByTime","groupBy","select","updateProjection","$inject","groupByParts","updatePersistedParts","hasGroupByTime","find","g","hasFill","addGroupBy","stringParts","typePart","arg","removeGroupByPart","categories","s","removeSelect","removeSelectPart","modelsIndex","partIndex","addSelectPart","renderTagCondition","interpolate","str","operator","condition","test","getMeasurementAndPolicy","measurement","interpolateQueryStr","variable","defaultFormatFn","multi","includeAll","kbn","regexEscape","render","rawQuery","y","selectText","conditions","groupBySection","fill","limit","slimit","tz","renderAdhocFilters","filters","response_parser","ResponseParser","parse","results","influxResults","normalizedQuery","toLowerCase","isValueFirst","res","serie","isArray","addUnique","undefined","toString","arr","ChangeType","query_builder_InfluxQueryBuilder","InfluxQueryBuilder","database","buildExploreQuery","withKey","withMeasurementFilter","whereConditions","reduce","memo","_super","InfluxDatasource","instanceSettings","backendSrv","call","urls","url","trim","username","password","basicAuth","withCredentials","settingsData","jsonData","interval","timeInterval","responseParser","Object","tslib_es6","queryModel","timeFilter","getTimeFilter","targets","cloneDeep","queryTargets","hide","__interval","influx_query_model","acc","current","allQueries","Promise","resolve","adhocFilters","getAdhocFilters","_seriesQuery","then","seriesList","result","influxSeries","influx_series","timeSeries","annotationQuery","reject","rangeRaw","timezone","e_1","_a","e_2","_b","_d","_e","_f","next","done","param","variableExists","error","interpolateVariablesInQueries","queries","expandedQueries","expandedQuery","datasource","expandedTags","metricFindQuery","interpolated","curry","getTagKeys","getTagValues","range","_influxRequest","httpMode","q","epoch","serializeParams","encodeURIComponent","testDatasource","get","status","catch","err","method","currentUrl","shift","u","p","db","has","extend","omit","pick","req","precision","inspect","paramSerializer","headers","Authorization","datasourceRequest","config","statusText","from","getInfluxTime","until","to","fromIsAbsolute","date","roundUp","isString","exec","valueOf","query_ctrl_InfluxQueryCtrl","InfluxQueryCtrl","$scope","$injector","uiSegmentSrv","panel","queryBuilder","groupBySegment","newPlusButton","resultFormats","policySegment","newSegment","measurementSegment","newSelectMeasurement","_c","tagSegments","newCondition","newKey","fixTagSegments","buildSelectMenu","removeTagFilterSegment","removeOrderByTime","cat","submenu","item","menu","getGroupByOptions","tags_1","tags_1_1","handleQueryError","bind","groupByAction","plusButton","html","panelCtrl","refresh","subitem","handleSelectPartEvent","evt","fieldsQuery","transformToSegments","handleGroupByPartEvent","tagsQuery","count","lastSegment","max","measurementChanged","getPolicySegments","policiesQuery","policyChanged","toggleEditorMode","console","log","getMeasurements","measurementFilter","segment","expandable","variables","unshift","e_3","getTagsOrValues","addTemplateVars","nextValue","newOperators","angular_default","copy","getFieldSegments","tagSegmentUpdated","newOperator","newFake","cssClass","rebuildTargetTagConditions","tagIndex","segment2","getTagValueOperator","tagOperator","tagValue","getCollapsedText","templateUrl","AdHocFilter","props","react","grafana_ui_src","styles","keyValueContainer","index_esm","templateObject_1","changeType","onKeyChanged","onValueChanged","onOperatorChanged","Key","Operator","Value","stringToOption","label","initialKey","keysPlaceHolder","initialOperator","initialValue","valuesPlaceHolder","keysAsOptions","selectedKey","option","valuesAsOptions","selectedValue","operatorsAsOptions","selectedOperator","react_default","createElement","className","isSearchable","onChange","placeholder","DEFAULT_REMOVE_FILTER_VALUE","addFilterButton","onAddFilter","onClick","AdHocFilterField","extendedOptions","sent","onPairsChanged_1","onPairsChanged","loadTagValues","setState","pairs","pairs_1","updatePairs","state","loadTagKeys","allPairs","pair","pairIndex","componentDidUpdate","prevProps","isEqual","pairs_2","newPairs","newPair","Fragment","adHocKey","concat","InfluxLogsQueryField","apply","arguments","field","every","allDefined","allEmpty","pairsAreValid","trys","measureMentsQuery","influxMeasurements","measurementObj","queryBuilder_1","influxFields","children","measurements","cascadeText","getChooserText","disabled","hasMeasurement","onMeasurementsChange","AdHocFilterField_AdHocFilterField","InfluxCheatSheet","InfluxStartPage","onClickExample","httpModes","components_ConfigEditor","ConfigEditor","onOptionsChange","secureJsonFields","secureJsonData","showAccessOptions","dataSourceConfig","defaultUrl","user","isConfigured","labelWidth","inputWidth","onReset","onResetPassword","tooltip","defaultValue","__webpack_require__","d","__webpack_exports__","module_plugin","InfluxAnnotationsQueryCtrl","influxdb_datasource","setConfigEditor","setQueryCtrl"],"mappings":"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","file":"influxdbPlugin.4d0490a94b199a11f40c.js","sourcesContent":["import _ from 'lodash';\nimport TableModel from 'app/core/table_model';\nimport { FieldType } from '@grafana/data';\n\nexport default class InfluxSeries {\n  series: any;\n  alias: any;\n  annotation: any;\n\n  constructor(options: { series: any; alias?: any; annotation?: any }) {\n    this.series = options.series;\n    this.alias = options.alias;\n    this.annotation = options.annotation;\n  }\n\n  getTimeSeries() {\n    const output: any[] = [];\n    let i, j;\n\n    if (this.series.length === 0) {\n      return output;\n    }\n\n    _.each(this.series, series => {\n      const columns = series.columns.length;\n      const tags = _.map(series.tags, (value, key) => {\n        return key + ': ' + value;\n      });\n\n      for (j = 1; j < columns; j++) {\n        let seriesName = series.name;\n        const columnName = series.columns[j];\n        if (columnName !== 'value') {\n          seriesName = seriesName + '.' + columnName;\n        }\n\n        if (this.alias) {\n          seriesName = this._getSeriesName(series, j);\n        } else if (series.tags) {\n          seriesName = seriesName + ' {' + tags.join(', ') + '}';\n        }\n\n        const datapoints = [];\n        if (series.values) {\n          for (i = 0; i < series.values.length; i++) {\n            datapoints[i] = [series.values[i][j], series.values[i][0]];\n          }\n        }\n\n        output.push({ target: seriesName, datapoints: datapoints });\n      }\n    });\n\n    return output;\n  }\n\n  _getSeriesName(series: any, index: number) {\n    const regex = /\\$(\\w+)|\\[\\[([\\s\\S]+?)\\]\\]/g;\n    const segments = series.name.split('.');\n\n    return this.alias.replace(regex, (match: any, g1: any, g2: any) => {\n      const group = g1 || g2;\n      const segIndex = parseInt(group, 10);\n\n      if (group === 'm' || group === 'measurement') {\n        return series.name;\n      }\n      if (group === 'col') {\n        return series.columns[index];\n      }\n      if (!isNaN(segIndex)) {\n        return segments[segIndex];\n      }\n      if (group.indexOf('tag_') !== 0) {\n        return match;\n      }\n\n      const tag = group.replace('tag_', '');\n      if (!series.tags) {\n        return match;\n      }\n      return series.tags[tag];\n    });\n  }\n\n  getAnnotations() {\n    const list: any[] = [];\n\n    _.each(this.series, series => {\n      let titleCol: any = null;\n      let timeCol: any = null;\n      const tagsCol: any = [];\n      let textCol: any = null;\n\n      _.each(series.columns, (column, index) => {\n        if (column === 'time') {\n          timeCol = index;\n          return;\n        }\n        if (column === 'sequence_number') {\n          return;\n        }\n        if (column === this.annotation.titleColumn) {\n          titleCol = index;\n          return;\n        }\n        if (_.includes((this.annotation.tagsColumn || '').replace(' ', '').split(','), column)) {\n          tagsCol.push(index);\n          return;\n        }\n        if (column === this.annotation.textColumn) {\n          textCol = index;\n          return;\n        }\n        // legacy case\n        if (!titleCol && textCol !== index) {\n          titleCol = index;\n        }\n      });\n\n      _.each(series.values, value => {\n        const data = {\n          annotation: this.annotation,\n          time: +new Date(value[timeCol]),\n          title: value[titleCol],\n          // Remove empty values, then split in different tags for comma separated values\n          tags: _.flatten(\n            tagsCol\n              .filter((t: any) => {\n                return value[t];\n              })\n              .map((t: any) => {\n                return value[t].split(',');\n              })\n          ),\n          text: value[textCol],\n        };\n\n        list.push(data);\n      });\n    });\n\n    return list;\n  }\n\n  getTable() {\n    const table = new TableModel();\n    let i, j;\n\n    if (this.series.length === 0) {\n      return table;\n    }\n\n    _.each(this.series, (series: any, seriesIndex: number) => {\n      if (seriesIndex === 0) {\n        j = 0;\n        // Check that the first column is indeed 'time'\n        if (series.columns[0] === 'time') {\n          // Push this now before the tags and with the right type\n          table.columns.push({ text: 'Time', type: FieldType.time });\n          j++;\n        }\n        _.each(_.keys(series.tags), key => {\n          table.columns.push({ text: key });\n        });\n        for (; j < series.columns.length; j++) {\n          table.columns.push({ text: series.columns[j] });\n        }\n      }\n\n      if (series.values) {\n        for (i = 0; i < series.values.length; i++) {\n          const values = series.values[i];\n          const reordered = [values[0]];\n          if (series.tags) {\n            for (const key in series.tags) {\n              if (series.tags.hasOwnProperty(key)) {\n                reordered.push(series.tags[key]);\n              }\n            }\n          }\n          for (j = 1; j < values.length; j++) {\n            reordered.push(values[j]);\n          }\n          table.rows.push(reordered);\n        }\n      }\n    });\n\n    return table;\n  }\n}\n","import _ from 'lodash';\nimport { QueryPartDef, QueryPart, functionRenderer, suffixRenderer } from 'app/core/components/query_part/query_part';\n\nconst index: any[] = [];\nconst categories: any = {\n  Aggregations: [],\n  Selectors: [],\n  Transformations: [],\n  Predictors: [],\n  Math: [],\n  Aliasing: [],\n  Fields: [],\n};\n\nfunction createPart(part: any): any {\n  const def = index[part.type];\n  if (!def) {\n    throw { message: 'Could not find query part ' + part.type };\n  }\n\n  return new QueryPart(part, def);\n}\n\nfunction register(options: any) {\n  index[options.type] = new QueryPartDef(options);\n  options.category.push(index[options.type]);\n}\n\nconst groupByTimeFunctions: any[] = [];\n\nfunction aliasRenderer(part: { params: string[] }, innerExpr: string) {\n  return innerExpr + ' AS ' + '\"' + part.params[0] + '\"';\n}\n\nfunction fieldRenderer(part: { params: string[] }, innerExpr: any) {\n  if (part.params[0] === '*') {\n    return '*';\n  }\n  return '\"' + part.params[0] + '\"';\n}\n\nfunction replaceAggregationAddStrategy(selectParts: any[], partModel: { def: { type: string } }) {\n  // look for existing aggregation\n  for (let i = 0; i < selectParts.length; i++) {\n    const part = selectParts[i];\n    if (part.def.category === categories.Aggregations) {\n      if (part.def.type === partModel.def.type) {\n        return;\n      }\n      // count distinct is allowed\n      if (part.def.type === 'count' && partModel.def.type === 'distinct') {\n        break;\n      }\n      // remove next aggregation if distinct was replaced\n      if (part.def.type === 'distinct') {\n        const morePartsAvailable = selectParts.length >= i + 2;\n        if (partModel.def.type !== 'count' && morePartsAvailable) {\n          const nextPart = selectParts[i + 1];\n          if (nextPart.def.category === categories.Aggregations) {\n            selectParts.splice(i + 1, 1);\n          }\n        } else if (partModel.def.type === 'count') {\n          if (!morePartsAvailable || selectParts[i + 1].def.type !== 'count') {\n            selectParts.splice(i + 1, 0, partModel);\n          }\n          return;\n        }\n      }\n      selectParts[i] = partModel;\n      return;\n    }\n    if (part.def.category === categories.Selectors) {\n      selectParts[i] = partModel;\n      return;\n    }\n  }\n\n  selectParts.splice(1, 0, partModel);\n}\n\nfunction addTransformationStrategy(selectParts: any[], partModel: any) {\n  let i;\n  // look for index to add transformation\n  for (i = 0; i < selectParts.length; i++) {\n    const part = selectParts[i];\n    if (part.def.category === categories.Math || part.def.category === categories.Aliasing) {\n      break;\n    }\n  }\n\n  selectParts.splice(i, 0, partModel);\n}\n\nfunction addMathStrategy(selectParts: any[], partModel: any) {\n  const partCount = selectParts.length;\n  if (partCount > 0) {\n    // if last is math, replace it\n    if (selectParts[partCount - 1].def.type === 'math') {\n      selectParts[partCount - 1] = partModel;\n      return;\n    }\n    // if next to last is math, replace it\n    if (partCount > 1 && selectParts[partCount - 2].def.type === 'math') {\n      selectParts[partCount - 2] = partModel;\n      return;\n    } else if (selectParts[partCount - 1].def.type === 'alias') {\n      // if last is alias add it before\n      selectParts.splice(partCount - 1, 0, partModel);\n      return;\n    }\n  }\n  selectParts.push(partModel);\n}\n\nfunction addAliasStrategy(selectParts: any[], partModel: any) {\n  const partCount = selectParts.length;\n  if (partCount > 0) {\n    // if last is alias, replace it\n    if (selectParts[partCount - 1].def.type === 'alias') {\n      selectParts[partCount - 1] = partModel;\n      return;\n    }\n  }\n  selectParts.push(partModel);\n}\n\nfunction addFieldStrategy(selectParts: any, partModel: any, query: { selectModels: any[][] }) {\n  // copy all parts\n  const parts = _.map(selectParts, (part: any) => {\n    return createPart({ type: part.def.type, params: _.clone(part.params) });\n  });\n\n  query.selectModels.push(parts);\n}\n\nregister({\n  type: 'field',\n  addStrategy: addFieldStrategy,\n  category: categories.Fields,\n  params: [{ type: 'field', dynamicLookup: true }],\n  defaultParams: ['value'],\n  renderer: fieldRenderer,\n});\n\n// Aggregations\nregister({\n  type: 'count',\n  addStrategy: replaceAggregationAddStrategy,\n  category: categories.Aggregations,\n  params: [],\n  defaultParams: [],\n  renderer: functionRenderer,\n});\n\nregister({\n  type: 'distinct',\n  addStrategy: replaceAggregationAddStrategy,\n  category: categories.Aggregations,\n  params: [],\n  defaultParams: [],\n  renderer: functionRenderer,\n});\n\nregister({\n  type: 'integral',\n  addStrategy: replaceAggregationAddStrategy,\n  category: categories.Aggregations,\n  params: [],\n  defaultParams: [],\n  renderer: functionRenderer,\n});\n\nregister({\n  type: 'mean',\n  addStrategy: replaceAggregationAddStrategy,\n  category: categories.Aggregations,\n  params: [],\n  defaultParams: [],\n  renderer: functionRenderer,\n});\n\nregister({\n  type: 'median',\n  addStrategy: replaceAggregationAddStrategy,\n  category: categories.Aggregations,\n  params: [],\n  defaultParams: [],\n  renderer: functionRenderer,\n});\n\nregister({\n  type: 'mode',\n  addStrategy: replaceAggregationAddStrategy,\n  category: categories.Aggregations,\n  params: [],\n  defaultParams: [],\n  renderer: functionRenderer,\n});\n\nregister({\n  type: 'sum',\n  addStrategy: replaceAggregationAddStrategy,\n  category: categories.Aggregations,\n  params: [],\n  defaultParams: [],\n  renderer: functionRenderer,\n});\n\n// transformations\n\nregister({\n  type: 'derivative',\n  addStrategy: addTransformationStrategy,\n  category: categories.Transformations,\n  params: [\n    {\n      name: 'duration',\n      type: 'interval',\n      options: ['1s', '10s', '1m', '5m', '10m', '15m', '1h'],\n    },\n  ],\n  defaultParams: ['10s'],\n  renderer: functionRenderer,\n});\n\nregister({\n  type: 'spread',\n  addStrategy: addTransformationStrategy,\n  category: categories.Transformations,\n  params: [],\n  defaultParams: [],\n  renderer: functionRenderer,\n});\n\nregister({\n  type: 'non_negative_derivative',\n  addStrategy: addTransformationStrategy,\n  category: categories.Transformations,\n  params: [\n    {\n      name: 'duration',\n      type: 'interval',\n      options: ['1s', '10s', '1m', '5m', '10m', '15m', '1h'],\n    },\n  ],\n  defaultParams: ['10s'],\n  renderer: functionRenderer,\n});\n\nregister({\n  type: 'difference',\n  addStrategy: addTransformationStrategy,\n  category: categories.Transformations,\n  params: [],\n  defaultParams: [],\n  renderer: functionRenderer,\n});\n\nregister({\n  type: 'non_negative_difference',\n  addStrategy: addTransformationStrategy,\n  category: categories.Transformations,\n  params: [],\n  defaultParams: [],\n  renderer: functionRenderer,\n});\n\nregister({\n  type: 'moving_average',\n  addStrategy: addTransformationStrategy,\n  category: categories.Transformations,\n  params: [{ name: 'window', type: 'int', options: [5, 10, 20, 30, 40] }],\n  defaultParams: [10],\n  renderer: functionRenderer,\n});\n\nregister({\n  type: 'cumulative_sum',\n  addStrategy: addTransformationStrategy,\n  category: categories.Transformations,\n  params: [],\n  defaultParams: [],\n  renderer: functionRenderer,\n});\n\nregister({\n  type: 'stddev',\n  addStrategy: addTransformationStrategy,\n  category: categories.Transformations,\n  params: [],\n  defaultParams: [],\n  renderer: functionRenderer,\n});\n\nregister({\n  type: 'time',\n  category: groupByTimeFunctions,\n  params: [\n    {\n      name: 'interval',\n      type: 'time',\n      options: ['$__interval', '1s', '10s', '1m', '5m', '10m', '15m', '1h'],\n    },\n  ],\n  defaultParams: ['$__interval'],\n  renderer: functionRenderer,\n});\n\nregister({\n  type: 'fill',\n  category: groupByTimeFunctions,\n  params: [\n    {\n      name: 'fill',\n      type: 'string',\n      options: ['none', 'null', '0', 'previous', 'linear'],\n    },\n  ],\n  defaultParams: ['null'],\n  renderer: functionRenderer,\n});\n\nregister({\n  type: 'elapsed',\n  addStrategy: addTransformationStrategy,\n  category: categories.Transformations,\n  params: [\n    {\n      name: 'duration',\n      type: 'interval',\n      options: ['1s', '10s', '1m', '5m', '10m', '15m', '1h'],\n    },\n  ],\n  defaultParams: ['10s'],\n  renderer: functionRenderer,\n});\n\n// predictions\nregister({\n  type: 'holt_winters',\n  addStrategy: addTransformationStrategy,\n  category: categories.Predictors,\n  params: [\n    { name: 'number', type: 'int', options: [5, 10, 20, 30, 40] },\n    { name: 'season', type: 'int', options: [0, 1, 2, 5, 10] },\n  ],\n  defaultParams: [10, 2],\n  renderer: functionRenderer,\n});\n\nregister({\n  type: 'holt_winters_with_fit',\n  addStrategy: addTransformationStrategy,\n  category: categories.Predictors,\n  params: [\n    { name: 'number', type: 'int', options: [5, 10, 20, 30, 40] },\n    { name: 'season', type: 'int', options: [0, 1, 2, 5, 10] },\n  ],\n  defaultParams: [10, 2],\n  renderer: functionRenderer,\n});\n\n// Selectors\nregister({\n  type: 'bottom',\n  addStrategy: replaceAggregationAddStrategy,\n  category: categories.Selectors,\n  params: [{ name: 'count', type: 'int' }],\n  defaultParams: [3],\n  renderer: functionRenderer,\n});\n\nregister({\n  type: 'first',\n  addStrategy: replaceAggregationAddStrategy,\n  category: categories.Selectors,\n  params: [],\n  defaultParams: [],\n  renderer: functionRenderer,\n});\n\nregister({\n  type: 'last',\n  addStrategy: replaceAggregationAddStrategy,\n  category: categories.Selectors,\n  params: [],\n  defaultParams: [],\n  renderer: functionRenderer,\n});\n\nregister({\n  type: 'max',\n  addStrategy: replaceAggregationAddStrategy,\n  category: categories.Selectors,\n  params: [],\n  defaultParams: [],\n  renderer: functionRenderer,\n});\n\nregister({\n  type: 'min',\n  addStrategy: replaceAggregationAddStrategy,\n  category: categories.Selectors,\n  params: [],\n  defaultParams: [],\n  renderer: functionRenderer,\n});\n\nregister({\n  type: 'percentile',\n  addStrategy: replaceAggregationAddStrategy,\n  category: categories.Selectors,\n  params: [{ name: 'nth', type: 'int' }],\n  defaultParams: [95],\n  renderer: functionRenderer,\n});\n\nregister({\n  type: 'top',\n  addStrategy: replaceAggregationAddStrategy,\n  category: categories.Selectors,\n  params: [{ name: 'count', type: 'int' }],\n  defaultParams: [3],\n  renderer: functionRenderer,\n});\n\nregister({\n  type: 'tag',\n  category: groupByTimeFunctions,\n  params: [{ name: 'tag', type: 'string', dynamicLookup: true }],\n  defaultParams: ['tag'],\n  renderer: fieldRenderer,\n});\n\nregister({\n  type: 'math',\n  addStrategy: addMathStrategy,\n  category: categories.Math,\n  params: [{ name: 'expr', type: 'string' }],\n  defaultParams: [' / 100'],\n  renderer: suffixRenderer,\n});\n\nregister({\n  type: 'alias',\n  addStrategy: addAliasStrategy,\n  category: categories.Aliasing,\n  params: [{ name: 'name', type: 'string', quote: 'double' }],\n  defaultParams: ['alias'],\n  renderMode: 'suffix',\n  renderer: aliasRenderer,\n});\n\nexport default {\n  create: createPart,\n  getCategories: () => {\n    return categories;\n  },\n  replaceAggregationAdd: replaceAggregationAddStrategy,\n};\n","import _ from 'lodash';\nimport queryPart from './query_part';\nimport kbn from 'app/core/utils/kbn';\nimport { InfluxQuery, InfluxQueryTag } from './types';\nimport { ScopedVars } from '@grafana/data';\nimport { TemplateSrv } from 'app/features/templating/template_srv';\n\nexport default class InfluxQueryModel {\n  target: InfluxQuery;\n  selectModels: any[];\n  queryBuilder: any;\n  groupByParts: any;\n  templateSrv: any;\n  scopedVars: any;\n  refId: string;\n\n  /** @ngInject */\n  constructor(target: InfluxQuery, templateSrv?: TemplateSrv, scopedVars?: ScopedVars) {\n    this.target = target;\n    this.templateSrv = templateSrv;\n    this.scopedVars = scopedVars;\n\n    target.policy = target.policy || 'default';\n    target.resultFormat = target.resultFormat || 'time_series';\n    target.orderByTime = target.orderByTime || 'ASC';\n    target.tags = target.tags || [];\n    target.groupBy = target.groupBy || [\n      { type: 'time', params: ['$__interval'] },\n      { type: 'fill', params: ['null'] },\n    ];\n    target.select = target.select || [\n      [\n        { type: 'field', params: ['value'] },\n        { type: 'mean', params: [] },\n      ],\n    ];\n\n    this.updateProjection();\n  }\n\n  updateProjection() {\n    this.selectModels = _.map(this.target.select, (parts: any) => {\n      return _.map(parts, queryPart.create);\n    });\n    this.groupByParts = _.map(this.target.groupBy, queryPart.create);\n  }\n\n  updatePersistedParts() {\n    this.target.select = _.map(this.selectModels, selectParts => {\n      return _.map(selectParts, (part: any) => {\n        return { type: part.def.type, params: part.params };\n      });\n    });\n  }\n\n  hasGroupByTime() {\n    return _.find(this.target.groupBy, (g: any) => g.type === 'time');\n  }\n\n  hasFill() {\n    return _.find(this.target.groupBy, (g: any) => g.type === 'fill');\n  }\n\n  addGroupBy(value: string) {\n    const stringParts = value.match(/^(\\w+)\\((.*)\\)$/);\n    const typePart = stringParts[1];\n    const arg = stringParts[2];\n    const partModel = queryPart.create({ type: typePart, params: [arg] });\n    const partCount = this.target.groupBy.length;\n\n    if (partCount === 0) {\n      this.target.groupBy.push(partModel.part);\n    } else if (typePart === 'time') {\n      this.target.groupBy.splice(0, 0, partModel.part);\n    } else if (typePart === 'tag') {\n      if (this.target.groupBy[partCount - 1].type === 'fill') {\n        this.target.groupBy.splice(partCount - 1, 0, partModel.part);\n      } else {\n        this.target.groupBy.push(partModel.part);\n      }\n    } else {\n      this.target.groupBy.push(partModel.part);\n    }\n\n    this.updateProjection();\n  }\n\n  removeGroupByPart(part: { def: { type: string } }, index: number) {\n    const categories = queryPart.getCategories();\n\n    if (part.def.type === 'time') {\n      // remove fill\n      this.target.groupBy = _.filter(this.target.groupBy, (g: any) => g.type !== 'fill');\n      // remove aggregations\n      this.target.select = _.map(this.target.select, (s: any) => {\n        return _.filter(s, (part: any) => {\n          const partModel = queryPart.create(part);\n          if (partModel.def.category === categories.Aggregations) {\n            return false;\n          }\n          if (partModel.def.category === categories.Selectors) {\n            return false;\n          }\n          return true;\n        });\n      });\n    }\n\n    this.target.groupBy.splice(index, 1);\n    this.updateProjection();\n  }\n\n  removeSelect(index: number) {\n    this.target.select.splice(index, 1);\n    this.updateProjection();\n  }\n\n  removeSelectPart(selectParts: any[], part: any) {\n    // if we remove the field remove the whole statement\n    if (part.def.type === 'field') {\n      if (this.selectModels.length > 1) {\n        const modelsIndex = _.indexOf(this.selectModels, selectParts);\n        this.selectModels.splice(modelsIndex, 1);\n      }\n    } else {\n      const partIndex = _.indexOf(selectParts, part);\n      selectParts.splice(partIndex, 1);\n    }\n\n    this.updatePersistedParts();\n  }\n\n  addSelectPart(selectParts: any[], type: string) {\n    const partModel = queryPart.create({ type: type });\n    partModel.def.addStrategy(selectParts, partModel, this);\n    this.updatePersistedParts();\n  }\n\n  private renderTagCondition(tag: InfluxQueryTag, index: number, interpolate: boolean) {\n    let str = '';\n    let operator = tag.operator;\n    let value = tag.value;\n    if (index > 0) {\n      str = (tag.condition || 'AND') + ' ';\n    }\n\n    if (!operator) {\n      if (/^\\/.*\\/$/.test(value)) {\n        operator = '=~';\n      } else {\n        operator = '=';\n      }\n    }\n\n    // quote value unless regex\n    if (operator !== '=~' && operator !== '!~') {\n      if (interpolate) {\n        value = this.templateSrv.replace(value, this.scopedVars);\n      }\n      if (operator !== '>' && operator !== '<') {\n        value = \"'\" + value.replace(/\\\\/g, '\\\\\\\\').replace(/\\'/g, \"\\\\'\") + \"'\";\n      }\n    } else if (interpolate) {\n      value = this.templateSrv.replace(value, this.scopedVars, 'regex');\n    }\n\n    return str + '\"' + tag.key + '\" ' + operator + ' ' + value;\n  }\n\n  getMeasurementAndPolicy(interpolate: any) {\n    let policy = this.target.policy;\n    let measurement = this.target.measurement || 'measurement';\n\n    if (!measurement.match('^/.*/$')) {\n      measurement = '\"' + measurement + '\"';\n    } else if (interpolate) {\n      measurement = this.templateSrv.replace(measurement, this.scopedVars, 'regex');\n    }\n\n    if (policy !== 'default') {\n      policy = '\"' + this.target.policy + '\".';\n    } else {\n      policy = '';\n    }\n\n    return policy + measurement;\n  }\n\n  interpolateQueryStr(value: any[], variable: { multi: any; includeAll: any }, defaultFormatFn: any) {\n    // if no multi or include all do not regexEscape\n    if (!variable.multi && !variable.includeAll) {\n      return value;\n    }\n\n    if (typeof value === 'string') {\n      return kbn.regexEscape(value);\n    }\n\n    const escapedValues = _.map(value, kbn.regexEscape);\n    return '(' + escapedValues.join('|') + ')';\n  }\n\n  render(interpolate?: boolean) {\n    const target = this.target;\n\n    if (target.rawQuery) {\n      if (interpolate) {\n        return this.templateSrv.replace(target.query, this.scopedVars, this.interpolateQueryStr);\n      } else {\n        return target.query;\n      }\n    }\n\n    let query = 'SELECT ';\n    let i, y;\n    for (i = 0; i < this.selectModels.length; i++) {\n      const parts = this.selectModels[i];\n      let selectText = '';\n      for (y = 0; y < parts.length; y++) {\n        const part = parts[y];\n        selectText = part.render(selectText);\n      }\n\n      if (i > 0) {\n        query += ', ';\n      }\n      query += selectText;\n    }\n\n    query += ' FROM ' + this.getMeasurementAndPolicy(interpolate) + ' WHERE ';\n    const conditions = _.map(target.tags, (tag, index) => {\n      return this.renderTagCondition(tag, index, interpolate);\n    });\n\n    if (conditions.length > 0) {\n      query += '(' + conditions.join(' ') + ') AND ';\n    }\n\n    query += '$timeFilter';\n\n    let groupBySection = '';\n    for (i = 0; i < this.groupByParts.length; i++) {\n      const part = this.groupByParts[i];\n      if (i > 0) {\n        // for some reason fill has no separator\n        groupBySection += part.def.type === 'fill' ? ' ' : ', ';\n      }\n      groupBySection += part.render('');\n    }\n\n    if (groupBySection.length) {\n      query += ' GROUP BY ' + groupBySection;\n    }\n\n    if (target.fill) {\n      query += ' fill(' + target.fill + ')';\n    }\n\n    if (target.orderByTime === 'DESC') {\n      query += ' ORDER BY time DESC';\n    }\n\n    if (target.limit) {\n      query += ' LIMIT ' + target.limit;\n    }\n\n    if (target.slimit) {\n      query += ' SLIMIT ' + target.slimit;\n    }\n\n    if (target.tz) {\n      query += \" tz('\" + target.tz + \"')\";\n    }\n\n    return query;\n  }\n\n  renderAdhocFilters(filters: any[]) {\n    const conditions = _.map(filters, (tag, index) => {\n      return this.renderTagCondition(tag, index, true);\n    });\n    return conditions.join(' ');\n  }\n}\n","import _ from 'lodash';\n\nexport default class ResponseParser {\n  parse(query: string, results: { results: any }) {\n    if (!results || results.results.length === 0) {\n      return [];\n    }\n\n    const influxResults = results.results[0];\n    if (!influxResults.series) {\n      return [];\n    }\n\n    const normalizedQuery = query.toLowerCase();\n    const isValueFirst =\n      normalizedQuery.indexOf('show field keys') >= 0 || normalizedQuery.indexOf('show retention policies') >= 0;\n\n    const res = {};\n    _.each(influxResults.series, serie => {\n      _.each(serie.values, value => {\n        if (_.isArray(value)) {\n          // In general, there are 2 possible shapes for the returned value.\n          // The first one is a two-element array,\n          // where the first element is somewhat a metadata value:\n          // the tag name for SHOW TAG VALUES queries,\n          // the time field for SELECT queries, etc.\n          // The second shape is an one-element array,\n          // that is containing an immediate value.\n          // For example, SHOW FIELD KEYS queries return such shape.\n          // Note, pre-0.11 versions return\n          // the second shape for SHOW TAG VALUES queries\n          // (while the newer versionsfirst).\n\n          if (isValueFirst) {\n            addUnique(res, value[0]);\n          } else if (value[1] !== undefined) {\n            addUnique(res, value[1]);\n          } else {\n            addUnique(res, value[0]);\n          }\n        } else {\n          addUnique(res, value);\n        }\n      });\n    });\n\n    // @ts-ignore problems with typings for this _.map only accepts [] but this needs to be object\n    return _.map(res, value => {\n      // @ts-ignore\n      return { text: value.toString() };\n    });\n  }\n}\n\nfunction addUnique(arr: { [x: string]: any }, value: string | number) {\n  arr[value] = value;\n}\n","import React, { useContext } from 'react';\nimport { Select, ThemeContext } from '@grafana/ui';\nimport { css, cx } from 'emotion';\nimport { GrafanaTheme, SelectableValue } from '@grafana/data';\n\nconst getStyles = (theme: GrafanaTheme) => ({\n  keyValueContainer: css`\n    label: key-value-container;\n    display: flex;\n    flex-flow: row nowrap;\n  `,\n});\n\nenum ChangeType {\n  Key = 'key',\n  Value = 'value',\n  Operator = 'operator',\n}\n\nexport interface Props {\n  keys: string[];\n  keysPlaceHolder?: string;\n  initialKey?: string;\n  initialOperator?: string;\n  initialValue?: string;\n  values?: string[];\n  valuesPlaceHolder?: string;\n  onKeyChanged: (key: string) => void;\n  onValueChanged: (value: string) => void;\n  onOperatorChanged: (operator: string) => void;\n}\n\nexport const AdHocFilter: React.FunctionComponent<Props> = props => {\n  const theme = useContext(ThemeContext);\n  const styles = getStyles(theme);\n\n  const onChange = (changeType: ChangeType) => (item: SelectableValue<string>) => {\n    const { onKeyChanged, onValueChanged, onOperatorChanged } = props;\n\n    if (!item.value) {\n      return;\n    }\n\n    switch (changeType) {\n      case ChangeType.Key:\n        onKeyChanged(item.value);\n        break;\n      case ChangeType.Operator:\n        onOperatorChanged(item.value);\n        break;\n      case ChangeType.Value:\n        onValueChanged(item.value);\n        break;\n    }\n  };\n\n  const stringToOption = (value: string) => ({ label: value, value: value });\n\n  const { keys, initialKey, keysPlaceHolder, initialOperator, values, initialValue, valuesPlaceHolder } = props;\n  const operators = ['=', '!='];\n  const keysAsOptions = keys ? keys.map(stringToOption) : [];\n  const selectedKey = initialKey ? keysAsOptions.filter(option => option.value === initialKey) : undefined;\n  const valuesAsOptions = values ? values.map(stringToOption) : [];\n  const selectedValue = initialValue ? valuesAsOptions.filter(option => option.value === initialValue) : undefined;\n  const operatorsAsOptions = operators.map(stringToOption);\n  const selectedOperator = initialOperator\n    ? operatorsAsOptions.filter(option => option.value === initialOperator)\n    : undefined;\n\n  return (\n    <div className={cx([styles.keyValueContainer])}>\n      <Select\n        options={keysAsOptions}\n        isSearchable\n        value={selectedKey}\n        onChange={onChange(ChangeType.Key)}\n        placeholder={keysPlaceHolder}\n      />\n      <Select options={operatorsAsOptions} value={selectedOperator} onChange={onChange(ChangeType.Operator)} />\n      <Select\n        options={valuesAsOptions}\n        isSearchable\n        value={selectedValue}\n        onChange={onChange(ChangeType.Value)}\n        placeholder={valuesPlaceHolder}\n      />\n    </div>\n  );\n};\n","import _ from 'lodash';\nimport kbn from 'app/core/utils/kbn';\n\nfunction renderTagCondition(tag: { operator: any; value: string; condition: any; key: string }, index: number) {\n  let str = '';\n  let operator = tag.operator;\n  let value = tag.value;\n  if (index > 0) {\n    str = (tag.condition || 'AND') + ' ';\n  }\n\n  if (!operator) {\n    if (/^\\/.*\\/$/.test(tag.value)) {\n      operator = '=~';\n    } else {\n      operator = '=';\n    }\n  }\n\n  // quote value unless regex or number\n  if (operator !== '=~' && operator !== '!~' && isNaN(+value)) {\n    value = \"'\" + value + \"'\";\n  }\n\n  return str + '\"' + tag.key + '\" ' + operator + ' ' + value;\n}\n\nexport class InfluxQueryBuilder {\n  constructor(private target: { measurement: any; tags: any; policy?: any }, private database?: string) {}\n\n  buildExploreQuery(type: string, withKey?: string, withMeasurementFilter?: string) {\n    let query;\n    let measurement;\n    let policy;\n\n    if (type === 'TAG_KEYS') {\n      query = 'SHOW TAG KEYS';\n      measurement = this.target.measurement;\n      policy = this.target.policy;\n    } else if (type === 'TAG_VALUES') {\n      query = 'SHOW TAG VALUES';\n      measurement = this.target.measurement;\n      policy = this.target.policy;\n    } else if (type === 'MEASUREMENTS') {\n      query = 'SHOW MEASUREMENTS';\n      if (withMeasurementFilter) {\n        query += ' WITH MEASUREMENT =~ /' + kbn.regexEscape(withMeasurementFilter) + '/';\n      }\n    } else if (type === 'FIELDS') {\n      measurement = this.target.measurement;\n      policy = this.target.policy;\n\n      if (!measurement.match('^/.*/')) {\n        measurement = '\"' + measurement + '\"';\n\n        if (policy && policy !== 'default') {\n          policy = '\"' + policy + '\"';\n          measurement = policy + '.' + measurement;\n        }\n      }\n\n      return 'SHOW FIELD KEYS FROM ' + measurement;\n    } else if (type === 'RETENTION POLICIES') {\n      query = 'SHOW RETENTION POLICIES on \"' + this.database + '\"';\n      return query;\n    }\n\n    if (measurement) {\n      if (!measurement.match('^/.*/') && !measurement.match(/^merge\\(.*\\)/)) {\n        measurement = '\"' + measurement + '\"';\n      }\n\n      if (policy && policy !== 'default') {\n        policy = '\"' + policy + '\"';\n        measurement = policy + '.' + measurement;\n      }\n\n      query += ' FROM ' + measurement;\n    }\n\n    if (withKey) {\n      query += ' WITH KEY = \"' + withKey + '\"';\n    }\n\n    if (this.target.tags && this.target.tags.length > 0) {\n      const whereConditions = _.reduce(\n        this.target.tags,\n        (memo, tag) => {\n          // do not add a condition for the key we want to explore for\n          if (tag.key === withKey) {\n            return memo;\n          }\n          memo.push(renderTagCondition(tag, memo.length));\n          return memo;\n        },\n        []\n      );\n\n      if (whereConditions.length > 0) {\n        query += ' WHERE ' + whereConditions.join(' ');\n      }\n    }\n    if (type === 'MEASUREMENTS') {\n      query += ' LIMIT 100';\n      //Solve issue #2524 by limiting the number of measurements returned\n      //LIMIT must be after WITH MEASUREMENT and WHERE clauses\n      //This also could be used for TAG KEYS and TAG VALUES, if desired\n    }\n    return query;\n  }\n}\n","import _ from 'lodash';\n\nimport { dateMath, DataSourceApi, DataSourceInstanceSettings, ScopedVars } from '@grafana/data';\nimport InfluxSeries from './influx_series';\nimport InfluxQueryModel from './influx_query_model';\nimport ResponseParser from './response_parser';\nimport { InfluxQueryBuilder } from './query_builder';\nimport { InfluxQuery, InfluxOptions } from './types';\nimport { BackendSrv } from 'app/core/services/backend_srv';\nimport { TemplateSrv } from 'app/features/templating/template_srv';\n\nexport default class InfluxDatasource extends DataSourceApi<InfluxQuery, InfluxOptions> {\n  type: string;\n  urls: any;\n  username: string;\n  password: string;\n  name: string;\n  database: any;\n  basicAuth: any;\n  withCredentials: any;\n  interval: any;\n  responseParser: any;\n  httpMode: string;\n\n  /** @ngInject */\n  constructor(\n    instanceSettings: DataSourceInstanceSettings<InfluxOptions>,\n    private backendSrv: BackendSrv,\n    private templateSrv: TemplateSrv\n  ) {\n    super(instanceSettings);\n    this.type = 'influxdb';\n    this.urls = _.map(instanceSettings.url.split(','), url => {\n      return url.trim();\n    });\n\n    this.username = instanceSettings.username;\n    this.password = instanceSettings.password;\n    this.name = instanceSettings.name;\n    this.database = instanceSettings.database;\n    this.basicAuth = instanceSettings.basicAuth;\n    this.withCredentials = instanceSettings.withCredentials;\n    const settingsData = instanceSettings.jsonData || ({} as InfluxOptions);\n    this.interval = settingsData.timeInterval;\n    this.httpMode = settingsData.httpMode || 'GET';\n    this.responseParser = new ResponseParser();\n  }\n\n  query(options: any) {\n    let timeFilter = this.getTimeFilter(options);\n    const scopedVars = options.scopedVars;\n    const targets = _.cloneDeep(options.targets);\n    const queryTargets: any[] = [];\n    let queryModel: InfluxQueryModel;\n    let i, y;\n\n    let allQueries = _.map(targets, target => {\n      if (target.hide) {\n        return '';\n      }\n\n      queryTargets.push(target);\n\n      // backward compatibility\n      scopedVars.interval = scopedVars.__interval;\n\n      queryModel = new InfluxQueryModel(target, this.templateSrv, scopedVars);\n      return queryModel.render(true);\n    }).reduce((acc, current) => {\n      if (current !== '') {\n        acc += ';' + current;\n      }\n      return acc;\n    });\n\n    if (allQueries === '') {\n      return Promise.resolve({ data: [] });\n    }\n\n    // add global adhoc filters to timeFilter\n    const adhocFilters = this.templateSrv.getAdhocFilters(this.name);\n    if (adhocFilters.length > 0) {\n      timeFilter += ' AND ' + queryModel.renderAdhocFilters(adhocFilters);\n    }\n\n    // replace grafana variables\n    scopedVars.timeFilter = { value: timeFilter };\n\n    // replace templated variables\n    allQueries = this.templateSrv.replace(allQueries, scopedVars);\n\n    return this._seriesQuery(allQueries, options).then((data: any): any => {\n      if (!data || !data.results) {\n        return [];\n      }\n\n      const seriesList = [];\n      for (i = 0; i < data.results.length; i++) {\n        const result = data.results[i];\n        if (!result || !result.series) {\n          continue;\n        }\n\n        const target = queryTargets[i];\n        let alias = target.alias;\n        if (alias) {\n          alias = this.templateSrv.replace(target.alias, options.scopedVars);\n        }\n\n        const influxSeries = new InfluxSeries({\n          series: data.results[i].series,\n          alias: alias,\n        });\n\n        switch (target.resultFormat) {\n          case 'table': {\n            seriesList.push(influxSeries.getTable());\n            break;\n          }\n          default: {\n            const timeSeries = influxSeries.getTimeSeries();\n            for (y = 0; y < timeSeries.length; y++) {\n              seriesList.push(timeSeries[y]);\n            }\n            break;\n          }\n        }\n      }\n\n      return { data: seriesList };\n    });\n  }\n\n  annotationQuery(options: any) {\n    if (!options.annotation.query) {\n      return Promise.reject({\n        message: 'Query missing in annotation definition',\n      });\n    }\n\n    const timeFilter = this.getTimeFilter({ rangeRaw: options.rangeRaw, timezone: options.timezone });\n    let query = options.annotation.query.replace('$timeFilter', timeFilter);\n    query = this.templateSrv.replace(query, null, 'regex');\n\n    return this._seriesQuery(query, options).then((data: any) => {\n      if (!data || !data.results || !data.results[0]) {\n        throw { message: 'No results in response from InfluxDB' };\n      }\n      return new InfluxSeries({\n        series: data.results[0].series,\n        annotation: options.annotation,\n      }).getAnnotations();\n    });\n  }\n\n  targetContainsTemplate(target: any) {\n    for (const group of target.groupBy) {\n      for (const param of group.params) {\n        if (this.templateSrv.variableExists(param)) {\n          return true;\n        }\n      }\n    }\n\n    for (const i in target.tags) {\n      if (this.templateSrv.variableExists(target.tags[i].value)) {\n        return true;\n      }\n    }\n\n    return false;\n  }\n\n  interpolateVariablesInQueries(queries: InfluxQuery[], scopedVars: ScopedVars): InfluxQuery[] {\n    if (!queries || queries.length === 0) {\n      return [];\n    }\n\n    let expandedQueries = queries;\n    if (queries && queries.length > 0) {\n      expandedQueries = queries.map(query => {\n        const expandedQuery = {\n          ...query,\n          datasource: this.name,\n          measurement: this.templateSrv.replace(query.measurement, scopedVars, 'regex'),\n        };\n\n        if (query.rawQuery) {\n          expandedQuery.query = this.templateSrv.replace(query.query, scopedVars, 'regex');\n        }\n\n        if (query.tags) {\n          const expandedTags = query.tags.map(tag => {\n            const expandedTag = {\n              ...tag,\n              value: this.templateSrv.replace(tag.value, null, 'regex'),\n            };\n            return expandedTag;\n          });\n          expandedQuery.tags = expandedTags;\n        }\n        return expandedQuery;\n      });\n    }\n    return expandedQueries;\n  }\n\n  metricFindQuery(query: string, options?: any) {\n    const interpolated = this.templateSrv.replace(query, null, 'regex');\n\n    return this._seriesQuery(interpolated, options).then(_.curry(this.responseParser.parse)(query));\n  }\n\n  getTagKeys(options: any = {}) {\n    const queryBuilder = new InfluxQueryBuilder({ measurement: options.measurement || '', tags: [] }, this.database);\n    const query = queryBuilder.buildExploreQuery('TAG_KEYS');\n    return this.metricFindQuery(query, options);\n  }\n\n  getTagValues(options: any = {}) {\n    const queryBuilder = new InfluxQueryBuilder({ measurement: options.measurement || '', tags: [] }, this.database);\n    const query = queryBuilder.buildExploreQuery('TAG_VALUES', options.key);\n    return this.metricFindQuery(query, options);\n  }\n\n  _seriesQuery(query: string, options?: any) {\n    if (!query) {\n      return Promise.resolve({ results: [] });\n    }\n\n    if (options && options.range) {\n      const timeFilter = this.getTimeFilter({ rangeRaw: options.range, timezone: options.timezone });\n      query = query.replace('$timeFilter', timeFilter);\n    }\n\n    return this._influxRequest(this.httpMode, '/query', { q: query, epoch: 'ms' }, options);\n  }\n\n  serializeParams(params: any) {\n    if (!params) {\n      return '';\n    }\n\n    return _.reduce(\n      params,\n      (memo, value, key) => {\n        if (value === null || value === undefined) {\n          return memo;\n        }\n        memo.push(encodeURIComponent(key) + '=' + encodeURIComponent(value));\n        return memo;\n      },\n      []\n    ).join('&');\n  }\n\n  testDatasource() {\n    const queryBuilder = new InfluxQueryBuilder({ measurement: '', tags: [] }, this.database);\n    const query = queryBuilder.buildExploreQuery('RETENTION POLICIES');\n\n    return this._seriesQuery(query)\n      .then((res: any) => {\n        const error = _.get(res, 'results[0].error');\n        if (error) {\n          return { status: 'error', message: error };\n        }\n        return { status: 'success', message: 'Data source is working' };\n      })\n      .catch((err: any) => {\n        return { status: 'error', message: err.message };\n      });\n  }\n\n  _influxRequest(method: string, url: string, data: any, options?: any) {\n    const currentUrl = this.urls.shift();\n    this.urls.push(currentUrl);\n\n    const params: any = {};\n\n    if (this.username) {\n      params.u = this.username;\n      params.p = this.password;\n    }\n\n    if (options && options.database) {\n      params.db = options.database;\n    } else if (this.database) {\n      params.db = this.database;\n    }\n\n    if (method === 'POST' && _.has(data, 'q')) {\n      // verb is POST and 'q' param is defined\n      _.extend(params, _.omit(data, ['q']));\n      data = this.serializeParams(_.pick(data, ['q']));\n    } else if (method === 'GET' || method === 'POST') {\n      // verb is GET, or POST without 'q' param\n      _.extend(params, data);\n      data = null;\n    }\n\n    const req: any = {\n      method: method,\n      url: currentUrl + url,\n      params: params,\n      data: data,\n      precision: 'ms',\n      inspect: { type: 'influxdb' },\n      paramSerializer: this.serializeParams,\n    };\n\n    req.headers = req.headers || {};\n    if (this.basicAuth || this.withCredentials) {\n      req.withCredentials = true;\n    }\n    if (this.basicAuth) {\n      req.headers.Authorization = this.basicAuth;\n    }\n\n    if (method === 'POST') {\n      req.headers['Content-type'] = 'application/x-www-form-urlencoded';\n    }\n\n    return this.backendSrv.datasourceRequest(req).then(\n      (result: any) => {\n        return result.data;\n      },\n      (err: any) => {\n        if (err.status !== 0 || err.status >= 300) {\n          if (err.data && err.data.error) {\n            throw {\n              message: 'InfluxDB Error: ' + err.data.error,\n              data: err.data,\n              config: err.config,\n            };\n          } else {\n            throw {\n              message: 'Network Error: ' + err.statusText + '(' + err.status + ')',\n              data: err.data,\n              config: err.config,\n            };\n          }\n        }\n      }\n    );\n  }\n\n  getTimeFilter(options: any) {\n    const from = this.getInfluxTime(options.rangeRaw.from, false, options.timezone);\n    const until = this.getInfluxTime(options.rangeRaw.to, true, options.timezone);\n    const fromIsAbsolute = from[from.length - 1] === 'ms';\n\n    if (until === 'now()' && !fromIsAbsolute) {\n      return 'time >= ' + from;\n    }\n\n    return 'time >= ' + from + ' and time <= ' + until;\n  }\n\n  getInfluxTime(date: any, roundUp: any, timezone: any) {\n    if (_.isString(date)) {\n      if (date === 'now') {\n        return 'now()';\n      }\n\n      const parts = /^now-(\\d+)([dhms])$/.exec(date);\n      if (parts) {\n        const amount = parseInt(parts[1], 10);\n        const unit = parts[2];\n        return 'now() - ' + amount + unit;\n      }\n      date = dateMath.parse(date, roundUp, timezone);\n    }\n\n    return date.valueOf() + 'ms';\n  }\n}\n","import angular, { auto } from 'angular';\nimport _ from 'lodash';\nimport { InfluxQueryBuilder } from './query_builder';\nimport InfluxQueryModel from './influx_query_model';\nimport queryPart from './query_part';\nimport { QueryCtrl } from 'app/plugins/sdk';\nimport { TemplateSrv } from 'app/features/templating/template_srv';\n\nexport class InfluxQueryCtrl extends QueryCtrl {\n  static templateUrl = 'partials/query.editor.html';\n\n  queryModel: InfluxQueryModel;\n  queryBuilder: any;\n  groupBySegment: any;\n  resultFormats: any[];\n  orderByTime: any[];\n  policySegment: any;\n  tagSegments: any[];\n  selectMenu: any;\n  measurementSegment: any;\n  removeTagFilterSegment: any;\n\n  /** @ngInject */\n  constructor(\n    $scope: any,\n    $injector: auto.IInjectorService,\n    private templateSrv: TemplateSrv,\n    private uiSegmentSrv: any\n  ) {\n    super($scope, $injector);\n    this.target = this.target;\n    this.queryModel = new InfluxQueryModel(this.target, templateSrv, this.panel.scopedVars);\n    this.queryBuilder = new InfluxQueryBuilder(this.target, this.datasource.database);\n    this.groupBySegment = this.uiSegmentSrv.newPlusButton();\n    this.resultFormats = [\n      { text: 'Time series', value: 'time_series' },\n      { text: 'Table', value: 'table' },\n    ];\n    this.policySegment = uiSegmentSrv.newSegment(this.target.policy);\n\n    if (!this.target.measurement) {\n      this.measurementSegment = uiSegmentSrv.newSelectMeasurement();\n    } else {\n      this.measurementSegment = uiSegmentSrv.newSegment(this.target.measurement);\n    }\n\n    this.tagSegments = [];\n    for (const tag of this.target.tags) {\n      if (!tag.operator) {\n        if (/^\\/.*\\/$/.test(tag.value)) {\n          tag.operator = '=~';\n        } else {\n          tag.operator = '=';\n        }\n      }\n\n      if (tag.condition) {\n        this.tagSegments.push(uiSegmentSrv.newCondition(tag.condition));\n      }\n\n      this.tagSegments.push(uiSegmentSrv.newKey(tag.key));\n      this.tagSegments.push(uiSegmentSrv.newOperator(tag.operator));\n      this.tagSegments.push(uiSegmentSrv.newKeyValue(tag.value));\n    }\n\n    this.fixTagSegments();\n    this.buildSelectMenu();\n    this.removeTagFilterSegment = uiSegmentSrv.newSegment({\n      fake: true,\n      value: '-- remove tag filter --',\n    });\n  }\n\n  removeOrderByTime() {\n    this.target.orderByTime = 'ASC';\n  }\n\n  buildSelectMenu() {\n    const categories = queryPart.getCategories();\n    this.selectMenu = _.reduce(\n      categories,\n      (memo, cat, key) => {\n        const menu = {\n          text: key,\n          submenu: cat.map((item: any) => {\n            return { text: item.type, value: item.type };\n          }),\n        };\n        memo.push(menu);\n        return memo;\n      },\n      []\n    );\n  }\n\n  getGroupByOptions() {\n    const query = this.queryBuilder.buildExploreQuery('TAG_KEYS');\n\n    return this.datasource\n      .metricFindQuery(query)\n      .then((tags: any) => {\n        const options = [];\n        if (!this.queryModel.hasFill()) {\n          options.push(this.uiSegmentSrv.newSegment({ value: 'fill(null)' }));\n        }\n        if (!this.target.limit) {\n          options.push(this.uiSegmentSrv.newSegment({ value: 'LIMIT' }));\n        }\n        if (!this.target.slimit) {\n          options.push(this.uiSegmentSrv.newSegment({ value: 'SLIMIT' }));\n        }\n        if (!this.target.tz) {\n          options.push(this.uiSegmentSrv.newSegment({ value: 'tz' }));\n        }\n        if (this.target.orderByTime === 'ASC') {\n          options.push(this.uiSegmentSrv.newSegment({ value: 'ORDER BY time DESC' }));\n        }\n        if (!this.queryModel.hasGroupByTime()) {\n          options.push(this.uiSegmentSrv.newSegment({ value: 'time($interval)' }));\n        }\n        for (const tag of tags) {\n          options.push(this.uiSegmentSrv.newSegment({ value: 'tag(' + tag.text + ')' }));\n        }\n        return options;\n      })\n      .catch(this.handleQueryError.bind(this));\n  }\n\n  groupByAction() {\n    switch (this.groupBySegment.value) {\n      case 'LIMIT': {\n        this.target.limit = 10;\n        break;\n      }\n      case 'SLIMIT': {\n        this.target.slimit = 10;\n        break;\n      }\n      case 'tz': {\n        this.target.tz = 'UTC';\n        break;\n      }\n      case 'ORDER BY time DESC': {\n        this.target.orderByTime = 'DESC';\n        break;\n      }\n      default: {\n        this.queryModel.addGroupBy(this.groupBySegment.value);\n      }\n    }\n\n    const plusButton = this.uiSegmentSrv.newPlusButton();\n    this.groupBySegment.value = plusButton.value;\n    this.groupBySegment.html = plusButton.html;\n    this.panelCtrl.refresh();\n  }\n\n  addSelectPart(selectParts: any, cat: any, subitem: { value: any }) {\n    this.queryModel.addSelectPart(selectParts, subitem.value);\n    this.panelCtrl.refresh();\n  }\n\n  handleSelectPartEvent(selectParts: any, part: any, evt: { name: any }) {\n    switch (evt.name) {\n      case 'get-param-options': {\n        const fieldsQuery = this.queryBuilder.buildExploreQuery('FIELDS');\n        return this.datasource\n          .metricFindQuery(fieldsQuery)\n          .then(this.transformToSegments(true))\n          .catch(this.handleQueryError.bind(this));\n      }\n      case 'part-param-changed': {\n        this.panelCtrl.refresh();\n        break;\n      }\n      case 'action': {\n        this.queryModel.removeSelectPart(selectParts, part);\n        this.panelCtrl.refresh();\n        break;\n      }\n      case 'get-part-actions': {\n        return Promise.resolve([{ text: 'Remove', value: 'remove-part' }]);\n      }\n    }\n  }\n\n  handleGroupByPartEvent(part: any, index: any, evt: { name: any }) {\n    switch (evt.name) {\n      case 'get-param-options': {\n        const tagsQuery = this.queryBuilder.buildExploreQuery('TAG_KEYS');\n        return this.datasource\n          .metricFindQuery(tagsQuery)\n          .then(this.transformToSegments(true))\n          .catch(this.handleQueryError.bind(this));\n      }\n      case 'part-param-changed': {\n        this.panelCtrl.refresh();\n        break;\n      }\n      case 'action': {\n        this.queryModel.removeGroupByPart(part, index);\n        this.panelCtrl.refresh();\n        break;\n      }\n      case 'get-part-actions': {\n        return Promise.resolve([{ text: 'Remove', value: 'remove-part' }]);\n      }\n    }\n  }\n\n  fixTagSegments() {\n    const count = this.tagSegments.length;\n    const lastSegment = this.tagSegments[Math.max(count - 1, 0)];\n\n    if (!lastSegment || lastSegment.type !== 'plus-button') {\n      this.tagSegments.push(this.uiSegmentSrv.newPlusButton());\n    }\n  }\n\n  measurementChanged() {\n    this.target.measurement = this.measurementSegment.value;\n    this.panelCtrl.refresh();\n  }\n\n  getPolicySegments() {\n    const policiesQuery = this.queryBuilder.buildExploreQuery('RETENTION POLICIES');\n    return this.datasource\n      .metricFindQuery(policiesQuery)\n      .then(this.transformToSegments(false))\n      .catch(this.handleQueryError.bind(this));\n  }\n\n  policyChanged() {\n    this.target.policy = this.policySegment.value;\n    this.panelCtrl.refresh();\n  }\n\n  toggleEditorMode() {\n    try {\n      this.target.query = this.queryModel.render(false);\n    } catch (err) {\n      console.log('query render error');\n    }\n    this.target.rawQuery = !this.target.rawQuery;\n  }\n\n  getMeasurements(measurementFilter: any) {\n    const query = this.queryBuilder.buildExploreQuery('MEASUREMENTS', undefined, measurementFilter);\n    return this.datasource\n      .metricFindQuery(query)\n      .then(this.transformToSegments(true))\n      .catch(this.handleQueryError.bind(this));\n  }\n\n  handleQueryError(err: any): any[] {\n    this.error = err.message || 'Failed to issue metric query';\n    return [];\n  }\n\n  transformToSegments(addTemplateVars: any) {\n    return (results: any) => {\n      const segments = _.map(results, segment => {\n        return this.uiSegmentSrv.newSegment({\n          value: segment.text,\n          expandable: segment.expandable,\n        });\n      });\n\n      if (addTemplateVars) {\n        for (const variable of this.templateSrv.variables) {\n          segments.unshift(\n            this.uiSegmentSrv.newSegment({\n              type: 'value',\n              value: '/^$' + variable.name + '$/',\n              expandable: true,\n            })\n          );\n        }\n      }\n\n      return segments;\n    };\n  }\n\n  getTagsOrValues(segment: { type: string }, index: number) {\n    if (segment.type === 'condition') {\n      return Promise.resolve([this.uiSegmentSrv.newSegment('AND'), this.uiSegmentSrv.newSegment('OR')]);\n    }\n    if (segment.type === 'operator') {\n      const nextValue = this.tagSegments[index + 1].value;\n      if (/^\\/.*\\/$/.test(nextValue)) {\n        return Promise.resolve(this.uiSegmentSrv.newOperators(['=~', '!~']));\n      } else {\n        return Promise.resolve(this.uiSegmentSrv.newOperators(['=', '!=', '<>', '<', '>']));\n      }\n    }\n\n    let query, addTemplateVars;\n    if (segment.type === 'key' || segment.type === 'plus-button') {\n      query = this.queryBuilder.buildExploreQuery('TAG_KEYS');\n      addTemplateVars = false;\n    } else if (segment.type === 'value') {\n      query = this.queryBuilder.buildExploreQuery('TAG_VALUES', this.tagSegments[index - 2].value);\n      addTemplateVars = true;\n    }\n\n    return this.datasource\n      .metricFindQuery(query)\n      .then(this.transformToSegments(addTemplateVars))\n      .then((results: any) => {\n        if (segment.type === 'key') {\n          results.splice(0, 0, angular.copy(this.removeTagFilterSegment));\n        }\n        return results;\n      })\n      .catch(this.handleQueryError.bind(this));\n  }\n\n  getFieldSegments() {\n    const fieldsQuery = this.queryBuilder.buildExploreQuery('FIELDS');\n    return this.datasource\n      .metricFindQuery(fieldsQuery)\n      .then(this.transformToSegments(false))\n      .catch(this.handleQueryError);\n  }\n\n  tagSegmentUpdated(segment: { value: any; type: string; cssClass: string }, index: number) {\n    this.tagSegments[index] = segment;\n\n    // handle remove tag condition\n    if (segment.value === this.removeTagFilterSegment.value) {\n      this.tagSegments.splice(index, 3);\n      if (this.tagSegments.length === 0) {\n        this.tagSegments.push(this.uiSegmentSrv.newPlusButton());\n      } else if (this.tagSegments.length > 2) {\n        this.tagSegments.splice(Math.max(index - 1, 0), 1);\n        if (this.tagSegments[this.tagSegments.length - 1].type !== 'plus-button') {\n          this.tagSegments.push(this.uiSegmentSrv.newPlusButton());\n        }\n      }\n    } else {\n      if (segment.type === 'plus-button') {\n        if (index > 2) {\n          this.tagSegments.splice(index, 0, this.uiSegmentSrv.newCondition('AND'));\n        }\n        this.tagSegments.push(this.uiSegmentSrv.newOperator('='));\n        this.tagSegments.push(this.uiSegmentSrv.newFake('select tag value', 'value', 'query-segment-value'));\n        segment.type = 'key';\n        segment.cssClass = 'query-segment-key';\n      }\n\n      if (index + 1 === this.tagSegments.length) {\n        this.tagSegments.push(this.uiSegmentSrv.newPlusButton());\n      }\n    }\n\n    this.rebuildTargetTagConditions();\n  }\n\n  rebuildTargetTagConditions() {\n    const tags: any[] = [];\n    let tagIndex = 0;\n    let tagOperator = '';\n\n    _.each(this.tagSegments, (segment2, index) => {\n      if (segment2.type === 'key') {\n        if (tags.length === 0) {\n          tags.push({});\n        }\n        tags[tagIndex].key = segment2.value;\n      } else if (segment2.type === 'value') {\n        tagOperator = this.getTagValueOperator(segment2.value, tags[tagIndex].operator);\n        if (tagOperator) {\n          this.tagSegments[index - 1] = this.uiSegmentSrv.newOperator(tagOperator);\n          tags[tagIndex].operator = tagOperator;\n        }\n        tags[tagIndex].value = segment2.value;\n      } else if (segment2.type === 'condition') {\n        tags.push({ condition: segment2.value });\n        tagIndex += 1;\n      } else if (segment2.type === 'operator') {\n        tags[tagIndex].operator = segment2.value;\n      }\n    });\n\n    this.target.tags = tags;\n    this.panelCtrl.refresh();\n  }\n\n  getTagValueOperator(tagValue: string, tagOperator: string): string {\n    if (tagOperator !== '=~' && tagOperator !== '!~' && /^\\/.*\\/$/.test(tagValue)) {\n      return '=~';\n    } else if ((tagOperator === '=~' || tagOperator === '!~') && /^(?!\\/.*\\/$)/.test(tagValue)) {\n      return '=';\n    }\n    return null;\n  }\n\n  getCollapsedText() {\n    return this.queryModel.render(false);\n  }\n}\n","import React from 'react';\nimport _ from 'lodash';\nimport { DataSourceApi, DataQuery, DataSourceJsonData } from '@grafana/data';\nimport { AdHocFilter } from './AdHocFilter';\nexport const DEFAULT_REMOVE_FILTER_VALUE = '-- remove filter --';\n\nconst addFilterButton = (onAddFilter: (event: React.MouseEvent) => void) => (\n  <button className=\"gf-form-label gf-form-label--btn query-part\" onClick={onAddFilter}>\n    <i className=\"fa fa-plus\" />\n  </button>\n);\n\nexport interface KeyValuePair {\n  keys: string[];\n  key: string;\n  operator: string;\n  value: string;\n  values: string[];\n}\n\nexport interface Props<TQuery extends DataQuery = DataQuery, TOptions extends DataSourceJsonData = DataSourceJsonData> {\n  datasource: DataSourceApi<TQuery, TOptions>;\n  onPairsChanged: (pairs: KeyValuePair[]) => void;\n  extendedOptions?: any;\n}\n\nexport interface State {\n  pairs: KeyValuePair[];\n}\n\nexport class AdHocFilterField<\n  TQuery extends DataQuery = DataQuery,\n  TOptions extends DataSourceJsonData = DataSourceJsonData\n> extends React.PureComponent<Props<TQuery, TOptions>, State> {\n  state: State = { pairs: [] };\n\n  componentDidUpdate(prevProps: Props<TQuery, TOptions>) {\n    if (_.isEqual(prevProps.extendedOptions, this.props.extendedOptions) === false) {\n      const pairs: any[] = [];\n\n      this.setState({ pairs }, () => this.props.onPairsChanged(pairs));\n    }\n  }\n\n  loadTagKeys = async () => {\n    const { datasource, extendedOptions } = this.props;\n    const options = extendedOptions || {};\n    const tagKeys = datasource.getTagKeys ? await datasource.getTagKeys(options) : [];\n    const keys = tagKeys.map(tagKey => tagKey.text);\n\n    return keys;\n  };\n\n  loadTagValues = async (key: string) => {\n    const { datasource, extendedOptions } = this.props;\n    const options = extendedOptions || {};\n    const tagValues = datasource.getTagValues ? await datasource.getTagValues({ ...options, key }) : [];\n    const values = tagValues.map(tagValue => tagValue.text);\n\n    return values;\n  };\n\n  updatePairs(pairs: KeyValuePair[], index: number, pair: Partial<KeyValuePair>) {\n    if (pairs.length === 0) {\n      return [\n        {\n          key: pair.key || '',\n          keys: pair.keys || [],\n          operator: pair.operator || '',\n          value: pair.value || '',\n          values: pair.values || [],\n        },\n      ];\n    }\n\n    const newPairs: KeyValuePair[] = [];\n    for (let pairIndex = 0; pairIndex < pairs.length; pairIndex++) {\n      const newPair = pairs[pairIndex];\n      if (index === pairIndex) {\n        newPairs.push({\n          ...newPair,\n          key: pair.key || newPair.key,\n          value: pair.value || newPair.value,\n          operator: pair.operator || newPair.operator,\n          keys: pair.keys || newPair.keys,\n          values: pair.values || newPair.values,\n        });\n        continue;\n      }\n\n      newPairs.push(newPair);\n    }\n\n    return newPairs;\n  }\n\n  onKeyChanged = (index: number) => async (key: string) => {\n    if (key !== DEFAULT_REMOVE_FILTER_VALUE) {\n      const { onPairsChanged } = this.props;\n      const values = await this.loadTagValues(key);\n      const pairs = this.updatePairs(this.state.pairs, index, { key, values });\n\n      this.setState({ pairs }, () => onPairsChanged(pairs));\n    } else {\n      this.onRemoveFilter(index);\n    }\n  };\n\n  onValueChanged = (index: number) => (value: string) => {\n    const pairs = this.updatePairs(this.state.pairs, index, { value });\n\n    this.setState({ pairs }, () => this.props.onPairsChanged(pairs));\n  };\n\n  onOperatorChanged = (index: number) => (operator: string) => {\n    const pairs = this.updatePairs(this.state.pairs, index, { operator });\n\n    this.setState({ pairs }, () => this.props.onPairsChanged(pairs));\n  };\n\n  onAddFilter = async () => {\n    const keys = await this.loadTagKeys();\n    const pairs = this.state.pairs.concat(this.updatePairs([], 0, { keys }));\n\n    this.setState({ pairs }, () => this.props.onPairsChanged(pairs));\n  };\n\n  onRemoveFilter = async (index: number) => {\n    const pairs = this.state.pairs.reduce((allPairs, pair, pairIndex) => {\n      if (pairIndex === index) {\n        return allPairs;\n      }\n      return allPairs.concat(pair);\n    }, [] as KeyValuePair[]);\n\n    this.setState({ pairs });\n  };\n\n  render() {\n    const { pairs } = this.state;\n    return (\n      <>\n        {pairs.length < 1 && addFilterButton(this.onAddFilter)}\n        {pairs.map((pair, index) => {\n          const adHocKey = `adhoc-filter-${index}-${pair.key}-${pair.value}`;\n          return (\n            <div className=\"align-items-center flex-grow-1\" key={adHocKey}>\n              <AdHocFilter\n                keys={[DEFAULT_REMOVE_FILTER_VALUE].concat(pair.keys)}\n                values={pair.values}\n                initialKey={pair.key}\n                initialOperator={pair.operator}\n                initialValue={pair.value}\n                onKeyChanged={this.onKeyChanged(index)}\n                onOperatorChanged={this.onOperatorChanged(index)}\n                onValueChanged={this.onValueChanged(index)}\n              />\n              {index < pairs.length - 1 && <span>&nbsp;AND&nbsp;</span>}\n              {index === pairs.length - 1 && addFilterButton(this.onAddFilter)}\n            </div>\n          );\n        })}\n      </>\n    );\n  }\n}\n","import React from 'react';\nimport { ExploreQueryFieldProps } from '@grafana/data';\nimport { ButtonCascader, CascaderOption } from '@grafana/ui';\n\nimport InfluxQueryModel from '../influx_query_model';\nimport { AdHocFilterField, KeyValuePair } from 'app/features/explore/AdHocFilterField';\nimport { TemplateSrv } from 'app/features/templating/template_srv';\nimport InfluxDatasource from '../datasource';\nimport { InfluxQueryBuilder } from '../query_builder';\nimport { InfluxQuery, InfluxOptions } from '../types';\n\nexport interface Props extends ExploreQueryFieldProps<InfluxDatasource, InfluxQuery, InfluxOptions> {}\n\nexport interface State {\n  measurements: CascaderOption[];\n  measurement: string;\n  field: string;\n  error: string;\n}\n\ninterface ChooserOptions {\n  measurement: string;\n  field: string;\n  error: string;\n}\n\n// Helper function for determining if a collection of pairs are valid\n// where a valid pair is either fully defined, or not defined at all, but not partially defined\nexport function pairsAreValid(pairs: KeyValuePair[]) {\n  return (\n    !pairs ||\n    pairs.every(pair => {\n      const allDefined = !!(pair.key && pair.operator && pair.value);\n      const allEmpty = pair.key === undefined && pair.operator === undefined && pair.value === undefined;\n      return allDefined || allEmpty;\n    })\n  );\n}\n\nfunction getChooserText({ measurement, field, error }: ChooserOptions): string {\n  if (error) {\n    return '(No measurement found)';\n  }\n  if (measurement) {\n    return `Measurements (${measurement}/${field})`;\n  }\n  return 'Measurements';\n}\n\nexport class InfluxLogsQueryField extends React.PureComponent<Props, State> {\n  templateSrv: TemplateSrv = new TemplateSrv();\n  state: State = { measurements: [], measurement: null, field: null, error: null };\n\n  async componentDidMount() {\n    const { datasource } = this.props;\n    try {\n      const queryBuilder = new InfluxQueryBuilder({ measurement: '', tags: [] }, datasource.database);\n      const measureMentsQuery = queryBuilder.buildExploreQuery('MEASUREMENTS');\n      const influxMeasurements = await datasource.metricFindQuery(measureMentsQuery);\n\n      const measurements = [];\n      for (let index = 0; index < influxMeasurements.length; index++) {\n        const measurementObj = influxMeasurements[index];\n        const queryBuilder = new InfluxQueryBuilder(\n          { measurement: measurementObj.text, tags: [] },\n          datasource.database\n        );\n        const fieldsQuery = queryBuilder.buildExploreQuery('FIELDS');\n        const influxFields = await datasource.metricFindQuery(fieldsQuery);\n        const fields: any[] = influxFields.map((field: any): any => ({\n          label: field.text,\n          value: field.text,\n          children: [],\n        }));\n        measurements.push({\n          label: measurementObj.text,\n          value: measurementObj.text,\n          children: fields,\n        });\n      }\n      this.setState({ measurements });\n    } catch (error) {\n      const message = error && error.message ? error.message : error;\n      this.setState({ error: message });\n    }\n  }\n\n  componentDidUpdate(prevProps: Props) {\n    if (prevProps.query.measurement && !this.props.query.measurement) {\n      this.setState({ measurement: null, field: null });\n    }\n  }\n\n  onMeasurementsChange = async (values: string[]) => {\n    const { query } = this.props;\n    const measurement = values[0];\n    const field = values[1];\n\n    this.setState({ measurement, field }, () => {\n      this.onPairsChanged((query as any).tags);\n    });\n  };\n\n  onPairsChanged = (pairs: KeyValuePair[]) => {\n    const { query } = this.props;\n    const { measurement, field } = this.state;\n    const queryModel = new InfluxQueryModel(\n      {\n        ...query,\n        resultFormat: 'table',\n        groupBy: [],\n        select: [[{ type: 'field', params: [field] }]],\n        tags: pairs,\n        limit: '1000',\n        measurement,\n      },\n      this.templateSrv\n    );\n\n    this.props.onChange(queryModel.target);\n\n    // Only run the query if measurement & field are set, and there are no invalid pairs\n    if (measurement && field && pairsAreValid(pairs)) {\n      this.props.onRunQuery();\n    }\n  };\n\n  render() {\n    const { datasource } = this.props;\n    const { measurements, measurement, field, error } = this.state;\n    const cascadeText = getChooserText({ measurement, field, error });\n    const hasMeasurement = measurements && measurements.length > 0;\n\n    return (\n      <div className=\"gf-form-inline gf-form-inline--nowrap\">\n        <div className=\"gf-form flex-shrink-0\">\n          <ButtonCascader\n            options={measurements}\n            disabled={!hasMeasurement}\n            value={[measurement, field]}\n            onChange={this.onMeasurementsChange}\n          >\n            {cascadeText}\n          </ButtonCascader>\n        </div>\n        <div className=\"flex-shrink-1 flex-flow-column-nowrap\">\n          {measurement && (\n            <AdHocFilterField\n              onPairsChanged={this.onPairsChanged}\n              datasource={datasource}\n              extendedOptions={{ measurement }}\n            />\n          )}\n          {error ? (\n            <span className=\"gf-form-label gf-form-label--transparent gf-form-label--error m-l-2\">{error}</span>\n          ) : null}\n        </div>\n      </div>\n    );\n  }\n}\n","import React from 'react';\n\nconst CHEAT_SHEET_ITEMS = [\n  {\n    title: 'Getting started',\n    label:\n      'Start by selecting a measurement and field from the dropdown above. You can then use the tag selector to further narrow your search.',\n  },\n];\n\nexport default (props: any) => (\n  <div>\n    <h2>InfluxDB Cheat Sheet</h2>\n    {CHEAT_SHEET_ITEMS.map(item => (\n      <div className=\"cheat-sheet-item\" key={item.title}>\n        <div className=\"cheat-sheet-item__title\">{item.title}</div>\n        <div className=\"cheat-sheet-item__label\">{item.label}</div>\n      </div>\n    ))}\n  </div>\n);\n","import React, { PureComponent } from 'react';\nimport { ExploreStartPageProps } from '@grafana/data';\nimport InfluxCheatSheet from './InfluxCheatSheet';\n\nexport default class InfluxStartPage extends PureComponent<ExploreStartPageProps> {\n  render() {\n    return <InfluxCheatSheet onClickExample={this.props.onClickExample} />;\n  }\n}\n","import React, { PureComponent } from 'react';\nimport {\n  DataSourcePluginOptionsEditorProps,\n  SelectableValue,\n  onUpdateDatasourceOption,\n  updateDatasourcePluginResetOption,\n  onUpdateDatasourceJsonDataOption,\n  onUpdateDatasourceJsonDataOptionSelect,\n  onUpdateDatasourceSecureJsonDataOption,\n} from '@grafana/data';\nimport { DataSourceHttpSettings, FormLabel, Input, SecretFormField, Select } from '@grafana/ui';\nimport { InfluxOptions, InfluxSecureJsonData } from '../types';\n\nconst httpModes = [\n  { label: 'GET', value: 'GET' },\n  { label: 'POST', value: 'POST' },\n] as SelectableValue[];\n\nexport type Props = DataSourcePluginOptionsEditorProps<InfluxOptions>;\n\nexport class ConfigEditor extends PureComponent<Props> {\n  onResetPassword = () => {\n    updateDatasourcePluginResetOption(this.props, 'password');\n  };\n\n  render() {\n    const { options, onOptionsChange } = this.props;\n    const { secureJsonFields } = options;\n    const secureJsonData = (options.secureJsonData || {}) as InfluxSecureJsonData;\n    return (\n      <>\n        <DataSourceHttpSettings\n          showAccessOptions={true}\n          dataSourceConfig={options}\n          defaultUrl=\"http://localhost:8086\"\n          onChange={onOptionsChange}\n        />\n\n        <h3 className=\"page-heading\">InfluxDB Details</h3>\n        <div className=\"gf-form-group\">\n          <div className=\"gf-form-inline\">\n            <div className=\"gf-form\">\n              <FormLabel className=\"width-10\">Database</FormLabel>\n              <div className=\"width-20\">\n                <Input\n                  className=\"width-20\"\n                  value={options.database || ''}\n                  onChange={onUpdateDatasourceOption(this.props, 'database')}\n                />\n              </div>\n            </div>\n          </div>\n          <div className=\"gf-form-inline\">\n            <div className=\"gf-form\">\n              <FormLabel className=\"width-10\">User</FormLabel>\n              <div className=\"width-10\">\n                <Input\n                  className=\"width-20\"\n                  value={options.user || ''}\n                  onChange={onUpdateDatasourceOption(this.props, 'user')}\n                />\n              </div>\n            </div>\n          </div>\n          <div className=\"gf-form-inline\">\n            <div className=\"gf-form\">\n              <SecretFormField\n                isConfigured={(secureJsonFields && secureJsonFields.password) as boolean}\n                value={secureJsonData.password || ''}\n                label=\"Password\"\n                labelWidth={10}\n                inputWidth={20}\n                onReset={this.onResetPassword}\n                onChange={onUpdateDatasourceSecureJsonDataOption(this.props, 'password')}\n              />\n            </div>\n          </div>\n          <div className=\"gf-form-inline\">\n            <div className=\"gf-form\">\n              <FormLabel\n                className=\"width-10\"\n                tooltip=\"You can use either GET or POST HTTP method to query your InfluxDB database. The POST\n          method allows you to perform heavy requests (with a lots of WHERE clause) while the GET method\n          will restrict you and return an error if the query is too large.\"\n              >\n                HTTP Method\n              </FormLabel>\n              <Select\n                className=\"width-10\"\n                value={httpModes.find(httpMode => httpMode.value === options.jsonData.httpMode)}\n                options={httpModes}\n                defaultValue={options.jsonData.httpMode}\n                onChange={onUpdateDatasourceJsonDataOptionSelect(this.props, 'httpMode')}\n              />\n            </div>\n          </div>\n        </div>\n        <div className=\"gf-form-group\">\n          <div className=\"grafana-info-box\">\n            <h5>Database Access</h5>\n            <p>\n              Setting the database for this datasource does not deny access to other databases. The InfluxDB query\n              syntax allows switching the database in the query. For example:\n              <code>SHOW MEASUREMENTS ON _internal</code> or <code>SELECT * FROM \"_internal\"..\"database\" LIMIT 10</code>\n              <br />\n              <br />\n              To support data isolation and security, make sure appropriate permissions are configured in InfluxDB.\n            </p>\n          </div>\n        </div>\n        <div className=\"gf-form-group\">\n          <div className=\"gf-form-inline\">\n            <div className=\"gf-form\">\n              <FormLabel\n                className=\"width-10\"\n                tooltip=\"A lower limit for the auto group by time interval. Recommended to be set to write frequency,\n\t\t\t\tfor example 1m if your data is written every minute.\"\n              >\n                Min time interval\n              </FormLabel>\n              <div className=\"width-10\">\n                <Input\n                  className=\"width-10\"\n                  placeholder=\"10s\"\n                  value={options.jsonData.timeInterval || ''}\n                  onChange={onUpdateDatasourceJsonDataOption(this.props, 'timeInterval')}\n                />\n              </div>\n            </div>\n          </div>\n        </div>\n      </>\n    );\n  }\n}\n\nexport default ConfigEditor;\n","import InfluxDatasource from './datasource';\nimport { InfluxQueryCtrl } from './query_ctrl';\nimport { InfluxLogsQueryField } from './components/InfluxLogsQueryField';\nimport InfluxStartPage from './components/InfluxStartPage';\nimport { DataSourcePlugin } from '@grafana/data';\nimport ConfigEditor from './components/ConfigEditor';\n\nclass InfluxAnnotationsQueryCtrl {\n  static templateUrl = 'partials/annotations.editor.html';\n}\n\nexport const plugin = new DataSourcePlugin(InfluxDatasource)\n  .setConfigEditor(ConfigEditor)\n  .setQueryCtrl(InfluxQueryCtrl)\n  .setAnnotationQueryCtrl(InfluxAnnotationsQueryCtrl)\n  .setExploreLogsQueryField(InfluxLogsQueryField)\n  .setExploreStartPage(InfluxStartPage);\n"],"sourceRoot":""}