{"version":3,"sources":["webpack:///./public/app/plugins/datasource/loki/syntax.ts","webpack:///./public/app/plugins/datasource/loki/language_provider.ts","webpack:///./public/app/plugins/datasource/loki/result_transformer.ts","webpack:///./public/app/plugins/datasource/loki/query_utils.ts","webpack:///./node_modules/rxjs/_esm5/internal/observable/dom/WebSocketSubject.js","webpack:///./public/app/plugins/datasource/loki/live_streams.ts","webpack:///./node_modules/rxjs/_esm5/internal/observable/dom/webSocket.js","webpack:///./public/app/plugins/datasource/loki/datasource.ts","webpack:///./public/app/plugins/datasource/loki/components/LokiCheatSheet.tsx","webpack:///./public/app/plugins/datasource/loki/components/LokiQueryField.tsx","webpack:///./public/app/plugins/datasource/loki/components/LokiQueryEditor.tsx","webpack:///./public/app/plugins/datasource/loki/LokiAnnotationsQueryCtrl.tsx","webpack:///./public/app/plugins/datasource/loki/module.ts","webpack:///./public/app/plugins/datasource/prometheus/language_utils.ts","webpack:///./public/app/plugins/datasource/prometheus/add_label_to_query.ts"],"names":["syntax","comment","pattern","lookbehind","context-labels","inside","label-key","alias","label-value","greedy","punctuation","operator","RegExp","DEFAULT_KEYS","HISTORY_COUNT_CUTOFF","wrapLabel","label","rangeToParams","range","start","from","end","to","_super","LokiLanguageProvider","datasource","initialValues","_this","call","this","cleanText","s","replace","trim","request","url","params","metadataRequest","startTask","fetchLogLabels","initialRange","then","started","labelKeys","labelValues","Object","assign","tslib_es6","prototype","getSyntax","getLabelKeys","getLabelValues","key","Promise","fetchLabelValues","_a","sent","provideCompletionItems","input","context","wrapperClasses","value","empty","document","text","length","lodash_default","a","includes","getLabelCompletionItems","getEmptyCompletionItems","suggestions","history","historyItems","chain","map","h","query","expr","filter","uniq","take","item","cutoffTs","Date","now","historyForItem","ts","count","recent","hint","src","fromNow","documentation","addHistoryMetadata","push","prefixMatch","skipSort","items","_b","labelKey","absoluteRange","line","anchorBlock","getText","cursorOffset","selection","anchor","offset","selector","parsedSelector","language_utils","_d","existingKeys","match","_c","possibleKeys","difference","importQueries","queries","datasourceType","all","importPrometheusQuery","rest","refId","selectorMatch","labels_1","_","labelsToKeep_1","keys","sort","join","logLabelFetchTs","res","data","json","body","slice","logLabelOptions","isLeaf","console","error","e_1","refreshLogLabels","forceRefresh","values_1","keyOption","children","exisingValues","nextValues","e_2","explore","logStreamToDataFrame","stream","reverse","labels","parsedLabels","times","lines","entries","next","done","entry","add","timestamp","buffer","fields","name","type","time","config","title","values","string","selectorRegexp","caseInsensitive","parseQuery","regexp","search","startsWith","formatQuery","getHighlighterExpressionsFromQuery","parsed","expression","results","filterStart","skip","substr","filterEnd","filterTerm","quotedTerm","unwrappedFilterTerm","DEFAULT_WEBSOCKET_CONFIG","deserializer","e","JSON","parse","serializer","stringify","WebSocketSubject_WebSocketSubject","WebSocketSubject","urlConfigOrSource","destination","Observable","source","_config","_output","Subject","hasOwnProperty","WebSocketCtor","WebSocket","Error","ReplaySubject","lift","sock","_resetState","_socket","multiplex","subMsg","unsubMsg","messageFilter","self","observer","err","subscription","subscribe","x","complete","unsubscribe","_connectSocket","protocol","binaryType","socket","Subscription","readyState","close","onopen","openObserver","queue","Subscriber","create","send","closingObserver","undefined","code","reason","TypeError","onerror","onclose","closeObserver","wasClean","onmessage","_subscribe","subscriber","observers","live_streams_LiveStreams","LiveStreams","streams","getStream","target","data_1","capacity","size","addField","other","pipe","finalize","response","streams_1","streams_1_1","unique","e_3","appendResponseToBufferedData","DEFAULT_MAX_LINES","DEFAULT_QUERY_PARAMS","direction","limit","serializeParams","k","v","encodeURIComponent","LokiDatasource","instanceSettings","backendSrv","templateSrv","processError","message","utils_explore","status","statusText","series","dataFrame","meta","searchWords","maxLines","runLiveQuery","options","liveTarget","prepareLiveTarget","state","Streaming","runQuery","prepareQueryTarget","_request","catch","cancelled","processResult","prepareLogRowContextQueryTarget","row","timeEpochNs","timeEpochMs","commontTargetOptons","trys","result","languageProvider","language_provider","settingsData","jsonData","$inject","apiUrl","req","datasourceRequest","baseUrl","Math","min","maxDataPoints","Infinity","getTime","targets","hide","liveStreaming","merge","apply","subQueries","originMeta","silent","modifyQuery","action","add_label_to_query","getHighlighterExpression","date","roundUp","isString","ceil","valueOf","testDatasource","annotation","requestId","dashboardId","dashboard","id","scopedVars","startTime","timezone","panelId","interval","intervalMs","queryRequestFromAnnotationOptions","frame","tags","forEachRow","data_1_1","_loop_1","DEFAULT_EXAMPLES","PREFERRED_LABELS","EXAMPLES_LIMIT","LokiCheatSheet","arguments","userExamples","props","provider","find","l","lodash","preferredLabel_1","componentDidMount","scheduleUserLabelChecking","componentWillUnmount","clearTimeout","userLabelTimer","setTimeout","checkUserLabels","renderExpression","onClickExample","react_default","createElement","className","onClick","render","example","href","LokiQueryField","datasourceStatus","otherProps","useLokiSyntax","isSyntaxReady","setActiveOption","refreshLabels","syntaxProps","LokiQueryFieldForm","syntaxLoaded","onLoadOptions","onLabelsRefresh","react","absolute","panelData","onChange","onRunQuery","grafana_ui_src","Connected","LokiAnnotationsQueryCtrl","onQueryChange","bind","templateUrl","__webpack_require__","d","__webpack_exports__","LokiConfigCtrl","loki_datasource","components_LokiQueryEditor","components_LokiQueryField","components_LokiCheatSheet","processHistogramLabels","index","test","indexOf","__name__","processLabels","withName","forEach","tslib__WEBPACK_IMPORTED_MODULE_0__","labelRegexp","parseSelector","prefix","prefixOpen","lastIndexOf","prefixClose","suffix","suffixClose","suffixOpenIndex","suffixOpen","metricMatch","cleanSelector","expandRecordingRules","mapping","ruleNames","rulesRegex","pre","post","addLabelToSelector","lodash__WEBPACK_IMPORTED_MODULE_0__","lodash__WEBPACK_IMPORTED_MODULE_0___default","n","keywords","builtInWords","split","metricNameRegexp","labelValue","labelOperator","exec","operatorForLabelKey","uniqWith","isEqual","compact","sortBy","previousWord","word","position","openChar","closeChar","nextSelectorStart","nextSelectorEnd","insideSelector","previousWordIsKeyWord","isColonBounded","endsWith","parts","lastIndex","selectorWithLabel"],"mappings":"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","file":"lokiPlugin.3932bda029d2299a9d96.js","sourcesContent":["import { Grammar } from 'prismjs';\n\n/* tslint:disable max-line-length */\n\nconst tokenizer: Grammar = {\n  comment: {\n    pattern: /(^|[^\\n])#.*/,\n    lookbehind: true,\n  },\n  'context-labels': {\n    pattern: /(^|\\s)\\{[^}]*(?=})/,\n    lookbehind: true,\n    inside: {\n      'label-key': {\n        pattern: /[a-z_]\\w*(?=\\s*(=|!=|=~|!~))/,\n        alias: 'attr-name',\n      },\n      'label-value': {\n        pattern: /\"(?:\\\\.|[^\\\\\"])*\"/,\n        greedy: true,\n        alias: 'attr-value',\n      },\n      punctuation: /[{]/,\n    },\n  },\n  // number: /\\b-?\\d+((\\.\\d*)?([eE][+-]?\\d+)?)?\\b/,\n  operator: new RegExp(`/&&?|\\\\|?\\\\||!=?|<(?:=>?|<|>)?|>[>=]?`, 'i'),\n  punctuation: /[{}`,.]/,\n};\n\nexport default tokenizer;\n","// Libraries\nimport _ from 'lodash';\n\n// Services & Utils\nimport { parseSelector, labelRegexp, selectorRegexp } from 'app/plugins/datasource/prometheus/language_utils';\nimport syntax from './syntax';\n\n// Types\nimport { CompletionItem, LanguageProvider, TypeaheadInput, TypeaheadOutput, HistoryItem } from 'app/types/explore';\nimport { LokiQuery } from './types';\nimport { dateTime, AbsoluteTimeRange } from '@grafana/data';\nimport { PromQuery } from '../prometheus/types';\n\nimport LokiDatasource from './datasource';\n\nconst DEFAULT_KEYS = ['job', 'namespace'];\nconst EMPTY_SELECTOR = '{}';\nconst HISTORY_ITEM_COUNT = 10;\nconst HISTORY_COUNT_CUTOFF = 1000 * 60 * 60 * 24; // 24h\nconst NS_IN_MS = 1000000;\nexport const LABEL_REFRESH_INTERVAL = 1000 * 30; // 30sec\n\nconst wrapLabel = (label: string) => ({ label });\nexport const rangeToParams = (range: AbsoluteTimeRange) => ({ start: range.from * NS_IN_MS, end: range.to * NS_IN_MS });\n\nexport type LokiHistoryItem = HistoryItem<LokiQuery>;\n\ntype TypeaheadContext = {\n  history?: LokiHistoryItem[];\n  absoluteRange?: AbsoluteTimeRange;\n};\n\nexport function addHistoryMetadata(item: CompletionItem, history: LokiHistoryItem[]): CompletionItem {\n  const cutoffTs = Date.now() - HISTORY_COUNT_CUTOFF;\n  const historyForItem = history.filter(h => h.ts > cutoffTs && (h.query.expr as string) === item.label);\n  const count = historyForItem.length;\n  const recent = historyForItem[0];\n  let hint = `Queried ${count} times in the last 24h.`;\n  if (recent) {\n    const lastQueried = dateTime(recent.ts).fromNow();\n    hint = `${hint} Last queried ${lastQueried}.`;\n  }\n  return {\n    ...item,\n    documentation: hint,\n  };\n}\n\nexport default class LokiLanguageProvider extends LanguageProvider {\n  labelKeys?: { [index: string]: string[] }; // metric -> [labelKey,...]\n  labelValues?: { [index: string]: { [index: string]: string[] } }; // metric -> labelKey -> [labelValue,...]\n  logLabelOptions: any[];\n  logLabelFetchTs?: number;\n  started: boolean;\n  initialRange: AbsoluteTimeRange;\n  datasource: LokiDatasource;\n\n  constructor(datasource: LokiDatasource, initialValues?: any) {\n    super();\n\n    this.datasource = datasource;\n    this.labelKeys = {};\n    this.labelValues = {};\n\n    Object.assign(this, initialValues);\n  }\n\n  // Strip syntax chars\n  cleanText = (s: string) => s.replace(/[{}[\\]=\"(),!~+\\-*/^%]/g, '').trim();\n\n  getSyntax() {\n    return syntax;\n  }\n\n  request = (url: string, params?: any) => {\n    return this.datasource.metadataRequest(url, params);\n  };\n\n  /**\n   * Initialise the language provider by fetching set of labels. Without this initialisation the provider would return\n   * just a set of hardcoded default labels on provideCompletionItems or a recent queries from history.\n   */\n  start = () => {\n    if (!this.startTask) {\n      this.startTask = this.fetchLogLabels(this.initialRange).then(() => {\n        this.started = true;\n        return [];\n      });\n    }\n    return this.startTask;\n  };\n\n  getLabelKeys(): string[] {\n    return this.labelKeys[EMPTY_SELECTOR];\n  }\n\n  async getLabelValues(key: string): Promise<string[]> {\n    await this.fetchLabelValues(key, this.initialRange);\n    return this.labelValues[EMPTY_SELECTOR][key];\n  }\n\n  /**\n   * Return suggestions based on input that can be then plugged into a typeahead dropdown.\n   * Keep this DOM-free for testing\n   * @param input\n   * @param context Is optional in types but is required in case we are doing getLabelCompletionItems\n   * @param context.absoluteRange Required in case we are doing getLabelCompletionItems\n   * @param context.history Optional used only in getEmptyCompletionItems\n   */\n  async provideCompletionItems(input: TypeaheadInput, context?: TypeaheadContext): Promise<TypeaheadOutput> {\n    const { wrapperClasses, value } = input;\n    // Local text properties\n    const empty = value.document.text.length === 0;\n    // Determine candidates by CSS context\n    if (_.includes(wrapperClasses, 'context-labels')) {\n      // Suggestions for {|} and {foo=|}\n      return await this.getLabelCompletionItems(input, context);\n    } else if (empty) {\n      return this.getEmptyCompletionItems(context || {});\n    }\n\n    return {\n      suggestions: [],\n    };\n  }\n\n  getEmptyCompletionItems(context: any): TypeaheadOutput {\n    const { history } = context;\n    const suggestions = [];\n\n    if (history && history.length > 0) {\n      const historyItems = _.chain(history)\n        .map((h: any) => h.query.expr)\n        .filter()\n        .uniq()\n        .take(HISTORY_ITEM_COUNT)\n        .map(wrapLabel)\n        .map((item: CompletionItem) => addHistoryMetadata(item, history))\n        .value();\n\n      suggestions.push({\n        prefixMatch: true,\n        skipSort: true,\n        label: 'History',\n        items: historyItems,\n      });\n    }\n\n    return { suggestions };\n  }\n\n  async getLabelCompletionItems(\n    { text, wrapperClasses, labelKey, value }: TypeaheadInput,\n    { absoluteRange }: any\n  ): Promise<TypeaheadOutput> {\n    let context: string;\n    const suggestions = [];\n    const line = value.anchorBlock.getText();\n    const cursorOffset: number = value.selection.anchor.offset;\n\n    // Use EMPTY_SELECTOR until series API is implemented for facetting\n    const selector = EMPTY_SELECTOR;\n    let parsedSelector;\n    try {\n      parsedSelector = parseSelector(line, cursorOffset);\n    } catch {}\n    const existingKeys = parsedSelector ? parsedSelector.labelKeys : [];\n\n    if ((text && text.match(/^!?=~?/)) || wrapperClasses.includes('attr-value')) {\n      // Label values\n      if (labelKey && this.labelValues[selector]) {\n        let labelValues = this.labelValues[selector][labelKey];\n        if (!labelValues) {\n          await this.fetchLabelValues(labelKey, absoluteRange);\n          labelValues = this.labelValues[selector][labelKey];\n        }\n\n        context = 'context-label-values';\n        suggestions.push({\n          label: `Label values for \"${labelKey}\"`,\n          items: labelValues.map(wrapLabel),\n        });\n      }\n    } else {\n      // Label keys\n      const labelKeys = this.labelKeys[selector] || DEFAULT_KEYS;\n      if (labelKeys) {\n        const possibleKeys = _.difference(labelKeys, existingKeys);\n        if (possibleKeys.length > 0) {\n          context = 'context-labels';\n          suggestions.push({ label: `Labels`, items: possibleKeys.map(wrapLabel) });\n        }\n      }\n    }\n\n    return { context, suggestions };\n  }\n\n  async importQueries(queries: LokiQuery[], datasourceType: string): Promise<LokiQuery[]> {\n    if (datasourceType === 'prometheus') {\n      return Promise.all(\n        queries.map(async query => {\n          const expr = await this.importPrometheusQuery(query.expr);\n          const { context, ...rest } = query as PromQuery;\n          return {\n            ...rest,\n            expr,\n          };\n        })\n      );\n    }\n    // Return a cleaned LokiQuery\n    return queries.map(query => ({\n      refId: query.refId,\n      expr: '',\n    }));\n  }\n\n  async importPrometheusQuery(query: string): Promise<string> {\n    if (!query) {\n      return '';\n    }\n\n    // Consider only first selector in query\n    const selectorMatch = query.match(selectorRegexp);\n    if (selectorMatch) {\n      const selector = selectorMatch[0];\n      const labels: { [key: string]: { value: any; operator: any } } = {};\n      selector.replace(labelRegexp, (_, key, operator, value) => {\n        labels[key] = { value, operator };\n        return '';\n      });\n\n      // Keep only labels that exist on origin and target datasource\n      await this.start(); // fetches all existing label keys\n      const existingKeys = this.labelKeys[EMPTY_SELECTOR];\n      let labelsToKeep: { [key: string]: { value: any; operator: any } } = {};\n      if (existingKeys && existingKeys.length > 0) {\n        // Check for common labels\n        for (const key in labels) {\n          if (existingKeys && existingKeys.includes(key)) {\n            // Should we check for label value equality here?\n            labelsToKeep[key] = labels[key];\n          }\n        }\n      } else {\n        // Keep all labels by default\n        labelsToKeep = labels;\n      }\n\n      const labelKeys = Object.keys(labelsToKeep).sort();\n      const cleanSelector = labelKeys\n        .map(key => `${key}${labelsToKeep[key].operator}${labelsToKeep[key].value}`)\n        .join(',');\n\n      return ['{', cleanSelector, '}'].join('');\n    }\n\n    return '';\n  }\n\n  async fetchLogLabels(absoluteRange: AbsoluteTimeRange): Promise<any> {\n    const url = '/api/prom/label';\n    try {\n      this.logLabelFetchTs = Date.now();\n\n      const res = await this.request(url, rangeToParams(absoluteRange));\n      const body = await (res.data || res.json());\n      const labelKeys = body.data.slice().sort();\n      this.labelKeys = {\n        ...this.labelKeys,\n        [EMPTY_SELECTOR]: labelKeys,\n      };\n      this.labelValues = {\n        [EMPTY_SELECTOR]: {},\n      };\n      this.logLabelOptions = labelKeys.map((key: string) => ({ label: key, value: key, isLeaf: false }));\n    } catch (e) {\n      console.error(e);\n    }\n    return [];\n  }\n\n  async refreshLogLabels(absoluteRange: AbsoluteTimeRange, forceRefresh?: boolean) {\n    if ((this.labelKeys && Date.now() - this.logLabelFetchTs > LABEL_REFRESH_INTERVAL) || forceRefresh) {\n      await this.fetchLogLabels(absoluteRange);\n    }\n  }\n\n  async fetchLabelValues(key: string, absoluteRange: AbsoluteTimeRange) {\n    const url = `/api/prom/label/${key}/values`;\n    try {\n      const res = await this.request(url, rangeToParams(absoluteRange));\n      const body = await (res.data || res.json());\n      const values = body.data.slice().sort();\n\n      // Add to label options\n      this.logLabelOptions = this.logLabelOptions.map(keyOption => {\n        if (keyOption.value === key) {\n          return {\n            ...keyOption,\n            children: values.map((value: string) => ({ label: value, value })),\n          };\n        }\n        return keyOption;\n      });\n\n      // Add to key map\n      const exisingValues = this.labelValues[EMPTY_SELECTOR];\n      const nextValues = {\n        ...exisingValues,\n        [key]: values,\n      };\n      this.labelValues = {\n        ...this.labelValues,\n        [EMPTY_SELECTOR]: nextValues,\n      };\n    } catch (e) {\n      console.error(e);\n    }\n  }\n}\n","import { LokiLogsStream, LokiResponse } from './types';\nimport {\n  parseLabels,\n  FieldType,\n  Labels,\n  DataFrame,\n  ArrayVector,\n  MutableDataFrame,\n  findUniqueLabels,\n} from '@grafana/data';\n\n/**\n * Transforms LokiLogStream structure into a dataFrame. Used when doing standard queries.\n */\nexport function logStreamToDataFrame(stream: LokiLogsStream, reverse?: boolean, refId?: string): DataFrame {\n  let labels: Labels = stream.parsedLabels;\n  if (!labels && stream.labels) {\n    labels = parseLabels(stream.labels);\n  }\n  const times = new ArrayVector<string>([]);\n  const lines = new ArrayVector<string>([]);\n\n  for (const entry of stream.entries) {\n    times.add(entry.ts || entry.timestamp);\n    lines.add(entry.line);\n  }\n\n  if (reverse) {\n    times.buffer = times.buffer.reverse();\n    lines.buffer = lines.buffer.reverse();\n  }\n\n  return {\n    refId,\n    labels,\n    fields: [\n      { name: 'ts', type: FieldType.time, config: { title: 'Time' }, values: times }, // Time\n      { name: 'line', type: FieldType.string, config: {}, values: lines }, // Line\n    ],\n    length: times.length,\n  };\n}\n\n/**\n * Transform LokiResponse data and appends it to MutableDataFrame. Used for streaming where the dataFrame can be\n * a CircularDataFrame creating a fixed size rolling buffer.\n * TODO: Probably could be unified with the logStreamToDataFrame function.\n */\nexport function appendResponseToBufferedData(response: LokiResponse, data: MutableDataFrame) {\n  // Should we do anythign with: response.dropped_entries?\n\n  const streams: LokiLogsStream[] = response.streams;\n  if (streams && streams.length) {\n    for (const stream of streams) {\n      // Find unique labels\n      const labels = parseLabels(stream.labels);\n      const unique = findUniqueLabels(labels, data.labels);\n\n      // Add each line\n      for (const entry of stream.entries) {\n        data.values.ts.add(entry.ts || entry.timestamp);\n        data.values.line.add(entry.line);\n        data.values.labels.add(unique);\n      }\n    }\n  }\n}\n","import { LokiExpression } from './types';\n\nconst selectorRegexp = /(?:^|\\s){[^{]*}/g;\nconst caseInsensitive = '(?i)'; // Golang mode modifier for Loki, doesn't work in JavaScript\nexport function parseQuery(input: string): LokiExpression {\n  input = input || '';\n  const match = input.match(selectorRegexp);\n  let query = input;\n  let regexp = '';\n\n  if (match) {\n    regexp = input.replace(selectorRegexp, '').trim();\n    // Keep old-style regexp, otherwise take whole query\n    if (regexp && regexp.search(/\\|=|\\|~|!=|!~/) === -1) {\n      query = match[0].trim();\n      if (!regexp.startsWith(caseInsensitive)) {\n        regexp = `${caseInsensitive}${regexp}`;\n      }\n    } else {\n      regexp = '';\n    }\n  }\n\n  return { regexp, query };\n}\n\nexport function formatQuery(selector: string, search: string): string {\n  return `${selector || ''} ${search || ''}`.trim();\n}\n\n/**\n * Returns search terms from a LogQL query.\n * E.g., `{} |= foo |=bar != baz` returns `['foo', 'bar']`.\n */\nexport function getHighlighterExpressionsFromQuery(input: string): string[] {\n  const parsed = parseQuery(input);\n  // Legacy syntax\n  if (parsed.regexp) {\n    return [parsed.regexp];\n  }\n  let expression = input;\n  const results = [];\n  // Consume filter expression from left to right\n  while (expression) {\n    const filterStart = expression.search(/\\|=|\\|~|!=|!~/);\n    // Nothing more to search\n    if (filterStart === -1) {\n      break;\n    }\n    // Drop terms for negative filters\n    const skip = expression.substr(filterStart).search(/!=|!~/) === 0;\n    expression = expression.substr(filterStart + 2);\n    if (skip) {\n      continue;\n    }\n    // Check if there is more chained\n    const filterEnd = expression.search(/\\|=|\\|~|!=|!~/);\n    let filterTerm;\n    if (filterEnd === -1) {\n      filterTerm = expression.trim();\n    } else {\n      filterTerm = expression.substr(0, filterEnd).trim();\n      expression = expression.substr(filterEnd);\n    }\n\n    // Unwrap the filter term by removing quotes\n    const quotedTerm = filterTerm.match(/^\"((?:[^\\\\\"]|\\\\\")*)\"$/);\n\n    if (quotedTerm) {\n      const unwrappedFilterTerm = quotedTerm[1];\n      results.push(unwrappedFilterTerm);\n    } else {\n      return null;\n    }\n  }\n  return results;\n}\n","/** PURE_IMPORTS_START tslib,_.._Subject,_.._Subscriber,_.._Observable,_.._Subscription,_.._ReplaySubject PURE_IMPORTS_END */\nimport * as tslib_1 from \"tslib\";\nimport { Subject, AnonymousSubject } from '../../Subject';\nimport { Subscriber } from '../../Subscriber';\nimport { Observable } from '../../Observable';\nimport { Subscription } from '../../Subscription';\nimport { ReplaySubject } from '../../ReplaySubject';\nvar DEFAULT_WEBSOCKET_CONFIG = {\n    url: '',\n    deserializer: function (e) { return JSON.parse(e.data); },\n    serializer: function (value) { return JSON.stringify(value); },\n};\nvar WEBSOCKETSUBJECT_INVALID_ERROR_OBJECT = 'WebSocketSubject.error must be called with an object with an error code, and an optional reason: { code: number, reason: string }';\nvar WebSocketSubject = /*@__PURE__*/ (function (_super) {\n    tslib_1.__extends(WebSocketSubject, _super);\n    function WebSocketSubject(urlConfigOrSource, destination) {\n        var _this = _super.call(this) || this;\n        if (urlConfigOrSource instanceof Observable) {\n            _this.destination = destination;\n            _this.source = urlConfigOrSource;\n        }\n        else {\n            var config = _this._config = tslib_1.__assign({}, DEFAULT_WEBSOCKET_CONFIG);\n            _this._output = new Subject();\n            if (typeof urlConfigOrSource === 'string') {\n                config.url = urlConfigOrSource;\n            }\n            else {\n                for (var key in urlConfigOrSource) {\n                    if (urlConfigOrSource.hasOwnProperty(key)) {\n                        config[key] = urlConfigOrSource[key];\n                    }\n                }\n            }\n            if (!config.WebSocketCtor && WebSocket) {\n                config.WebSocketCtor = WebSocket;\n            }\n            else if (!config.WebSocketCtor) {\n                throw new Error('no WebSocket constructor can be found');\n            }\n            _this.destination = new ReplaySubject();\n        }\n        return _this;\n    }\n    WebSocketSubject.prototype.lift = function (operator) {\n        var sock = new WebSocketSubject(this._config, this.destination);\n        sock.operator = operator;\n        sock.source = this;\n        return sock;\n    };\n    WebSocketSubject.prototype._resetState = function () {\n        this._socket = null;\n        if (!this.source) {\n            this.destination = new ReplaySubject();\n        }\n        this._output = new Subject();\n    };\n    WebSocketSubject.prototype.multiplex = function (subMsg, unsubMsg, messageFilter) {\n        var self = this;\n        return new Observable(function (observer) {\n            try {\n                self.next(subMsg());\n            }\n            catch (err) {\n                observer.error(err);\n            }\n            var subscription = self.subscribe(function (x) {\n                try {\n                    if (messageFilter(x)) {\n                        observer.next(x);\n                    }\n                }\n                catch (err) {\n                    observer.error(err);\n                }\n            }, function (err) { return observer.error(err); }, function () { return observer.complete(); });\n            return function () {\n                try {\n                    self.next(unsubMsg());\n                }\n                catch (err) {\n                    observer.error(err);\n                }\n                subscription.unsubscribe();\n            };\n        });\n    };\n    WebSocketSubject.prototype._connectSocket = function () {\n        var _this = this;\n        var _a = this._config, WebSocketCtor = _a.WebSocketCtor, protocol = _a.protocol, url = _a.url, binaryType = _a.binaryType;\n        var observer = this._output;\n        var socket = null;\n        try {\n            socket = protocol ?\n                new WebSocketCtor(url, protocol) :\n                new WebSocketCtor(url);\n            this._socket = socket;\n            if (binaryType) {\n                this._socket.binaryType = binaryType;\n            }\n        }\n        catch (e) {\n            observer.error(e);\n            return;\n        }\n        var subscription = new Subscription(function () {\n            _this._socket = null;\n            if (socket && socket.readyState === 1) {\n                socket.close();\n            }\n        });\n        socket.onopen = function (e) {\n            var _socket = _this._socket;\n            if (!_socket) {\n                socket.close();\n                _this._resetState();\n                return;\n            }\n            var openObserver = _this._config.openObserver;\n            if (openObserver) {\n                openObserver.next(e);\n            }\n            var queue = _this.destination;\n            _this.destination = Subscriber.create(function (x) {\n                if (socket.readyState === 1) {\n                    try {\n                        var serializer = _this._config.serializer;\n                        socket.send(serializer(x));\n                    }\n                    catch (e) {\n                        _this.destination.error(e);\n                    }\n                }\n            }, function (e) {\n                var closingObserver = _this._config.closingObserver;\n                if (closingObserver) {\n                    closingObserver.next(undefined);\n                }\n                if (e && e.code) {\n                    socket.close(e.code, e.reason);\n                }\n                else {\n                    observer.error(new TypeError(WEBSOCKETSUBJECT_INVALID_ERROR_OBJECT));\n                }\n                _this._resetState();\n            }, function () {\n                var closingObserver = _this._config.closingObserver;\n                if (closingObserver) {\n                    closingObserver.next(undefined);\n                }\n                socket.close();\n                _this._resetState();\n            });\n            if (queue && queue instanceof ReplaySubject) {\n                subscription.add(queue.subscribe(_this.destination));\n            }\n        };\n        socket.onerror = function (e) {\n            _this._resetState();\n            observer.error(e);\n        };\n        socket.onclose = function (e) {\n            _this._resetState();\n            var closeObserver = _this._config.closeObserver;\n            if (closeObserver) {\n                closeObserver.next(e);\n            }\n            if (e.wasClean) {\n                observer.complete();\n            }\n            else {\n                observer.error(e);\n            }\n        };\n        socket.onmessage = function (e) {\n            try {\n                var deserializer = _this._config.deserializer;\n                observer.next(deserializer(e));\n            }\n            catch (err) {\n                observer.error(err);\n            }\n        };\n    };\n    WebSocketSubject.prototype._subscribe = function (subscriber) {\n        var _this = this;\n        var source = this.source;\n        if (source) {\n            return source.subscribe(subscriber);\n        }\n        if (!this._socket) {\n            this._connectSocket();\n        }\n        this._output.subscribe(subscriber);\n        subscriber.add(function () {\n            var _socket = _this._socket;\n            if (_this._output.observers.length === 0) {\n                if (_socket && _socket.readyState === 1) {\n                    _socket.close();\n                }\n                _this._resetState();\n            }\n        });\n        return subscriber;\n    };\n    WebSocketSubject.prototype.unsubscribe = function () {\n        var _socket = this._socket;\n        if (_socket && _socket.readyState === 1) {\n            _socket.close();\n        }\n        this._resetState();\n        _super.prototype.unsubscribe.call(this);\n    };\n    return WebSocketSubject;\n}(AnonymousSubject));\nexport { WebSocketSubject };\n//# sourceMappingURL=WebSocketSubject.js.map\n","import { DataFrame, FieldType, parseLabels, KeyValue, CircularDataFrame } from '@grafana/data';\nimport { Observable } from 'rxjs';\nimport { webSocket } from 'rxjs/webSocket';\nimport { LokiResponse } from './types';\nimport { finalize, map } from 'rxjs/operators';\nimport { appendResponseToBufferedData } from './result_transformer';\n\n/**\n * Maps directly to a query in the UI (refId is key)\n */\nexport interface LiveTarget {\n  query: string;\n  regexp: string;\n  url: string;\n  refId: string;\n  size: number;\n}\n\n/**\n * Cache of websocket streams that can be returned as observable. In case there already is a stream for particular\n * target it is returned and on subscription returns the latest dataFrame.\n */\nexport class LiveStreams {\n  private streams: KeyValue<Observable<DataFrame[]>> = {};\n\n  getStream(target: LiveTarget): Observable<DataFrame[]> {\n    let stream = this.streams[target.url];\n    if (!stream) {\n      const data = new CircularDataFrame({ capacity: target.size });\n      data.labels = parseLabels(target.query);\n      data.addField({ name: 'ts', type: FieldType.time, config: { title: 'Time' } });\n      data.addField({ name: 'line', type: FieldType.string });\n      data.addField({ name: 'labels', type: FieldType.other });\n\n      stream = webSocket(target.url).pipe(\n        finalize(() => {\n          delete this.streams[target.url];\n        }),\n        map((response: LokiResponse) => {\n          appendResponseToBufferedData(response, data);\n          return [data];\n        })\n      );\n      this.streams[target.url] = stream;\n    }\n    return stream;\n  }\n}\n","/** PURE_IMPORTS_START _WebSocketSubject PURE_IMPORTS_END */\nimport { WebSocketSubject } from './WebSocketSubject';\nexport function webSocket(urlConfigOrSource) {\n    return new WebSocketSubject(urlConfigOrSource);\n}\n//# sourceMappingURL=webSocket.js.map\n","// Libraries\nimport _ from 'lodash';\n// Services & Utils\nimport {\n  dateMath,\n  DataFrame,\n  LogRowModel,\n  DateTime,\n  AnnotationEvent,\n  DataFrameView,\n  LoadingState,\n} from '@grafana/data';\nimport { addLabelToSelector } from 'app/plugins/datasource/prometheus/add_label_to_query';\nimport LanguageProvider from './language_provider';\nimport { logStreamToDataFrame } from './result_transformer';\nimport { formatQuery, parseQuery, getHighlighterExpressionsFromQuery } from './query_utils';\n// Types\nimport {\n  PluginMeta,\n  DataSourceApi,\n  DataSourceInstanceSettings,\n  DataQueryError,\n  DataQueryRequest,\n  DataQueryResponse,\n  AnnotationQueryRequest,\n} from '@grafana/ui';\n\nimport { LokiQuery, LokiOptions, LokiLogsStream, LokiResponse } from './types';\nimport { BackendSrv } from 'app/core/services/backend_srv';\nimport { TemplateSrv } from 'app/features/templating/template_srv';\nimport { safeStringifyValue, convertToWebSocketUrl } from 'app/core/utils/explore';\nimport { LiveTarget, LiveStreams } from './live_streams';\nimport { Observable, from, merge } from 'rxjs';\nimport { map, filter } from 'rxjs/operators';\n\nexport const DEFAULT_MAX_LINES = 1000;\n\nconst DEFAULT_QUERY_PARAMS = {\n  direction: 'BACKWARD',\n  limit: DEFAULT_MAX_LINES,\n  regexp: '',\n  query: '',\n};\n\nfunction serializeParams(data: any) {\n  return Object.keys(data)\n    .map(k => {\n      const v = data[k];\n      return encodeURIComponent(k) + '=' + encodeURIComponent(v);\n    })\n    .join('&');\n}\n\ninterface LokiContextQueryOptions {\n  direction?: 'BACKWARD' | 'FORWARD';\n  limit?: number;\n}\n\nexport class LokiDatasource extends DataSourceApi<LokiQuery, LokiOptions> {\n  private streams = new LiveStreams();\n  languageProvider: LanguageProvider;\n  maxLines: number;\n\n  /** @ngInject */\n  constructor(\n    private instanceSettings: DataSourceInstanceSettings<LokiOptions>,\n    private backendSrv: BackendSrv,\n    private templateSrv: TemplateSrv\n  ) {\n    super(instanceSettings);\n    this.languageProvider = new LanguageProvider(this);\n    const settingsData = instanceSettings.jsonData || {};\n    this.maxLines = parseInt(settingsData.maxLines, 10) || DEFAULT_MAX_LINES;\n  }\n\n  _request(apiUrl: string, data?: any, options?: any) {\n    const baseUrl = this.instanceSettings.url;\n    const params = data ? serializeParams(data) : '';\n    const url = `${baseUrl}${apiUrl}?${params}`;\n    const req = {\n      ...options,\n      url,\n    };\n\n    return this.backendSrv.datasourceRequest(req);\n  }\n\n  prepareLiveTarget(target: LokiQuery, options: DataQueryRequest<LokiQuery>): LiveTarget {\n    const interpolated = this.templateSrv.replace(target.expr);\n    const { query, regexp } = parseQuery(interpolated);\n    const refId = target.refId;\n    const baseUrl = this.instanceSettings.url;\n    const params = serializeParams({ query, regexp });\n    const url = convertToWebSocketUrl(`${baseUrl}/api/prom/tail?${params}`);\n\n    return {\n      query,\n      regexp,\n      url,\n      refId,\n      size: Math.min(options.maxDataPoints || Infinity, this.maxLines),\n    };\n  }\n\n  prepareQueryTarget(target: LokiQuery, options: DataQueryRequest<LokiQuery>) {\n    const interpolated = this.templateSrv.replace(target.expr);\n    const { query, regexp } = parseQuery(interpolated);\n    const start = this.getTime(options.range.from, false);\n    const end = this.getTime(options.range.to, true);\n    const refId = target.refId;\n    return {\n      ...DEFAULT_QUERY_PARAMS,\n      query,\n      regexp,\n      start,\n      end,\n      limit: Math.min(options.maxDataPoints || Infinity, this.maxLines),\n      refId,\n    };\n  }\n\n  processError = (err: any, target: any): DataQueryError => {\n    const error: DataQueryError = {\n      message: 'Unknown error during query transaction. Please check JS console logs.',\n      refId: target.refId,\n    };\n\n    if (err.data) {\n      if (typeof err.data === 'string') {\n        error.message = err.data;\n      } else if (err.data.error) {\n        error.message = safeStringifyValue(err.data.error);\n      }\n    } else if (err.message) {\n      error.message = err.message;\n    } else if (typeof err === 'string') {\n      error.message = err;\n    }\n\n    error.status = err.status;\n    error.statusText = err.statusText;\n\n    return error;\n  };\n\n  processResult = (data: LokiLogsStream | LokiResponse, target: any): DataFrame[] => {\n    const series: DataFrame[] = [];\n\n    if (Object.keys(data).length === 0) {\n      return series;\n    }\n\n    if (!(data as any).streams) {\n      return [logStreamToDataFrame(data as LokiLogsStream, false, target.refId)];\n    }\n\n    data = data as LokiResponse;\n    for (const stream of data.streams || []) {\n      const dataFrame = logStreamToDataFrame(stream);\n      dataFrame.refId = target.refId;\n      dataFrame.meta = {\n        searchWords: getHighlighterExpressionsFromQuery(formatQuery(target.query, target.regexp)),\n        limit: this.maxLines,\n      };\n      series.push(dataFrame);\n    }\n\n    return series;\n  };\n\n  runLiveQuery = (options: DataQueryRequest<LokiQuery>, target: LokiQuery): Observable<DataQueryResponse> => {\n    const liveTarget = this.prepareLiveTarget(target, options);\n    const stream = this.streams.getStream(liveTarget);\n    return stream.pipe(\n      map(data => {\n        return {\n          data,\n          key: `loki-${liveTarget.refId}`,\n          state: LoadingState.Streaming,\n        };\n      })\n    );\n  };\n\n  runQuery = (options: DataQueryRequest<LokiQuery>, target: LokiQuery): Observable<DataQueryResponse> => {\n    const query = this.prepareQueryTarget(target, options);\n    return from(\n      this._request('/api/prom/query', query).catch((err: any) => {\n        if (err.cancelled) {\n          return err;\n        }\n\n        const error: DataQueryError = this.processError(err, query);\n        throw error;\n      })\n    ).pipe(\n      filter((response: any) => (response.cancelled ? false : true)),\n      map((response: any) => {\n        const data = this.processResult(response.data, query);\n        return { data, key: query.refId };\n      })\n    );\n  };\n\n  query(options: DataQueryRequest<LokiQuery>): Observable<DataQueryResponse> {\n    const subQueries = options.targets\n      .filter(target => target.expr && !target.hide)\n      .map(target => {\n        if (target.liveStreaming) {\n          return this.runLiveQuery(options, target);\n        }\n        return this.runQuery(options, target);\n      });\n\n    return merge(...subQueries);\n  }\n\n  async importQueries(queries: LokiQuery[], originMeta: PluginMeta): Promise<LokiQuery[]> {\n    return this.languageProvider.importQueries(queries, originMeta.id);\n  }\n\n  metadataRequest(url: string, params?: any) {\n    // HACK to get label values for {job=|}, will be replaced when implementing LokiQueryField\n    const apiUrl = url.replace('v1', 'prom');\n    return this._request(apiUrl, params, { silent: true }).then((res: DataQueryResponse) => {\n      const data: any = { data: { data: res.data.values || [] } };\n      return data;\n    });\n  }\n\n  modifyQuery(query: LokiQuery, action: any): LokiQuery {\n    const parsed = parseQuery(query.expr || '');\n    let { query: selector } = parsed;\n    switch (action.type) {\n      case 'ADD_FILTER': {\n        selector = addLabelToSelector(selector, action.key, action.value);\n        break;\n      }\n      default:\n        break;\n    }\n    const expression = formatQuery(selector, parsed.regexp);\n    return { ...query, expr: expression };\n  }\n\n  getHighlighterExpression(query: LokiQuery): string[] {\n    return getHighlighterExpressionsFromQuery(query.expr);\n  }\n\n  getTime(date: string | DateTime, roundUp: boolean) {\n    if (_.isString(date)) {\n      date = dateMath.parse(date, roundUp);\n    }\n    return Math.ceil(date.valueOf() * 1e6);\n  }\n\n  prepareLogRowContextQueryTarget = (row: LogRowModel, limit: number, direction: 'BACKWARD' | 'FORWARD') => {\n    const query = Object.keys(row.labels)\n      .map(label => {\n        return `${label}=\"${row.labels[label]}\"`;\n      })\n      .join(',');\n    const contextTimeBuffer = 2 * 60 * 60 * 1000 * 1e6; // 2h buffer\n    const timeEpochNs = row.timeEpochMs * 1e6;\n\n    const commontTargetOptons = {\n      limit,\n      query: `{${query}}`,\n      direction,\n    };\n\n    if (direction === 'BACKWARD') {\n      return {\n        ...commontTargetOptons,\n        start: timeEpochNs - contextTimeBuffer,\n        end: row.timestamp, // using RFC3339Nano format to avoid precision loss\n        direction,\n      };\n    } else {\n      return {\n        ...commontTargetOptons,\n        start: row.timestamp, // start param in Loki API is inclusive so we'll have to filter out the row that this request is based from\n        end: timeEpochNs + contextTimeBuffer,\n      };\n    }\n  };\n\n  getLogRowContext = async (row: LogRowModel, options?: LokiContextQueryOptions) => {\n    const target = this.prepareLogRowContextQueryTarget(\n      row,\n      (options && options.limit) || 10,\n      (options && options.direction) || 'BACKWARD'\n    );\n    const series: DataFrame[] = [];\n\n    try {\n      const reverse = options && options.direction === 'FORWARD';\n      const result = await this._request('/api/prom/query', target);\n      if (result.data) {\n        for (const stream of result.data.streams || []) {\n          series.push(logStreamToDataFrame(stream, reverse));\n        }\n      }\n\n      return {\n        data: series,\n      };\n    } catch (e) {\n      const error: DataQueryError = {\n        message: 'Error during context query. Please check JS console logs.',\n        status: e.status,\n        statusText: e.statusText,\n      };\n      throw error;\n    }\n  };\n\n  testDatasource() {\n    // Consider only last 10 minutes otherwise request takes too long\n    const startMs = Date.now() - 10 * 60 * 1000;\n    const start = `${startMs}000000`; // API expects nanoseconds\n    return this._request('/api/prom/label', { start })\n      .then((res: DataQueryResponse) => {\n        if (res && res.data && res.data.values && res.data.values.length > 0) {\n          return { status: 'success', message: 'Data source connected and labels found.' };\n        }\n        return {\n          status: 'error',\n          message:\n            'Data source connected, but no labels received. Verify that Loki and Promtail is configured properly.',\n        };\n      })\n      .catch((err: any) => {\n        let message = 'Loki: ';\n        if (err.statusText) {\n          message += err.statusText;\n        } else {\n          message += 'Cannot connect to Loki';\n        }\n\n        if (err.status) {\n          message += `. ${err.status}`;\n        }\n\n        if (err.data && err.data.message) {\n          message += `. ${err.data.message}`;\n        } else if (err.data) {\n          message += `. ${err.data}`;\n        }\n        return { status: 'error', message: message };\n      });\n  }\n\n  async annotationQuery(options: AnnotationQueryRequest<LokiQuery>): Promise<AnnotationEvent[]> {\n    if (!options.annotation.expr) {\n      return [];\n    }\n\n    const request = queryRequestFromAnnotationOptions(options);\n    const { data } = await this.runQuery(request, request.targets[0]).toPromise();\n    const annotations: AnnotationEvent[] = [];\n\n    for (const frame of data) {\n      const tags = Object.values(frame.labels) as string[];\n      const view = new DataFrameView<{ ts: string; line: string }>(frame);\n\n      view.forEachRow(row => {\n        annotations.push({\n          time: new Date(row.ts).valueOf(),\n          text: row.line,\n          tags,\n        });\n      });\n    }\n\n    return annotations;\n  }\n}\n\nfunction queryRequestFromAnnotationOptions(options: AnnotationQueryRequest<LokiQuery>): DataQueryRequest<LokiQuery> {\n  const refId = `annotation-${options.annotation.name}`;\n  const target: LokiQuery = { refId, expr: options.annotation.expr };\n\n  return {\n    requestId: refId,\n    range: options.range,\n    targets: [target],\n    dashboardId: options.dashboard.id,\n    scopedVars: null,\n    startTime: Date.now(),\n\n    // This should mean the default defined on datasource is used.\n    maxDataPoints: 0,\n\n    // Dummy values, are required in type but not used here.\n    timezone: 'utc',\n    panelId: 0,\n    interval: '',\n    intervalMs: 0,\n  };\n}\n\nexport default LokiDatasource;\n","import React, { PureComponent } from 'react';\nimport { shuffle } from 'lodash';\nimport { ExploreStartPageProps, DataQuery } from '@grafana/ui';\nimport LokiLanguageProvider from '../language_provider';\n\nconst DEFAULT_EXAMPLES = ['{job=\"default/prometheus\"}'];\nconst PREFERRED_LABELS = ['job', 'app', 'k8s_app'];\nconst EXAMPLES_LIMIT = 5;\n\nexport default class LokiCheatSheet extends PureComponent<ExploreStartPageProps, { userExamples: string[] }> {\n  userLabelTimer: NodeJS.Timeout;\n  state = {\n    userExamples: DEFAULT_EXAMPLES,\n  };\n\n  componentDidMount() {\n    this.scheduleUserLabelChecking();\n  }\n\n  componentWillUnmount() {\n    clearTimeout(this.userLabelTimer);\n  }\n\n  scheduleUserLabelChecking() {\n    this.userLabelTimer = setTimeout(this.checkUserLabels, 1000);\n  }\n\n  checkUserLabels = async () => {\n    // Set example from user labels\n    const provider: LokiLanguageProvider = this.props.datasource.languageProvider;\n    if (provider.started) {\n      const labels = provider.getLabelKeys() || [];\n      const preferredLabel = PREFERRED_LABELS.find(l => labels.includes(l));\n      if (preferredLabel) {\n        const values = await provider.getLabelValues(preferredLabel);\n        const userExamples = shuffle(values)\n          .slice(0, EXAMPLES_LIMIT)\n          .map(value => `{${preferredLabel}=\"${value}\"}`);\n        this.setState({ userExamples });\n      }\n    } else {\n      this.scheduleUserLabelChecking();\n    }\n  };\n\n  renderExpression(expr: string) {\n    const { onClickExample } = this.props;\n\n    return (\n      <div\n        className=\"cheat-sheet-item__example\"\n        key={expr}\n        onClick={e => onClickExample({ refId: 'A', expr } as DataQuery)}\n      >\n        <code>{expr}</code>\n      </div>\n    );\n  }\n\n  render() {\n    const { userExamples } = this.state;\n\n    return (\n      <div>\n        <h2>Loki Cheat Sheet</h2>\n        <div className=\"cheat-sheet-item\">\n          <div className=\"cheat-sheet-item__title\">See your logs</div>\n          <div className=\"cheat-sheet-item__label\">Start by selecting a log stream from the Log labels selector.</div>\n          <div className=\"cheat-sheet-item__label\">\n            Alternatively, you can write a stream selector into the query field:\n          </div>\n          {this.renderExpression('{job=\"default/prometheus\"}')}\n          {userExamples !== DEFAULT_EXAMPLES && userExamples.length > 0 ? (\n            <div>\n              <div className=\"cheat-sheet-item__label\">Here are some example streams from your logs:</div>\n              {userExamples.map(example => this.renderExpression(example))}\n            </div>\n          ) : null}\n        </div>\n        <div className=\"cheat-sheet-item\">\n          <div className=\"cheat-sheet-item__title\">Combine stream selectors</div>\n          {this.renderExpression('{app=\"cassandra\",namespace=\"prod\"}')}\n          <div className=\"cheat-sheet-item__label\">Returns all log lines from streams that have both labels.</div>\n        </div>\n\n        <div className=\"cheat-sheet-item\">\n          <div className=\"cheat-sheet-item__title\">Filtering for search terms.</div>\n          {this.renderExpression('{app=\"cassandra\"} |~ \"(duration|latency)s*(=|is|of)s*[d.]+\"')}\n          {this.renderExpression('{app=\"cassandra\"} |= \"exact match\"')}\n          {this.renderExpression('{app=\"cassandra\"} != \"do not match\"')}\n          <div className=\"cheat-sheet-item__label\">\n            <a href=\"https://github.com/grafana/loki/blob/master/docs/logql.md#filter-expression\" target=\"logql\">\n              LogQL\n            </a>{' '}\n            supports exact and regular expression filters.\n          </div>\n        </div>\n      </div>\n    );\n  }\n}\n","import React, { FunctionComponent } from 'react';\nimport { LokiQueryFieldForm, LokiQueryFieldFormProps } from './LokiQueryFieldForm';\nimport { useLokiSyntax } from './useLokiSyntax';\nimport LokiLanguageProvider from '../language_provider';\n\nexport const LokiQueryField: FunctionComponent<LokiQueryFieldFormProps> = ({\n  datasource,\n  datasourceStatus,\n  ...otherProps\n}) => {\n  const { isSyntaxReady, setActiveOption, refreshLabels, ...syntaxProps } = useLokiSyntax(\n    datasource.languageProvider as LokiLanguageProvider,\n    datasourceStatus,\n    otherProps.absoluteRange\n  );\n\n  return (\n    <LokiQueryFieldForm\n      datasource={datasource}\n      datasourceStatus={datasourceStatus}\n      syntaxLoaded={isSyntaxReady}\n      /**\n       * setActiveOption name is intentional. Because of the way rc-cascader requests additional data\n       * https://github.com/react-component/cascader/blob/master/src/Cascader.jsx#L165\n       * we are notyfing useLokiSyntax hook, what the active option is, and then it's up to the hook logic\n       * to fetch data of options that aren't fetched yet\n       */\n      onLoadOptions={setActiveOption}\n      onLabelsRefresh={refreshLabels}\n      {...syntaxProps}\n      {...otherProps}\n    />\n  );\n};\n\nexport default LokiQueryField;\n","// Libraries\nimport React, { memo } from 'react';\n\n// Types\nimport { AbsoluteTimeRange } from '@grafana/data';\nimport { QueryEditorProps, DataSourceStatus } from '@grafana/ui';\nimport { LokiDatasource } from '../datasource';\nimport { LokiQuery } from '../types';\nimport { LokiQueryField } from './LokiQueryField';\nimport { useLokiSyntax } from './useLokiSyntax';\n\ntype Props = QueryEditorProps<LokiDatasource, LokiQuery>;\n\nexport const LokiQueryEditor = memo(function LokiQueryEditor(props: Props) {\n  const { query, panelData, datasource, onChange, onRunQuery } = props;\n\n  let absolute: AbsoluteTimeRange;\n  if (panelData && panelData.request) {\n    const { range } = panelData.request;\n    absolute = {\n      from: range.from.valueOf(),\n      to: range.to.valueOf(),\n    };\n  } else {\n    absolute = {\n      from: Date.now() - 10000,\n      to: Date.now(),\n    };\n  }\n\n  const { isSyntaxReady, setActiveOption, refreshLabels, ...syntaxProps } = useLokiSyntax(\n    datasource.languageProvider,\n    // TODO maybe use real status\n    DataSourceStatus.Connected,\n    absolute\n  );\n\n  return (\n    <div>\n      <LokiQueryField\n        datasource={datasource}\n        datasourceStatus={DataSourceStatus.Connected}\n        query={query}\n        onChange={onChange}\n        onRunQuery={onRunQuery}\n        history={[]}\n        panelData={panelData}\n        onLoadOptions={setActiveOption}\n        onLabelsRefresh={refreshLabels}\n        syntaxLoaded={isSyntaxReady}\n        absoluteRange={absolute}\n        {...syntaxProps}\n      />\n    </div>\n  );\n});\n\nexport default LokiQueryEditor;\n","/**\n * Just a simple wrapper for a react component that is actually implementing the query editor.\n */\nexport class LokiAnnotationsQueryCtrl {\n  static templateUrl = 'partials/annotations.editor.html';\n  annotation: any;\n\n  /** @ngInject */\n  constructor() {\n    this.annotation.target = this.annotation.target || {};\n    this.onQueryChange = this.onQueryChange.bind(this);\n  }\n\n  onQueryChange(expr: string) {\n    this.annotation.expr = expr;\n  }\n}\n","import Datasource from './datasource';\n\nimport LokiCheatSheet from './components/LokiCheatSheet';\nimport LokiQueryField from './components/LokiQueryField';\nimport LokiQueryEditor from './components/LokiQueryEditor';\nimport { LokiAnnotationsQueryCtrl } from './LokiAnnotationsQueryCtrl';\n\nexport class LokiConfigCtrl {\n  static templateUrl = 'partials/config.html';\n}\n\nexport {\n  Datasource,\n  LokiQueryEditor as QueryEditor,\n  LokiConfigCtrl as ConfigCtrl,\n  LokiQueryField as ExploreQueryField,\n  LokiCheatSheet as ExploreStartPage,\n  LokiAnnotationsQueryCtrl as AnnotationsQueryCtrl,\n};\n","export const RATE_RANGES = ['1m', '5m', '10m', '30m', '1h'];\n\nexport const processHistogramLabels = (labels: string[]) => {\n  const result = [];\n  const regexp = new RegExp('_bucket($|:)');\n  for (let index = 0; index < labels.length; index++) {\n    const label = labels[index];\n    const isHistogramValue = regexp.test(label);\n    if (isHistogramValue) {\n      if (result.indexOf(label) === -1) {\n        result.push(label);\n      }\n    }\n  }\n\n  return { values: { __name__: result } };\n};\n\nexport function processLabels(labels: Array<{ [key: string]: string }>, withName = false) {\n  const values: { [key: string]: string[] } = {};\n  labels.forEach(l => {\n    const { __name__, ...rest } = l;\n    if (withName) {\n      values['__name__'] = values['__name__'] || [];\n      if (!values['__name__'].includes(__name__)) {\n        values['__name__'].push(__name__);\n      }\n    }\n\n    Object.keys(rest).forEach(key => {\n      if (!values[key]) {\n        values[key] = [];\n      }\n      if (!values[key].includes(rest[key])) {\n        values[key].push(rest[key]);\n      }\n    });\n  });\n  return { values, keys: Object.keys(values) };\n}\n\n// const cleanSelectorRegexp = /\\{(\\w+=\"[^\"\\n]*?\")(,\\w+=\"[^\"\\n]*?\")*\\}/;\nexport const selectorRegexp = /\\{[^}]*?\\}/;\nexport const labelRegexp = /\\b(\\w+)(!?=~?)(\"[^\"\\n]*?\")/g;\nexport function parseSelector(query: string, cursorOffset = 1): { labelKeys: any[]; selector: string } {\n  if (!query.match(selectorRegexp)) {\n    // Special matcher for metrics\n    if (query.match(/^[A-Za-z:][\\w:]*$/)) {\n      return {\n        selector: `{__name__=\"${query}\"}`,\n        labelKeys: ['__name__'],\n      };\n    }\n    throw new Error('Query must contain a selector: ' + query);\n  }\n\n  // Check if inside a selector\n  const prefix = query.slice(0, cursorOffset);\n  const prefixOpen = prefix.lastIndexOf('{');\n  const prefixClose = prefix.lastIndexOf('}');\n  if (prefixOpen === -1) {\n    throw new Error('Not inside selector, missing open brace: ' + prefix);\n  }\n  if (prefixClose > -1 && prefixClose > prefixOpen) {\n    throw new Error('Not inside selector, previous selector already closed: ' + prefix);\n  }\n  const suffix = query.slice(cursorOffset);\n  const suffixCloseIndex = suffix.indexOf('}');\n  const suffixClose = suffixCloseIndex + cursorOffset;\n  const suffixOpenIndex = suffix.indexOf('{');\n  const suffixOpen = suffixOpenIndex + cursorOffset;\n  if (suffixClose === -1) {\n    throw new Error('Not inside selector, missing closing brace in suffix: ' + suffix);\n  }\n  if (suffixOpenIndex > -1 && suffixOpen < suffixClose) {\n    throw new Error('Not inside selector, next selector opens before this one closed: ' + suffix);\n  }\n\n  // Extract clean labels to form clean selector, incomplete labels are dropped\n  const selector = query.slice(prefixOpen, suffixClose);\n  const labels: { [key: string]: { value: string; operator: string } } = {};\n  selector.replace(labelRegexp, (_, key, operator, value) => {\n    labels[key] = { value, operator };\n    return '';\n  });\n\n  // Add metric if there is one before the selector\n  const metricPrefix = query.slice(0, prefixOpen);\n  const metricMatch = metricPrefix.match(/[A-Za-z:][\\w:]*$/);\n  if (metricMatch) {\n    labels['__name__'] = { value: `\"${metricMatch[0]}\"`, operator: '=' };\n  }\n\n  // Build sorted selector\n  const labelKeys = Object.keys(labels).sort();\n  const cleanSelector = labelKeys.map(key => `${key}${labels[key].operator}${labels[key].value}`).join(',');\n\n  const selectorString = ['{', cleanSelector, '}'].join('');\n\n  return { labelKeys, selector: selectorString };\n}\n\nexport function expandRecordingRules(query: string, mapping: { [name: string]: string }): string {\n  const ruleNames = Object.keys(mapping);\n  const rulesRegex = new RegExp(`(\\\\s|^)(${ruleNames.join('|')})(\\\\s|$|\\\\(|\\\\[|\\\\{)`, 'ig');\n  return query.replace(rulesRegex, (match, pre, name, post) => `${pre}${mapping[name]}${post}`);\n}\n","import _ from 'lodash';\n\nconst keywords = 'by|without|on|ignoring|group_left|group_right|bool|or|and|unless';\n\n// Duplicate from mode-prometheus.js, which can't be used in tests due to global ace not being loaded.\nconst builtInWords = [\n  keywords,\n  'count|count_values|min|max|avg|sum|stddev|stdvar|bottomk|topk|quantile',\n  'true|false|null|__name__|job',\n  'abs|absent|ceil|changes|clamp_max|clamp_min|count_scalar|day_of_month|day_of_week|days_in_month|delta|deriv',\n  'drop_common_labels|exp|floor|histogram_quantile|holt_winters|hour|idelta|increase|irate|label_replace|ln|log2',\n  'log10|minute|month|predict_linear|rate|resets|round|scalar|sort|sort_desc|sqrt|time|vector|year|avg_over_time',\n  'min_over_time|max_over_time|sum_over_time|count_over_time|quantile_over_time|stddev_over_time|stdvar_over_time',\n]\n  .join('|')\n  .split('|');\n\nconst metricNameRegexp = /([A-Za-z:][\\w:]*)\\b(?![\\(\\]{=!\",])/g;\nconst selectorRegexp = /{([^{]*)}/g;\n\n// addLabelToQuery('foo', 'bar', 'baz') => 'foo{bar=\"baz\"}'\nexport function addLabelToQuery(query: string, key: string, value: string, operator?: string): string {\n  if (!key || !value) {\n    throw new Error('Need label to add to query.');\n  }\n\n  // Add empty selectors to bare metric names\n  let previousWord: string;\n  query = query.replace(metricNameRegexp, (match, word, offset) => {\n    const insideSelector = isPositionInsideChars(query, offset, '{', '}');\n    // Handle \"sum by (key) (metric)\"\n    const previousWordIsKeyWord = previousWord && keywords.split('|').indexOf(previousWord) > -1;\n\n    // check for colon as as \"word boundary\" symbol\n    const isColonBounded = word.endsWith(':');\n\n    previousWord = word;\n    if (!insideSelector && !isColonBounded && !previousWordIsKeyWord && builtInWords.indexOf(word) === -1) {\n      return `${word}{}`;\n    }\n    return word;\n  });\n\n  // Adding label to existing selectors\n  let match = selectorRegexp.exec(query);\n  const parts = [];\n  let lastIndex = 0;\n  let suffix = '';\n\n  while (match) {\n    const prefix = query.slice(lastIndex, match.index);\n    const selector = match[1];\n    const selectorWithLabel = addLabelToSelector(selector, key, value, operator);\n    lastIndex = match.index + match[1].length + 2;\n    suffix = query.slice(match.index + match[0].length);\n    parts.push(prefix, selectorWithLabel);\n    match = selectorRegexp.exec(query);\n  }\n\n  parts.push(suffix);\n  return parts.join('');\n}\n\nconst labelRegexp = /(\\w+)\\s*(=|!=|=~|!~)\\s*(\"[^\"]*\")/g;\n\nexport function addLabelToSelector(selector: string, labelKey: string, labelValue: string, labelOperator?: string) {\n  const parsedLabels = [];\n\n  // Split selector into labels\n  if (selector) {\n    let match = labelRegexp.exec(selector);\n    while (match) {\n      parsedLabels.push({ key: match[1], operator: match[2], value: match[3] });\n      match = labelRegexp.exec(selector);\n    }\n  }\n\n  // Add new label\n  const operatorForLabelKey = labelOperator || '=';\n  parsedLabels.push({ key: labelKey, operator: operatorForLabelKey, value: `\"${labelValue}\"` });\n\n  // Sort labels by key and put them together\n  const formatted = _.chain(parsedLabels)\n    .uniqWith(_.isEqual)\n    .compact()\n    .sortBy('key')\n    .map(({ key, operator, value }) => `${key}${operator}${value}`)\n    .value()\n    .join(',');\n\n  return `{${formatted}}`;\n}\n\nfunction isPositionInsideChars(text: string, position: number, openChar: string, closeChar: string) {\n  const nextSelectorStart = text.slice(position).indexOf(openChar);\n  const nextSelectorEnd = text.slice(position).indexOf(closeChar);\n  return nextSelectorEnd > -1 && (nextSelectorStart === -1 || nextSelectorStart > nextSelectorEnd);\n}\n\nexport default addLabelToQuery;\n"],"sourceRoot":""}