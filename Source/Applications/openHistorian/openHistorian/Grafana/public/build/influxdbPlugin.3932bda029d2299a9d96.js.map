{"version":3,"sources":["webpack:///./public/app/plugins/datasource/influxdb/influx_series.ts","webpack:///./public/app/plugins/datasource/influxdb/query_part.ts","webpack:///./public/app/plugins/datasource/influxdb/influx_query_model.ts","webpack:///./public/app/plugins/datasource/influxdb/response_parser.ts","webpack:///./public/app/features/explore/AdHocFilter.tsx","webpack:///./public/app/plugins/datasource/influxdb/query_builder.ts","webpack:///./public/app/plugins/datasource/influxdb/datasource.ts","webpack:///./public/app/plugins/datasource/influxdb/query_ctrl.ts","webpack:///./public/app/features/explore/AdHocFilterField.tsx","webpack:///./public/app/plugins/datasource/influxdb/components/InfluxLogsQueryField.tsx","webpack:///./public/app/plugins/datasource/influxdb/components/InfluxCheatSheet.tsx","webpack:///./public/app/plugins/datasource/influxdb/components/InfluxStartPage.tsx","webpack:///./public/app/plugins/datasource/influxdb/module.ts"],"names":["InfluxSeries","options","this","series","alias","annotation","prototype","getTimeSeries","i","j","_this","output","length","lodash_default","a","each","columns","tags","map","value","key","seriesName","name","columnName","_getSeriesName","join","datapoints","values","push","target","index","segments","split","replace","match","g1","g2","group","segIndex","parseInt","isNaN","indexOf","tag","getAnnotations","list","titleCol","timeCol","tagsCol","textCol","column","titleColumn","includes","tagsColumn","textColumn","data","time","Date","title","flatten","filter","t","text","getTable","table","table_model","seriesIndex","type","src","keys","reordered","hasOwnProperty","rows","query_part_index","query_part_categories","Aggregations","Selectors","Transformations","Predictors","Math","Aliasing","Fields","createPart","part","def","message","query_part","register","category","groupByTimeFunctions","fieldRenderer","innerExpr","params","replaceAggregationAddStrategy","selectParts","partModel","morePartsAvailable","splice","addTransformationStrategy","addStrategy","query","parts","clone","selectModels","dynamicLookup","defaultParams","renderer","partCount","quote","renderMode","influxdb_query_part","create","getCategories","replaceAggregationAdd","InfluxQueryModel","templateSrv","scopedVars","policy","resultFormat","orderByTime","groupBy","select","updateProjection","$inject","groupByParts","updatePersistedParts","hasGroupByTime","find","g","hasFill","addGroupBy","stringParts","typePart","arg","removeGroupByPart","categories","s","removeSelect","removeSelectPart","modelsIndex","partIndex","addSelectPart","renderTagCondition","interpolate","str","operator","condition","test","getMeasurementAndPolicy","measurement","interpolateQueryStr","variable","defaultFormatFn","multi","includeAll","kbn","regexEscape","render","rawQuery","y","selectText","conditions","groupBySection","fill","limit","slimit","tz","renderAdhocFilters","filters","response_parser","ResponseParser","parse","results","influxResults","normalizedQuery","toLowerCase","isValueFirst","res","serie","isArray","addUnique","undefined","toString","arr","ChangeType","query_builder_InfluxQueryBuilder","InfluxQueryBuilder","database","buildExploreQuery","withKey","withMeasurementFilter","whereConditions","reduce","memo","_super","InfluxDatasource","instanceSettings","$q","backendSrv","call","urls","url","trim","username","password","basicAuth","withCredentials","settingsData","jsonData","interval","timeInterval","responseParser","tslib_es6","queryModel","timeFilter","getTimeFilter","targets","cloneDeep","queryTargets","hide","__interval","influx_query_model","acc","current","allQueries","when","adhocFilters","getAdhocFilters","_seriesQuery","then","seriesList","result","influxSeries","influx_series","timeSeries","annotationQuery","reject","rangeRaw","timezone","e_1","_a","e_2","_b","_d","_e","_f","next","done","param","variableExists","error","metricFindQuery","interpolated","curry","getTagKeys","getTagValues","range","_influxRequest","httpMode","q","epoch","serializeParams","encodeURIComponent","testDatasource","get","status","catch","err","method","currentUrl","shift","u","p","db","has","extend","omit","pick","req","precision","inspect","paramSerializer","headers","Authorization","datasourceRequest","config","statusText","from","getInfluxTime","until","to","fromIsAbsolute","date","roundUp","isString","exec","valueOf","query_ctrl_InfluxQueryCtrl","InfluxQueryCtrl","$scope","$injector","uiSegmentSrv","panel","queryBuilder","datasource","groupBySegment","newPlusButton","resultFormats","policySegment","newSegment","measurementSegment","newSelectMeasurement","_c","tagSegments","newCondition","newKey","fixTagSegments","buildSelectMenu","removeTagFilterSegment","removeOrderByTime","cat","submenu","item","menu","getGroupByOptions","tags_1","tags_1_1","handleQueryError","bind","groupByAction","plusButton","html","panelCtrl","refresh","subitem","handleSelectPartEvent","evt","fieldsQuery","transformToSegments","handleGroupByPartEvent","tagsQuery","count","lastSegment","max","measurementChanged","getPolicySegments","policiesQuery","policyChanged","toggleEditorMode","console","log","getMeasurements","measurementFilter","segment","expandable","variables","unshift","e_3","getTagsOrValues","addTemplateVars","nextValue","newOperators","angular_default","copy","getFieldSegments","tagSegmentUpdated","newOperator","newFake","cssClass","rebuildTargetTagConditions","tagIndex","segment2","getTagValueOperator","tagOperator","tagValue","getCollapsedText","templateUrl","AdHocFilter","props","Object","react","grafana_ui_src","styles","keyValueContainer","index_esm","templateObject_1","changeType","onKeyChanged","onValueChanged","onOperatorChanged","Key","Operator","Value","stringToOption","label","initialKey","keysPlaceHolder","initialOperator","initialValue","valuesPlaceHolder","keysAsOptions","selectedKey","option","valuesAsOptions","selectedValue","operatorsAsOptions","selectedOperator","react_default","createElement","className","isSearchable","onChange","placeholder","DEFAULT_REMOVE_FILTER_VALUE","addFilterButton","onAddFilter","onClick","AdHocFilterField","extendedOptions","sent","onPairsChanged_1","onPairsChanged","loadTagValues","setState","pairs","pairs_1","updatePairs","state","loadTagKeys","allPairs","pair","pairIndex","componentDidUpdate","prevProps","isEqual","pairs_2","newPairs","newPair","Fragment","adHocKey","concat","InfluxLogsQueryField","apply","arguments","field","every","allDefined","allEmpty","pairsAreValid","measureMentsQuery","influxMeasurements","measurementObj","queryBuilder_1","influxFields","children","measurements","cascadeText","AdHocFilterField_AdHocFilterField","InfluxCheatSheet","InfluxStartPage","onClickExample","passwordHandlers","__webpack_require__","d","__webpack_exports__","module_plugin","InfluxConfigCtrl","onPasswordReset","Password","onPasswordChange","InfluxAnnotationsQueryCtrl","influxdb_datasource","setConfigCtrl","module_InfluxConfigCtrl","setQueryCtrl"],"mappings":"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","file":"influxdbPlugin.3932bda029d2299a9d96.js","sourcesContent":["import _ from 'lodash';\nimport TableModel from 'app/core/table_model';\nimport { FieldType } from '@grafana/data';\n\nexport default class InfluxSeries {\n  series: any;\n  alias: any;\n  annotation: any;\n\n  constructor(options: { series: any; alias?: any; annotation?: any }) {\n    this.series = options.series;\n    this.alias = options.alias;\n    this.annotation = options.annotation;\n  }\n\n  getTimeSeries() {\n    const output: any[] = [];\n    let i, j;\n\n    if (this.series.length === 0) {\n      return output;\n    }\n\n    _.each(this.series, series => {\n      const columns = series.columns.length;\n      const tags = _.map(series.tags, (value, key) => {\n        return key + ': ' + value;\n      });\n\n      for (j = 1; j < columns; j++) {\n        let seriesName = series.name;\n        const columnName = series.columns[j];\n        if (columnName !== 'value') {\n          seriesName = seriesName + '.' + columnName;\n        }\n\n        if (this.alias) {\n          seriesName = this._getSeriesName(series, j);\n        } else if (series.tags) {\n          seriesName = seriesName + ' {' + tags.join(', ') + '}';\n        }\n\n        const datapoints = [];\n        if (series.values) {\n          for (i = 0; i < series.values.length; i++) {\n            datapoints[i] = [series.values[i][j], series.values[i][0]];\n          }\n        }\n\n        output.push({ target: seriesName, datapoints: datapoints });\n      }\n    });\n\n    return output;\n  }\n\n  _getSeriesName(series: any, index: number) {\n    const regex = /\\$(\\w+)|\\[\\[([\\s\\S]+?)\\]\\]/g;\n    const segments = series.name.split('.');\n\n    return this.alias.replace(regex, (match: any, g1: any, g2: any) => {\n      const group = g1 || g2;\n      const segIndex = parseInt(group, 10);\n\n      if (group === 'm' || group === 'measurement') {\n        return series.name;\n      }\n      if (group === 'col') {\n        return series.columns[index];\n      }\n      if (!isNaN(segIndex)) {\n        return segments[segIndex];\n      }\n      if (group.indexOf('tag_') !== 0) {\n        return match;\n      }\n\n      const tag = group.replace('tag_', '');\n      if (!series.tags) {\n        return match;\n      }\n      return series.tags[tag];\n    });\n  }\n\n  getAnnotations() {\n    const list: any[] = [];\n\n    _.each(this.series, series => {\n      let titleCol: any = null;\n      let timeCol: any = null;\n      const tagsCol: any = [];\n      let textCol: any = null;\n\n      _.each(series.columns, (column, index) => {\n        if (column === 'time') {\n          timeCol = index;\n          return;\n        }\n        if (column === 'sequence_number') {\n          return;\n        }\n        if (column === this.annotation.titleColumn) {\n          titleCol = index;\n          return;\n        }\n        if (_.includes((this.annotation.tagsColumn || '').replace(' ', '').split(','), column)) {\n          tagsCol.push(index);\n          return;\n        }\n        if (column === this.annotation.textColumn) {\n          textCol = index;\n          return;\n        }\n        // legacy case\n        if (!titleCol && textCol !== index) {\n          titleCol = index;\n        }\n      });\n\n      _.each(series.values, value => {\n        const data = {\n          annotation: this.annotation,\n          time: +new Date(value[timeCol]),\n          title: value[titleCol],\n          // Remove empty values, then split in different tags for comma separated values\n          tags: _.flatten(\n            tagsCol\n              .filter((t: any) => {\n                return value[t];\n              })\n              .map((t: any) => {\n                return value[t].split(',');\n              })\n          ),\n          text: value[textCol],\n        };\n\n        list.push(data);\n      });\n    });\n\n    return list;\n  }\n\n  getTable() {\n    const table = new TableModel();\n    let i, j;\n\n    if (this.series.length === 0) {\n      return table;\n    }\n\n    _.each(this.series, (series: any, seriesIndex: number) => {\n      if (seriesIndex === 0) {\n        j = 0;\n        // Check that the first column is indeed 'time'\n        if (series.columns[0] === 'time') {\n          // Push this now before the tags and with the right type\n          table.columns.push({ text: 'Time', type: FieldType.time });\n          j++;\n        }\n        _.each(_.keys(series.tags), key => {\n          table.columns.push({ text: key });\n        });\n        for (; j < series.columns.length; j++) {\n          table.columns.push({ text: series.columns[j] });\n        }\n      }\n\n      if (series.values) {\n        for (i = 0; i < series.values.length; i++) {\n          const values = series.values[i];\n          const reordered = [values[0]];\n          if (series.tags) {\n            for (const key in series.tags) {\n              if (series.tags.hasOwnProperty(key)) {\n                reordered.push(series.tags[key]);\n              }\n            }\n          }\n          for (j = 1; j < values.length; j++) {\n            reordered.push(values[j]);\n          }\n          table.rows.push(reordered);\n        }\n      }\n    });\n\n    return table;\n  }\n}\n","import _ from 'lodash';\nimport { QueryPartDef, QueryPart, functionRenderer, suffixRenderer } from 'app/core/components/query_part/query_part';\n\nconst index: any[] = [];\nconst categories: any = {\n  Aggregations: [],\n  Selectors: [],\n  Transformations: [],\n  Predictors: [],\n  Math: [],\n  Aliasing: [],\n  Fields: [],\n};\n\nfunction createPart(part: any): any {\n  const def = index[part.type];\n  if (!def) {\n    throw { message: 'Could not find query part ' + part.type };\n  }\n\n  return new QueryPart(part, def);\n}\n\nfunction register(options: any) {\n  index[options.type] = new QueryPartDef(options);\n  options.category.push(index[options.type]);\n}\n\nconst groupByTimeFunctions: any[] = [];\n\nfunction aliasRenderer(part: { params: string[] }, innerExpr: string) {\n  return innerExpr + ' AS ' + '\"' + part.params[0] + '\"';\n}\n\nfunction fieldRenderer(part: { params: string[] }, innerExpr: any) {\n  if (part.params[0] === '*') {\n    return '*';\n  }\n  return '\"' + part.params[0] + '\"';\n}\n\nfunction replaceAggregationAddStrategy(selectParts: any[], partModel: { def: { type: string } }) {\n  // look for existing aggregation\n  for (let i = 0; i < selectParts.length; i++) {\n    const part = selectParts[i];\n    if (part.def.category === categories.Aggregations) {\n      if (part.def.type === partModel.def.type) {\n        return;\n      }\n      // count distinct is allowed\n      if (part.def.type === 'count' && partModel.def.type === 'distinct') {\n        break;\n      }\n      // remove next aggregation if distinct was replaced\n      if (part.def.type === 'distinct') {\n        const morePartsAvailable = selectParts.length >= i + 2;\n        if (partModel.def.type !== 'count' && morePartsAvailable) {\n          const nextPart = selectParts[i + 1];\n          if (nextPart.def.category === categories.Aggregations) {\n            selectParts.splice(i + 1, 1);\n          }\n        } else if (partModel.def.type === 'count') {\n          if (!morePartsAvailable || selectParts[i + 1].def.type !== 'count') {\n            selectParts.splice(i + 1, 0, partModel);\n          }\n          return;\n        }\n      }\n      selectParts[i] = partModel;\n      return;\n    }\n    if (part.def.category === categories.Selectors) {\n      selectParts[i] = partModel;\n      return;\n    }\n  }\n\n  selectParts.splice(1, 0, partModel);\n}\n\nfunction addTransformationStrategy(selectParts: any[], partModel: any) {\n  let i;\n  // look for index to add transformation\n  for (i = 0; i < selectParts.length; i++) {\n    const part = selectParts[i];\n    if (part.def.category === categories.Math || part.def.category === categories.Aliasing) {\n      break;\n    }\n  }\n\n  selectParts.splice(i, 0, partModel);\n}\n\nfunction addMathStrategy(selectParts: any[], partModel: any) {\n  const partCount = selectParts.length;\n  if (partCount > 0) {\n    // if last is math, replace it\n    if (selectParts[partCount - 1].def.type === 'math') {\n      selectParts[partCount - 1] = partModel;\n      return;\n    }\n    // if next to last is math, replace it\n    if (partCount > 1 && selectParts[partCount - 2].def.type === 'math') {\n      selectParts[partCount - 2] = partModel;\n      return;\n    } else if (selectParts[partCount - 1].def.type === 'alias') {\n      // if last is alias add it before\n      selectParts.splice(partCount - 1, 0, partModel);\n      return;\n    }\n  }\n  selectParts.push(partModel);\n}\n\nfunction addAliasStrategy(selectParts: any[], partModel: any) {\n  const partCount = selectParts.length;\n  if (partCount > 0) {\n    // if last is alias, replace it\n    if (selectParts[partCount - 1].def.type === 'alias') {\n      selectParts[partCount - 1] = partModel;\n      return;\n    }\n  }\n  selectParts.push(partModel);\n}\n\nfunction addFieldStrategy(selectParts: any, partModel: any, query: { selectModels: any[][] }) {\n  // copy all parts\n  const parts = _.map(selectParts, (part: any) => {\n    return createPart({ type: part.def.type, params: _.clone(part.params) });\n  });\n\n  query.selectModels.push(parts);\n}\n\nregister({\n  type: 'field',\n  addStrategy: addFieldStrategy,\n  category: categories.Fields,\n  params: [{ type: 'field', dynamicLookup: true }],\n  defaultParams: ['value'],\n  renderer: fieldRenderer,\n});\n\n// Aggregations\nregister({\n  type: 'count',\n  addStrategy: replaceAggregationAddStrategy,\n  category: categories.Aggregations,\n  params: [],\n  defaultParams: [],\n  renderer: functionRenderer,\n});\n\nregister({\n  type: 'distinct',\n  addStrategy: replaceAggregationAddStrategy,\n  category: categories.Aggregations,\n  params: [],\n  defaultParams: [],\n  renderer: functionRenderer,\n});\n\nregister({\n  type: 'integral',\n  addStrategy: replaceAggregationAddStrategy,\n  category: categories.Aggregations,\n  params: [],\n  defaultParams: [],\n  renderer: functionRenderer,\n});\n\nregister({\n  type: 'mean',\n  addStrategy: replaceAggregationAddStrategy,\n  category: categories.Aggregations,\n  params: [],\n  defaultParams: [],\n  renderer: functionRenderer,\n});\n\nregister({\n  type: 'median',\n  addStrategy: replaceAggregationAddStrategy,\n  category: categories.Aggregations,\n  params: [],\n  defaultParams: [],\n  renderer: functionRenderer,\n});\n\nregister({\n  type: 'mode',\n  addStrategy: replaceAggregationAddStrategy,\n  category: categories.Aggregations,\n  params: [],\n  defaultParams: [],\n  renderer: functionRenderer,\n});\n\nregister({\n  type: 'sum',\n  addStrategy: replaceAggregationAddStrategy,\n  category: categories.Aggregations,\n  params: [],\n  defaultParams: [],\n  renderer: functionRenderer,\n});\n\n// transformations\n\nregister({\n  type: 'derivative',\n  addStrategy: addTransformationStrategy,\n  category: categories.Transformations,\n  params: [\n    {\n      name: 'duration',\n      type: 'interval',\n      options: ['1s', '10s', '1m', '5m', '10m', '15m', '1h'],\n    },\n  ],\n  defaultParams: ['10s'],\n  renderer: functionRenderer,\n});\n\nregister({\n  type: 'spread',\n  addStrategy: addTransformationStrategy,\n  category: categories.Transformations,\n  params: [],\n  defaultParams: [],\n  renderer: functionRenderer,\n});\n\nregister({\n  type: 'non_negative_derivative',\n  addStrategy: addTransformationStrategy,\n  category: categories.Transformations,\n  params: [\n    {\n      name: 'duration',\n      type: 'interval',\n      options: ['1s', '10s', '1m', '5m', '10m', '15m', '1h'],\n    },\n  ],\n  defaultParams: ['10s'],\n  renderer: functionRenderer,\n});\n\nregister({\n  type: 'difference',\n  addStrategy: addTransformationStrategy,\n  category: categories.Transformations,\n  params: [],\n  defaultParams: [],\n  renderer: functionRenderer,\n});\n\nregister({\n  type: 'non_negative_difference',\n  addStrategy: addTransformationStrategy,\n  category: categories.Transformations,\n  params: [],\n  defaultParams: [],\n  renderer: functionRenderer,\n});\n\nregister({\n  type: 'moving_average',\n  addStrategy: addTransformationStrategy,\n  category: categories.Transformations,\n  params: [{ name: 'window', type: 'int', options: [5, 10, 20, 30, 40] }],\n  defaultParams: [10],\n  renderer: functionRenderer,\n});\n\nregister({\n  type: 'cumulative_sum',\n  addStrategy: addTransformationStrategy,\n  category: categories.Transformations,\n  params: [],\n  defaultParams: [],\n  renderer: functionRenderer,\n});\n\nregister({\n  type: 'stddev',\n  addStrategy: addTransformationStrategy,\n  category: categories.Transformations,\n  params: [],\n  defaultParams: [],\n  renderer: functionRenderer,\n});\n\nregister({\n  type: 'time',\n  category: groupByTimeFunctions,\n  params: [\n    {\n      name: 'interval',\n      type: 'time',\n      options: ['$__interval', '1s', '10s', '1m', '5m', '10m', '15m', '1h'],\n    },\n  ],\n  defaultParams: ['$__interval'],\n  renderer: functionRenderer,\n});\n\nregister({\n  type: 'fill',\n  category: groupByTimeFunctions,\n  params: [\n    {\n      name: 'fill',\n      type: 'string',\n      options: ['none', 'null', '0', 'previous', 'linear'],\n    },\n  ],\n  defaultParams: ['null'],\n  renderer: functionRenderer,\n});\n\nregister({\n  type: 'elapsed',\n  addStrategy: addTransformationStrategy,\n  category: categories.Transformations,\n  params: [\n    {\n      name: 'duration',\n      type: 'interval',\n      options: ['1s', '10s', '1m', '5m', '10m', '15m', '1h'],\n    },\n  ],\n  defaultParams: ['10s'],\n  renderer: functionRenderer,\n});\n\n// predictions\nregister({\n  type: 'holt_winters',\n  addStrategy: addTransformationStrategy,\n  category: categories.Predictors,\n  params: [\n    { name: 'number', type: 'int', options: [5, 10, 20, 30, 40] },\n    { name: 'season', type: 'int', options: [0, 1, 2, 5, 10] },\n  ],\n  defaultParams: [10, 2],\n  renderer: functionRenderer,\n});\n\nregister({\n  type: 'holt_winters_with_fit',\n  addStrategy: addTransformationStrategy,\n  category: categories.Predictors,\n  params: [\n    { name: 'number', type: 'int', options: [5, 10, 20, 30, 40] },\n    { name: 'season', type: 'int', options: [0, 1, 2, 5, 10] },\n  ],\n  defaultParams: [10, 2],\n  renderer: functionRenderer,\n});\n\n// Selectors\nregister({\n  type: 'bottom',\n  addStrategy: replaceAggregationAddStrategy,\n  category: categories.Selectors,\n  params: [{ name: 'count', type: 'int' }],\n  defaultParams: [3],\n  renderer: functionRenderer,\n});\n\nregister({\n  type: 'first',\n  addStrategy: replaceAggregationAddStrategy,\n  category: categories.Selectors,\n  params: [],\n  defaultParams: [],\n  renderer: functionRenderer,\n});\n\nregister({\n  type: 'last',\n  addStrategy: replaceAggregationAddStrategy,\n  category: categories.Selectors,\n  params: [],\n  defaultParams: [],\n  renderer: functionRenderer,\n});\n\nregister({\n  type: 'max',\n  addStrategy: replaceAggregationAddStrategy,\n  category: categories.Selectors,\n  params: [],\n  defaultParams: [],\n  renderer: functionRenderer,\n});\n\nregister({\n  type: 'min',\n  addStrategy: replaceAggregationAddStrategy,\n  category: categories.Selectors,\n  params: [],\n  defaultParams: [],\n  renderer: functionRenderer,\n});\n\nregister({\n  type: 'percentile',\n  addStrategy: replaceAggregationAddStrategy,\n  category: categories.Selectors,\n  params: [{ name: 'nth', type: 'int' }],\n  defaultParams: [95],\n  renderer: functionRenderer,\n});\n\nregister({\n  type: 'top',\n  addStrategy: replaceAggregationAddStrategy,\n  category: categories.Selectors,\n  params: [{ name: 'count', type: 'int' }],\n  defaultParams: [3],\n  renderer: functionRenderer,\n});\n\nregister({\n  type: 'tag',\n  category: groupByTimeFunctions,\n  params: [{ name: 'tag', type: 'string', dynamicLookup: true }],\n  defaultParams: ['tag'],\n  renderer: fieldRenderer,\n});\n\nregister({\n  type: 'math',\n  addStrategy: addMathStrategy,\n  category: categories.Math,\n  params: [{ name: 'expr', type: 'string' }],\n  defaultParams: [' / 100'],\n  renderer: suffixRenderer,\n});\n\nregister({\n  type: 'alias',\n  addStrategy: addAliasStrategy,\n  category: categories.Aliasing,\n  params: [{ name: 'name', type: 'string', quote: 'double' }],\n  defaultParams: ['alias'],\n  renderMode: 'suffix',\n  renderer: aliasRenderer,\n});\n\nexport default {\n  create: createPart,\n  getCategories: () => {\n    return categories;\n  },\n  replaceAggregationAdd: replaceAggregationAddStrategy,\n};\n","import _ from 'lodash';\nimport queryPart from './query_part';\nimport kbn from 'app/core/utils/kbn';\nimport { InfluxQuery, InfluxQueryTag } from './types';\nimport { ScopedVars } from '@grafana/data';\nimport { TemplateSrv } from 'app/features/templating/template_srv';\n\nexport default class InfluxQueryModel {\n  target: InfluxQuery;\n  selectModels: any[];\n  queryBuilder: any;\n  groupByParts: any;\n  templateSrv: any;\n  scopedVars: any;\n  refId: string;\n\n  /** @ngInject */\n  constructor(target: InfluxQuery, templateSrv?: TemplateSrv, scopedVars?: ScopedVars) {\n    this.target = target;\n    this.templateSrv = templateSrv;\n    this.scopedVars = scopedVars;\n\n    target.policy = target.policy || 'default';\n    target.resultFormat = target.resultFormat || 'time_series';\n    target.orderByTime = target.orderByTime || 'ASC';\n    target.tags = target.tags || [];\n    target.groupBy = target.groupBy || [{ type: 'time', params: ['$__interval'] }, { type: 'fill', params: ['null'] }];\n    target.select = target.select || [[{ type: 'field', params: ['value'] }, { type: 'mean', params: [] }]];\n\n    this.updateProjection();\n  }\n\n  updateProjection() {\n    this.selectModels = _.map(this.target.select, (parts: any) => {\n      return _.map(parts, queryPart.create);\n    });\n    this.groupByParts = _.map(this.target.groupBy, queryPart.create);\n  }\n\n  updatePersistedParts() {\n    this.target.select = _.map(this.selectModels, selectParts => {\n      return _.map(selectParts, (part: any) => {\n        return { type: part.def.type, params: part.params };\n      });\n    });\n  }\n\n  hasGroupByTime() {\n    return _.find(this.target.groupBy, (g: any) => g.type === 'time');\n  }\n\n  hasFill() {\n    return _.find(this.target.groupBy, (g: any) => g.type === 'fill');\n  }\n\n  addGroupBy(value: string) {\n    const stringParts = value.match(/^(\\w+)\\((.*)\\)$/);\n    const typePart = stringParts[1];\n    const arg = stringParts[2];\n    const partModel = queryPart.create({ type: typePart, params: [arg] });\n    const partCount = this.target.groupBy.length;\n\n    if (partCount === 0) {\n      this.target.groupBy.push(partModel.part);\n    } else if (typePart === 'time') {\n      this.target.groupBy.splice(0, 0, partModel.part);\n    } else if (typePart === 'tag') {\n      if (this.target.groupBy[partCount - 1].type === 'fill') {\n        this.target.groupBy.splice(partCount - 1, 0, partModel.part);\n      } else {\n        this.target.groupBy.push(partModel.part);\n      }\n    } else {\n      this.target.groupBy.push(partModel.part);\n    }\n\n    this.updateProjection();\n  }\n\n  removeGroupByPart(part: { def: { type: string } }, index: number) {\n    const categories = queryPart.getCategories();\n\n    if (part.def.type === 'time') {\n      // remove fill\n      this.target.groupBy = _.filter(this.target.groupBy, (g: any) => g.type !== 'fill');\n      // remove aggregations\n      this.target.select = _.map(this.target.select, (s: any) => {\n        return _.filter(s, (part: any) => {\n          const partModel = queryPart.create(part);\n          if (partModel.def.category === categories.Aggregations) {\n            return false;\n          }\n          if (partModel.def.category === categories.Selectors) {\n            return false;\n          }\n          return true;\n        });\n      });\n    }\n\n    this.target.groupBy.splice(index, 1);\n    this.updateProjection();\n  }\n\n  removeSelect(index: number) {\n    this.target.select.splice(index, 1);\n    this.updateProjection();\n  }\n\n  removeSelectPart(selectParts: any[], part: any) {\n    // if we remove the field remove the whole statement\n    if (part.def.type === 'field') {\n      if (this.selectModels.length > 1) {\n        const modelsIndex = _.indexOf(this.selectModels, selectParts);\n        this.selectModels.splice(modelsIndex, 1);\n      }\n    } else {\n      const partIndex = _.indexOf(selectParts, part);\n      selectParts.splice(partIndex, 1);\n    }\n\n    this.updatePersistedParts();\n  }\n\n  addSelectPart(selectParts: any[], type: string) {\n    const partModel = queryPart.create({ type: type });\n    partModel.def.addStrategy(selectParts, partModel, this);\n    this.updatePersistedParts();\n  }\n\n  private renderTagCondition(tag: InfluxQueryTag, index: number, interpolate: boolean) {\n    let str = '';\n    let operator = tag.operator;\n    let value = tag.value;\n    if (index > 0) {\n      str = (tag.condition || 'AND') + ' ';\n    }\n\n    if (!operator) {\n      if (/^\\/.*\\/$/.test(value)) {\n        operator = '=~';\n      } else {\n        operator = '=';\n      }\n    }\n\n    // quote value unless regex\n    if (operator !== '=~' && operator !== '!~') {\n      if (interpolate) {\n        value = this.templateSrv.replace(value, this.scopedVars);\n      }\n      if (operator !== '>' && operator !== '<') {\n        value = \"'\" + value.replace(/\\\\/g, '\\\\\\\\').replace(/\\'/g, \"\\\\'\") + \"'\";\n      }\n    } else if (interpolate) {\n      value = this.templateSrv.replace(value, this.scopedVars, 'regex');\n    }\n\n    return str + '\"' + tag.key + '\" ' + operator + ' ' + value;\n  }\n\n  getMeasurementAndPolicy(interpolate: any) {\n    let policy = this.target.policy;\n    let measurement = this.target.measurement || 'measurement';\n\n    if (!measurement.match('^/.*/$')) {\n      measurement = '\"' + measurement + '\"';\n    } else if (interpolate) {\n      measurement = this.templateSrv.replace(measurement, this.scopedVars, 'regex');\n    }\n\n    if (policy !== 'default') {\n      policy = '\"' + this.target.policy + '\".';\n    } else {\n      policy = '';\n    }\n\n    return policy + measurement;\n  }\n\n  interpolateQueryStr(value: any[], variable: { multi: any; includeAll: any }, defaultFormatFn: any) {\n    // if no multi or include all do not regexEscape\n    if (!variable.multi && !variable.includeAll) {\n      return value;\n    }\n\n    if (typeof value === 'string') {\n      return kbn.regexEscape(value);\n    }\n\n    const escapedValues = _.map(value, kbn.regexEscape);\n    return '(' + escapedValues.join('|') + ')';\n  }\n\n  render(interpolate?: boolean) {\n    const target = this.target;\n\n    if (target.rawQuery) {\n      if (interpolate) {\n        return this.templateSrv.replace(target.query, this.scopedVars, this.interpolateQueryStr);\n      } else {\n        return target.query;\n      }\n    }\n\n    let query = 'SELECT ';\n    let i, y;\n    for (i = 0; i < this.selectModels.length; i++) {\n      const parts = this.selectModels[i];\n      let selectText = '';\n      for (y = 0; y < parts.length; y++) {\n        const part = parts[y];\n        selectText = part.render(selectText);\n      }\n\n      if (i > 0) {\n        query += ', ';\n      }\n      query += selectText;\n    }\n\n    query += ' FROM ' + this.getMeasurementAndPolicy(interpolate) + ' WHERE ';\n    const conditions = _.map(target.tags, (tag, index) => {\n      return this.renderTagCondition(tag, index, interpolate);\n    });\n\n    if (conditions.length > 0) {\n      query += '(' + conditions.join(' ') + ') AND ';\n    }\n\n    query += '$timeFilter';\n\n    let groupBySection = '';\n    for (i = 0; i < this.groupByParts.length; i++) {\n      const part = this.groupByParts[i];\n      if (i > 0) {\n        // for some reason fill has no separator\n        groupBySection += part.def.type === 'fill' ? ' ' : ', ';\n      }\n      groupBySection += part.render('');\n    }\n\n    if (groupBySection.length) {\n      query += ' GROUP BY ' + groupBySection;\n    }\n\n    if (target.fill) {\n      query += ' fill(' + target.fill + ')';\n    }\n\n    if (target.orderByTime === 'DESC') {\n      query += ' ORDER BY time DESC';\n    }\n\n    if (target.limit) {\n      query += ' LIMIT ' + target.limit;\n    }\n\n    if (target.slimit) {\n      query += ' SLIMIT ' + target.slimit;\n    }\n\n    if (target.tz) {\n      query += \" tz('\" + target.tz + \"')\";\n    }\n\n    return query;\n  }\n\n  renderAdhocFilters(filters: any[]) {\n    const conditions = _.map(filters, (tag, index) => {\n      return this.renderTagCondition(tag, index, true);\n    });\n    return conditions.join(' ');\n  }\n}\n","import _ from 'lodash';\n\nexport default class ResponseParser {\n  parse(query: string, results: { results: any }) {\n    if (!results || results.results.length === 0) {\n      return [];\n    }\n\n    const influxResults = results.results[0];\n    if (!influxResults.series) {\n      return [];\n    }\n\n    const normalizedQuery = query.toLowerCase();\n    const isValueFirst =\n      normalizedQuery.indexOf('show field keys') >= 0 || normalizedQuery.indexOf('show retention policies') >= 0;\n\n    const res = {};\n    _.each(influxResults.series, serie => {\n      _.each(serie.values, value => {\n        if (_.isArray(value)) {\n          // In general, there are 2 possible shapes for the returned value.\n          // The first one is a two-element array,\n          // where the first element is somewhat a metadata value:\n          // the tag name for SHOW TAG VALUES queries,\n          // the time field for SELECT queries, etc.\n          // The second shape is an one-element array,\n          // that is containing an immediate value.\n          // For example, SHOW FIELD KEYS queries return such shape.\n          // Note, pre-0.11 versions return\n          // the second shape for SHOW TAG VALUES queries\n          // (while the newer versions—first).\n\n          if (isValueFirst) {\n            addUnique(res, value[0]);\n          } else if (value[1] !== undefined) {\n            addUnique(res, value[1]);\n          } else {\n            addUnique(res, value[0]);\n          }\n        } else {\n          addUnique(res, value);\n        }\n      });\n    });\n\n    // @ts-ignore problems with typings for this _.map only accepts [] but this needs to be object\n    return _.map(res, value => {\n      // @ts-ignore\n      return { text: value.toString() };\n    });\n  }\n}\n\nfunction addUnique(arr: { [x: string]: any }, value: string | number) {\n  arr[value] = value;\n}\n","import React, { useContext } from 'react';\nimport { Select, GrafanaTheme, ThemeContext } from '@grafana/ui';\nimport { css, cx } from 'emotion';\nimport { SelectableValue } from '@grafana/data';\n\nconst getStyles = (theme: GrafanaTheme) => ({\n  keyValueContainer: css`\n    label: key-value-container;\n    display: flex;\n    flex-flow: row nowrap;\n  `,\n});\n\nenum ChangeType {\n  Key = 'key',\n  Value = 'value',\n  Operator = 'operator',\n}\n\nexport interface Props {\n  keys: string[];\n  keysPlaceHolder?: string;\n  initialKey?: string;\n  initialOperator?: string;\n  initialValue?: string;\n  values?: string[];\n  valuesPlaceHolder?: string;\n  onKeyChanged: (key: string) => void;\n  onValueChanged: (value: string) => void;\n  onOperatorChanged: (operator: string) => void;\n}\n\nexport const AdHocFilter: React.FunctionComponent<Props> = props => {\n  const theme = useContext(ThemeContext);\n  const styles = getStyles(theme);\n\n  const onChange = (changeType: ChangeType) => (item: SelectableValue<string>) => {\n    const { onKeyChanged, onValueChanged, onOperatorChanged } = props;\n    switch (changeType) {\n      case ChangeType.Key:\n        onKeyChanged(item.value);\n        break;\n      case ChangeType.Operator:\n        onOperatorChanged(item.value);\n        break;\n      case ChangeType.Value:\n        onValueChanged(item.value);\n        break;\n    }\n  };\n\n  const stringToOption = (value: string) => ({ label: value, value: value });\n\n  const { keys, initialKey, keysPlaceHolder, initialOperator, values, initialValue, valuesPlaceHolder } = props;\n  const operators = ['=', '!='];\n  const keysAsOptions = keys ? keys.map(stringToOption) : [];\n  const selectedKey = initialKey ? keysAsOptions.filter(option => option.value === initialKey) : null;\n  const valuesAsOptions = values ? values.map(stringToOption) : [];\n  const selectedValue = initialValue ? valuesAsOptions.filter(option => option.value === initialValue) : null;\n  const operatorsAsOptions = operators.map(stringToOption);\n  const selectedOperator = initialOperator\n    ? operatorsAsOptions.filter(option => option.value === initialOperator)\n    : null;\n\n  return (\n    <div className={cx([styles.keyValueContainer])}>\n      <Select\n        options={keysAsOptions}\n        isSearchable\n        value={selectedKey}\n        onChange={onChange(ChangeType.Key)}\n        placeholder={keysPlaceHolder}\n      />\n      <Select options={operatorsAsOptions} value={selectedOperator} onChange={onChange(ChangeType.Operator)} />\n      <Select\n        options={valuesAsOptions}\n        isSearchable\n        value={selectedValue}\n        onChange={onChange(ChangeType.Value)}\n        placeholder={valuesPlaceHolder}\n      />\n    </div>\n  );\n};\n","import _ from 'lodash';\nimport kbn from 'app/core/utils/kbn';\n\nfunction renderTagCondition(tag: { operator: any; value: string; condition: any; key: string }, index: number) {\n  let str = '';\n  let operator = tag.operator;\n  let value = tag.value;\n  if (index > 0) {\n    str = (tag.condition || 'AND') + ' ';\n  }\n\n  if (!operator) {\n    if (/^\\/.*\\/$/.test(tag.value)) {\n      operator = '=~';\n    } else {\n      operator = '=';\n    }\n  }\n\n  // quote value unless regex or number\n  if (operator !== '=~' && operator !== '!~' && isNaN(+value)) {\n    value = \"'\" + value + \"'\";\n  }\n\n  return str + '\"' + tag.key + '\" ' + operator + ' ' + value;\n}\n\nexport class InfluxQueryBuilder {\n  constructor(private target: { measurement: any; tags: any; policy?: any }, private database?: string) {}\n\n  buildExploreQuery(type: string, withKey?: string, withMeasurementFilter?: string) {\n    let query;\n    let measurement;\n    let policy;\n\n    if (type === 'TAG_KEYS') {\n      query = 'SHOW TAG KEYS';\n      measurement = this.target.measurement;\n      policy = this.target.policy;\n    } else if (type === 'TAG_VALUES') {\n      query = 'SHOW TAG VALUES';\n      measurement = this.target.measurement;\n      policy = this.target.policy;\n    } else if (type === 'MEASUREMENTS') {\n      query = 'SHOW MEASUREMENTS';\n      if (withMeasurementFilter) {\n        query += ' WITH MEASUREMENT =~ /' + kbn.regexEscape(withMeasurementFilter) + '/';\n      }\n    } else if (type === 'FIELDS') {\n      measurement = this.target.measurement;\n      policy = this.target.policy;\n\n      if (!measurement.match('^/.*/')) {\n        measurement = '\"' + measurement + '\"';\n\n        if (policy && policy !== 'default') {\n          policy = '\"' + policy + '\"';\n          measurement = policy + '.' + measurement;\n        }\n      }\n\n      return 'SHOW FIELD KEYS FROM ' + measurement;\n    } else if (type === 'RETENTION POLICIES') {\n      query = 'SHOW RETENTION POLICIES on \"' + this.database + '\"';\n      return query;\n    }\n\n    if (measurement) {\n      if (!measurement.match('^/.*/') && !measurement.match(/^merge\\(.*\\)/)) {\n        measurement = '\"' + measurement + '\"';\n      }\n\n      if (policy && policy !== 'default') {\n        policy = '\"' + policy + '\"';\n        measurement = policy + '.' + measurement;\n      }\n\n      query += ' FROM ' + measurement;\n    }\n\n    if (withKey) {\n      query += ' WITH KEY = \"' + withKey + '\"';\n    }\n\n    if (this.target.tags && this.target.tags.length > 0) {\n      const whereConditions = _.reduce(\n        this.target.tags,\n        (memo, tag) => {\n          // do not add a condition for the key we want to explore for\n          if (tag.key === withKey) {\n            return memo;\n          }\n          memo.push(renderTagCondition(tag, memo.length));\n          return memo;\n        },\n        []\n      );\n\n      if (whereConditions.length > 0) {\n        query += ' WHERE ' + whereConditions.join(' ');\n      }\n    }\n    if (type === 'MEASUREMENTS') {\n      query += ' LIMIT 100';\n      //Solve issue #2524 by limiting the number of measurements returned\n      //LIMIT must be after WITH MEASUREMENT and WHERE clauses\n      //This also could be used for TAG KEYS and TAG VALUES, if desired\n    }\n    return query;\n  }\n}\n","import _ from 'lodash';\n\nimport { dateMath } from '@grafana/data';\nimport InfluxSeries from './influx_series';\nimport InfluxQueryModel from './influx_query_model';\nimport ResponseParser from './response_parser';\nimport { InfluxQueryBuilder } from './query_builder';\nimport { DataSourceApi, DataSourceInstanceSettings } from '@grafana/ui';\nimport { InfluxQuery, InfluxOptions } from './types';\nimport { BackendSrv } from 'app/core/services/backend_srv';\nimport { TemplateSrv } from 'app/features/templating/template_srv';\nimport { IQService } from 'angular';\n\nexport default class InfluxDatasource extends DataSourceApi<InfluxQuery, InfluxOptions> {\n  type: string;\n  urls: any;\n  username: string;\n  password: string;\n  name: string;\n  database: any;\n  basicAuth: any;\n  withCredentials: any;\n  interval: any;\n  responseParser: any;\n  httpMode: string;\n\n  /** @ngInject */\n  constructor(\n    instanceSettings: DataSourceInstanceSettings<InfluxOptions>,\n    private $q: IQService,\n    private backendSrv: BackendSrv,\n    private templateSrv: TemplateSrv\n  ) {\n    super(instanceSettings);\n    this.type = 'influxdb';\n    this.urls = _.map(instanceSettings.url.split(','), url => {\n      return url.trim();\n    });\n\n    this.username = instanceSettings.username;\n    this.password = instanceSettings.password;\n    this.name = instanceSettings.name;\n    this.database = instanceSettings.database;\n    this.basicAuth = instanceSettings.basicAuth;\n    this.withCredentials = instanceSettings.withCredentials;\n    const settingsData = instanceSettings.jsonData || ({} as InfluxOptions);\n    this.interval = settingsData.timeInterval;\n    this.httpMode = settingsData.httpMode || 'GET';\n    this.responseParser = new ResponseParser();\n  }\n\n  query(options: any) {\n    let timeFilter = this.getTimeFilter(options);\n    const scopedVars = options.scopedVars;\n    const targets = _.cloneDeep(options.targets);\n    const queryTargets: any[] = [];\n    let queryModel: InfluxQueryModel;\n    let i, y;\n\n    let allQueries = _.map(targets, target => {\n      if (target.hide) {\n        return '';\n      }\n\n      queryTargets.push(target);\n\n      // backward compatibility\n      scopedVars.interval = scopedVars.__interval;\n\n      queryModel = new InfluxQueryModel(target, this.templateSrv, scopedVars);\n      return queryModel.render(true);\n    }).reduce((acc, current) => {\n      if (current !== '') {\n        acc += ';' + current;\n      }\n      return acc;\n    });\n\n    if (allQueries === '') {\n      return this.$q.when({ data: [] });\n    }\n\n    // add global adhoc filters to timeFilter\n    const adhocFilters = this.templateSrv.getAdhocFilters(this.name);\n    if (adhocFilters.length > 0) {\n      timeFilter += ' AND ' + queryModel.renderAdhocFilters(adhocFilters);\n    }\n\n    // replace grafana variables\n    scopedVars.timeFilter = { value: timeFilter };\n\n    // replace templated variables\n    allQueries = this.templateSrv.replace(allQueries, scopedVars);\n\n    return this._seriesQuery(allQueries, options).then(\n      (data: any): any => {\n        if (!data || !data.results) {\n          return [];\n        }\n\n        const seriesList = [];\n        for (i = 0; i < data.results.length; i++) {\n          const result = data.results[i];\n          if (!result || !result.series) {\n            continue;\n          }\n\n          const target = queryTargets[i];\n          let alias = target.alias;\n          if (alias) {\n            alias = this.templateSrv.replace(target.alias, options.scopedVars);\n          }\n\n          const influxSeries = new InfluxSeries({\n            series: data.results[i].series,\n            alias: alias,\n          });\n\n          switch (target.resultFormat) {\n            case 'table': {\n              seriesList.push(influxSeries.getTable());\n              break;\n            }\n            default: {\n              const timeSeries = influxSeries.getTimeSeries();\n              for (y = 0; y < timeSeries.length; y++) {\n                seriesList.push(timeSeries[y]);\n              }\n              break;\n            }\n          }\n        }\n\n        return { data: seriesList };\n      }\n    );\n  }\n\n  annotationQuery(options: any) {\n    if (!options.annotation.query) {\n      return this.$q.reject({\n        message: 'Query missing in annotation definition',\n      });\n    }\n\n    const timeFilter = this.getTimeFilter({ rangeRaw: options.rangeRaw, timezone: options.timezone });\n    let query = options.annotation.query.replace('$timeFilter', timeFilter);\n    query = this.templateSrv.replace(query, null, 'regex');\n\n    return this._seriesQuery(query, options).then((data: any) => {\n      if (!data || !data.results || !data.results[0]) {\n        throw { message: 'No results in response from InfluxDB' };\n      }\n      return new InfluxSeries({\n        series: data.results[0].series,\n        annotation: options.annotation,\n      }).getAnnotations();\n    });\n  }\n\n  targetContainsTemplate(target: any) {\n    for (const group of target.groupBy) {\n      for (const param of group.params) {\n        if (this.templateSrv.variableExists(param)) {\n          return true;\n        }\n      }\n    }\n\n    for (const i in target.tags) {\n      if (this.templateSrv.variableExists(target.tags[i].value)) {\n        return true;\n      }\n    }\n\n    return false;\n  }\n\n  metricFindQuery(query: string, options?: any) {\n    const interpolated = this.templateSrv.replace(query, null, 'regex');\n\n    return this._seriesQuery(interpolated, options).then(_.curry(this.responseParser.parse)(query));\n  }\n\n  getTagKeys(options: any = {}) {\n    const queryBuilder = new InfluxQueryBuilder({ measurement: options.measurement || '', tags: [] }, this.database);\n    const query = queryBuilder.buildExploreQuery('TAG_KEYS');\n    return this.metricFindQuery(query, options);\n  }\n\n  getTagValues(options: any = {}) {\n    const queryBuilder = new InfluxQueryBuilder({ measurement: options.measurement || '', tags: [] }, this.database);\n    const query = queryBuilder.buildExploreQuery('TAG_VALUES', options.key);\n    return this.metricFindQuery(query, options);\n  }\n\n  _seriesQuery(query: string, options?: any) {\n    if (!query) {\n      return this.$q.when({ results: [] });\n    }\n\n    if (options && options.range) {\n      const timeFilter = this.getTimeFilter({ rangeRaw: options.range, timezone: options.timezone });\n      query = query.replace('$timeFilter', timeFilter);\n    }\n\n    return this._influxRequest(this.httpMode, '/query', { q: query, epoch: 'ms' }, options);\n  }\n\n  serializeParams(params: any) {\n    if (!params) {\n      return '';\n    }\n\n    return _.reduce(\n      params,\n      (memo, value, key) => {\n        if (value === null || value === undefined) {\n          return memo;\n        }\n        memo.push(encodeURIComponent(key) + '=' + encodeURIComponent(value));\n        return memo;\n      },\n      []\n    ).join('&');\n  }\n\n  testDatasource() {\n    const queryBuilder = new InfluxQueryBuilder({ measurement: '', tags: [] }, this.database);\n    const query = queryBuilder.buildExploreQuery('RETENTION POLICIES');\n\n    return this._seriesQuery(query)\n      .then((res: any) => {\n        const error = _.get(res, 'results[0].error');\n        if (error) {\n          return { status: 'error', message: error };\n        }\n        return { status: 'success', message: 'Data source is working' };\n      })\n      .catch((err: any) => {\n        return { status: 'error', message: err.message };\n      });\n  }\n\n  _influxRequest(method: string, url: string, data: any, options?: any) {\n    const currentUrl = this.urls.shift();\n    this.urls.push(currentUrl);\n\n    const params: any = {};\n\n    if (this.username) {\n      params.u = this.username;\n      params.p = this.password;\n    }\n\n    if (options && options.database) {\n      params.db = options.database;\n    } else if (this.database) {\n      params.db = this.database;\n    }\n\n    if (method === 'POST' && _.has(data, 'q')) {\n      // verb is POST and 'q' param is defined\n      _.extend(params, _.omit(data, ['q']));\n      data = this.serializeParams(_.pick(data, ['q']));\n    } else if (method === 'GET' || method === 'POST') {\n      // verb is GET, or POST without 'q' param\n      _.extend(params, data);\n      data = null;\n    }\n\n    const req: any = {\n      method: method,\n      url: currentUrl + url,\n      params: params,\n      data: data,\n      precision: 'ms',\n      inspect: { type: 'influxdb' },\n      paramSerializer: this.serializeParams,\n    };\n\n    req.headers = req.headers || {};\n    if (this.basicAuth || this.withCredentials) {\n      req.withCredentials = true;\n    }\n    if (this.basicAuth) {\n      req.headers.Authorization = this.basicAuth;\n    }\n\n    if (method === 'POST') {\n      req.headers['Content-type'] = 'application/x-www-form-urlencoded';\n    }\n\n    return this.backendSrv.datasourceRequest(req).then(\n      (result: any) => {\n        return result.data;\n      },\n      (err: any) => {\n        if (err.status !== 0 || err.status >= 300) {\n          if (err.data && err.data.error) {\n            throw {\n              message: 'InfluxDB Error: ' + err.data.error,\n              data: err.data,\n              config: err.config,\n            };\n          } else {\n            throw {\n              message: 'Network Error: ' + err.statusText + '(' + err.status + ')',\n              data: err.data,\n              config: err.config,\n            };\n          }\n        }\n      }\n    );\n  }\n\n  getTimeFilter(options: any) {\n    const from = this.getInfluxTime(options.rangeRaw.from, false, options.timezone);\n    const until = this.getInfluxTime(options.rangeRaw.to, true, options.timezone);\n    const fromIsAbsolute = from[from.length - 1] === 'ms';\n\n    if (until === 'now()' && !fromIsAbsolute) {\n      return 'time >= ' + from;\n    }\n\n    return 'time >= ' + from + ' and time <= ' + until;\n  }\n\n  getInfluxTime(date: any, roundUp: any, timezone: any) {\n    if (_.isString(date)) {\n      if (date === 'now') {\n        return 'now()';\n      }\n\n      const parts = /^now-(\\d+)([dhms])$/.exec(date);\n      if (parts) {\n        const amount = parseInt(parts[1], 10);\n        const unit = parts[2];\n        return 'now() - ' + amount + unit;\n      }\n      date = dateMath.parse(date, roundUp, timezone);\n    }\n\n    return date.valueOf() + 'ms';\n  }\n}\n","import angular, { auto, IQService } from 'angular';\nimport _ from 'lodash';\nimport { InfluxQueryBuilder } from './query_builder';\nimport InfluxQueryModel from './influx_query_model';\nimport queryPart from './query_part';\nimport { QueryCtrl } from 'app/plugins/sdk';\nimport { TemplateSrv } from 'app/features/templating/template_srv';\n\nexport class InfluxQueryCtrl extends QueryCtrl {\n  static templateUrl = 'partials/query.editor.html';\n\n  queryModel: InfluxQueryModel;\n  queryBuilder: any;\n  groupBySegment: any;\n  resultFormats: any[];\n  orderByTime: any[];\n  policySegment: any;\n  tagSegments: any[];\n  selectMenu: any;\n  measurementSegment: any;\n  removeTagFilterSegment: any;\n\n  /** @ngInject */\n  constructor(\n    $scope: any,\n    $injector: auto.IInjectorService,\n    private templateSrv: TemplateSrv,\n    private $q: IQService,\n    private uiSegmentSrv: any\n  ) {\n    super($scope, $injector);\n    this.target = this.target;\n    this.queryModel = new InfluxQueryModel(this.target, templateSrv, this.panel.scopedVars);\n    this.queryBuilder = new InfluxQueryBuilder(this.target, this.datasource.database);\n    this.groupBySegment = this.uiSegmentSrv.newPlusButton();\n    this.resultFormats = [{ text: 'Time series', value: 'time_series' }, { text: 'Table', value: 'table' }];\n    this.policySegment = uiSegmentSrv.newSegment(this.target.policy);\n\n    if (!this.target.measurement) {\n      this.measurementSegment = uiSegmentSrv.newSelectMeasurement();\n    } else {\n      this.measurementSegment = uiSegmentSrv.newSegment(this.target.measurement);\n    }\n\n    this.tagSegments = [];\n    for (const tag of this.target.tags) {\n      if (!tag.operator) {\n        if (/^\\/.*\\/$/.test(tag.value)) {\n          tag.operator = '=~';\n        } else {\n          tag.operator = '=';\n        }\n      }\n\n      if (tag.condition) {\n        this.tagSegments.push(uiSegmentSrv.newCondition(tag.condition));\n      }\n\n      this.tagSegments.push(uiSegmentSrv.newKey(tag.key));\n      this.tagSegments.push(uiSegmentSrv.newOperator(tag.operator));\n      this.tagSegments.push(uiSegmentSrv.newKeyValue(tag.value));\n    }\n\n    this.fixTagSegments();\n    this.buildSelectMenu();\n    this.removeTagFilterSegment = uiSegmentSrv.newSegment({\n      fake: true,\n      value: '-- remove tag filter --',\n    });\n  }\n\n  removeOrderByTime() {\n    this.target.orderByTime = 'ASC';\n  }\n\n  buildSelectMenu() {\n    const categories = queryPart.getCategories();\n    this.selectMenu = _.reduce(\n      categories,\n      (memo, cat, key) => {\n        const menu = {\n          text: key,\n          submenu: cat.map((item: any) => {\n            return { text: item.type, value: item.type };\n          }),\n        };\n        memo.push(menu);\n        return memo;\n      },\n      []\n    );\n  }\n\n  getGroupByOptions() {\n    const query = this.queryBuilder.buildExploreQuery('TAG_KEYS');\n\n    return this.datasource\n      .metricFindQuery(query)\n      .then((tags: any) => {\n        const options = [];\n        if (!this.queryModel.hasFill()) {\n          options.push(this.uiSegmentSrv.newSegment({ value: 'fill(null)' }));\n        }\n        if (!this.target.limit) {\n          options.push(this.uiSegmentSrv.newSegment({ value: 'LIMIT' }));\n        }\n        if (!this.target.slimit) {\n          options.push(this.uiSegmentSrv.newSegment({ value: 'SLIMIT' }));\n        }\n        if (!this.target.tz) {\n          options.push(this.uiSegmentSrv.newSegment({ value: 'tz' }));\n        }\n        if (this.target.orderByTime === 'ASC') {\n          options.push(this.uiSegmentSrv.newSegment({ value: 'ORDER BY time DESC' }));\n        }\n        if (!this.queryModel.hasGroupByTime()) {\n          options.push(this.uiSegmentSrv.newSegment({ value: 'time($interval)' }));\n        }\n        for (const tag of tags) {\n          options.push(this.uiSegmentSrv.newSegment({ value: 'tag(' + tag.text + ')' }));\n        }\n        return options;\n      })\n      .catch(this.handleQueryError.bind(this));\n  }\n\n  groupByAction() {\n    switch (this.groupBySegment.value) {\n      case 'LIMIT': {\n        this.target.limit = 10;\n        break;\n      }\n      case 'SLIMIT': {\n        this.target.slimit = 10;\n        break;\n      }\n      case 'tz': {\n        this.target.tz = 'UTC';\n        break;\n      }\n      case 'ORDER BY time DESC': {\n        this.target.orderByTime = 'DESC';\n        break;\n      }\n      default: {\n        this.queryModel.addGroupBy(this.groupBySegment.value);\n      }\n    }\n\n    const plusButton = this.uiSegmentSrv.newPlusButton();\n    this.groupBySegment.value = plusButton.value;\n    this.groupBySegment.html = plusButton.html;\n    this.panelCtrl.refresh();\n  }\n\n  addSelectPart(selectParts: any, cat: any, subitem: { value: any }) {\n    this.queryModel.addSelectPart(selectParts, subitem.value);\n    this.panelCtrl.refresh();\n  }\n\n  handleSelectPartEvent(selectParts: any, part: any, evt: { name: any }) {\n    switch (evt.name) {\n      case 'get-param-options': {\n        const fieldsQuery = this.queryBuilder.buildExploreQuery('FIELDS');\n        return this.datasource\n          .metricFindQuery(fieldsQuery)\n          .then(this.transformToSegments(true))\n          .catch(this.handleQueryError.bind(this));\n      }\n      case 'part-param-changed': {\n        this.panelCtrl.refresh();\n        break;\n      }\n      case 'action': {\n        this.queryModel.removeSelectPart(selectParts, part);\n        this.panelCtrl.refresh();\n        break;\n      }\n      case 'get-part-actions': {\n        return this.$q.when([{ text: 'Remove', value: 'remove-part' }]);\n      }\n    }\n  }\n\n  handleGroupByPartEvent(part: any, index: any, evt: { name: any }) {\n    switch (evt.name) {\n      case 'get-param-options': {\n        const tagsQuery = this.queryBuilder.buildExploreQuery('TAG_KEYS');\n        return this.datasource\n          .metricFindQuery(tagsQuery)\n          .then(this.transformToSegments(true))\n          .catch(this.handleQueryError.bind(this));\n      }\n      case 'part-param-changed': {\n        this.panelCtrl.refresh();\n        break;\n      }\n      case 'action': {\n        this.queryModel.removeGroupByPart(part, index);\n        this.panelCtrl.refresh();\n        break;\n      }\n      case 'get-part-actions': {\n        return this.$q.when([{ text: 'Remove', value: 'remove-part' }]);\n      }\n    }\n  }\n\n  fixTagSegments() {\n    const count = this.tagSegments.length;\n    const lastSegment = this.tagSegments[Math.max(count - 1, 0)];\n\n    if (!lastSegment || lastSegment.type !== 'plus-button') {\n      this.tagSegments.push(this.uiSegmentSrv.newPlusButton());\n    }\n  }\n\n  measurementChanged() {\n    this.target.measurement = this.measurementSegment.value;\n    this.panelCtrl.refresh();\n  }\n\n  getPolicySegments() {\n    const policiesQuery = this.queryBuilder.buildExploreQuery('RETENTION POLICIES');\n    return this.datasource\n      .metricFindQuery(policiesQuery)\n      .then(this.transformToSegments(false))\n      .catch(this.handleQueryError.bind(this));\n  }\n\n  policyChanged() {\n    this.target.policy = this.policySegment.value;\n    this.panelCtrl.refresh();\n  }\n\n  toggleEditorMode() {\n    try {\n      this.target.query = this.queryModel.render(false);\n    } catch (err) {\n      console.log('query render error');\n    }\n    this.target.rawQuery = !this.target.rawQuery;\n  }\n\n  getMeasurements(measurementFilter: any) {\n    const query = this.queryBuilder.buildExploreQuery('MEASUREMENTS', undefined, measurementFilter);\n    return this.datasource\n      .metricFindQuery(query)\n      .then(this.transformToSegments(true))\n      .catch(this.handleQueryError.bind(this));\n  }\n\n  handleQueryError(err: any): any[] {\n    this.error = err.message || 'Failed to issue metric query';\n    return [];\n  }\n\n  transformToSegments(addTemplateVars: any) {\n    return (results: any) => {\n      const segments = _.map(results, segment => {\n        return this.uiSegmentSrv.newSegment({\n          value: segment.text,\n          expandable: segment.expandable,\n        });\n      });\n\n      if (addTemplateVars) {\n        for (const variable of this.templateSrv.variables) {\n          segments.unshift(\n            this.uiSegmentSrv.newSegment({\n              type: 'value',\n              value: '/^$' + variable.name + '$/',\n              expandable: true,\n            })\n          );\n        }\n      }\n\n      return segments;\n    };\n  }\n\n  getTagsOrValues(segment: { type: string }, index: number) {\n    if (segment.type === 'condition') {\n      return this.$q.when([this.uiSegmentSrv.newSegment('AND'), this.uiSegmentSrv.newSegment('OR')]);\n    }\n    if (segment.type === 'operator') {\n      const nextValue = this.tagSegments[index + 1].value;\n      if (/^\\/.*\\/$/.test(nextValue)) {\n        return this.$q.when(this.uiSegmentSrv.newOperators(['=~', '!~']));\n      } else {\n        return this.$q.when(this.uiSegmentSrv.newOperators(['=', '!=', '<>', '<', '>']));\n      }\n    }\n\n    let query, addTemplateVars;\n    if (segment.type === 'key' || segment.type === 'plus-button') {\n      query = this.queryBuilder.buildExploreQuery('TAG_KEYS');\n      addTemplateVars = false;\n    } else if (segment.type === 'value') {\n      query = this.queryBuilder.buildExploreQuery('TAG_VALUES', this.tagSegments[index - 2].value);\n      addTemplateVars = true;\n    }\n\n    return this.datasource\n      .metricFindQuery(query)\n      .then(this.transformToSegments(addTemplateVars))\n      .then((results: any) => {\n        if (segment.type === 'key') {\n          results.splice(0, 0, angular.copy(this.removeTagFilterSegment));\n        }\n        return results;\n      })\n      .catch(this.handleQueryError.bind(this));\n  }\n\n  getFieldSegments() {\n    const fieldsQuery = this.queryBuilder.buildExploreQuery('FIELDS');\n    return this.datasource\n      .metricFindQuery(fieldsQuery)\n      .then(this.transformToSegments(false))\n      .catch(this.handleQueryError);\n  }\n\n  tagSegmentUpdated(segment: { value: any; type: string; cssClass: string }, index: number) {\n    this.tagSegments[index] = segment;\n\n    // handle remove tag condition\n    if (segment.value === this.removeTagFilterSegment.value) {\n      this.tagSegments.splice(index, 3);\n      if (this.tagSegments.length === 0) {\n        this.tagSegments.push(this.uiSegmentSrv.newPlusButton());\n      } else if (this.tagSegments.length > 2) {\n        this.tagSegments.splice(Math.max(index - 1, 0), 1);\n        if (this.tagSegments[this.tagSegments.length - 1].type !== 'plus-button') {\n          this.tagSegments.push(this.uiSegmentSrv.newPlusButton());\n        }\n      }\n    } else {\n      if (segment.type === 'plus-button') {\n        if (index > 2) {\n          this.tagSegments.splice(index, 0, this.uiSegmentSrv.newCondition('AND'));\n        }\n        this.tagSegments.push(this.uiSegmentSrv.newOperator('='));\n        this.tagSegments.push(this.uiSegmentSrv.newFake('select tag value', 'value', 'query-segment-value'));\n        segment.type = 'key';\n        segment.cssClass = 'query-segment-key';\n      }\n\n      if (index + 1 === this.tagSegments.length) {\n        this.tagSegments.push(this.uiSegmentSrv.newPlusButton());\n      }\n    }\n\n    this.rebuildTargetTagConditions();\n  }\n\n  rebuildTargetTagConditions() {\n    const tags: any[] = [];\n    let tagIndex = 0;\n    let tagOperator = '';\n\n    _.each(this.tagSegments, (segment2, index) => {\n      if (segment2.type === 'key') {\n        if (tags.length === 0) {\n          tags.push({});\n        }\n        tags[tagIndex].key = segment2.value;\n      } else if (segment2.type === 'value') {\n        tagOperator = this.getTagValueOperator(segment2.value, tags[tagIndex].operator);\n        if (tagOperator) {\n          this.tagSegments[index - 1] = this.uiSegmentSrv.newOperator(tagOperator);\n          tags[tagIndex].operator = tagOperator;\n        }\n        tags[tagIndex].value = segment2.value;\n      } else if (segment2.type === 'condition') {\n        tags.push({ condition: segment2.value });\n        tagIndex += 1;\n      } else if (segment2.type === 'operator') {\n        tags[tagIndex].operator = segment2.value;\n      }\n    });\n\n    this.target.tags = tags;\n    this.panelCtrl.refresh();\n  }\n\n  getTagValueOperator(tagValue: string, tagOperator: string): string {\n    if (tagOperator !== '=~' && tagOperator !== '!~' && /^\\/.*\\/$/.test(tagValue)) {\n      return '=~';\n    } else if ((tagOperator === '=~' || tagOperator === '!~') && /^(?!\\/.*\\/$)/.test(tagValue)) {\n      return '=';\n    }\n    return null;\n  }\n\n  getCollapsedText() {\n    return this.queryModel.render(false);\n  }\n}\n","import React from 'react';\nimport _ from 'lodash';\nimport { DataSourceApi, DataQuery, DataSourceJsonData } from '@grafana/ui';\nimport { AdHocFilter } from './AdHocFilter';\nexport const DEFAULT_REMOVE_FILTER_VALUE = '-- remove filter --';\n\nconst addFilterButton = (onAddFilter: (event: React.MouseEvent) => void) => (\n  <button className=\"gf-form-label gf-form-label--btn query-part\" onClick={onAddFilter}>\n    <i className=\"fa fa-plus\" />\n  </button>\n);\n\nexport interface KeyValuePair {\n  keys: string[];\n  key: string;\n  operator: string;\n  value: string;\n  values: string[];\n}\n\nexport interface Props<TQuery extends DataQuery = DataQuery, TOptions extends DataSourceJsonData = DataSourceJsonData> {\n  datasource: DataSourceApi<TQuery, TOptions>;\n  onPairsChanged: (pairs: KeyValuePair[]) => void;\n  extendedOptions?: any;\n}\n\nexport interface State {\n  pairs: KeyValuePair[];\n}\n\nexport class AdHocFilterField<\n  TQuery extends DataQuery = DataQuery,\n  TOptions extends DataSourceJsonData = DataSourceJsonData\n> extends React.PureComponent<Props<TQuery, TOptions>, State> {\n  state: State = { pairs: [] };\n\n  componentDidUpdate(prevProps: Props) {\n    if (_.isEqual(prevProps.extendedOptions, this.props.extendedOptions) === false) {\n      const pairs: any[] = [];\n\n      this.setState({ pairs }, () => this.props.onPairsChanged(pairs));\n    }\n  }\n\n  loadTagKeys = async () => {\n    const { datasource, extendedOptions } = this.props;\n    const options = extendedOptions || {};\n    const tagKeys = datasource.getTagKeys ? await datasource.getTagKeys(options) : [];\n    const keys = tagKeys.map(tagKey => tagKey.text);\n\n    return keys;\n  };\n\n  loadTagValues = async (key: string) => {\n    const { datasource, extendedOptions } = this.props;\n    const options = extendedOptions || {};\n    const tagValues = datasource.getTagValues ? await datasource.getTagValues({ ...options, key }) : [];\n    const values = tagValues.map(tagValue => tagValue.text);\n\n    return values;\n  };\n\n  updatePairs(pairs: KeyValuePair[], index: number, pair: Partial<KeyValuePair>) {\n    if (pairs.length === 0) {\n      return [\n        {\n          key: pair.key || '',\n          keys: pair.keys || [],\n          operator: pair.operator || '',\n          value: pair.value || '',\n          values: pair.values || [],\n        },\n      ];\n    }\n\n    const newPairs: KeyValuePair[] = [];\n    for (let pairIndex = 0; pairIndex < pairs.length; pairIndex++) {\n      const newPair = pairs[pairIndex];\n      if (index === pairIndex) {\n        newPairs.push({\n          ...newPair,\n          key: pair.key || newPair.key,\n          value: pair.value || newPair.value,\n          operator: pair.operator || newPair.operator,\n          keys: pair.keys || newPair.keys,\n          values: pair.values || newPair.values,\n        });\n        continue;\n      }\n\n      newPairs.push(newPair);\n    }\n\n    return newPairs;\n  }\n\n  onKeyChanged = (index: number) => async (key: string) => {\n    if (key !== DEFAULT_REMOVE_FILTER_VALUE) {\n      const { onPairsChanged } = this.props;\n      const values = await this.loadTagValues(key);\n      const pairs = this.updatePairs(this.state.pairs, index, { key, values });\n\n      this.setState({ pairs }, () => onPairsChanged(pairs));\n    } else {\n      this.onRemoveFilter(index);\n    }\n  };\n\n  onValueChanged = (index: number) => (value: string) => {\n    const pairs = this.updatePairs(this.state.pairs, index, { value });\n\n    this.setState({ pairs }, () => this.props.onPairsChanged(pairs));\n  };\n\n  onOperatorChanged = (index: number) => (operator: string) => {\n    const pairs = this.updatePairs(this.state.pairs, index, { operator });\n\n    this.setState({ pairs }, () => this.props.onPairsChanged(pairs));\n  };\n\n  onAddFilter = async () => {\n    const keys = await this.loadTagKeys();\n    const pairs = this.state.pairs.concat(this.updatePairs([], 0, { keys }));\n\n    this.setState({ pairs }, () => this.props.onPairsChanged(pairs));\n  };\n\n  onRemoveFilter = async (index: number) => {\n    const pairs = this.state.pairs.reduce((allPairs, pair, pairIndex) => {\n      if (pairIndex === index) {\n        return allPairs;\n      }\n      return allPairs.concat(pair);\n    }, []);\n\n    this.setState({ pairs });\n  };\n\n  render() {\n    const { pairs } = this.state;\n    return (\n      <>\n        {pairs.length < 1 && addFilterButton(this.onAddFilter)}\n        {pairs.map((pair, index) => {\n          const adHocKey = `adhoc-filter-${index}-${pair.key}-${pair.value}`;\n          return (\n            <div className=\"align-items-center flex-grow-1\" key={adHocKey}>\n              <AdHocFilter\n                keys={[DEFAULT_REMOVE_FILTER_VALUE].concat(pair.keys)}\n                values={pair.values}\n                initialKey={pair.key}\n                initialOperator={pair.operator}\n                initialValue={pair.value}\n                onKeyChanged={this.onKeyChanged(index)}\n                onOperatorChanged={this.onOperatorChanged(index)}\n                onValueChanged={this.onValueChanged(index)}\n              />\n              {index < pairs.length - 1 && <span>&nbsp;AND&nbsp;</span>}\n              {index === pairs.length - 1 && addFilterButton(this.onAddFilter)}\n            </div>\n          );\n        })}\n      </>\n    );\n  }\n}\n","import React from 'react';\nimport { ExploreQueryFieldProps } from '@grafana/ui';\n// @ts-ignore\nimport Cascader from 'rc-cascader';\n\nimport InfluxQueryModel from '../influx_query_model';\nimport { AdHocFilterField, KeyValuePair } from 'app/features/explore/AdHocFilterField';\nimport { TemplateSrv } from 'app/features/templating/template_srv';\nimport InfluxDatasource from '../datasource';\nimport { InfluxQueryBuilder } from '../query_builder';\nimport { InfluxQuery, InfluxOptions } from '../types';\nimport { CascaderOption } from '../../loki/components/LokiQueryFieldForm';\n\nexport interface Props extends ExploreQueryFieldProps<InfluxDatasource, InfluxQuery, InfluxOptions> {}\n\nexport interface State {\n  measurements: CascaderOption[];\n  measurement: string;\n  field: string;\n}\n\n// Helper function for determining if a collection of pairs are valid\n// where a valid pair is either fully defined, or not defined at all, but not partially defined\nexport function pairsAreValid(pairs: KeyValuePair[]) {\n  return (\n    !pairs ||\n    pairs.every(pair => {\n      const allDefined = !!(pair.key && pair.operator && pair.value);\n      const allEmpty = pair.key === undefined && pair.operator === undefined && pair.value === undefined;\n      return allDefined || allEmpty;\n    })\n  );\n}\n\nexport class InfluxLogsQueryField extends React.PureComponent<Props, State> {\n  templateSrv: TemplateSrv = new TemplateSrv();\n  state: State = { measurements: [], measurement: null, field: null };\n\n  async componentDidMount() {\n    const { datasource } = this.props;\n    const queryBuilder = new InfluxQueryBuilder({ measurement: '', tags: [] }, datasource.database);\n    const measureMentsQuery = queryBuilder.buildExploreQuery('MEASUREMENTS');\n    const influxMeasurements = await datasource.metricFindQuery(measureMentsQuery);\n\n    const measurements = [];\n    for (let index = 0; index < influxMeasurements.length; index++) {\n      const measurementObj = influxMeasurements[index];\n      const queryBuilder = new InfluxQueryBuilder({ measurement: measurementObj.text, tags: [] }, datasource.database);\n      const fieldsQuery = queryBuilder.buildExploreQuery('FIELDS');\n      const influxFields = await datasource.metricFindQuery(fieldsQuery);\n      const fields: any[] = influxFields.map(\n        (field: any): any => ({\n          label: field.text,\n          value: field.text,\n          children: [],\n        })\n      );\n      measurements.push({\n        label: measurementObj.text,\n        value: measurementObj.text,\n        children: fields,\n      });\n    }\n\n    this.setState({ measurements });\n  }\n\n  componentDidUpdate(prevProps: Props) {\n    if (prevProps.query.measurement && !this.props.query.measurement) {\n      this.setState({ measurement: null, field: null });\n    }\n  }\n\n  onMeasurementsChange = async (values: string[]) => {\n    const { query } = this.props;\n    const measurement = values[0];\n    const field = values[1];\n\n    this.setState({ measurement, field }, () => {\n      this.onPairsChanged((query as any).tags);\n    });\n  };\n\n  onPairsChanged = (pairs: KeyValuePair[]) => {\n    const { query } = this.props;\n    const { measurement, field } = this.state;\n    const queryModel = new InfluxQueryModel(\n      {\n        ...query,\n        resultFormat: 'table',\n        groupBy: [],\n        select: [[{ type: 'field', params: [field] }]],\n        tags: pairs,\n        limit: '1000',\n        measurement,\n      },\n      this.templateSrv\n    );\n\n    this.props.onChange(queryModel.target);\n\n    // Only run the query if measurement & field are set, and there are no invalid pairs\n    if (measurement && field && pairsAreValid(pairs)) {\n      this.props.onRunQuery();\n    }\n  };\n\n  render() {\n    const { datasource } = this.props;\n    const { measurements, measurement, field } = this.state;\n    const cascadeText = measurement ? `Measurements (${measurement}/${field})` : 'Measurements';\n\n    return (\n      <div className=\"gf-form-inline gf-form-inline--nowrap\">\n        <div className=\"gf-form flex-shrink-0\">\n          <Cascader\n            options={measurements}\n            value={[measurement, field]}\n            onChange={this.onMeasurementsChange}\n            expandIcon={null}\n          >\n            <button className=\"gf-form-label gf-form-label--btn\">\n              {cascadeText} <i className=\"fa fa-caret-down\" />\n            </button>\n          </Cascader>\n        </div>\n        <div className=\"flex-shrink-1 flex-flow-column-nowrap\">\n          {measurement && (\n            <AdHocFilterField\n              onPairsChanged={this.onPairsChanged}\n              datasource={datasource}\n              extendedOptions={{ measurement }}\n            />\n          )}\n        </div>\n      </div>\n    );\n  }\n}\n","import React from 'react';\n\nconst CHEAT_SHEET_ITEMS = [\n  {\n    title: 'Getting started',\n    label:\n      'Start by selecting a measurement and field from the dropdown above. You can then use the tag selector to further narrow your search.',\n  },\n];\n\nexport default (props: any) => (\n  <div>\n    <h2>InfluxDB Cheat Sheet</h2>\n    {CHEAT_SHEET_ITEMS.map(item => (\n      <div className=\"cheat-sheet-item\" key={item.title}>\n        <div className=\"cheat-sheet-item__title\">{item.title}</div>\n        <div className=\"cheat-sheet-item__label\">{item.label}</div>\n      </div>\n    ))}\n  </div>\n);\n","import React, { PureComponent } from 'react';\nimport { ExploreStartPageProps } from '@grafana/ui';\nimport InfluxCheatSheet from './InfluxCheatSheet';\n\nexport default class InfluxStartPage extends PureComponent<ExploreStartPageProps> {\n  render() {\n    return (\n      <div className=\"grafana-info-box grafana-info-box--max-lg\">\n        <InfluxCheatSheet onClickExample={this.props.onClickExample} />\n      </div>\n    );\n  }\n}\n","import InfluxDatasource from './datasource';\nimport { InfluxQueryCtrl } from './query_ctrl';\nimport { InfluxLogsQueryField } from './components/InfluxLogsQueryField';\nimport InfluxStartPage from './components/InfluxStartPage';\n\nimport {\n  createChangeHandler,\n  createResetHandler,\n  PasswordFieldEnum,\n} from '../../../features/datasources/utils/passwordHandlers';\nimport { DataSourcePlugin } from '@grafana/ui';\n\nclass InfluxConfigCtrl {\n  static templateUrl = 'partials/config.html';\n  current: any;\n  onPasswordReset: ReturnType<typeof createResetHandler>;\n  onPasswordChange: ReturnType<typeof createChangeHandler>;\n\n  constructor() {\n    this.onPasswordReset = createResetHandler(this, PasswordFieldEnum.Password);\n    this.onPasswordChange = createChangeHandler(this, PasswordFieldEnum.Password);\n    this.current.jsonData.httpMode = this.current.jsonData.httpMode || 'GET';\n  }\n\n  httpMode = [{ name: 'GET', value: 'GET' }, { name: 'POST', value: 'POST' }];\n}\n\nclass InfluxAnnotationsQueryCtrl {\n  static templateUrl = 'partials/annotations.editor.html';\n}\n\nexport const plugin = new DataSourcePlugin(InfluxDatasource)\n  .setConfigCtrl(InfluxConfigCtrl)\n  .setQueryCtrl(InfluxQueryCtrl)\n  .setAnnotationQueryCtrl(InfluxAnnotationsQueryCtrl)\n  .setExploreLogsQueryField(InfluxLogsQueryField)\n  .setExploreStartPage(InfluxStartPage);\n"],"sourceRoot":""}