{"version":3,"file":"5524.874619dfe248d1146e59.js","mappings":";;;;;;;;;;;;;+4WiBWA","sources":["webpack://grafana/../../../src/FeaturesState.tsx","webpack://grafana/../../../src/FeatureState.tsx","webpack://grafana/../../../src/Features.tsx","webpack://grafana/../../../src/EnableContext.tsx","webpack://grafana/../../../src/FeatureContext.tsx","webpack://grafana/../../../src/useConsoleOverride.tsx","webpack://grafana/../../../src/GlobalEnable.tsx","webpack://grafana/../../../src/usePersist.tsx","webpack://grafana/../../../src/useTestCallback.tsx","webpack://grafana/../../../src/testFeature.tsx","webpack://grafana/../../../src/Enable.tsx","webpack://grafana/../../../src/utils.ts","webpack://grafana/../../../src/useAllEnabled.tsx","webpack://grafana/../../../src/useEnabled.tsx","webpack://grafana/../../../src/Disable.tsx","webpack://grafana/../../../src/useAllDisabled.tsx","webpack://grafana/../../../src/useDisabled.tsx","webpack://grafana/../../../src/ToggleFeatures.tsx"],"sourcesContent":["import { ActorRefFrom, InterpreterFrom, StateFrom, assign, createMachine, spawn } from 'xstate';\n\nimport { FeatureMachine, FeatureDescription, FeatureValue, valueForState } from './FeatureState';\n\nexport interface FeaturesContext {\n  // features are layered:\n  //  - defaults: if nothing else matches, provided a value for feature\n  //  - browser: browser-local values for features (kept in local storage, etc)\n  //  - user: values from the user's profile, if any\n  //  - org: value from the org's profile, if any\n  features: { [x: string]: ActorRefFrom<typeof FeatureMachine> };\n}\n\nexport type FeaturesAction =\n  | { type: 'DE_INIT' }\n  | { type: 'DISABLE'; name: string }\n  | { type: 'ENABLE'; name: string }\n  | { type: 'INIT'; features: readonly FeatureDescription[] }\n  | { type: 'SET_ALL'; features: { [key: string]: FeatureValue } }\n  | { type: 'SET'; name: string; value: FeatureValue }\n  | { type: 'TOGGLE'; name: string }\n  | { type: 'UNSET'; name: string };\n\nexport interface FeaturesTypeState {\n  value: 'ready';\n  context: FeaturesContext;\n}\n\nexport type FeaturesState = StateFrom<typeof FeaturesMachine>;\nexport type FeaturesDispatch = InterpreterFrom<typeof FeaturesMachine>['send'];\n\nexport function valueOfFeature(featuresState: FeaturesState, feature: string): [FeatureValue, boolean] {\n  if (featuresState.context.features[feature] == null) {\n    return [undefined, false];\n  }\n  const featureState = featuresState.context.features[feature].getSnapshot();\n  if (featureState != null) {\n    return valueForState(featureState);\n  }\n  return [undefined, false];\n}\n\n/// state machine that manages a set of features with user, org, and local overrides\nexport const FeaturesMachine = createMachine<FeaturesContext, FeaturesAction, FeaturesTypeState>({\n  id: 'features',\n  initial: 'idle',\n  predictableActionArguments: true,\n  context: {\n    features: {},\n  },\n  states: {\n    idle: {\n      on: {\n        INIT: {\n          target: 'ready',\n          cond: (_, e) => e.features.length > 0,\n          actions: assign({\n            features: (context, event) => {\n              const features: typeof context.features = {};\n\n              for (const feature of event.features) {\n                features[feature.name] = spawn(FeatureMachine, {\n                  name: feature.name,\n                  sync: true,\n                });\n                features[feature.name].send({ type: 'INIT', feature });\n              }\n              return features;\n            },\n          }),\n        },\n      },\n    },\n\n    // the features are loaded and ready to be used\n    ready: {\n      on: {\n        DE_INIT: { target: 'idle', actions: assign({ features: (_, __) => ({}) }) },\n        SET_ALL: {\n          actions: assign({\n            features: (ctx, e) => {\n              const features = { ...ctx.features };\n              // All configured features are set to on/off or undefined\n              Object.keys(features).forEach((name) => {\n                features[name].send({ type: 'SET', value: e.features[name] ?? undefined });\n              });\n              return features;\n            },\n          }),\n        },\n\n        // Set a feature to a value\n        SET: {\n          actions: (ctx, e) => {\n            const feature = ctx.features[e.name];\n            if (feature != null) {\n              feature.send({ type: 'SET', value: e.value });\n            }\n          },\n        },\n\n        // toggle a feature\n        TOGGLE: {\n          actions: (ctx, e) => {\n            const feature = ctx.features[e.name];\n            if (feature != null) {\n              feature.send({ type: 'TOGGLE' });\n            }\n          },\n        },\n\n        // when a feature is enabled, send the enable message to the actor\n        ENABLE: {\n          actions: (ctx, e) => {\n            const feature = ctx.features[e.name];\n            if (feature != null) {\n              feature.send({ type: 'ENABLE' });\n            }\n          },\n        },\n\n        // when a feature is disabled, send the disable message to the actor\n        DISABLE: {\n          actions: (ctx, e) => {\n            const feature = ctx.features[e.name];\n            if (feature != null) {\n              feature.send({ type: 'DISABLE' });\n            }\n          },\n        },\n\n        // when a feature is unset, send the unset message to the actor\n        UNSET: {\n          actions: (ctx, e) => {\n            const feature = ctx.features[e.name];\n            if (feature != null) {\n              feature.send({ type: 'UNSET' });\n            }\n          },\n        },\n      },\n    },\n  },\n});\n","import { assign, createMachine, DoneInvokeEvent, InterpreterFrom, StateFrom } from 'xstate';\n\n/**\n * Feature is either on, off, or 'unset',\n * which means it will go to the default value or the less specific value.\n */\nexport type FeatureValue = false | true | undefined;\n\nexport type FeatureState = StateFrom<typeof FeatureMachine>;\nexport type FeatureDispatch = InterpreterFrom<typeof FeatureMachine>['send'];\n\n/// Given a featurestate, determine the value (on, off, or unset)\nexport function valueForState(featureState: FeatureState): [FeatureValue, boolean] {\n  return [\n    featureState.matches('enabled') ? true : featureState.matches('disabled') ? false : undefined,\n    featureState.context.featureDesc?.force ?? false,\n  ];\n}\n\n/**\n * Definition of a feature that can be enabled or disabled.\n * K is the type of the key that is used to identify the feature.\n */\nexport interface FeatureDescription<K extends string = string> {\n  readonly name: K;\n  readonly description?: string;\n\n  /// If set, will be used to update the feature default state instead of simply overriding.\n  /// For example, you might use this to update a feature flag on a backend server.\n  /// when set, the feature will be updated on the backend server, and the result of the async\n  /// will be used for the final state after the change. while changing, the feature will be\n  /// in the 'changing' state. Also note that the feature will be changed at the \"default\" layer.\n  readonly onChangeDefault?: (name: K, newValue: FeatureValue) => Promise<FeatureValue>;\n\n  /// if set true, will force the field to what it is set here through layers of states.\n  /// useful to invert the layers, similar to !important in CSS.\n  readonly force?: boolean;\n\n  /// If set to true, the feature will not be overridable by the user.\n  readonly noOverride?: boolean;\n\n  /// can be used to specify what should happen if the feature is not set to a particular value.\n  readonly defaultValue?: FeatureValue;\n}\n\ninterface FeatureContext {\n  featureDesc?: FeatureDescription;\n}\n\ntype FeatureTypeState =\n  | {\n      value: 'asyncDenabled';\n      context: FeatureContext;\n    }\n  | {\n      value: 'asyncDisabled';\n      context: FeatureContext;\n    }\n  | {\n      value: 'asyncUnspecied';\n      context: FeatureContext;\n    }\n  | {\n      value: 'disabled';\n      context: FeatureContext;\n    }\n  | {\n      value: 'enabled';\n      context: FeatureContext;\n    }\n  | {\n      value: 'initial';\n      context: never;\n    }\n  | {\n      value: 'unspecied';\n      context: FeatureContext;\n    };\n\n/**\n * Actions that can be performed on a feature.\n */\nexport type FeatureAction =\n  | { type: 'DISABLE' }\n  | { type: 'ENABLE' }\n  | { type: 'INIT'; feature: FeatureDescription }\n  | { type: 'SET'; value: FeatureValue }\n  | { type: 'TOGGLE' }\n  | { type: 'UNSET' };\n\n/**\n * Fully describe the states a feature can be in\n */\nexport const FeatureMachine = createMachine<FeatureContext, FeatureAction, FeatureTypeState>({\n  id: 'feature',\n  initial: 'initial',\n  context: {},\n  predictableActionArguments: true,\n  on: {\n    ENABLE: [\n      { target: 'asyncEnabled', cond: (ctx) => ctx.featureDesc?.onChangeDefault != null },\n      { target: 'enabled' },\n    ],\n\n    TOGGLE: [\n      { target: 'asyncEnabled', cond: (ctx) => ctx.featureDesc?.onChangeDefault != null },\n      { target: 'enabled' },\n    ],\n\n    DISABLE: [\n      { target: 'asyncDisabled', cond: (ctx) => ctx.featureDesc?.onChangeDefault != null },\n      { target: 'disabled' },\n    ],\n\n    UNSET: [\n      { target: 'asyncUnspecied', cond: (ctx) => ctx.featureDesc?.onChangeDefault != null },\n      { target: 'unspecified' },\n    ],\n\n    SET: [\n      {\n        target: 'asyncEnabled',\n        cond: (ctx, e) => e.value === true && ctx.featureDesc?.onChangeDefault != null,\n      },\n      {\n        target: 'asyncDisabled',\n        cond: (ctx, e) => e.value === false && ctx.featureDesc?.onChangeDefault != null,\n      },\n      {\n        target: 'asyncUnspecied',\n        cond: (ctx, _e) => ctx.featureDesc?.onChangeDefault != null,\n      },\n      {\n        target: 'enabled',\n        cond: (_ctx, e) => e.value === true,\n      },\n      {\n        target: 'disabled',\n        cond: (_ctx, e) => e.value === false,\n      },\n      { target: 'unspecified' },\n    ],\n  },\n\n  states: {\n    initial: {\n      on: {\n        INIT: [\n          {\n            actions: assign({ featureDesc: (_, e) => e.feature }),\n            target: 'enabled',\n            cond: (_, e) => e.feature.defaultValue === true,\n          },\n          {\n            actions: assign({ featureDesc: (_, e) => e.feature }),\n            target: 'unspecified',\n            cond: (_, e) => e.feature.defaultValue === undefined,\n          },\n          {\n            actions: assign({ featureDesc: (_, e) => e.feature }),\n            target: 'disabled',\n            cond: (_, e) => e.feature.defaultValue === false,\n          },\n        ],\n      },\n    },\n\n    unspecified: {},\n    disabled: {},\n    enabled: {},\n\n    asyncDisabled: {\n      invoke: {\n        id: 'set-off-upstream',\n        src: async (ctx) => {\n          const onchange = ctx.featureDesc?.onChangeDefault;\n          if (onchange != null && ctx.featureDesc != null) {\n            return onchange(ctx.featureDesc.name, false);\n          }\n          return undefined;\n        },\n        onDone: [\n          {\n            target: 'enabled',\n            cond: (_ctx, e: DoneInvokeEvent<FeatureValue>) => e.data === true,\n          },\n          {\n            target: 'disabled',\n            cond: (_ctx, e: DoneInvokeEvent<FeatureValue>) => e.data === false,\n          },\n          { target: 'unspecified' },\n        ],\n        onError: 'unspecified',\n      },\n    },\n\n    asyncUnspecied: {\n      invoke: {\n        id: 'set-unset-upstream',\n        src: async (ctx) => {\n          const onchange = ctx.featureDesc?.onChangeDefault;\n          if (onchange != null && ctx.featureDesc != null) {\n            return onchange(ctx.featureDesc.name, undefined);\n          }\n          return undefined;\n        },\n        onDone: [\n          {\n            target: 'enabled',\n            cond: (_ctx, e: DoneInvokeEvent<FeatureValue>) => e.data === true,\n          },\n          {\n            target: 'disabled',\n            cond: (_ctx, e: DoneInvokeEvent<FeatureValue>) => e.data === false,\n          },\n          { target: 'unspecified' },\n        ],\n        onError: 'unspecified',\n      },\n    },\n\n    asyncEnabled: {\n      invoke: {\n        id: 'set-on-upstream',\n        src: async (ctx) => {\n          const onchange = ctx.featureDesc?.onChangeDefault;\n          if (onchange != null && ctx.featureDesc != null) {\n            return onchange(ctx.featureDesc.name, true);\n          }\n          return undefined;\n        },\n        onDone: [\n          {\n            target: 'enabled',\n            cond: (_ctx, e: DoneInvokeEvent<FeatureValue>) => e.data === true,\n          },\n          {\n            target: 'disabled',\n            cond: (_ctx, e: DoneInvokeEvent<FeatureValue>) => e.data === false,\n          },\n          { target: 'unspecified' },\n        ],\n        onError: 'unspecified',\n      },\n    },\n  },\n});\n","import React, { useMemo, ReactNode, useEffect, useRef } from 'react';\n\nimport { useMachine } from '@xstate/react';\n\nimport { EnableContext } from './EnableContext';\nimport { FeatureContext } from './FeatureContext';\nimport { FeaturesMachine } from './FeaturesState';\nimport { FeatureDescription } from './FeatureState';\nimport useConsoleOverride from './useConsoleOverride';\nimport usePersist, { KEY } from './usePersist';\nimport useTestCallback from './useTestCallback';\n\ninterface FeatureProps {\n  readonly features: readonly FeatureDescription[];\n  readonly children?: ReactNode;\n  readonly disableConsole?: boolean;\n  readonly storage?: Storage;\n}\n\n/**\n * A more batteries-enabled parent component that keeps track of feature state\n * internally, and creates window.feature.enable(\"f\") and window.feature.disable(\"f\").\n * Keeps track of overrides and defaults, with defaults potentially coming from your props\n * and overrides being persisted to your choice of storage layer.\n */\nexport function Features({\n  children,\n  features,\n  disableConsole = false,\n  storage = window.sessionStorage,\n}: FeatureProps): JSX.Element {\n  // Capture only first value; we don't care about future updates\n  const featuresRef = useRef(features);\n  const [overridesState, overridesSend] = useMachine(FeaturesMachine);\n  const [defaultsState, defaultsSend] = useMachine(FeaturesMachine);\n\n  useEffect(() => {\n    /// Load defaults\n    defaultsSend({ type: 'INIT', features });\n    return () => {\n      defaultsSend({ type: 'DE_INIT' });\n    };\n  }, [defaultsSend, features]);\n\n  useEffect(() => {\n    let f: Record<string, boolean | undefined> = {};\n    if (storage != null) {\n      try {\n        const featuresJson = storage.getItem(KEY);\n        if (featuresJson != null) {\n          const fh = JSON.parse(featuresJson);\n          f = fh.overrides;\n        }\n      } catch (e) {\n        // Can't parse or get or otherwise; ignore\n        console.error('error in localStorage', e);\n      }\n    }\n\n    overridesSend({\n      type: 'INIT',\n      features: featuresRef.current\n        .filter((x) => x.noOverride !== true)\n        .map((x) => ({ name: x.name, description: x.description, defaultValue: f?.[x.name] ?? undefined })),\n    });\n\n    return () => {\n      overridesSend({ type: 'DE_INIT' });\n    };\n  }, [featuresRef, overridesSend, storage]);\n\n  usePersist(storage, featuresRef.current, overridesState);\n\n  const testCallback = useTestCallback(overridesState, defaultsState);\n  useConsoleOverride(!disableConsole, featuresRef.current, testCallback, defaultsSend);\n\n  const featureValue = useMemo(\n    () => ({\n      overridesSend,\n      defaultsSend,\n      featuresDescription: featuresRef.current,\n      overridesState,\n      defaultsState,\n      test: testCallback,\n    }),\n    [overridesSend, defaultsSend, overridesState, defaultsState, testCallback]\n  );\n\n  return (\n    <FeatureContext.Provider value={featureValue}>\n      <EnableContext.Provider value={testCallback}>{children}</EnableContext.Provider>\n    </FeatureContext.Provider>\n  );\n}\n","import { createContext } from 'react';\n\nimport { FeatureValue } from './FeatureState';\n\nexport type EnableContextType = (feature: string) => FeatureValue;\n\n/**\n * Contained function can check whether a given feature is enabled.\n */\nexport const EnableContext = createContext<EnableContextType>((_s) => false);\n","import { createContext } from 'react';\n\nimport { FeaturesDispatch, FeaturesState } from './FeaturesState';\nimport { FeatureDescription, FeatureValue } from './FeatureState';\n\nexport const FeatureContext = createContext<FeatureContextType | null>(null);\n\n/// Give access to the overrides layer\nexport interface FeatureContextType {\n  // Make changes to the overrides\n  overridesSend: FeaturesDispatch;\n\n  // Make changes to defaults\n  defaultsSend: FeaturesDispatch;\n\n  featuresDescription: readonly FeatureDescription[];\n\n  // State is in layers; overrides and defaults\n  overridesState: FeaturesState;\n  defaultsState: FeaturesState;\n\n  /// Test with proper fallback and respecting the user's force preference\n  test: (flag: string) => FeatureValue;\n}\n","import { useEffect } from 'react';\n\nimport { FeaturesDispatch } from './FeaturesState';\nimport { FeatureDescription, FeatureValue } from './FeatureState';\nimport { GlobalEnable } from './GlobalEnable';\n\nexport default function useConsoleOverride(\n  consoleOverride: boolean,\n  features: readonly FeatureDescription[],\n  testFeature: (_: string) => FeatureValue,\n  dispatch: FeaturesDispatch\n): void {\n  useEffect(() => {\n    if (!consoleOverride) {\n      return () => {\n        /* empty */\n      };\n    }\n    window.feature = new GlobalEnable(dispatch, testFeature, features);\n    return () => {\n      if (window.feature != null) {\n        delete window.feature;\n      }\n    };\n  }, [features, dispatch, consoleOverride, testFeature]);\n}\n","import { FeaturesDispatch } from './FeaturesState';\nimport { FeatureDescription, FeatureValue } from './FeatureState';\n\nexport class GlobalEnable {\n  private readonly featureDesc: readonly FeatureDescription[];\n  private readonly dispatch: FeaturesDispatch;\n  private readonly testFeature: (value: string) => FeatureValue;\n\n  constructor(\n    dispatch: FeaturesDispatch,\n    testFeature: (_: string) => FeatureValue,\n    featureDesc: readonly FeatureDescription[]\n  ) {\n    this.featureDesc = featureDesc;\n    this.dispatch = dispatch;\n    this.testFeature = testFeature;\n  }\n\n  public toggle(feature: string): void {\n    this.dispatch({ type: 'TOGGLE', name: feature });\n  }\n\n  public enable(feature: string): void {\n    this.dispatch({ type: 'ENABLE', name: feature });\n  }\n\n  public unset(feature: string): void {\n    this.dispatch({ type: 'UNSET', name: feature });\n  }\n\n  public disable(feature: string): void {\n    this.dispatch({ type: 'DISABLE', name: feature });\n  }\n\n  public setAll(features: { [key: string]: FeatureValue }): void {\n    this.dispatch({ type: 'SET_ALL', features });\n  }\n\n  public listFeatures(): readonly [string, FeatureValue][] {\n    return this.featureDesc.map((f) => [f.name, this.testFeature(f.name)]);\n  }\n}\ndeclare global {\n  interface Window {\n    feature?: GlobalEnable;\n  }\n}\n","import { useMemo, useEffect } from 'react';\n\nimport { FeaturesState, valueOfFeature } from './FeaturesState';\nimport { FeatureDescription, FeatureValue } from './FeatureState';\n\nexport const KEY = 'react-enable:feature-values';\n\nexport default function usePersist(\n  storage: Storage | undefined,\n  features: readonly FeatureDescription[],\n  overrideState: FeaturesState\n): void {\n  const overrides = useMemo(() => {\n    const newOverrides: { [key: string]: FeatureValue } = {};\n    if (overrideState.matches('ready')) {\n      for (const feature of features) {\n        const [value] = valueOfFeature(overrideState, feature.name);\n        if (value != null) {\n          newOverrides[feature.name] = value;\n        }\n      }\n    }\n    return newOverrides;\n  }, [features, overrideState]);\n\n  const strState = Object.keys(overrides).length === 0 || storage == null ? '{}' : JSON.stringify({ overrides });\n\n  useEffect(() => {\n    try {\n      if (storage != null && overrideState.matches('ready')) {\n        storage.setItem(KEY, strState);\n      }\n    } catch (e) {\n      // Can't set for some reason\n    }\n  }, [overrideState, storage, strState]);\n}\n","import { useCallback } from 'react';\n\nimport { FeaturesState } from './FeaturesState';\nimport testFeature from './testFeature';\n\n/// A callback that can be called to test if a feature is enabled or disabled\nexport default function useTestCallback(\n  defaultsState: FeaturesState,\n  overridesState: FeaturesState\n): (feature: string) => boolean | undefined {\n  return useCallback((f: string) => testFeature(f, [defaultsState, overridesState]), [defaultsState, overridesState]);\n}\n","import { FeaturesState, valueOfFeature } from './FeaturesState';\nimport { FeatureValue } from './FeatureState';\n\n/** Determine if the feature is enabled in one of the state machines, in order\n *\n * @param state The current state of the machine\n * @param feature The feature to check\n */\n\nexport default function testFeature(feature: string, states: FeaturesState[]): FeatureValue {\n  const values = states.map((state) => valueOfFeature(state, feature));\n\n  // look for best forced option, in order\n  for (const [featureValue, featureForced] of values) {\n    if (featureValue != null && featureForced) {\n      return featureValue;\n    }\n  }\n\n  // look for best non-forced option, in order\n  for (const [featureValue] of values) {\n    if (featureValue != null) {\n      return featureValue;\n    }\n  }\n\n  // unset if nothing hit\n  return undefined;\n}\n","import * as React from 'react';\n\nimport { useAllEnabled } from './useAllEnabled';\nimport { useEnabled } from './useEnabled';\n\nexport interface EnableProps {\n  readonly feature?: string[] | string;\n  readonly allFeatures?: string[];\n  children: React.ReactNode;\n}\n\n/**\n * Feature will be enabled if any feature in the list are enabled,\n */\nexport function Enable({ feature = [], allFeatures = [], children }: EnableProps): JSX.Element | null {\n  const isAny = useEnabled(feature);\n  const isAll = useAllEnabled(allFeatures);\n\n  if (isAny || isAll) {\n    return <>{children}</>;\n  }\n\n  return null;\n}\n","import { useContext, useMemo } from 'react';\n\nimport { EnableContextType, EnableContext } from './EnableContext';\n\n// Helper: get rid of some boilerplate.\n// just input mashing and sanitation, removing extra renders, and getting test function\nexport function useTestAndConvert(input?: string[] | string | null): [EnableContextType, string[]] {\n  const test = useContext(EnableContext);\n\n  // We memoize just to prevent re-renders since this could be at the leaf of a tree\n  const converted = useMemo(() => (input == null ? [] : Array.isArray(input) ? input : [input]), [input]);\n\n  return [test, converted];\n}\n","import { useTestAndConvert } from './utils';\n\n/**\n * returns true iff all specified features are enabled\n */\nexport function useAllEnabled(allFeatures: string[] | string): boolean {\n  const [test, queryAllPresent] = useTestAndConvert(allFeatures);\n  return queryAllPresent.length > 0 && queryAllPresent.every(test);\n}\n","import { useTestAndConvert } from './utils';\n\n/**\n * returns true iff any specified feature is enabled\n */\nexport function useEnabled(feature: string[] | string): boolean {\n  const [test, queryAnyPresent] = useTestAndConvert(feature);\n  return queryAnyPresent.some(test);\n}\n","import * as React from \"react\";\n\nimport { EnableProps } from \"./Enable\";\nimport { useAllDisabled } from \"./useAllDisabled\";\nimport { useDisabled } from \"./useDisabled\";\n\n/**\n * Feature will be disabled if any in the list are enabled\n */\nexport const Disable: React.FC<EnableProps> = ({\n  feature = [],\n  allFeatures = [],\n  children\n}) => {\n  const isAny = useDisabled(feature);\n  const isAll = useAllDisabled(allFeatures);\n\n  if (isAny || isAll) {\n    return <>{children}</>;\n  }\n\n  return null;\n};\n","import { useTestAndConvert } from './utils';\n\n/**\n * returns true iff all specified features are disabled\n */\nexport function useAllDisabled(withoutAll: string[] | string): boolean {\n  const [test, queryAllWithout] = useTestAndConvert(withoutAll);\n  return withoutAll.length > 0 && queryAllWithout.every((x) => !(test(x) ?? false));\n}\n","import { useTestAndConvert } from './utils';\n\n/**\n * returns true iff any specified feature is disabled\n */\nexport function useDisabled(without: string[] | string): boolean {\n  const [test, queryAnyWithout] = useTestAndConvert(without);\n  return queryAnyWithout.some((x) => !(test(x) ?? false));\n}\n","import React, { useContext, useState, useCallback, ReactNode } from 'react';\nimport ReactDOM from 'react-dom';\n\nimport { RadioGroup } from '@headlessui/react';\n\nimport { FeatureContext } from './FeatureContext';\nimport { valueOfFeature } from './FeaturesState';\nimport { FeatureDescription } from './FeatureState';\n// @ts-expect-error bundler will take care of this\nimport styles from './tailwind.css';\n\nfunction classNames(...classes: string[]): string {\n  return classes.filter(Boolean).join(' ');\n}\n\nfunction ToggleFeature({ feature }: { feature: FeatureDescription }): JSX.Element | null {\n  const context = useContext(FeatureContext);\n  const handleChangeSelection = useCallback(\n    (value: 'false' | 'true' | 'unset') => {\n      if (context?.overridesSend != null) {\n        switch (value) {\n          case 'true': {\n            context.overridesSend({ type: 'ENABLE', name: feature.name });\n            break;\n          }\n          case 'false': {\n            context.overridesSend({ type: 'DISABLE', name: feature.name });\n            break;\n          }\n          case 'unset': {\n            context.overridesSend({ type: 'UNSET', name: feature.name });\n            break;\n          }\n        }\n      }\n    },\n    [feature.name, context]\n  );\n\n  if (context == null) {\n    return null;\n  }\n\n  const { overridesState, test: testFeature, defaultsState } = context;\n\n  const valueInDefaults = (valueOfFeature(defaultsState, feature.name)[0] ?? 'unset').toString() as\n    | 'false'\n    | 'true'\n    | 'unset';\n\n  const valueInOverrides = (valueOfFeature(overridesState, feature.name)[0] ?? 'unset').toString() as\n    | 'false'\n    | 'true'\n    | 'unset';\n\n  const actualChecked = testFeature(feature.name);\n\n  return (\n    <RadioGroup disabled={feature.noOverride} onChange={handleChangeSelection} value={valueInOverrides}>\n      <RadioGroup.Label>\n        <h6 className=\"text-gray-900 align-center flex flex-row flex-nowrap items-center gap-2 lg:gap-4 h-7\">\n          <span className=\"font-medium\">\n            Feature: <code>{feature.name}</code>\n          </span>\n          {feature.noOverride === true ? (\n            <div className=\"border-orange-500 text-orange-500 flex flex-nowrap text-xs flex-row gap-1 rounded-sm border items-center justify-center px-2 py-1\">\n              <svg\n                aria-hidden=\"true\"\n                className=\"h-4 w-4 min-w-4\"\n                fill=\"currentColor\"\n                viewBox=\"0 0 20 20\"\n                xmlns=\"http://www.w3.org/2000/svg\"\n              >\n                <path\n                  clipRule=\"evenodd\"\n                  d=\"M5 9V7a5 5 0 0110 0v2a2 2 0 012 2v5a2 2 0 01-2 2H5a2 2 0 01-2-2v-5a2 2 0 012-2zm8-2v2H7V7a3 3 0 016 0z\"\n                  fillRule=\"evenodd\"\n                />\n              </svg>\n              <div>No Overrides</div>\n            </div>\n          ) : null}\n          {actualChecked === true ? (\n            <div className=\"flex flex-nowrap text-xs text-green-500 flex-row gap-1 rounded-sm border items-center justify-center border-green-500 px-2 py-1\">\n              <svg\n                aria-hidden=\"true\"\n                className=\"h-4 w-4 min-w-4\"\n                fill=\"currentColor\"\n                viewBox=\"0 0 20 20\"\n                xmlns=\"http://www.w3.org/2000/svg\"\n              >\n                <path\n                  clipRule=\"evenodd\"\n                  d=\"M10 18a8 8 0 100-16 8 8 0 000 16zm3.707-9.293a1 1 0 00-1.414-1.414L9 10.586 7.707 9.293a1 1 0 00-1.414 1.414l2 2a1 1 0 001.414 0l4-4z\"\n                  fillRule=\"evenodd\"\n                />\n              </svg>\n              <div>{actualChecked ? 'Enabled' : 'Disabled'}</div>\n            </div>\n          ) : null}\n        </h6>\n        {feature.description == null ? null : <p className=\"text-base text-gray-500 text-sm\">{feature.description}</p>}\n      </RadioGroup.Label>\n      <div className=\"mt-4 grid grid-cols-1 gap-y-6 sm:grid-cols-3 sm:gap-x-4\">\n        {[\n          { id: 'false', title: `Disable ${feature.name}`, description: 'Override the feature to be disabled' },\n          {\n            id: 'unset',\n            title: 'Default',\n            description: 'Inherit enabled state from defaults',\n            disabled: (feature.noOverride ?? false) || feature.force,\n            defaultValue:\n              valueInDefaults === 'true' ? (\n                <div className=\"text-green-500 border-green-500 flex flex-nowrap text-xs flex-row gap-1 rounded-sm border items-center justify-center px-2 py-1\">\n                  <span>Enabled</span>\n                </div>\n              ) : (\n                <div className=\"text-red-500 border-red-500 flex flex-nowrap text-xs flex-row gap-1 rounded-sm border items-center justify-center px-2 py-1\">\n                  <span>Disabled</span>\n                </div>\n              ),\n          },\n          { id: 'true', title: `Enable ${feature.name}`, description: 'Override the feature to be enabled' },\n        ].map((option) => (\n          <RadioGroup.Option\n            className={({ checked, active, disabled }) =>\n              classNames(\n                checked ? 'border-transparent' : 'border-gray-300',\n                !disabled && active ? 'border-blue-500 ring-2 ring-blue-500' : '',\n                disabled ? 'border-transparent ring-gray-500 cursor-not-allowed' : 'cursor-pointer',\n                'relative bg-white border rounded-lg shadow-sm p-3 flex focus:outline-none'\n              )\n            }\n            disabled={option.disabled}\n            key={option.id}\n            value={option.id}\n          >\n            {({ checked, active, disabled }) => (\n              <>\n                <div className=\"flex flex-col grow\">\n                  <RadioGroup.Label as=\"span\" className=\"flex flex-nowrap flex-row gap-1 items-center space-between\">\n                    <span className=\"text-sm font-medium text-gray-900 grow shrink\">{option.title}</span>\n                    {option.defaultValue != null ? option.defaultValue : null}\n                    <svg\n                      aria-hidden=\"true\"\n                      className={classNames(!checked ? 'invisible' : '', 'h-5 w-5 text-blue-500 min-w-4')}\n                      fill=\"currentColor\"\n                      viewBox=\"0 0 20 20\"\n                      xmlns=\"http://www.w3.org/2000/svg\"\n                    >\n                      <path\n                        clipRule=\"evenodd\"\n                        d=\"M10 18a8 8 0 100-16 8 8 0 000 16zm3.707-9.293a1 1 0 00-1.414-1.414L9 10.586 7.707 9.293a1 1 0 00-1.414 1.414l2 2a1 1 0 001.414 0l4-4z\"\n                        fillRule=\"evenodd\"\n                      />\n                    </svg>\n                  </RadioGroup.Label>\n                  <RadioGroup.Description as=\"span\" className=\"mt-1 flex items-center text-sm text-gray-500\">\n                    {option.description}\n                  </RadioGroup.Description>\n                </div>\n                <div\n                  aria-hidden=\"true\"\n                  className={classNames(\n                    !disabled && active ? 'border' : 'border-2',\n                    checked ? (disabled ? 'border-gray-500' : 'border-blue-500') : 'border-transparent',\n                    'absolute -inset-px rounded-lg pointer-events-none'\n                  )}\n                />\n              </>\n            )}\n          </RadioGroup.Option>\n        ))}\n      </div>\n    </RadioGroup>\n  );\n}\n\nfunction ShadowContent({ root, children }: { children: ReactNode; root: Element }) {\n  return ReactDOM.createPortal(children, root);\n}\n\n/// Permit users to override feature flags via a GUI.\n/// Renders a small floating button in lower left or right, pressing it brings up\n/// a list of features to toggle and their current override state. you can override on or override off,\n/// or unset the override and go back to default value.\n// eslint-disable-next-line no-undef\nexport function ToggleFeatures({ defaultOpen = false }: { defaultOpen?: boolean }): JSX.Element | null {\n  const [root, setCoreRoot] = useState<HTMLDivElement | null>(null);\n\n  const setRoot = (host: HTMLDivElement | null) => {\n    if (host == null || root != null) {\n      return;\n    }\n    const shadowRoot = host?.attachShadow({ mode: 'open' });\n    const style = document.createElement('style');\n    const renderDiv = document.createElement('div');\n    style.textContent = styles;\n    shadowRoot.appendChild(style);\n    shadowRoot.appendChild(renderDiv);\n    setCoreRoot(renderDiv);\n  };\n\n  return (\n    <div ref={setRoot} style={{ zIndex: 99999, position: 'fixed', width: '0', height: '0', bottom: 0 }}>\n      {root != null ? (\n        <ShadowContent root={root}>\n          <ToggleFeatureUnwrapped defaultOpen={defaultOpen} />\n        </ShadowContent>\n      ) : null}\n    </div>\n  );\n}\n\n/// Like ToggleFeatures, but does not inject styles into a shadow DOM root node.\n/// useful if you're using tailwind.\nexport function ToggleFeatureUnwrapped({ defaultOpen = false }: { defaultOpen?: boolean }): JSX.Element | null {\n  const [open, setOpen] = useState(defaultOpen);\n  const context = useContext(FeatureContext);\n\n  if (context == null) {\n    return null;\n  }\n\n  // We want: Real value after all nestings, value of the override. we toggle override\n  const { featuresDescription } = context;\n\n  if (featuresDescription.length === 0) {\n    return null;\n  }\n\n  return (\n    <div className=\"relative\">\n      <div className=\"absolute bottom-0 left-0 mx-4 my-4\">\n        <button\n          className=\"inline-flex items-center text-sm font-medium p-1 h-8 w-8 align-middle cursor-pointer rounded-full bg-blue-600 text-white  border border-transparent justify-center text-base font-medium focus:outline-none focus:ring-2 focus:ring-offset-2 focus:ring-blue-600 sm:text-sm\"\n          onClick={() => setOpen(true)}\n          title=\"Toggle features\"\n          type=\"button\"\n        >\n          <svg\n            className=\"w-6 h-6 min-h-6 min-w-6\"\n            fill=\"currentColor\"\n            viewBox=\"0 0 20 20\"\n            xmlns=\"http://www.w3.org/2000/svg\"\n          >\n            <path\n              clipRule=\"evenodd\"\n              d=\"M3 6a3 3 0 013-3h10a1 1 0 01.8 1.6L14.25 8l2.55 3.4A1 1 0 0116 13H6a1 1 0 00-1 1v3a1 1 0 11-2 0V6z\"\n              fillRule=\"evenodd\"\n            />\n          </svg>\n        </button>\n      </div>\n      {!open ? null : (\n        <div className=\"fixed z-10 inset-0 overflow-y-auto\">\n          <div className=\"flex items-end justify-flex-start mx-8 my-4 min-h-screen pt-4 px-4 pb-10 sm:block sm:p-0\">\n            <div className=\"relative inline-block align-bottom bg-white rounded-lg px-4 pt-5 pb-4 text-left overflow-hidden shadow-xl transform transition-all sm:my-8 sm:align-middle sm:p-6 lg:max-w-[80%] max-w-full\">\n              <div>\n                <div className=\"mt-1 sm:mt-3\">\n                  <h3 className=\"flex flex-row gap-4 flex-nowrap items-center space-between\">\n                    <div className=\"grow text-lg leading-6 font-medium text-gray-900\">Feature Flag Overrides</div>\n                  </h3>\n                  <p className=\"text-sm text-gray-500\">\n                    Features can be enabled or disabled unless they are forced upstream. You can also revert to default.\n                  </p>\n                  <div className=\"mt-6\">\n                    <fieldset className=\"flex flex-col gap-9\">\n                      <legend className=\"sr-only\">Feature Flags</legend>\n                      {featuresDescription.map((feature) => (\n                        <ToggleFeature feature={feature} key={feature.name} />\n                      ))}\n                    </fieldset>\n                  </div>\n                  <div className=\"flex justify-center items-center mt-5 sm:mt-6\">\n                    <button\n                      className=\"inline-flex items-center text-sm font-medium pt-0 pb-0 pr-4 pl-4 h-8 leading-7 align-middle cursor-pointer rounded-sm bg-blue-600 text-white border border-transparent justify-center text-base font-medium focus:outline-none focus:ring-2 focus:ring-offset-2 focus:ring-blue-600 sm:text-sm\"\n                      onClick={() => setOpen(false)}\n                      type=\"button\"\n                    >\n                      Done\n                    </button>\n                  </div>\n                </div>\n              </div>\n            </div>\n          </div>\n        </div>\n      )}\n    </div>\n  );\n}\n"],"names":[],"sourceRoot":""}