{"version":3,"file":"8895.798f7b1aef7dce87f66b.js","mappings":"iaAaA,KAAM,CAAE,MAAAA,EAAO,IAAAC,GAAK,KAAAC,EAAK,EAAI,KAEvBC,GAAc,EAEpB,IAAIC,GAAY,EAEhB,MAAMC,GAAY,MAIlB,SAASC,GAAKC,EAAmBC,EAAqBC,EAAeC,EAAaC,EAAc,IAC9FC,GAAA,IAAWH,EAAOF,EAAWF,GAAWG,EAAM,CAACK,EAAGC,EAAQC,IAAW,CACnE,IAAIC,EAAYN,EAAMI,EAClBG,EAAYP,EAAMK,EAEtBJ,EAAKE,EAAGG,EAAWC,CAAS,CAC9B,CAAC,CACH,CA+BO,SAASC,GAAUC,EAA2B,CACnD,KAAM,CACJ,KAAAC,EACA,UAAAC,EACA,WAAAC,EACA,cAAAC,EACA,UAAAhB,EAAY,EACZ,SAAAiB,EAAW,EACX,UAAAC,EACA,YAAAC,EAAc,GACd,MAAAC,EACA,MAAAC,EACA,YAAAC,EACA,WAAAC,EAAa,OACb,aAAAC,EACA,cAAAC,EACA,eAAAC,GACA,WAAAC,EACF,EAAIf,EAEJ,IAAIgB,EAGAC,EAEJ,MAAMC,GAAyB5B,GAAkB,CAC/C2B,EAAmB,MAAMf,CAAS,EAC/B,KAAK,IAAI,EACT,IAAKiB,GAAM,MAAM7B,CAAK,EAAE,KAAK,IAAI,CAAC,CACvC,EAEM8B,EAAO,OAAO,KAAK,MAAM,GAAK,gBAAgB,CAAC,MAAMZ,EAAM,WAAW,UAAU,GAChFa,EAA8B,MAAMnB,CAAS,EAAE,KAAK,IAAI,EAC9D,IAAIoB,EAA+B,KAEnC,MAAMC,GAAO,CAAClB,EAAU,GAAQ,EAC1BmB,GAAY,EAAID,GAAK,CAAC,EACtBE,IAAYF,GAAK,CAAC,GAAK,KAAY,IAAM,QAEzCG,GAAgE,IAAI,IACpEC,GAAoE,IAAI,IAE9E,SAASC,GAAUC,EAA+B,CAChDH,GAAU,QAAQ,CAACI,EAAUC,IAAc,CACzCF,EAAI,UAAYE,EAChBF,EAAI,KAAKC,CAAQ,CACnB,CAAC,EAEDH,GAAY,QAAQ,CAACK,EAAYC,IAAgB,CAC/CJ,EAAI,YAAcI,EAClBJ,EAAI,OAAOG,CAAU,CACvB,CAAC,EAEDN,GAAU,MAAM,EAChBC,GAAY,MAAM,CACpB,CAEA,SAASO,GACPL,EACAM,EACAC,EACAC,EACAC,EACAC,EACAC,EACAC,EACAC,EACAC,EACAC,EACAC,EACAC,GACA,CAEAN,EAAW,KAAK,IAAI,EAAGA,CAAQ,EAE/B,MAAMO,EAAalC,EAAc8B,EAAY,EAAGE,CAAK,EAC/CG,GAAclC,GAAe6B,CAAS,EACtCM,GAAYC,GAAaF,GAAaD,CAAU,EAatD,GAXA9B,EAAiB0B,CAAS,EAAEC,CAAQ,EAAI,CACtC,EAAG/D,EAAMyD,EAAOF,CAAI,EACpB,EAAGvD,EAAM0D,EAAMF,CAAI,EACnB,EAAGG,EACH,EAAGC,EACH,KAAME,EAAY,EAClB,KAAMC,EAEN,UAAAK,EACF,EAEIH,GAAU,CACZ,IAAIf,GAAYkB,GACZnB,GAAWJ,GAAU,IAAIK,EAAS,EAQtC,GANID,IAAY,MACdJ,GAAU,IAAIK,GAAYD,GAAW,IAAI,MAAS,EAGpDK,EAAKL,GAAUQ,EAAMC,EAAKC,EAAUC,CAAS,EAEzCC,EAAa,CACf,IAAIT,EAAcc,EACdf,EAAaL,GAAY,IAAIM,CAAW,EAExCD,GAAc,MAChBL,GAAY,IAAIM,EAAcD,EAAa,IAAI,MAAS,EAG1DG,EACEH,EACAM,EAAOI,EAAc,EACrBH,EAAMG,EAAc,EACpBF,EAAWE,EACXD,EAAYC,CACd,CACF,CACF,MACEb,EAAI,UAAU,EACdM,EAAKN,EAAKS,EAAMC,EAAKC,EAAUC,CAAS,EACxCZ,EAAI,UAAYoB,GAChBpB,EAAI,KAAK,EAELa,IACFb,EAAI,UAAU,EACdM,EAAKN,EAAKS,EAAOI,EAAc,EAAGH,EAAMG,EAAc,EAAGF,EAAWE,EAAaD,EAAYC,CAAW,EACxGb,EAAI,YAAckB,EAClBlB,EAAI,UAAYa,EAChBb,EAAI,OAAO,EAGjB,CAEA,MAAMsB,GAAgC,CAACC,EAAGC,EAAMC,EAAMC,KACpD,IAAM,OACJH,EACAC,EACA,CAACG,EAAQC,EAAOC,EAAOC,EAAQC,EAAQC,EAAWC,EAAW1B,EAAMC,GAAM0B,EAAMC,GAAMC,GAAQC,GAAQ/B,KAAS,CAC5G,IAAIO,EAAc7D,GAAO2E,EAAO,OAAS,GAAK,IAAM,OAAO,EAEvDV,EAAW3C,EAAWkD,CAAI,EAC1Bc,EAAarB,GAAY1C,EAAciD,CAAI,EAE/CD,EAAE,IAAI,KAAK,EACXjB,GAAKiB,EAAE,IAAKA,EAAE,KAAK,KAAMA,EAAE,KAAK,IAAKA,EAAE,KAAK,MAAOA,EAAE,KAAK,MAAM,EAChEA,EAAE,IAAI,KAAK,EAEXjE,GAAKC,EAAWiE,EAAO,EAAGnD,EAAW8D,GAAM,CAACI,GAAIC,GAAIC,KAAW,CAC7D,GAAIrE,IAASsE,EAAa,QACxB,QAASC,EAAK,EAAGA,EAAKd,EAAM,OAAQc,IAAM,CACxC,IAAIC,GAAOf,EAAMc,CAAE,EAEnB,GAAIC,IAAQ,MAAQN,EAAY,CAC9B,IAAI7B,GAAO,KAAK,MAAMuB,EAAUJ,EAAMe,CAAE,EAAGb,EAAQI,EAAM3B,CAAI,CAAC,EAE1DsC,GAASF,EACb,KACE,EAAEE,GAAShB,EAAM,SAChBA,EAAMgB,EAAM,IAAM,QAAcnE,GAAemD,EAAMgB,EAAM,IAAMD,KAClE,CAGF,IAAIE,GACFD,KAAWhB,EAAM,OACbtB,EAAO2B,EAAOrB,EACd,KAAK,MAAMmB,EAAUJ,EAAMiB,EAAM,EAAGf,EAAQI,EAAM3B,CAAI,CAAC,EAE7DF,GACEkB,EAAE,IACFjB,GACAC,EACAC,GACAC,GACAzD,EAAMwD,GAAOgC,EAAE,EACfM,GAAQrC,GACRzD,EAAMyF,EAAM,EACZ5B,EACA0B,GACAI,EACAC,GACA3B,CACF,EAEA0B,EAAKE,GAAS,CAChB,CACF,SACSzE,IAASsE,EAAa,QAAS,CACxC,IAAIK,EAASf,EAAUJ,EAAM,CAAC,EAAGE,EAAQI,EAAM3B,CAAI,EAAIyB,EAAUJ,EAAM,CAAC,EAAGE,EAAQI,EAAM3B,CAAI,EACzFyC,GAASD,EAASpD,GAClBsD,GAASjG,EAAMC,GAAI2C,GAAUmD,EAASC,EAAM,EAAInC,CAAW,EAC3DqC,GAASD,GAAS,EAGtB,QAASN,GAAKlB,EAAMkB,IAAMjB,EAAMiB,KAAM,CACpC,IAAIC,GAAOf,EAAMc,EAAE,EAEnB,GAAIC,IAAQ,MAAQN,EAAY,CAE9B,IAAI7B,GAAOuB,EAAUJ,EAAMe,EAAE,EAAGb,EAAQI,EAAM3B,CAAI,EAElDF,GACEkB,EAAE,IACFjB,GACAC,EACAC,GACAxD,EAAMyD,GAAOyC,EAAM,EACnBlG,EAAMwD,GAAOgC,EAAE,EACfS,GACAjG,EAAMyF,EAAM,EACZ5B,EACA0B,GACAI,GACAC,GACA3B,CACF,CACF,CACF,CACF,CACF,CAAC,EAEGA,IACFM,EAAE,IAAI,UAAYV,EAClBd,GAAUwB,EAAE,GAAG,GAGjBA,EAAE,IAAI,QAAQ,CAChB,CACF,EAEO,MAGH4B,GACJtE,GAAe,MAAQJ,IAAc,KAAe,MAChD,GACA,CAAC8C,EAAGC,EAAM4B,EAAIC,KACZ9B,EAAE,IAAI,KAAK,EACXA,EAAE,IAAI,KAAKA,EAAE,KAAK,KAAMA,EAAE,KAAK,IAAKA,EAAE,KAAK,MAAOA,EAAE,KAAK,MAAM,EAC/DA,EAAE,IAAI,KAAK,EAEXA,EAAE,IAAI,KAAOhC,EACbgC,EAAE,IAAI,UAAYnD,IAASsE,EAAa,QAAU5D,EAAa,SAC/DyC,EAAE,IAAI,aAAe,SAErB,IAAM,OACJA,EACAC,EACA,CAACG,EAAQC,EAAOC,EAAOC,EAAQC,EAAQC,EAAWC,EAAW1B,EAAMC,GAAM0B,EAAMC,KAAS,CACtF,IAAItB,GAAc7D,GAAO2E,EAAO,OAAS,GAAK,IAAM,OAAO,EAGvDW,GADWhE,EAAWkD,CAAI,GACDjD,EAAciD,CAAI,EAE3C8B,EAAItG,EAAMiF,EAAUsB,GAAQ/B,EAAO,CAAC,EAAGO,EAAQI,GAAM3B,EAAI,CAAC,EAE9D,QAASmC,EAAK,EAAGA,EAAKd,EAAM,OAAQc,IAClC,GAAId,EAAMc,CAAE,GAAK,MAAQL,GAAY,CACnC,MAAMkB,EAAUpE,EAAiBoC,EAAO,CAAC,EAAEmB,CAAE,EAE7C,GAAI,CAACa,GAAWA,EAAQ,GAAKtB,EAC3B,SAGF,IAAIuB,GAAW,KAAK,MAAMD,GAAS,EAAIpG,EAAS,EAEhD,GAAIqB,IAAc,KAAe,MAAQgF,GAAW,EAClD,SAGF,IAAIC,GAAM7E,EAAY2C,EAAMK,EAAMc,CAAE,CAAC,EAGjCgB,GAAI3G,EAAMwG,EAAQ,EAAIjD,EAAOiD,EAAQ,EAAI,CAAC,EAC1CpF,IAASsE,EAAa,UACpB5D,IAAe,OACjB6E,GAAI3G,EAAMwG,EAAQ,EAAIjD,EAAOM,GAAc1D,EAAW,EAC7C2B,IAAe,UACxB6E,GAAI3G,EAAMwG,EAAQ,EAAIjD,EAAOiD,EAAQ,EAAI3C,GAAc1D,EAAW,IAKtEoE,EAAE,IAAI,UAAY5C,EAAM,OAAO,gBAAgB6E,EAAQ,UAAW,CAAC,EACnEjC,EAAE,IAAI,SAASmC,GAAI,MAAM,EAAGD,EAAQ,EAAGE,GAAGL,CAAC,CAC7C,CAEJ,CACF,EAEA/B,EAAE,IAAI,QAAQ,EAEP,IAGTqC,GAAQrC,GAAa,CACzB,IAAIsC,EAAQ,GACZ,QAAShG,EAAI,GAAIA,GAAK,IAAKA,IACzBgG,GAAS,OAAO,aAAahG,CAAC,EAEhCT,GAAY,KAAK,KAAMmE,EAAE,IAAI,YAAYsC,CAAK,EAAE,MAAQA,EAAM,OAAU,IAAM,OAAO,EAGrFzG,IAAa,IAEbmE,EAAE,KAAK,iBAAiC,cAAc,EAAE,QAASuC,GAAO,CACtEA,EAAG,MAAM,aAAe,GAC1B,CAAC,CACH,EAEMC,GAAaxC,GAAa,CAC9BpC,EAAKA,GAAM,IAAI,MAAS,EAAG,EAAGoC,EAAE,KAAK,MAAOA,EAAE,KAAK,MAAM,EAEzDpC,EAAG,MAAM,EACTE,GAAsBkC,EAAE,KAAK,CAAC,EAAE,MAAM,EAGtCA,EAAE,OAAO,QAASyC,GAAM,CAEtBA,EAAE,OAAS,IACb,CAAC,CACH,EAEA,SAASC,GAAWC,EAAYC,EAAYC,EAAU,GAAO,CAC3D5E,EAAQ,KAAK,IAAI,EACjBC,EAAkB,KAEd,EAAAyE,EAAK,IAMT/E,EAAG,IAAI+E,EAAI,EAAG,IAAM,QAAS,IAAMG,GAAM,CAEnCH,GAAMG,EAAE,GAAKH,GAAMG,EAAE,EAAIA,EAAE,IAEzBF,GAAME,EAAE,GAAKF,GAAME,EAAE,EAAIA,EAAE,EAC7B7E,EAAQ6E,EAAE,IAAI,EAAI5E,EAAkB4E,GAG7BnF,IAAckF,KACrB5E,EAAQ6E,EAAE,IAAI,EAAIA,GAGxB,CAAC,CACH,CAEA,MAAMC,GAAuB,CAC3B,EAAGlG,IAASsE,EAAa,QACzB,EAAG,GACH,QAAS,CAACnB,EAAGT,IAAc,CACzB,GAAIA,IAAc,EAAG,CAEnB,GAAI3B,EAAG,EAAE,SAAW,GAAKA,EAAG,GAAK,KAC/B,UAAWoF,KAAenF,EACxB,UAAWkB,KAAQiE,EACjBjE,GAAQnB,EAAG,IAAImB,CAAI,EAKzB,IAAI4D,EAAK3C,EAAE,OAAO,KAAQ,IAAM,QAC5B4C,EAAK5C,EAAE,OAAO,IAAO,IAAM,QAE/B0C,GAAWC,EAAIC,EAAI5C,EAAE,OAAO,OAAS,IAAI,CAC3C,CAEA,OAAO/B,EAAQsB,CAAS,GAAG,IAC7B,EACA,MAAO,CACL,KAAM,IACN,KAAM,CAACS,EAAGT,IAAerB,GAAiB,OAASqB,EAAY,EAAI,GACrE,EACA,OAAQ,CACN,KAAM,wBACN,KAAM,CAACS,EAAGT,IAAc,CACtB,IAAI0D,EAAQhF,EAAQsB,CAAS,EACzB2D,EAAYD,GAAS,KAEzB,MAAO,CACL,KAAMC,EAAYD,EAAO,EAAI,IAAM,QAAU,IAC7C,IAAKC,EAAYD,EAAO,EAAI,IAAM,QAAU,IAC5C,MAAOC,EAAYD,EAAO,EAAI,IAAM,QAAU,EAC9C,OAAQC,EAAYD,EAAO,EAAI,IAAM,QAAU,CACjD,CACF,CACF,CACF,EAEMjB,GAAoB,MAAMlF,CAAS,EAAE,KAAK,CAAC,EAC3CqG,GAA6B,CAAC,EAAG,CAAC,EAExC,MAAO,CACL,OAAAJ,GAEA,QACElG,IAASsE,EAAa,QAClB,CAACnB,EAAUoD,EAAiBC,EAAkBC,EAAkBC,EAAmBC,IAAuB,CACxG,IAAIC,EAAS,CAAC,EAEVC,EAAW1D,EAAE,KAAK,CAAC,EAAE,CAAC,EAAIA,EAAE,KAAK,CAAC,EAAE,CAAC,EACrC2D,EAAahI,GAAK4H,EAAYG,CAAQ,EAE1C,QAASpH,EAAI,EAAGA,EAAI0D,EAAE,KAAK,CAAC,EAAE,OAAQ1D,GAAKqH,EAAY,CACrD,IAAI5F,EAAIiC,EAAE,KAAK,CAAC,EAAE1D,CAAC,EAEfyB,GAAKsF,GAAYtF,GAAKuF,GACxBG,EAAO,KAAK1F,CAAC,CAEjB,CAEA,OAAO0F,CACT,EACA,KAEN,OAASzD,GAAa,CACpB,MAAM4D,EAAIpG,EAAa,EAEvB,IAAI9B,EAAMkI,EAAE,KAAK,QAAQ,EACrBC,EAAMD,EAAE,GAAG,QAAQ,EAEvB,GAAI/G,IAASsE,EAAa,QAAS,CAEjC,IAAI2C,GADS9D,EAAE,KAAK,CAAC,EAAE,CAAC,EAAIA,EAAE,KAAK,CAAC,EAAE,CAAC,GACf,EAEpBtE,GAAOsE,EAAE,KAAK,CAAC,EAAE,CAAC,IACpBtE,EAAMsE,EAAE,KAAK,CAAC,EAAE,CAAC,EAAI8D,GAGvB,IAAIC,EAAU/D,EAAE,KAAK,CAAC,EAAE,OAAS,EAE7B6D,GAAO7D,EAAE,KAAK,CAAC,EAAE+D,CAAO,IAC1BF,EAAM7D,EAAE,KAAK,CAAC,EAAE+D,CAAO,EAAID,EAE/B,CAGA,MADmC,CAACpI,EAAKmI,CAAG,CAE9C,EAEA,QAAU7D,IACRjE,GAAKC,EAAW,KAAMc,EAAWkD,EAAE,KAAK,OAAQ,CAACgB,EAAIC,EAAI+C,IAAQ,CAE/D,IAAIC,EAAOxI,EAAMwF,EAAK+C,EAAM,CAAC,EAC7BhC,GAAQhB,CAAE,EAAIhB,EAAE,SAASiE,EAAO,IAAM,QAAS,GAAU,CAC3D,CAAC,EAEMjC,IAGT,QAAS,CAAChC,EAAUyD,IAAqBA,EAAO,IAAI,CAAC1F,EAAGzB,IAAMe,EAAMf,EAAI,CAAC,CAAC,EAC1E,OAAA6G,GAGA,UAAApD,GACA,WAAA6B,GAGA,KAAAS,GACA,UAAAG,EACF,CACF,CAEA,SAAS1C,GAAaF,EAA2DsE,EAAe,CAG9F,GAAIA,EAAM,CAAC,IAAM,KAAOA,EAAM,SAAW,EACvC,OAAOA,EAGT,MAAMC,GAAkBvE,EAAY,aAAe,KAAO,IAC1D,SAAO,MAAMsE,EAAOC,CAAc,CACpC,CCrdO,IAAKhD,GAAAA,IACVA,EAAA,QAAU,UACVA,EAAA,QAAU,UAFAA,IAAAA,GAAA,IAKZ,MAAMiD,GAAkC,CACtC,UAAW,EACX,YAAa,EACf,EAEaC,GAAkE,CAAC,CAC9E,MAAAC,EACA,MAAAlH,EACA,UAAAmH,EACA,aAAA/G,EACA,KAAAX,EACA,UAAAb,EACA,SAAAiB,EACA,UAAAC,EACA,WAAAK,EACA,YAAAJ,EACA,cAAAM,EACA,WAAAE,CACF,IAAM,CACJ,MAAM6G,EAAU,IAAIC,EAAA,EAAmBF,EAAU,CAAC,CAAC,EAE7CG,EAAY,IAEZ3H,EAAc4H,GAAiB,CACnC,MAAM9H,EAAO8H,EAAM,QAAQ,OAAO,KAClC,MAAO,EAAE9H,GAAQ8H,EAAM,SAAW9H,EAAK,WAAW,aAAa,EACjE,EAEMG,GAAiB2H,GAEnBA,EAAM,OAAO,UAAU,KACpBC,GAAYA,EAAQ,OAAS,KAAY,cAAgBA,EAAQ,QAAQ,QAAU,MACtF,GAAK,GAIHC,GAAkB,CAACtF,EAAmBE,IAAmB,CAC7D,MAAMkF,EAAQL,EAAM,OAAO/E,CAAS,EAEpC,OACEoF,EAAM,OAAO,QAAQ,aAAe,QACpCA,EAAM,OAAO,QAAQ,aAAe,QACpClH,EAEOA,EAAckH,EAAM,OAAO,QAAQ,WAAYA,EAAM,OAAO,QAAQ,WAAYlF,CAAK,EAGvF,GACT,EAEM7C,EAA4B,CAChC,KAAAC,EACA,UAAWyH,EAAM,OAAO,OAAS,EACjC,WAAa/E,GAAcxC,EAAWuH,EAAM,OAAO/E,CAAS,CAAC,EAC7D,cAAgBA,GAAcvC,GAAcsH,EAAM,OAAO/E,CAAS,CAAC,EACnE,YAAApC,EACA,UAAAnB,EACA,SAAAiB,EACA,UAAAC,EACA,WAAAK,EACA,MAAAH,EACA,MAAQmC,MAAc,OAAoB+E,EAAM,OAAO/E,CAAS,EAAG+E,CAAK,EACxE,eAAiB/E,GAAc+E,EAAM,OAAO/E,CAAS,EAAE,OAAO,OAC9D,cAAesF,GACf,aAAArH,EAEA,YAAa,CAAC+B,EAAWE,OAAU,OAAuB6E,EAAM,OAAO/E,CAAS,EAAE,QAASE,CAAK,CAAC,EACjG,WAAA9B,CACF,EAEMmH,EAAanI,GAAUC,CAAI,EAEjC4H,EAAQ,QAAQ,OAAQM,EAAW,IAAI,EACvCN,EAAQ,QAAQ,YAAaM,EAAW,SAAS,EAEjDN,EAAQ,YAAaO,MAAW,MAAiBA,EAAO,CAAC,KAAG,MAAkBA,EAAO,CAAC,CAAC,CAAC,CAAC,EAEzFP,EAAQ,UAAUM,EAAW,MAAM,EAEnCN,EAAQ,SAAS,CACf,SAAUE,EACV,OAAQ,GACR,YAAa,KAAiB,WAC9B,UAAW,KAAe,MAC1B,MAAOI,EAAW,MACpB,CAAC,EAEDN,EAAQ,SAAS,CACf,SAAU,IACV,OAAQ,GACR,YAAa,KAAiB,SAC9B,UAAW,KAAe,GAC1B,MAAOM,EAAW,MACpB,CAAC,EAEDN,EAAQ,QAAQ,CACd,SAAUE,EACV,OAAQ,GACR,OAAQI,EAAW,QACnB,UAAW,KAAc,OACzB,SAAUP,EAAU,CAAC,EACrB,MAAAnH,EACA,KAAM,CAAE,KAAM,EAAK,CACrB,CAAC,EAEDoH,EAAQ,QAAQ,CACd,SAAU,IACV,OAAQ,GACR,UAAW,KAAc,KACzB,OAAQM,EAAW,QACnB,OAAQA,EAAW,QACnB,KAAM,CAAE,KAAM,EAAM,EACpB,MAAO,CAAE,KAAM,EAAM,EACrB,IAAK,GACL,MAAA1H,CACF,CAAC,EAED,IAAI4H,GAAc,EAElB,QAAS1I,EAAI,EAAGA,EAAIgI,EAAM,OAAO,OAAQhI,IAAK,CAC5C,GAAIA,IAAM,EACR,SAGF,MAAMqI,EAAQL,EAAM,OAAOhI,CAAC,EACtB2I,EAAwCN,EAAM,OAC9CO,GAAiC,CACrC,GAAGd,GACH,GAAGa,EAAO,MACZ,EAEAN,EAAM,MAAO,YAAcK,KAK3BR,EAAQ,UAAU,CAChB,SAAU,IACV,YAAaM,EAAW,UACxB,cAAeA,EAAW,WAE1B,UAAWI,GAAa,UACxB,YAAaA,GAAa,YAC1B,MAAA9H,EACA,KAAM,CAAC8H,GAAa,UAAU,IAC9B,WAAYD,EAAO,WAEnB,oBAAqBN,EAAM,OAAO,MACpC,CAAC,CACH,CAEA,OAAOH,CACT,EAEA,SAASW,GAAaR,EAAc,CAClC,IAAIS,EAAYT,EAAM,OAAO,QAAQ,UAKrC,OAAQS,EAAiBA,IAAc,GAAO,IAAWA,EAArC,EACtB,CAKO,SAASC,GAAqBV,EAAcvH,EAAyC,CAC1F,MAAMkI,EAAaX,EAAM,OAAO,WAChC,GAAIA,EAAM,OAAS,KAAU,QAAU,CAACW,GAAc,CAACA,EAAW,MAAM,OACtE,OAGF,MAAMC,EAAQC,GAAkBb,EAAM,OAAQvH,CAAK,EACnD,GAAImI,EAAM,SAAWD,EAAW,MAAM,OACpC,OAGF,MAAMG,EAAkB,IAAI,IACtBC,EAAc,IAAI,IACxB,QAASpJ,EAAI,EAAGA,EAAIiJ,EAAM,OAAQjJ,IAChCmJ,EAAgB,IAAIH,EAAW,MAAMhJ,CAAC,EAAGiJ,EAAMjJ,CAAC,EAAE,KAAK,EACvDoJ,EAAY,IAAIH,EAAMjJ,CAAC,EAAE,MAAOiJ,EAAMjJ,CAAC,EAAE,KAAM,EAGjD,IAAIqJ,EAAQhB,EAAM,OAClB,MAAMiB,EAAO,IAAI,MAA0BjB,EAAM,OAAO,MAAM,EAC9D,GAAIW,EAAW,OAAS,KAAe,WAAY,CACjD,KAAM,CAAE,IAAA5J,EAAK,IAAAmI,CAAI,KAAI,MAAyBc,CAAK,EAC7CkB,EAAQhC,EAAOnI,EACrBiK,EAAQA,EAAM,IAAK5H,GACbA,GAAK,KACAA,GAEAA,EAAIrC,GAAQmK,EAAS,GAC/B,CACH,CAEA,QAASvJ,EAAI,EAAGA,EAAIsJ,EAAK,OAAQtJ,IAAK,CACpC,MAAMyB,EAAI4H,EAAMrJ,CAAC,EACbyB,GAAK,KACP6H,EAAKtJ,CAAC,EAAIyB,EAEV6H,EAAKtJ,CAAC,EAAImJ,EAAgB,OAAI,MAAmB1H,EAAGuH,EAAW,KAAK,CAAC,CAEzE,CAEA,MAAO,CACL,GAAGX,EACH,OAAQ,CACN,GAAGA,EAAM,OACT,OAAQ,CACN,GAAGA,EAAM,OAAO,OAChB,UAAWQ,GAAaR,CAAK,CAC/B,CACF,EACA,KAAM,KAAU,OAChB,OAAQiB,EACR,QAAUnG,IAAW,CACnB,KAAM,OAAOA,CAAK,EAClB,MAAOiG,EAAY,IAAI,OAAOjG,CAAK,CAAC,EACpC,QAAS,GACX,EACF,CACF,CAGO,SAASqG,GACd1F,EACAjD,EACA4I,EACA3I,EACyC,CACzC,GAAI,CAACgD,GAAQ,OACX,MAAO,CAAE,KAAM,qBAAsB,KAGvC,OAAuBA,CAAM,EAE7B,IAAI4F,EAAgB,GACpB,MAAMjB,EAAsB,CAAC,EAE7B,QAAST,KAASlE,EAAQ,CACxB,IAAI6F,EAAgB,GAChBC,EAAc,GAElB,QAAS5J,EAAI,EAAGA,EAAIgI,EAAM,OAAO,OAAQhI,IAGvC,GAFQgI,EAAM,OAAOhI,CAAC,EAEhB,OAAS,KAAU,MACvB,GAAI2J,IAAkB,GACpBA,EAAgB3J,UACP4J,IAAgB,GAAI,CAC7BA,EAAc5J,EACd,KACF,EAIJ,IAAI6J,EAAeF,IAAkB,GACjCG,EAAU,GAKd,GAJA9B,KAAQ,MAAeA,EAAO2B,CAAa,EAIvCC,IAAgB,GAAI,CACtB,IAAIG,EAAwB,CAC1B,GAAG/B,EACH,OAAQA,EAAM,OAAO,OAAO,CAACgC,GAAGhK,KAAMA,KAAM4J,CAAW,CACzD,EAEIK,EAAsB,CACxB,OAAQjC,EAAM,OACd,OAAQ,CAACA,EAAM,OAAO4B,CAAW,CAAC,CACpC,EAEA5B,KAAQ,MAAoB,CAC1B,OAAQ,CAAC+B,EAAYE,CAAQ,EAC7B,iBAAkB,GAClB,SAAU,IAAM,IAClB,CAAC,EAEDjC,EAAM,OAAO,QAAQ,CAACgC,GAAGhK,KAAM,CAC7B,GAAIA,GAAI,EAAG,CACT,IAAIsJ,EAAOU,GAAE,OACb,QAAShK,EAAI,EAAGA,EAAIsJ,EAAK,OAAQtJ,IAC3BsJ,EAAKtJ,CAAC,GAAK,OACbsJ,EAAKtJ,CAAC,EAAI,KAGhB,CACF,CAAC,EAED8J,EAAU,EACZ,CAEA,IAAII,KAAc,KAAyB,CACzC,MAAAlC,EACA,kBAAmByB,EAAU,KAAK,QAAQ,EAC1C,kBAAmBA,EAAU,GAAG,QAAQ,CAC1C,CAAC,EAEGS,IAAgBlC,IAClB8B,EAAU,IAGZ9B,KAAQmC,EAAA,GAAYD,CAAW,EAE/B,MAAME,EAAkB,CAAC,EACzB,QAAS/B,KAASL,EAAM,OACtB,GAAI,CAAAK,EAAM,OAAO,QAAQ,UAAU,IAGnC,OAAQA,EAAM,KAAM,CAClB,KAAK,KAAU,KACbwB,EAAe,GACfH,EAAgB,GAChBU,EAAO,KAAK/B,CAAK,EACjB,MACF,KAAK,KAAU,KACf,KAAK,KAAU,OACb,GAAIxH,GAAewH,EAAM,OAAO,OAAO,OAAS,IAAiB,WAAY,CAC3E,MAAM2B,EAAIjB,GAAqBV,EAAOvH,CAAK,EAC3C,GAAIkJ,EAAG,CACLI,EAAO,KAAKJ,CAAC,EACbF,EAAU,GACV,QACF,CACF,CAEF,KAAK,KAAU,QACf,KAAK,KAAU,OACbzB,EAAQ,CACN,GAAGA,EACH,OAAQ,CACN,GAAGA,EAAM,OACT,OAAQ,CACN,GAAGA,EAAM,OAAO,OAChB,UAAWQ,GAAaR,CAAK,CAC/B,CACF,CACF,EACAyB,EAAU,GACVM,EAAO,KAAK/B,CAAK,EACjB,MACF,QACEyB,EAAU,EACd,CAEED,GAAgBO,EAAO,OAAS,IAClCV,EAAgB,GACZI,EACFrB,EAAO,KAAK,CACV,GAAGT,EACH,OAAAoC,CACF,CAAC,EAED3B,EAAO,KAAKT,CAAK,EAGvB,CAEA,OAAK0B,EAGAjB,EAAO,OAIL,CAAE,OAAAA,CAAO,EAHP,CAAE,KAAM,qBAAsB,EAH9B,CAAE,KAAM,iCAAkC,CAOrD,CAEO,SAAS4B,GAAmB5B,EAAqB,CACtD,MAAM6B,EAAyB,CAAC,EAEhC,QAAStC,KAASS,EAAQ,CACxB,MAAM8B,EAAavC,EAAM,OAAO,OAAQK,GAAUA,EAAM,OAAS,KAAU,IAAI,EAE/E,GAAIkC,EAAW,OAAS,EACtB,QAASlC,KAASL,EAAM,OAClBK,EAAM,OAAS,KAAU,MAC3BiC,EAAU,KAAK,CAAE,OAAQ,CAAC,GAAGC,EAAYlC,CAAK,EAAG,OAAQL,EAAM,MAAO,CAAC,CAI/E,CAEA,OAAOsC,CACT,CAEO,SAASpB,GACd5F,EACAxC,EACA0J,EACiB,CACjB,MAAMvB,EAAyB,CAAC,EAC1BD,EAAawB,GAAkClH,EAAY,WACjE,GAAI,CAAC0F,GAAc,CAACA,EAAW,MAAM,OACnC,OAAOC,EAGT,MAAMwB,EAAQzB,EAAW,MACnB0B,KAAa,OACjB1B,EAAW,OAAS,KAAe,WAAa,UAAa1F,EAAY,MAAQ,EACnF,EAGMqH,EAAUxH,MAAkB,OAAuBuH,EAAWvH,EAAOG,EAAY,UAAY,MAAS,CAAC,EAE7G,QAAStD,EAAI,EAAGA,EAAIyK,EAAM,OAAQzK,IAAK,CACrC,IAAI4K,EAAOH,EAAMzK,CAAC,EACdmD,EAAQyH,EAAK,MACbC,EAAM,GACNC,EAAM,GAEN3H,IAAU,MAAanD,EAAIyK,EAAM,OAAS,GAC5CtH,EAAQsH,EAAMzK,EAAI,CAAC,EAAE,MACrB6K,EAAM,MAENC,EAAM,IAGR7B,EAAM,KAAK,CACT,MAAO,GAAG4B,CAAG,GAAGF,EAAOxH,CAAK,CAAC,GAAG2H,CAAG,GACnC,MAAOhK,EAAM,cAAc,eAAe8J,EAAK,KAAK,EACpD,MAAO,CACT,CAAC,CACH,CAEA,OAAO3B,CACT,CAEO,SAAS8B,GAAqBC,EAA0BlK,EAAuC,CACpG,MAAMmI,EAAyB,CAAC,EAChC,GAAI,CAAC+B,EACH,OAAO/B,EAGT,QAASX,KAAW0C,EAAU,CAC5B,KAAM,CAAE,QAAAC,EAAS,KAAAC,CAAK,EAAI5C,EAE1B,GAAI4C,IAAS,KAAY,YACvB,OAAS,CAACnK,EAAOoC,CAAK,IAAK,OAAO,QAAQ8H,CAAO,EAAG,CAClD,MAAMrD,EAAQzE,EAAM,MACpB8F,EAAM,KAAK,CACT,MAAAlI,EACA,MAAOD,EAAM,cAAc,eAAe8G,GAAS,GAAc,EACjE,MAAO,CACT,CAAC,CACH,CAGF,GAAIsD,IAAS,KAAY,YAAa,CACpC,KAAM,CAAE,KAAAC,EAAM,OAAAC,EAAQ,GAAAC,CAAG,EAAIJ,EACvB,CAAE,KAAAK,EAAM,MAAA1D,CAAM,EAAIwD,EAClBrK,EAAQuK,EAAO,IAAIH,CAAI,MAAME,CAAE,KAAKC,CAAI,GAAK,IAAIH,CAAI,MAAME,CAAE,IAEnEpC,EAAM,KAAK,CACT,MAAAlI,EACA,MAAOD,EAAM,cAAc,eAAe8G,GAAS,GAAc,EACjE,MAAO,CACT,CAAC,CACH,CAEA,GAAIsD,IAAS,KAAY,YAAa,CACpC,KAAM,CAAE,QAAAK,EAAS,OAAAH,CAAO,EAAIH,EACtB,CAAE,KAAAK,EAAM,MAAA1D,CAAM,EAAIwD,EAClBrK,EAAQ,GAAGuK,GAAQC,CAAO,GAEhCtC,EAAM,KAAK,CACT,MAAAlI,EACA,MAAOD,EAAM,cAAc,eAAe8G,GAAS,GAAc,EACjE,MAAO,CACT,CAAC,CACH,CAEA,GAAIsD,IAAS,KAAY,aAAc,CACrC,KAAM,CAAE,MAAAM,EAAO,OAAAJ,CAAO,EAAIH,EACpB,CAAE,KAAAK,EAAM,MAAA1D,CAAM,EAAIwD,EAClBrK,EAAQ,GAAGuK,GAAQE,CAAK,GAE9BvC,EAAM,KAAK,CACT,MAAAlI,EACA,MAAOD,EAAM,cAAc,eAAe8G,GAAS,GAAc,EACjE,MAAO,CACT,CAAC,CACH,CACF,CAEA,OAAOqB,CACT,CAEO,SAASwC,GACdhD,EACAwC,EACAnK,EAC6B,CAC7B,GAAI,GAAC2H,GAAUwC,EAAQ,aAAe,IAItC,OAAOS,GAAmBC,GAAiBlD,CAAM,EAAG3H,CAAK,CAC3D,CAEO,SAAS4K,GAAmBtB,EAAiBtJ,EAAmD,CACrG,GAAI,CAACsJ,EAAO,OACV,OAGF,MAAMnB,EAAyB,CAAC,EAC1B3F,EAAc8G,EAAO,CAAC,EAAE,OACxBwB,EAAYtI,EAAY,OAAO,MAAQ,IAAiB,MACxD0F,EAAa1F,EAAY,WAI/B,GAAIsI,IAAc,IAAiB,YAAc5C,GAAY,OAASA,EAAW,MAAM,OAAS,EAC9F,OAAOE,GAAkB5F,EAAaxC,CAAK,EAI7C,GAAI8K,EAAU,WAAW,YAAY,EACnC,OAGF,MAAMC,EAA+C,IAAI,IAEzD,OAAAzB,EAAO,QAAS/B,GAAU,CACnBA,EAAM,OAAO,QAAQ,UAAU,QAClCA,EAAM,OAAO,QAAS5G,GAAM,CAC1B,IAAIqK,EAAQzD,EAAM,QAAS5G,CAAC,EACxBqK,EAAM,OACRD,EAAY,IAAIC,EAAM,KAAMA,EAAM,KAAM,CAE5C,CAAC,CAEL,CAAC,EAEDD,EAAY,QAAQ,CAACjE,EAAO7G,IAAU,CAChCA,EAAM,OAAS,GACjBkI,EAAM,KAAK,CACT,MAAAlI,EACA,MAAOD,EAAM,cAAc,eAAe8G,GAAS,GAAc,EACjE,MAAO,CACT,CAAC,CAEL,CAAC,EAEMqB,CACT,CAEA,SAAS0C,GAAiBlD,EAA8B,CACtD,MAAM2B,EAAkB,CAAC,EACzB,UAAWpC,KAASS,EAClB,UAAWJ,KAASL,EAAM,OACpBK,EAAM,OAAS,KAAU,MAC3B+B,EAAO,KAAK/B,CAAK,EAIvB,OAAO+B,CACT,CAEO,SAAS2B,GAAmB1D,EAAc2D,EAAsB,CACrE,IAAIC,EACAC,EAAeF,EAAe,EAElC,GAAIE,GAAgB7D,EAAM,OAAO,OAC/B,OAAO,KAGT,MAAM8D,EAAa9D,EAAM,OAAO2D,CAAY,EAE5C,KAAOC,IAAQ,QAAW,CACxB,GAAIC,GAAgB7D,EAAM,OAAO,OAC/B,OAAO,KAET,MAAM+D,EAAa/D,EAAM,OAAO6D,CAAY,EAExCE,IAAe,QAAaA,IAAeD,EAC7CD,IAEAD,EAAMC,CAEV,CAEA,OAAOD,CACT,CASO,SAASI,GAAYC,EAA8B,CACxD,GAAIA,EAAe,GAAK,OAAO,MAAMA,CAAY,EAC/C,MAAO,GAGT,IAAIC,EAAYC,EAAYC,EAAYC,EAAWC,EAAWC,EAAWzG,EAAW0G,EAEpF,OAAA1G,EAAI,KAAK,MAAMmG,EAAe,GAAI,EAClCM,EAAI,KAAK,MAAMzG,EAAI,EAAE,EACrBA,EAAIA,EAAI,GACRwG,EAAI,KAAK,MAAMC,EAAI,EAAE,EACrBA,EAAIA,EAAI,GACRF,EAAI,KAAK,MAAMC,EAAI,EAAE,EACrBA,EAAIA,EAAI,GAERJ,EAAK,KAAK,MAAMG,EAAI,GAAG,EACnBH,EAAK,IACPG,EAAIA,EAAI,KAGVF,EAAK,KAAK,MAAME,EAAI,EAAE,EAClBF,EAAK,IACPE,EAAIA,EAAI,IAGVD,EAAK,KAAK,MAAMC,EAAI,CAAC,EAEjBD,EAAK,IACPC,EAAIA,EAAI,GAGVG,EAAK,KAAK,MAAOP,EAAe,IAAQ,GAAI,EAAI,KAG9CC,EAAK,EACDA,EAAK,MAAQC,EAAK,EAAIA,EAAK,MAAQ,KAAOC,EAAK,EAAIA,EAAK,KAAO,KAAOC,EAAI,EAAIA,EAAI,KAAO,IACzFF,EAAK,EACHA,EAAK,OAASC,EAAK,EAAIA,EAAK,KAAO,KAAOC,EAAI,EAAIA,EAAI,KAAO,IAC7DD,EAAK,EACHA,EAAK,MAAQC,EAAI,EAAIA,EAAI,KAAO,IAChCA,EAAI,EACFA,EAAI,MAAQC,EAAI,EAAIA,EAAI,KAAO,IAC/BA,EAAI,EACFA,EAAI,MAAQC,EAAI,EAAIA,EAAI,KAAO,IAC/BA,EAAI,EACFA,EAAI,MAAQzG,EAAI,EAAIA,EAAI,KAAO,IAC/BA,EAAI,EACFA,EAAI,MAAQ0G,EAAK,EAAIA,EAAK,MAAQ,IAClCA,EAAK,EACHA,EAAK,MACL,KAClB,KAAK,CACT,C,gECzsBO,MAAMC,GAAgB,EAChBC,GAAe,EACfC,EAAe,EAEtBC,GAAQ,CAACjN,EAAWkN,EAAcC,EAAcC,OAAgB,KAAcF,EAAOlN,GAAKmN,EAAOC,GAAM,CAAC,EAOvG,SAASrN,EAAWsN,EAAkBC,EAAoBC,EAAiBC,EAAwBC,EAAY,CACpH,IAAIC,EAAQ,EAAIJ,EAIZF,EACFG,IAAYT,GAAgBY,GAASL,EAAW,GAChDE,IAAYR,GAAgBW,EAASL,EACrCE,IAAYP,EAAgBU,GAASL,EAAW,GAAK,GAGnD,MAAMD,CAAG,GAAKA,IAAQ,OACxBA,EAAM,GAIR,IAAIF,EACFK,IAAYT,GAAgB,EAC5BS,IAAYR,GAAgBK,EAAM,EAClCG,IAAYP,EAAgBI,EAAU,EAIpCD,EAAOG,EAAaD,EACpBM,KAAQ,KAAcR,EAAM,CAAC,EAEjC,GAAIK,GAAW,KACb,QAASxN,EAAI,EAAGA,EAAIqN,EAAUrN,IAC5ByN,EAAKzN,EAAGiN,GAAMjN,EAAGkN,EAAMC,EAAMC,CAAG,EAAGO,CAAK,OAG1CF,EAAKD,EAASP,GAAMO,EAASN,EAAMC,EAAMC,CAAG,EAAGO,CAAK,CAExD,C,mEC9CA,MAAMC,EAAc,GACdC,GAAa,EAQZ,SAASC,GAAYC,EAAYC,EAAYC,EAAcC,EAAcC,EAAcC,EAAc,CAC1G,OAAOL,GAAME,GAAQF,GAAMI,GAAQH,GAAME,GAAQF,GAAMI,CACzD,CAKO,SAASC,EAAU/M,EAAcqC,EAAe2K,EAAe,CACpE,IAAIC,EAAgB,CAAC,EAMrB,GAJIjN,EAAG,EAAE,QACPiN,EAAM,KAAK,GAAGjN,EAAG,EAAE,OAAQmB,IAAUkB,GAAQ,MAAQlB,EAAK,OAASkB,KAAU2K,GAAQ,MAAQ7L,EAAK,OAAS6L,EAAK,CAAC,EAG/GhN,EAAG,EACL,QAAStB,EAAI,EAAGA,EAAIsB,EAAG,EAAE,OAAQtB,IAC/BuO,EAAM,KAAK,GAAGF,EAAU/M,EAAG,EAAEtB,CAAC,EAAG2D,EAAM2K,CAAI,CAAC,EAIhD,OAAOC,CACT,CAOO,SAASC,GAAWC,EAAUC,EAAU,CAC7C,OAAOD,EAAG,GAAKC,EAAG,EAAIA,EAAG,GAAKD,EAAG,EAAIA,EAAG,GAAKC,EAAG,GAAKD,EAAG,EAAIA,EAAG,GAAKC,EAAG,GAAKD,EAAG,GAAKC,EAAG,EAAIA,EAAG,CAChG,CAKO,MAAMC,CAAS,CAIpB,YACS7I,EACAL,EACAmJ,EACAjC,EACAkC,EAAI,EACX,CALO,OAAA/I,EACA,OAAAL,EACA,OAAAmJ,EACA,OAAAjC,EACA,OAAAkC,EAEP,KAAK,EAAI,CAAC,EACV,KAAK,EAAI,IACX,CAEA,OAAQ,CACN,IAAIC,EAAI,KACNhJ,EAAIgJ,EAAE,EACNrJ,EAAIqJ,EAAE,EACNF,EAAIE,EAAE,EAAI,EACVnC,EAAImC,EAAE,EAAI,EACVD,EAAIC,EAAE,EAAI,EAEZA,EAAE,EAAI,CAEJ,IAAIH,EAAS7I,EAAI8I,EAAGnJ,EAAGmJ,EAAGjC,EAAGkC,CAAC,EAE9B,IAAIF,EAAS7I,EAAGL,EAAGmJ,EAAGjC,EAAGkC,CAAC,EAE1B,IAAIF,EAAS7I,EAAGL,EAAIkH,EAAGiC,EAAGjC,EAAGkC,CAAC,EAE9B,IAAIF,EAAS7I,EAAI8I,EAAGnJ,EAAIkH,EAAGiC,EAAGjC,EAAGkC,CAAC,CACpC,CACF,CAGA,MAAM/I,EAAWL,EAAWmJ,EAAWjC,EAAWoC,EAA2B,CAC3E,IAAID,EAAI,KACNE,EAAIF,EAAE,EACNG,EAAQH,EAAE,EAAIA,EAAE,EAAI,EACpBI,EAAQJ,EAAE,EAAIA,EAAE,EAAI,EACpBK,EAAe1J,EAAIyJ,EACnBE,GAActJ,EAAImJ,EAClBI,GAAYvJ,EAAI8I,EAAIK,EACpBK,EAAa7J,EAAIkH,EAAIuC,EAGvBC,GAAgBE,IAAaN,EAAGC,EAAE,CAAC,CAAC,EAEpCI,IAAeD,GAAgBJ,EAAGC,EAAE,CAAC,CAAC,EAEtCI,IAAeE,GAAcP,EAAGC,EAAE,CAAC,CAAC,EAEpCK,IAAaC,GAAcP,EAAGC,EAAE,CAAC,CAAC,CACpC,CAEA,IAAIxI,EAAS,CACX,IAAIsI,EAAI,KAER,GAAIA,EAAE,GAAK,KACTA,EAAE,MAAMtI,EAAE,EAAGA,EAAE,EAAGA,EAAE,EAAGA,EAAE,EAAIwI,GAAM,CACjCA,EAAE,IAAIxI,CAAC,CACT,CAAC,MACI,CACL,IAAI+I,EAAKT,EAAE,EAIX,GAFAS,EAAG,KAAK/I,CAAC,EAEL+I,EAAG,OAAS3B,GAAekB,EAAE,EAAIjB,GAAY,CAC/CiB,EAAE,MAAM,EAER,QAAS9O,EAAI,EAAGA,EAAIuP,EAAG,OAAQvP,IAAK,CAClC,IAAIwP,EAAKD,EAAGvP,CAAC,EAEb8O,EAAE,MAAMU,EAAG,EAAGA,EAAG,EAAGA,EAAG,EAAGA,EAAG,EAAIR,GAAM,CACrCA,EAAE,IAAIQ,CAAE,CACV,CAAC,CACH,CAEAV,EAAE,EAAE,OAAS,CACf,CACF,CACF,CAEA,IAAIhJ,EAAWL,EAAWmJ,EAAWjC,EAAWoC,EAAuB,CACrE,IAAID,EAAI,KACJS,EAAKT,EAAE,EAEX,QAAS9O,EAAI,EAAGA,EAAIuP,EAAG,OAAQvP,IAC7B+O,EAAGQ,EAAGvP,CAAC,CAAC,EAGN8O,EAAE,GAAK,MACTA,EAAE,MAAMhJ,EAAGL,EAAGmJ,EAAGjC,EAAIqC,GAAM,CACzBA,EAAE,IAAIlJ,EAAGL,EAAGmJ,EAAGjC,EAAGoC,CAAE,CACtB,CAAC,CAEL,CAEA,OAAQ,CACN,KAAK,EAAE,OAAS,EAChB,KAAK,EAAI,IACX,CACF,C","sources":["webpack://grafana/./public/app/core/components/TimelineChart/timeline.ts","webpack://grafana/./public/app/core/components/TimelineChart/utils.ts","webpack://grafana/./public/app/plugins/panel/barchart/distribute.ts","webpack://grafana/./public/app/plugins/panel/barchart/quadtree.ts"],"sourcesContent":["import uPlot, { Series } from 'uplot';\n\nimport { GrafanaTheme2, TimeRange } from '@grafana/data';\nimport { alpha } from '@grafana/data/src/themes/colorManipulator';\nimport { TimelineValueAlignment, VisibilityMode } from '@grafana/schema';\nimport { FIXED_UNIT } from '@grafana/ui';\nimport { distribute, SPACE_BETWEEN } from 'app/plugins/panel/barchart/distribute';\nimport { Quadtree, Rect } from 'app/plugins/panel/barchart/quadtree';\nimport { FieldConfig as StateTimeLineFieldConfig } from 'app/plugins/panel/state-timeline/panelcfg.gen';\nimport { FieldConfig as StatusHistoryFieldConfig } from 'app/plugins/panel/status-history/panelcfg.gen';\n\nimport { TimelineMode } from './utils';\n\nconst { round, min, ceil } = Math;\n\nconst textPadding = 2;\n\nlet pxPerChar = 6;\n\nconst laneDistr = SPACE_BETWEEN;\n\ntype WalkCb = (idx: number, offPx: number, dimPx: number) => void;\n\nfunction walk(rowHeight: number, yIdx: number | null, count: number, dim: number, draw: WalkCb) {\n  distribute(count, rowHeight, laneDistr, yIdx, (i, offPct, dimPct) => {\n    let laneOffPx = dim * offPct;\n    let laneWidPx = dim * dimPct;\n\n    draw(i, laneOffPx, laneWidPx);\n  });\n}\n\ninterface TimelineBoxRect extends Rect {\n  fillColor: string;\n}\n\n/**\n * @internal\n */\nexport interface TimelineCoreOptions {\n  mode: TimelineMode;\n  alignValue?: TimelineValueAlignment;\n  numSeries: number;\n  rowHeight?: number;\n  colWidth?: number;\n  theme: GrafanaTheme2;\n  showValue: VisibilityMode;\n  mergeValues?: boolean;\n  isDiscrete: (seriesIdx: number) => boolean;\n  hasMappedNull: (seriesIdx: number) => boolean;\n  getValueColor: (seriesIdx: number, value: unknown) => string;\n  label: (seriesIdx: number) => string;\n  getTimeRange: () => TimeRange;\n  formatValue?: (seriesIdx: number, value: unknown) => string;\n  getFieldConfig: (seriesIdx: number) => StateTimeLineFieldConfig | StatusHistoryFieldConfig;\n  hoverMulti: boolean;\n}\n\n/**\n * @internal\n */\nexport function getConfig(opts: TimelineCoreOptions) {\n  const {\n    mode,\n    numSeries,\n    isDiscrete,\n    hasMappedNull,\n    rowHeight = 0,\n    colWidth = 0,\n    showValue,\n    mergeValues = false,\n    theme,\n    label,\n    formatValue,\n    alignValue = 'left',\n    getTimeRange,\n    getValueColor,\n    getFieldConfig,\n    hoverMulti,\n  } = opts;\n\n  let qt: Quadtree;\n\n  // Needed for to calculate text positions\n  let boxRectsBySeries: TimelineBoxRect[][];\n\n  const resetBoxRectsBySeries = (count: number) => {\n    boxRectsBySeries = Array(numSeries)\n      .fill(null)\n      .map((v) => Array(count).fill(null));\n  };\n\n  const font = `500 ${Math.round(12 * devicePixelRatio)}px ${theme.typography.fontFamily}`;\n  const hovered: Array<Rect | null> = Array(numSeries).fill(null);\n  let hoveredAtCursor: Rect | null = null;\n\n  const size = [colWidth, Infinity];\n  const gapFactor = 1 - size[0];\n  const maxWidth = (size[1] ?? Infinity) * uPlot.pxRatio;\n\n  const fillPaths: Map<CanvasRenderingContext2D['fillStyle'], Path2D> = new Map();\n  const strokePaths: Map<CanvasRenderingContext2D['strokeStyle'], Path2D> = new Map();\n\n  function drawBoxes(ctx: CanvasRenderingContext2D) {\n    fillPaths.forEach((fillPath, fillStyle) => {\n      ctx.fillStyle = fillStyle;\n      ctx.fill(fillPath);\n    });\n\n    strokePaths.forEach((strokePath, strokeStyle) => {\n      ctx.strokeStyle = strokeStyle;\n      ctx.stroke(strokePath);\n    });\n\n    fillPaths.clear();\n    strokePaths.clear();\n  }\n\n  function putBox(\n    ctx: CanvasRenderingContext2D,\n    rect: uPlot.RectH,\n    xOff: number,\n    yOff: number,\n    left: number,\n    top: number,\n    boxWidth: number,\n    boxHeight: number,\n    strokeWidth: number,\n    seriesIdx: number,\n    valueIdx: number,\n    value: number | null,\n    discrete: boolean\n  ) {\n    // clamp width to allow small boxes to be rendered\n    boxWidth = Math.max(1, boxWidth);\n\n    const valueColor = getValueColor(seriesIdx + 1, value);\n    const fieldConfig = getFieldConfig(seriesIdx);\n    const fillColor = getFillColor(fieldConfig, valueColor);\n\n    boxRectsBySeries[seriesIdx][valueIdx] = {\n      x: round(left - xOff),\n      y: round(top - yOff),\n      w: boxWidth,\n      h: boxHeight,\n      sidx: seriesIdx + 1,\n      didx: valueIdx,\n      // for computing label contrast\n      fillColor,\n    };\n\n    if (discrete) {\n      let fillStyle = fillColor;\n      let fillPath = fillPaths.get(fillStyle);\n\n      if (fillPath == null) {\n        fillPaths.set(fillStyle, (fillPath = new Path2D()));\n      }\n\n      rect(fillPath, left, top, boxWidth, boxHeight);\n\n      if (strokeWidth) {\n        let strokeStyle = valueColor;\n        let strokePath = strokePaths.get(strokeStyle);\n\n        if (strokePath == null) {\n          strokePaths.set(strokeStyle, (strokePath = new Path2D()));\n        }\n\n        rect(\n          strokePath,\n          left + strokeWidth / 2,\n          top + strokeWidth / 2,\n          boxWidth - strokeWidth,\n          boxHeight - strokeWidth\n        );\n      }\n    } else {\n      ctx.beginPath();\n      rect(ctx, left, top, boxWidth, boxHeight);\n      ctx.fillStyle = fillColor;\n      ctx.fill();\n\n      if (strokeWidth) {\n        ctx.beginPath();\n        rect(ctx, left + strokeWidth / 2, top + strokeWidth / 2, boxWidth - strokeWidth, boxHeight - strokeWidth);\n        ctx.strokeStyle = valueColor;\n        ctx.lineWidth = strokeWidth;\n        ctx.stroke();\n      }\n    }\n  }\n\n  const drawPaths: Series.PathBuilder = (u, sidx, idx0, idx1) => {\n    uPlot.orient(\n      u,\n      sidx,\n      (series, dataX, dataY, scaleX, scaleY, valToPosX, valToPosY, xOff, yOff, xDim, yDim, moveTo, lineTo, rect) => {\n        let strokeWidth = round((series.width || 0) * uPlot.pxRatio);\n\n        let discrete = isDiscrete(sidx);\n        let mappedNull = discrete && hasMappedNull(sidx);\n\n        u.ctx.save();\n        rect(u.ctx, u.bbox.left, u.bbox.top, u.bbox.width, u.bbox.height);\n        u.ctx.clip();\n\n        walk(rowHeight, sidx - 1, numSeries, yDim, (iy, y0, height) => {\n          if (mode === TimelineMode.Changes) {\n            for (let ix = 0; ix < dataY.length; ix++) {\n              let yVal = dataY[ix];\n\n              if (yVal != null || mappedNull) {\n                let left = Math.round(valToPosX(dataX[ix], scaleX, xDim, xOff));\n\n                let nextIx = ix;\n                while (\n                  ++nextIx < dataY.length &&\n                  (dataY[nextIx] === undefined || (mergeValues && dataY[nextIx] === yVal))\n                ) {}\n\n                // to now (not to end of chart)\n                let right =\n                  nextIx === dataY.length\n                    ? xOff + xDim + strokeWidth\n                    : Math.round(valToPosX(dataX[nextIx], scaleX, xDim, xOff));\n\n                putBox(\n                  u.ctx,\n                  rect,\n                  xOff,\n                  yOff,\n                  left,\n                  round(yOff + y0),\n                  right - left,\n                  round(height),\n                  strokeWidth,\n                  iy,\n                  ix,\n                  yVal,\n                  discrete\n                );\n\n                ix = nextIx - 1;\n              }\n            }\n          } else if (mode === TimelineMode.Samples) {\n            let colWid = valToPosX(dataX[1], scaleX, xDim, xOff) - valToPosX(dataX[0], scaleX, xDim, xOff);\n            let gapWid = colWid * gapFactor;\n            let barWid = round(min(maxWidth, colWid - gapWid) - strokeWidth);\n            let xShift = barWid / 2;\n            //let xShift = align === 1 ? 0 : align === -1 ? barWid : barWid / 2;\n\n            for (let ix = idx0; ix <= idx1; ix++) {\n              let yVal = dataY[ix];\n\n              if (yVal != null || mappedNull) {\n                // TODO: all xPos can be pre-computed once for all series in aligned set\n                let left = valToPosX(dataX[ix], scaleX, xDim, xOff);\n\n                putBox(\n                  u.ctx,\n                  rect,\n                  xOff,\n                  yOff,\n                  round(left - xShift),\n                  round(yOff + y0),\n                  barWid,\n                  round(height),\n                  strokeWidth,\n                  iy,\n                  ix,\n                  yVal,\n                  discrete\n                );\n              }\n            }\n          }\n        });\n\n        if (discrete) {\n          u.ctx.lineWidth = strokeWidth;\n          drawBoxes(u.ctx);\n        }\n\n        u.ctx.restore();\n      }\n    );\n\n    return null;\n  };\n\n  const drawPoints: Series.Points.Show =\n    formatValue == null || showValue === VisibilityMode.Never\n      ? false\n      : (u, sidx, i0, i1) => {\n          u.ctx.save();\n          u.ctx.rect(u.bbox.left, u.bbox.top, u.bbox.width, u.bbox.height);\n          u.ctx.clip();\n\n          u.ctx.font = font;\n          u.ctx.textAlign = mode === TimelineMode.Changes ? alignValue : 'center';\n          u.ctx.textBaseline = 'middle';\n\n          uPlot.orient(\n            u,\n            sidx,\n            (series, dataX, dataY, scaleX, scaleY, valToPosX, valToPosY, xOff, yOff, xDim, yDim) => {\n              let strokeWidth = round((series.width || 0) * uPlot.pxRatio);\n\n              let discrete = isDiscrete(sidx);\n              let mappedNull = discrete && hasMappedNull(sidx);\n\n              let y = round(valToPosY(ySplits[sidx - 1], scaleY, yDim, yOff));\n\n              for (let ix = 0; ix < dataY.length; ix++) {\n                if (dataY[ix] != null || mappedNull) {\n                  const boxRect = boxRectsBySeries[sidx - 1][ix];\n\n                  if (!boxRect || boxRect.x >= xDim) {\n                    continue;\n                  }\n\n                  let maxChars = Math.floor(boxRect?.w / pxPerChar);\n\n                  if (showValue === VisibilityMode.Auto && maxChars < 2) {\n                    continue;\n                  }\n\n                  let txt = formatValue(sidx, dataY[ix]);\n\n                  // center-aligned\n                  let x = round(boxRect.x + xOff + boxRect.w / 2);\n                  if (mode === TimelineMode.Changes) {\n                    if (alignValue === 'left') {\n                      x = round(boxRect.x + xOff + strokeWidth + textPadding);\n                    } else if (alignValue === 'right') {\n                      x = round(boxRect.x + xOff + boxRect.w - strokeWidth - textPadding);\n                    }\n                  }\n\n                  // TODO: cache by fillColor to avoid setting ctx for label\n                  u.ctx.fillStyle = theme.colors.getContrastText(boxRect.fillColor, 3);\n                  u.ctx.fillText(txt.slice(0, maxChars), x, y);\n                }\n              }\n            }\n          );\n\n          u.ctx.restore();\n\n          return false;\n        };\n\n  const init = (u: uPlot) => {\n    let chars = '';\n    for (let i = 32; i <= 126; i++) {\n      chars += String.fromCharCode(i);\n    }\n    pxPerChar = Math.ceil((u.ctx.measureText(chars).width / chars.length) * uPlot.pxRatio);\n\n    // be a bit more conservtive to prevent overlap\n    pxPerChar += 2.5;\n\n    u.root.querySelectorAll<HTMLDivElement>('.u-cursor-pt').forEach((el) => {\n      el.style.borderRadius = '0';\n    });\n  };\n\n  const drawClear = (u: uPlot) => {\n    qt = qt || new Quadtree(0, 0, u.bbox.width, u.bbox.height);\n\n    qt.clear();\n    resetBoxRectsBySeries(u.data[0].length);\n\n    // force-clear the path cache to cause drawBars() to rebuild new quadtree\n    u.series.forEach((s) => {\n      // @ts-ignore\n      s._paths = null;\n    });\n  };\n\n  function setHovered(cx: number, cy: number, viaSync = false) {\n    hovered.fill(null);\n    hoveredAtCursor = null;\n\n    if (cx < 0) {\n      return;\n    }\n\n    // first gets all items in all quads intersected by a 1px wide by 10k high rect at the x cursor position and 0 y position.\n    // (we use 10k instead of plot area height for simplicity and not having to pass around the uPlot instance)\n    qt.get(cx, 0, uPlot.pxRatio, 1e4, (o) => {\n      // filter only rects that intersect along x dir\n      if (cx >= o.x && cx <= o.x + o.w) {\n        // if also intersect along y dir, set both \"direct hovered\" and \"one-of hovered\"\n        if (cy >= o.y && cy <= o.y + o.h) {\n          hovered[o.sidx] = hoveredAtCursor = o;\n        }\n        // else only set \"one-of hovered\" (no \"direct hovered\") in multi mode or when synced\n        else if (hoverMulti || viaSync) {\n          hovered[o.sidx] = o;\n        }\n      }\n    });\n  }\n\n  const cursor: uPlot.Cursor = {\n    x: mode === TimelineMode.Changes,\n    y: false,\n    dataIdx: (u, seriesIdx) => {\n      if (seriesIdx === 1) {\n        // if quadtree is empty, fill it\n        if (qt.o.length === 0 && qt.q == null) {\n          for (const seriesRects of boxRectsBySeries) {\n            for (const rect of seriesRects) {\n              rect && qt.add(rect);\n            }\n          }\n        }\n\n        let cx = u.cursor.left! * uPlot.pxRatio;\n        let cy = u.cursor.top! * uPlot.pxRatio;\n\n        setHovered(cx, cy, u.cursor.event == null);\n      }\n\n      return hovered[seriesIdx]?.didx;\n    },\n    focus: {\n      prox: 1e3,\n      dist: (u, seriesIdx) => (hoveredAtCursor?.sidx === seriesIdx ? 0 : Infinity),\n    },\n    points: {\n      fill: 'rgba(255,255,255,0.2)',\n      bbox: (u, seriesIdx) => {\n        let hRect = hovered[seriesIdx];\n        let isHovered = hRect != null;\n\n        return {\n          left: isHovered ? hRect!.x / uPlot.pxRatio : -10,\n          top: isHovered ? hRect!.y / uPlot.pxRatio : -10,\n          width: isHovered ? hRect!.w / uPlot.pxRatio : 0,\n          height: isHovered ? hRect!.h / uPlot.pxRatio : 0,\n        };\n      },\n    },\n  };\n\n  const ySplits: number[] = Array(numSeries).fill(0);\n  const yRange: uPlot.Range.MinMax = [0, 1];\n\n  return {\n    cursor,\n\n    xSplits:\n      mode === TimelineMode.Samples\n        ? (u: uPlot, axisIdx: number, scaleMin: number, scaleMax: number, foundIncr: number, foundSpace: number) => {\n            let splits = [];\n\n            let dataIncr = u.data[0][1] - u.data[0][0];\n            let skipFactor = ceil(foundIncr / dataIncr);\n\n            for (let i = 0; i < u.data[0].length; i += skipFactor) {\n              let v = u.data[0][i];\n\n              if (v >= scaleMin && v <= scaleMax) {\n                splits.push(v);\n              }\n            }\n\n            return splits;\n          }\n        : null,\n\n    xRange: (u: uPlot) => {\n      const r = getTimeRange();\n\n      let min = r.from.valueOf();\n      let max = r.to.valueOf();\n\n      if (mode === TimelineMode.Samples) {\n        let colWid = u.data[0][1] - u.data[0][0];\n        let scalePad = colWid / 2;\n\n        if (min <= u.data[0][0]) {\n          min = u.data[0][0] - scalePad;\n        }\n\n        let lastIdx = u.data[0].length - 1;\n\n        if (max >= u.data[0][lastIdx]) {\n          max = u.data[0][lastIdx] + scalePad;\n        }\n      }\n\n      const result: uPlot.Range.MinMax = [min, max];\n      return result;\n    },\n\n    ySplits: (u: uPlot) => {\n      walk(rowHeight, null, numSeries, u.bbox.height, (iy, y0, hgt) => {\n        // vertical midpoints of each series' timeline (stored relative to .u-over)\n        let yMid = round(y0 + hgt / 2);\n        ySplits[iy] = u.posToVal(yMid / uPlot.pxRatio, FIXED_UNIT);\n      });\n\n      return ySplits;\n    },\n\n    yValues: (u: uPlot, splits: number[]) => splits.map((v, i) => label(i + 1)),\n    yRange,\n\n    // pathbuilders\n    drawPaths,\n    drawPoints,\n\n    // hooks\n    init,\n    drawClear,\n  };\n}\n\nfunction getFillColor(fieldConfig: { fillOpacity?: number; lineWidth?: number }, color: string) {\n  // if #rgba with pre-existing alpha. ignore fieldConfig.fillOpacity\n  // e.g. thresholds with opacity\n  if (color[0] === '#' && color.length === 9) {\n    return color;\n  }\n\n  const opacityPercent = (fieldConfig.fillOpacity ?? 100) / 100;\n  return alpha(color, opacityPercent);\n}\n","import {\n  DataFrame,\n  FALLBACK_COLOR,\n  Field,\n  FieldColorModeId,\n  FieldConfig,\n  FieldType,\n  formattedValueToString,\n  getFieldDisplayName,\n  getValueFormat,\n  GrafanaTheme2,\n  getActiveThreshold,\n  Threshold,\n  getFieldConfigWithMinMax,\n  ThresholdsMode,\n  TimeRange,\n  cacheFieldDisplayNames,\n  outerJoinDataFrames,\n  ValueMapping,\n  ThresholdsConfig,\n} from '@grafana/data';\nimport { maybeSortFrame, NULL_RETAIN } from '@grafana/data/src/transformations/transformers/joinDataFrames';\nimport { applyNullInsertThreshold } from '@grafana/data/src/transformations/transformers/nulls/nullInsertThreshold';\nimport { nullToValue } from '@grafana/data/src/transformations/transformers/nulls/nullToValue';\nimport {\n  VizLegendOptions,\n  AxisPlacement,\n  ScaleDirection,\n  ScaleOrientation,\n  VisibilityMode,\n  TimelineValueAlignment,\n  HideableFieldConfig,\n  MappingType,\n} from '@grafana/schema';\nimport { FIXED_UNIT, UPlotConfigBuilder, UPlotConfigPrepFn, VizLegendItem } from '@grafana/ui';\nimport { preparePlotData2, getStackingGroups } from '@grafana/ui/src/components/uPlot/utils';\n\nimport { getConfig, TimelineCoreOptions } from './timeline';\n\n/**\n * @internal\n */\ninterface UPlotConfigOptions {\n  frame: DataFrame;\n  theme: GrafanaTheme2;\n  mode: TimelineMode;\n  rowHeight?: number;\n  colWidth?: number;\n  showValue: VisibilityMode;\n  alignValue?: TimelineValueAlignment;\n  mergeValues?: boolean;\n  getValueColor: (frameIdx: number, fieldIdx: number, value: unknown) => string;\n  hoverMulti: boolean;\n}\n\n/**\n * @internal\n */\ninterface PanelFieldConfig extends HideableFieldConfig {\n  fillOpacity?: number;\n  lineWidth?: number;\n}\n\nexport enum TimelineMode {\n  Changes = 'changes',\n  Samples = 'samples',\n}\n\nconst defaultConfig: PanelFieldConfig = {\n  lineWidth: 0,\n  fillOpacity: 80,\n};\n\nexport const preparePlotConfigBuilder: UPlotConfigPrepFn<UPlotConfigOptions> = ({\n  frame,\n  theme,\n  timeZones,\n  getTimeRange,\n  mode,\n  rowHeight,\n  colWidth,\n  showValue,\n  alignValue,\n  mergeValues,\n  getValueColor,\n  hoverMulti,\n}) => {\n  const builder = new UPlotConfigBuilder(timeZones[0]);\n\n  const xScaleKey = 'x';\n\n  const isDiscrete = (field: Field) => {\n    const mode = field.config?.color?.mode;\n    return !(mode && field.display && mode.startsWith('continuous-'));\n  };\n\n  const hasMappedNull = (field: Field) => {\n    return (\n      field.config.mappings?.some(\n        (mapping) => mapping.type === MappingType.SpecialValue && mapping.options.match === 'null'\n      ) || false\n    );\n  };\n\n  const getValueColorFn = (seriesIdx: number, value: unknown) => {\n    const field = frame.fields[seriesIdx];\n\n    if (\n      field.state?.origin?.fieldIndex !== undefined &&\n      field.state?.origin?.frameIndex !== undefined &&\n      getValueColor\n    ) {\n      return getValueColor(field.state?.origin?.frameIndex, field.state?.origin?.fieldIndex, value);\n    }\n\n    return FALLBACK_COLOR;\n  };\n\n  const opts: TimelineCoreOptions = {\n    mode: mode!,\n    numSeries: frame.fields.length - 1,\n    isDiscrete: (seriesIdx) => isDiscrete(frame.fields[seriesIdx]),\n    hasMappedNull: (seriesIdx) => hasMappedNull(frame.fields[seriesIdx]),\n    mergeValues,\n    rowHeight: rowHeight,\n    colWidth: colWidth,\n    showValue: showValue!,\n    alignValue,\n    theme,\n    label: (seriesIdx) => getFieldDisplayName(frame.fields[seriesIdx], frame),\n    getFieldConfig: (seriesIdx) => frame.fields[seriesIdx].config.custom,\n    getValueColor: getValueColorFn,\n    getTimeRange,\n    // hardcoded formatter for state values\n    formatValue: (seriesIdx, value) => formattedValueToString(frame.fields[seriesIdx].display!(value)),\n    hoverMulti,\n  };\n\n  const coreConfig = getConfig(opts);\n\n  builder.addHook('init', coreConfig.init);\n  builder.addHook('drawClear', coreConfig.drawClear);\n\n  builder.setPrepData((frames) => preparePlotData2(frames[0], getStackingGroups(frames[0])));\n\n  builder.setCursor(coreConfig.cursor);\n\n  builder.addScale({\n    scaleKey: xScaleKey,\n    isTime: true,\n    orientation: ScaleOrientation.Horizontal,\n    direction: ScaleDirection.Right,\n    range: coreConfig.xRange,\n  });\n\n  builder.addScale({\n    scaleKey: FIXED_UNIT, // y\n    isTime: false,\n    orientation: ScaleOrientation.Vertical,\n    direction: ScaleDirection.Up,\n    range: coreConfig.yRange,\n  });\n\n  builder.addAxis({\n    scaleKey: xScaleKey,\n    isTime: true,\n    splits: coreConfig.xSplits!,\n    placement: AxisPlacement.Bottom,\n    timeZone: timeZones[0],\n    theme,\n    grid: { show: true },\n  });\n\n  builder.addAxis({\n    scaleKey: FIXED_UNIT, // y\n    isTime: false,\n    placement: AxisPlacement.Left,\n    splits: coreConfig.ySplits,\n    values: coreConfig.yValues,\n    grid: { show: false },\n    ticks: { show: false },\n    gap: 16,\n    theme,\n  });\n\n  let seriesIndex = 0;\n\n  for (let i = 0; i < frame.fields.length; i++) {\n    if (i === 0) {\n      continue;\n    }\n\n    const field = frame.fields[i];\n    const config: FieldConfig<PanelFieldConfig> = field.config;\n    const customConfig: PanelFieldConfig = {\n      ...defaultConfig,\n      ...config.custom,\n    };\n\n    field.state!.seriesIndex = seriesIndex++;\n\n    // const scaleKey = config.unit || FIXED_UNIT;\n    // const colorMode = getFieldColorModeForField(field);\n\n    builder.addSeries({\n      scaleKey: FIXED_UNIT,\n      pathBuilder: coreConfig.drawPaths,\n      pointsBuilder: coreConfig.drawPoints,\n      //colorMode,\n      lineWidth: customConfig.lineWidth,\n      fillOpacity: customConfig.fillOpacity,\n      theme,\n      show: !customConfig.hideFrom?.viz,\n      thresholds: config.thresholds,\n      // The following properties are not used in the uPlot config, but are utilized as transport for legend config\n      dataFrameFieldIndex: field.state?.origin,\n    });\n  }\n\n  return builder;\n};\n\nfunction getSpanNulls(field: Field) {\n  let spanNulls = field.config.custom?.spanNulls;\n\n  // magic value for join() to leave nulls alone instead of expanding null ranges\n  // should be set to -1 when spanNulls = null|undefined|false|0, which is \"retain nulls, without expanding\"\n  // Infinity is not optimal here since it causes spanNulls to be more expensive than simply removing all nulls unconditionally\n  return !spanNulls ? -1 : spanNulls === true ? Infinity : spanNulls;\n}\n\n/**\n * Merge values by the threshold\n */\nexport function mergeThresholdValues(field: Field, theme: GrafanaTheme2): Field | undefined {\n  const thresholds = field.config.thresholds;\n  if (field.type !== FieldType.number || !thresholds || !thresholds.steps.length) {\n    return undefined;\n  }\n\n  const items = getThresholdItems(field.config, theme);\n  if (items.length !== thresholds.steps.length) {\n    return undefined; // should not happen\n  }\n\n  const thresholdToText = new Map<Threshold, string>();\n  const textToColor = new Map<string, string>();\n  for (let i = 0; i < items.length; i++) {\n    thresholdToText.set(thresholds.steps[i], items[i].label);\n    textToColor.set(items[i].label, items[i].color!);\n  }\n\n  let input = field.values;\n  const vals = new Array<String | undefined>(field.values.length);\n  if (thresholds.mode === ThresholdsMode.Percentage) {\n    const { min, max } = getFieldConfigWithMinMax(field);\n    const delta = max! - min!;\n    input = input.map((v) => {\n      if (v == null) {\n        return v;\n      }\n      return ((v - min!) / delta) * 100;\n    });\n  }\n\n  for (let i = 0; i < vals.length; i++) {\n    const v = input[i];\n    if (v == null) {\n      vals[i] = v;\n    } else {\n      vals[i] = thresholdToText.get(getActiveThreshold(v, thresholds.steps));\n    }\n  }\n\n  return {\n    ...field,\n    config: {\n      ...field.config,\n      custom: {\n        ...field.config.custom,\n        spanNulls: getSpanNulls(field),\n      },\n    },\n    type: FieldType.string,\n    values: vals,\n    display: (value) => ({\n      text: String(value),\n      color: textToColor.get(String(value)),\n      numeric: NaN,\n    }),\n  };\n}\n\n// This will return a set of frames with only graphable values included\nexport function prepareTimelineFields(\n  series: DataFrame[] | undefined,\n  mergeValues: boolean,\n  timeRange: TimeRange,\n  theme: GrafanaTheme2\n): { frames?: DataFrame[]; warn?: string } {\n  if (!series?.length) {\n    return { warn: 'No data in response' };\n  }\n\n  cacheFieldDisplayNames(series);\n\n  let hasTimeseries = false;\n  const frames: DataFrame[] = [];\n\n  for (let frame of series) {\n    let startFieldIdx = -1;\n    let endFieldIdx = -1;\n\n    for (let i = 0; i < frame.fields.length; i++) {\n      let f = frame.fields[i];\n\n      if (f.type === FieldType.time) {\n        if (startFieldIdx === -1) {\n          startFieldIdx = i;\n        } else if (endFieldIdx === -1) {\n          endFieldIdx = i;\n          break;\n        }\n      }\n    }\n\n    let isTimeseries = startFieldIdx !== -1;\n    let changed = false;\n    frame = maybeSortFrame(frame, startFieldIdx);\n\n    // if we have a second time field, assume it is state end timestamps\n    // and insert nulls into the data at the end timestamps\n    if (endFieldIdx !== -1) {\n      let startFrame: DataFrame = {\n        ...frame,\n        fields: frame.fields.filter((f, i) => i !== endFieldIdx),\n      };\n\n      let endFrame: DataFrame = {\n        length: frame.length,\n        fields: [frame.fields[endFieldIdx]],\n      };\n\n      frame = outerJoinDataFrames({\n        frames: [startFrame, endFrame],\n        keepDisplayNames: true,\n        nullMode: () => NULL_RETAIN,\n      })!;\n\n      frame.fields.forEach((f, i) => {\n        if (i > 0) {\n          let vals = f.values;\n          for (let i = 0; i < vals.length; i++) {\n            if (vals[i] == null) {\n              vals[i] = null;\n            }\n          }\n        }\n      });\n\n      changed = true;\n    }\n\n    let nulledFrame = applyNullInsertThreshold({\n      frame,\n      refFieldPseudoMin: timeRange.from.valueOf(),\n      refFieldPseudoMax: timeRange.to.valueOf(),\n    });\n\n    if (nulledFrame !== frame) {\n      changed = true;\n    }\n\n    frame = nullToValue(nulledFrame);\n\n    const fields: Field[] = [];\n    for (let field of frame.fields) {\n      if (field.config.custom?.hideFrom?.viz) {\n        continue;\n      }\n      switch (field.type) {\n        case FieldType.time:\n          isTimeseries = true;\n          hasTimeseries = true;\n          fields.push(field);\n          break;\n        case FieldType.enum:\n        case FieldType.number:\n          if (mergeValues && field.config.color?.mode === FieldColorModeId.Thresholds) {\n            const f = mergeThresholdValues(field, theme);\n            if (f) {\n              fields.push(f);\n              changed = true;\n              continue;\n            }\n          }\n\n        case FieldType.boolean:\n        case FieldType.string:\n          field = {\n            ...field,\n            config: {\n              ...field.config,\n              custom: {\n                ...field.config.custom,\n                spanNulls: getSpanNulls(field),\n              },\n            },\n          };\n          changed = true;\n          fields.push(field);\n          break;\n        default:\n          changed = true;\n      }\n    }\n    if (isTimeseries && fields.length > 1) {\n      hasTimeseries = true;\n      if (changed) {\n        frames.push({\n          ...frame,\n          fields,\n        });\n      } else {\n        frames.push(frame);\n      }\n    }\n  }\n\n  if (!hasTimeseries) {\n    return { warn: 'Data does not have a time field' };\n  }\n  if (!frames.length) {\n    return { warn: 'No graphable fields' };\n  }\n\n  return { frames };\n}\n\nexport function makeFramePerSeries(frames: DataFrame[]) {\n  const outFrames: DataFrame[] = [];\n\n  for (let frame of frames) {\n    const timeFields = frame.fields.filter((field) => field.type === FieldType.time);\n\n    if (timeFields.length > 0) {\n      for (let field of frame.fields) {\n        if (field.type !== FieldType.time) {\n          outFrames.push({ fields: [...timeFields, field], length: frame.length });\n        }\n      }\n    }\n  }\n\n  return outFrames;\n}\n\nexport function getThresholdItems(\n  fieldConfig: FieldConfig,\n  theme: GrafanaTheme2,\n  thresholdItems?: ThresholdsConfig\n): VizLegendItem[] {\n  const items: VizLegendItem[] = [];\n  const thresholds = thresholdItems ? thresholdItems : fieldConfig.thresholds;\n  if (!thresholds || !thresholds.steps.length) {\n    return items;\n  }\n\n  const steps = thresholds.steps;\n  const getDisplay = getValueFormat(\n    thresholds.mode === ThresholdsMode.Percentage ? 'percent' : (fieldConfig.unit ?? '')\n  );\n\n  // `undefined` value for decimals will use `auto`\n  const format = (value: number) => formattedValueToString(getDisplay(value, fieldConfig.decimals ?? undefined));\n\n  for (let i = 0; i < steps.length; i++) {\n    let step = steps[i];\n    let value = step.value;\n    let pre = '';\n    let suf = '';\n\n    if (value === -Infinity && i < steps.length - 1) {\n      value = steps[i + 1].value;\n      pre = '< ';\n    } else {\n      suf = '+';\n    }\n\n    items.push({\n      label: `${pre}${format(value)}${suf}`,\n      color: theme.visualization.getColorByName(step.color),\n      yAxis: 1,\n    });\n  }\n\n  return items;\n}\n\nexport function getValueMappingItems(mappings: ValueMapping[], theme: GrafanaTheme2): VizLegendItem[] {\n  const items: VizLegendItem[] = [];\n  if (!mappings) {\n    return items;\n  }\n\n  for (let mapping of mappings) {\n    const { options, type } = mapping;\n\n    if (type === MappingType.ValueToText) {\n      for (let [label, value] of Object.entries(options)) {\n        const color = value.color;\n        items.push({\n          label: label,\n          color: theme.visualization.getColorByName(color ?? FALLBACK_COLOR),\n          yAxis: 1,\n        });\n      }\n    }\n\n    if (type === MappingType.RangeToText) {\n      const { from, result, to } = options;\n      const { text, color } = result;\n      const label = text ? `[${from} - ${to}] ${text}` : `[${from} - ${to}]`;\n\n      items.push({\n        label: label,\n        color: theme.visualization.getColorByName(color ?? FALLBACK_COLOR),\n        yAxis: 1,\n      });\n    }\n\n    if (type === MappingType.RegexToText) {\n      const { pattern, result } = options;\n      const { text, color } = result;\n      const label = `${text || pattern}`;\n\n      items.push({\n        label: label,\n        color: theme.visualization.getColorByName(color ?? FALLBACK_COLOR),\n        yAxis: 1,\n      });\n    }\n\n    if (type === MappingType.SpecialValue) {\n      const { match, result } = options;\n      const { text, color } = result;\n      const label = `${text || match}`;\n\n      items.push({\n        label: label,\n        color: theme.visualization.getColorByName(color ?? FALLBACK_COLOR),\n        yAxis: 1,\n      });\n    }\n  }\n\n  return items;\n}\n\nexport function prepareTimelineLegendItems(\n  frames: DataFrame[] | undefined,\n  options: VizLegendOptions,\n  theme: GrafanaTheme2\n): VizLegendItem[] | undefined {\n  if (!frames || options.showLegend === false) {\n    return undefined;\n  }\n\n  return getFieldLegendItem(allNonTimeFields(frames), theme);\n}\n\nexport function getFieldLegendItem(fields: Field[], theme: GrafanaTheme2): VizLegendItem[] | undefined {\n  if (!fields.length) {\n    return undefined;\n  }\n\n  const items: VizLegendItem[] = [];\n  const fieldConfig = fields[0].config;\n  const colorMode = fieldConfig.color?.mode ?? FieldColorModeId.Fixed;\n  const thresholds = fieldConfig.thresholds;\n\n  // If thresholds are enabled show each step in the legend\n  // This ignores the hide from legend since the range is valid\n  if (colorMode === FieldColorModeId.Thresholds && thresholds?.steps && thresholds.steps.length > 1) {\n    return getThresholdItems(fieldConfig, theme);\n  }\n\n  // If thresholds are enabled show each step in the legend\n  if (colorMode.startsWith('continuous')) {\n    return undefined; // eventually a color bar\n  }\n\n  const stateColors: Map<string, string | undefined> = new Map();\n\n  fields.forEach((field) => {\n    if (!field.config.custom?.hideFrom?.legend) {\n      field.values.forEach((v) => {\n        let state = field.display!(v);\n        if (state.color) {\n          stateColors.set(state.text, state.color!);\n        }\n      });\n    }\n  });\n\n  stateColors.forEach((color, label) => {\n    if (label.length > 0) {\n      items.push({\n        label: label!,\n        color: theme.visualization.getColorByName(color ?? FALLBACK_COLOR),\n        yAxis: 1,\n      });\n    }\n  });\n\n  return items;\n}\n\nfunction allNonTimeFields(frames: DataFrame[]): Field[] {\n  const fields: Field[] = [];\n  for (const frame of frames) {\n    for (const field of frame.fields) {\n      if (field.type !== FieldType.time) {\n        fields.push(field);\n      }\n    }\n  }\n  return fields;\n}\n\nexport function findNextStateIndex(field: Field, datapointIdx: number) {\n  let end;\n  let rightPointer = datapointIdx + 1;\n\n  if (rightPointer >= field.values.length) {\n    return null;\n  }\n\n  const startValue = field.values[datapointIdx];\n\n  while (end === undefined) {\n    if (rightPointer >= field.values.length) {\n      return null;\n    }\n    const rightValue = field.values[rightPointer];\n\n    if (rightValue === undefined || rightValue === startValue) {\n      rightPointer++;\n    } else {\n      end = rightPointer;\n    }\n  }\n\n  return end;\n}\n\n/**\n * Returns the precise duration of a time range passed in milliseconds.\n * This function calculates with 30 days month and 365 days year.\n * adapted from https://gist.github.com/remino/1563878\n * @param milliSeconds The duration in milliseconds\n * @returns A formated string of the duration\n */\nexport function fmtDuration(milliSeconds: number): string {\n  if (milliSeconds < 0 || Number.isNaN(milliSeconds)) {\n    return '';\n  }\n\n  let yr: number, mo: number, wk: number, d: number, h: number, m: number, s: number, ms: number;\n\n  s = Math.floor(milliSeconds / 1000);\n  m = Math.floor(s / 60);\n  s = s % 60;\n  h = Math.floor(m / 60);\n  m = m % 60;\n  d = Math.floor(h / 24);\n  h = h % 24;\n\n  yr = Math.floor(d / 365);\n  if (yr > 0) {\n    d = d % 365;\n  }\n\n  mo = Math.floor(d / 30);\n  if (mo > 0) {\n    d = d % 30;\n  }\n\n  wk = Math.floor(d / 7);\n\n  if (wk > 0) {\n    d = d % 7;\n  }\n\n  ms = Math.round((milliSeconds % 1000) * 1000) / 1000;\n\n  return (\n    yr > 0\n      ? yr + 'y ' + (mo > 0 ? mo + 'mo ' : '') + (wk > 0 ? wk + 'w ' : '') + (d > 0 ? d + 'd ' : '')\n      : mo > 0\n        ? mo + 'mo ' + (wk > 0 ? wk + 'w ' : '') + (d > 0 ? d + 'd ' : '')\n        : wk > 0\n          ? wk + 'w ' + (d > 0 ? d + 'd ' : '')\n          : d > 0\n            ? d + 'd ' + (h > 0 ? h + 'h ' : '')\n            : h > 0\n              ? h + 'h ' + (m > 0 ? m + 'm ' : '')\n              : m > 0\n                ? m + 'm ' + (s > 0 ? s + 's ' : '')\n                : s > 0\n                  ? s + 's ' + (ms > 0 ? ms + 'ms ' : '')\n                  : ms > 0\n                    ? ms + 'ms '\n                    : '0'\n  ).trim();\n}\n","import { roundDecimals } from '@grafana/data';\n\nexport const SPACE_BETWEEN = 1;\nexport const SPACE_AROUND = 2;\nexport const SPACE_EVENLY = 3;\n\nconst coord = (i: number, offs: number, iwid: number, gap: number) => roundDecimals(offs + i * (iwid + gap), 6);\n\nexport type Each = (idx: number, offPct: number, dimPct: number) => void;\n\n/**\n * @internal\n */\nexport function distribute(numItems: number, sizeFactor: number, justify: number, onlyIdx: number | null, each: Each) {\n  let space = 1 - sizeFactor;\n\n  /* eslint-disable no-multi-spaces */\n  // prettier-ignore\n  let gap = (\n    justify === SPACE_BETWEEN ? space / (numItems - 1) :\n    justify === SPACE_AROUND  ? space / (numItems  )   :\n    justify === SPACE_EVENLY  ? space / (numItems + 1) : 0\n  );\n\n  if (isNaN(gap) || gap === Infinity) {\n    gap = 0;\n  }\n\n  // prettier-ignore\n  let offs = (\n    justify === SPACE_BETWEEN ? 0       :\n    justify === SPACE_AROUND  ? gap / 2 :\n    justify === SPACE_EVENLY  ? gap     : 0\n  );\n  /* eslint-enable */\n\n  let iwid = sizeFactor / numItems;\n  let _iwid = roundDecimals(iwid, 6);\n\n  if (onlyIdx == null) {\n    for (let i = 0; i < numItems; i++) {\n      each(i, coord(i, offs, iwid, gap), _iwid);\n    }\n  } else {\n    each(onlyIdx, coord(onlyIdx, offs, iwid, gap), _iwid);\n  }\n}\n","const MAX_OBJECTS = 10;\nconst MAX_LEVELS = 4;\n\nexport type Quads = [Quadtree, Quadtree, Quadtree, Quadtree];\nexport type Rect = { x: number; y: number; w: number; h: number; [_: string]: any };\n\n/**\n * @internal\n */\nexport function pointWithin(px: number, py: number, rlft: number, rtop: number, rrgt: number, rbtm: number) {\n  return px >= rlft && px <= rrgt && py >= rtop && py <= rbtm;\n}\n\n/**\n * @internal\n */\nexport function findRects(qt: Quadtree, sidx?: number, didx?: number) {\n  let rects: Rect[] = [];\n\n  if (qt.o.length) {\n    rects.push(...qt.o.filter((rect) => (sidx == null || rect.sidx === sidx) && (didx == null || rect.didx === didx)));\n  }\n\n  if (qt.q) {\n    for (let i = 0; i < qt.q.length; i++) {\n      rects.push(...findRects(qt.q[i], sidx, didx));\n    }\n  }\n\n  return rects;\n}\n\n/**\n * @internal\n *\n * Determines if r2 is intersected by r1.\n */\nexport function intersects(r1: Rect, r2: Rect) {\n  return r1.x <= r2.x + r2.w && r1.x + r1.w >= r2.x && r1.y + r1.h >= r2.y && r1.y <= r2.y + r2.h;\n}\n\n/**\n * @internal\n */\nexport class Quadtree {\n  o: Rect[];\n  q: Quads | null;\n\n  constructor(\n    public x: number,\n    public y: number,\n    public w: number,\n    public h: number,\n    public l = 0\n  ) {\n    this.o = [];\n    this.q = null;\n  }\n\n  split() {\n    let t = this,\n      x = t.x,\n      y = t.y,\n      w = t.w / 2,\n      h = t.h / 2,\n      l = t.l + 1;\n\n    t.q = [\n      // top right\n      new Quadtree(x + w, y, w, h, l),\n      // top left\n      new Quadtree(x, y, w, h, l),\n      // bottom left\n      new Quadtree(x, y + h, w, h, l),\n      // bottom right\n      new Quadtree(x + w, y + h, w, h, l),\n    ];\n  }\n\n  // invokes callback with index of each overlapping quad\n  quads(x: number, y: number, w: number, h: number, cb: (q: Quadtree) => void) {\n    let t = this,\n      q = t.q!,\n      hzMid = t.x + t.w / 2,\n      vtMid = t.y + t.h / 2,\n      startIsNorth = y < vtMid,\n      startIsWest = x < hzMid,\n      endIsEast = x + w > hzMid,\n      endIsSouth = y + h > vtMid;\n\n    // top-right quad\n    startIsNorth && endIsEast && cb(q[0]);\n    // top-left quad\n    startIsWest && startIsNorth && cb(q[1]);\n    // bottom-left quad\n    startIsWest && endIsSouth && cb(q[2]);\n    // bottom-right quad\n    endIsEast && endIsSouth && cb(q[3]);\n  }\n\n  add(o: Rect) {\n    let t = this;\n\n    if (t.q != null) {\n      t.quads(o.x, o.y, o.w, o.h, (q) => {\n        q.add(o);\n      });\n    } else {\n      let os = t.o;\n\n      os.push(o);\n\n      if (os.length > MAX_OBJECTS && t.l < MAX_LEVELS) {\n        t.split();\n\n        for (let i = 0; i < os.length; i++) {\n          let oi = os[i];\n\n          t.quads(oi.x, oi.y, oi.w, oi.h, (q) => {\n            q.add(oi);\n          });\n        }\n\n        t.o.length = 0;\n      }\n    }\n  }\n\n  get(x: number, y: number, w: number, h: number, cb: (o: Rect) => void) {\n    let t = this;\n    let os = t.o;\n\n    for (let i = 0; i < os.length; i++) {\n      cb(os[i]);\n    }\n\n    if (t.q != null) {\n      t.quads(x, y, w, h, (q) => {\n        q.get(x, y, w, h, cb);\n      });\n    }\n  }\n\n  clear() {\n    this.o.length = 0;\n    this.q = null;\n  }\n}\n"],"names":["round","min","ceil","textPadding","pxPerChar","laneDistr","walk","rowHeight","yIdx","count","dim","draw","distribute","i","offPct","dimPct","laneOffPx","laneWidPx","getConfig","opts","mode","numSeries","isDiscrete","hasMappedNull","colWidth","showValue","mergeValues","theme","label","formatValue","alignValue","getTimeRange","getValueColor","getFieldConfig","hoverMulti","qt","boxRectsBySeries","resetBoxRectsBySeries","v","font","hovered","hoveredAtCursor","size","gapFactor","maxWidth","fillPaths","strokePaths","drawBoxes","ctx","fillPath","fillStyle","strokePath","strokeStyle","putBox","rect","xOff","yOff","left","top","boxWidth","boxHeight","strokeWidth","seriesIdx","valueIdx","value","discrete","valueColor","fieldConfig","fillColor","getFillColor","drawPaths","u","sidx","idx0","idx1","series","dataX","dataY","scaleX","scaleY","valToPosX","valToPosY","xDim","yDim","moveTo","lineTo","mappedNull","iy","y0","height","TimelineMode","ix","yVal","nextIx","right","colWid","gapWid","barWid","xShift","drawPoints","i0","i1","y","ySplits","boxRect","maxChars","txt","x","init","chars","el","drawClear","s","setHovered","cx","cy","viaSync","o","cursor","seriesRects","hRect","isHovered","yRange","axisIdx","scaleMin","scaleMax","foundIncr","foundSpace","splits","dataIncr","skipFactor","r","max","scalePad","lastIdx","hgt","yMid","color","opacityPercent","defaultConfig","preparePlotConfigBuilder","frame","timeZones","builder","UPlotConfigBuilder","xScaleKey","field","mapping","getValueColorFn","coreConfig","frames","seriesIndex","config","customConfig","getSpanNulls","spanNulls","mergeThresholdValues","thresholds","items","getThresholdItems","thresholdToText","textToColor","input","vals","delta","prepareTimelineFields","timeRange","hasTimeseries","startFieldIdx","endFieldIdx","isTimeseries","changed","startFrame","f","endFrame","nulledFrame","nullToValue","fields","makeFramePerSeries","outFrames","timeFields","thresholdItems","steps","getDisplay","format","step","pre","suf","getValueMappingItems","mappings","options","type","from","result","to","text","pattern","match","prepareTimelineLegendItems","getFieldLegendItem","allNonTimeFields","colorMode","stateColors","state","findNextStateIndex","datapointIdx","end","rightPointer","startValue","rightValue","fmtDuration","milliSeconds","yr","mo","wk","d","h","m","ms","SPACE_BETWEEN","SPACE_AROUND","SPACE_EVENLY","coord","offs","iwid","gap","numItems","sizeFactor","justify","onlyIdx","each","space","_iwid","MAX_OBJECTS","MAX_LEVELS","pointWithin","px","py","rlft","rtop","rrgt","rbtm","findRects","didx","rects","intersects","r1","r2","Quadtree","w","l","t","cb","q","hzMid","vtMid","startIsNorth","startIsWest","endIsEast","endIsSouth","os","oi"],"sourceRoot":""}