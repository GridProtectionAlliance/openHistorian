{"version":3,"file":"8078.a4260b06f1454becf5c9.js","mappings":"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","sources":["webpack://grafana/./packages/grafana-data/src/field/fieldComparers.ts","webpack://grafana/./packages/grafana-data/src/transformations/matchers/compareValues.ts","webpack://grafana/./packages/grafana-data/src/transformations/matchers/fieldTypeMatcher.ts","webpack://grafana/./packages/grafana-data/src/transformations/matchers/fieldValueMatcher.ts","webpack://grafana/./packages/grafana-data/src/transformations/matchers/ids.ts","webpack://grafana/./packages/grafana-data/src/transformations/matchers/refIdMatcher.ts","webpack://grafana/./packages/grafana-data/src/transformations/matchers/simpleFieldMatcher.ts","webpack://grafana/./packages/grafana-data/src/transformations/matchers/valueMatchers/equalMatchers.ts","webpack://grafana/./packages/grafana-data/src/transformations/matchers/valueMatchers/nullMatchers.ts","webpack://grafana/./packages/grafana-data/src/transformations/matchers/valueMatchers/numericMatchers.ts","webpack://grafana/./packages/grafana-data/src/transformations/matchers/valueMatchers/rangeMatchers.ts","webpack://grafana/./packages/grafana-data/src/transformations/matchers/valueMatchers/regexMatchers.ts","webpack://grafana/./packages/grafana-data/src/transformations/matchers/valueMatchers/substringMatchers.ts","webpack://grafana/./packages/grafana-data/src/transformations/transformers/ids.ts","webpack://grafana/./packages/grafana-data/src/utils/legend.ts","webpack://grafana/./packages/grafana-runtime/src/utils/toDataQueryError.ts","webpack://grafana/./public/app/features/live/centrifuge/LiveDataStream.ts","webpack://grafana/./public/app/features/live/centrifuge/channel.ts","webpack://grafana/./public/app/features/live/centrifuge/service.ts","webpack://grafana/./public/app/features/live/centrifuge/transferHandlers.ts"],"sourcesContent":["import { isNumber } from 'lodash';\n\nimport { isDateTimeInput, dateTime } from '../datetime/moment_wrapper';\nimport { Field, FieldType } from '../types/dataFrame';\n\ntype IndexComparer = (a: number, b: number) => number;\n\nexport const fieldIndexComparer = (field: Field, reverse = false): IndexComparer => {\n  const values = field.values;\n\n  switch (field.type) {\n    case FieldType.number:\n      return numericIndexComparer(values, reverse);\n    case FieldType.string:\n      return stringIndexComparer(values, reverse);\n    case FieldType.boolean:\n      return booleanIndexComparer(values, reverse);\n    case FieldType.time:\n      if (typeof field.values[0] === 'number') {\n        return timestampIndexComparer(values, reverse);\n      }\n      return timeIndexComparer(values, reverse);\n    default:\n      return naturalIndexComparer(reverse);\n  }\n};\n\nconst timeComparer = (a: unknown, b: unknown): number => {\n  if (!a || !b) {\n    return falsyComparer(a, b);\n  }\n\n  if (isNumber(a) && isNumber(b)) {\n    return numericComparer(a, b);\n  }\n\n  if (isDateTimeInput(a) && isDateTimeInput(b)) {\n    if (dateTime(a).isBefore(b)) {\n      return -1;\n    }\n\n    if (dateTime(b).isBefore(a)) {\n      return 1;\n    }\n  }\n\n  return 0;\n};\n\nconst numericComparer = (a: number, b: number): number => {\n  return a - b;\n};\n\nconst stringComparer = (a: string, b: string): number => {\n  if (!a || !b) {\n    return falsyComparer(a, b);\n  }\n  return a.localeCompare(b);\n};\n\nconst booleanComparer = (a: boolean, b: boolean): number => {\n  return falsyComparer(a, b);\n};\n\nconst falsyComparer = (a: unknown, b: unknown): number => {\n  if (!a && b) {\n    return 1;\n  }\n\n  if (a && !b) {\n    return -1;\n  }\n\n  return 0;\n};\n\nconst timestampIndexComparer = (values: number[], reverse: boolean): IndexComparer => {\n  let mult = reverse ? -1 : 1;\n  return (a: number, b: number): number => mult * (values[a] - values[b]);\n};\n\nconst timeIndexComparer = (values: unknown[], reverse: boolean): IndexComparer => {\n  return (a: number, b: number): number => {\n    const vA = values[a];\n    const vB = values[b];\n    return reverse ? timeComparer(vB, vA) : timeComparer(vA, vB);\n  };\n};\n\nconst booleanIndexComparer = (values: boolean[], reverse: boolean): IndexComparer => {\n  return (a: number, b: number): number => {\n    const vA = values[a];\n    const vB = values[b];\n    return reverse ? booleanComparer(vB, vA) : booleanComparer(vA, vB);\n  };\n};\n\nconst numericIndexComparer = (values: number[], reverse: boolean): IndexComparer => {\n  return (a: number, b: number): number => {\n    const vA = values[a];\n    const vB = values[b];\n    return reverse ? numericComparer(vB, vA) : numericComparer(vA, vB);\n  };\n};\n\nconst stringIndexComparer = (values: string[], reverse: boolean): IndexComparer => {\n  return (a: number, b: number): number => {\n    const vA = values[a];\n    const vB = values[b];\n    return reverse ? stringComparer(vB, vA) : stringComparer(vA, vB);\n  };\n};\n\nconst naturalIndexComparer = (reverse: boolean): IndexComparer => {\n  return (a: number, b: number): number => {\n    return reverse ? numericComparer(b, a) : numericComparer(a, b);\n  };\n};\n","import { ComparisonOperation } from '@grafana/schema';\n\n/**\n * Compare two values\n *\n * @internal -- not yet exported in `@grafana/data`\n */\nexport function compareValues(\n  left: string | number | boolean | null | undefined,\n  op: ComparisonOperation,\n  right: string | number | boolean | null | undefined\n) {\n  // Normalize null|undefined values\n  if (left == null || right == null) {\n    if (left == null) {\n      left = 'null';\n    }\n    if (right == null) {\n      right = 'null';\n    }\n    if (op === ComparisonOperation.GTE || op === ComparisonOperation.LTE) {\n      op = ComparisonOperation.EQ; // check for equality\n    }\n  }\n\n  switch (op) {\n    case ComparisonOperation.EQ:\n      return `${left}` === `${right}`;\n    case ComparisonOperation.NEQ:\n      return `${left}` !== `${right}`;\n    case ComparisonOperation.GT:\n      return left > right;\n    case ComparisonOperation.GTE:\n      return left >= right;\n    case ComparisonOperation.LT:\n      return left < right;\n    case ComparisonOperation.LTE:\n      return left <= right;\n    default:\n      return false;\n  }\n}\n","import { Field, FieldType, DataFrame } from '../../types/dataFrame';\nimport { FieldMatcherInfo } from '../../types/transformations';\n\nimport { FieldMatcherID } from './ids';\n\n// General Field matcher\nconst fieldTypeMatcher: FieldMatcherInfo<FieldType> = {\n  id: FieldMatcherID.byType,\n  name: 'Field Type',\n  description: 'match based on the field type',\n  defaultOptions: FieldType.number,\n\n  get: (type: FieldType) => {\n    return (field: Field, frame: DataFrame, allFrames: DataFrame[]) => {\n      return type === field.type;\n    };\n  },\n\n  getOptionsDisplayText: (type: FieldType) => {\n    return `Field type: ${type}`;\n  },\n};\n\n// General Field matcher (multiple types)\nconst fieldTypesMatcher: FieldMatcherInfo<Set<FieldType>> = {\n  id: FieldMatcherID.byTypes,\n  name: 'Field Type',\n  description: 'match based on the field types',\n  defaultOptions: new Set(),\n\n  get: (types) => {\n    return (field: Field, frame: DataFrame, allFrames: DataFrame[]) => {\n      return types.has(field.type);\n    };\n  },\n\n  getOptionsDisplayText: (types) => {\n    return `Field types: ${[...types].join(' | ')}`;\n  },\n};\n\n// Numeric Field matcher\n// This gets its own entry so it shows up in the dropdown\nconst numericMatcher: FieldMatcherInfo = {\n  id: FieldMatcherID.numeric,\n  name: 'Numeric Fields',\n  description: 'Fields with type number',\n\n  get: () => {\n    return fieldTypeMatcher.get(FieldType.number);\n  },\n\n  getOptionsDisplayText: () => {\n    return 'Numeric Fields';\n  },\n};\n\n// Time Field matcher\nconst timeMatcher: FieldMatcherInfo = {\n  id: FieldMatcherID.time,\n  name: 'Time Fields',\n  description: 'Fields with type time',\n\n  get: () => {\n    return fieldTypeMatcher.get(FieldType.time);\n  },\n\n  getOptionsDisplayText: () => {\n    return 'Time Fields';\n  },\n};\n\n/**\n * Registry Initialization\n */\nexport function getFieldTypeMatchers(): FieldMatcherInfo[] {\n  return [fieldTypeMatcher, fieldTypesMatcher, numericMatcher, timeMatcher];\n}\n","import { ComparisonOperation } from '@grafana/schema';\n\nimport { Field, DataFrame } from '../../types/dataFrame';\nimport { FieldMatcherInfo } from '../../types/transformations';\nimport { reduceField, ReducerID } from '../fieldReducer';\n\nimport { compareValues } from './compareValues';\nimport { FieldMatcherID } from './ids';\n\nexport interface FieldValueMatcherConfig {\n  reducer: ReducerID;\n  op?: ComparisonOperation;\n  value?: number; // or string?\n}\n\n// This should move to a utility function on the reducer registry\nfunction isBooleanReducer(r: ReducerID) {\n  return r === ReducerID.allIsNull || r === ReducerID.allIsZero;\n}\n\nexport const fieldValueMatcherInfo: FieldMatcherInfo<FieldValueMatcherConfig> = {\n  id: FieldMatcherID.byValue,\n  name: 'By value (reducer)',\n  description: 'Reduce a field to a single value and test for inclusion',\n\n  // This is added to overrides by default\n  defaultOptions: {\n    reducer: ReducerID.allIsZero,\n    op: ComparisonOperation.GTE,\n    value: 0,\n  },\n\n  get: (props) => {\n    if (!props || !props.reducer) {\n      return () => false;\n    }\n    let { reducer, op, value } = props;\n    const isBoolean = isBooleanReducer(reducer);\n    if (!op) {\n      op = ComparisonOperation.EQ;\n    }\n    return (field: Field, frame: DataFrame, allFrames: DataFrame[]) => {\n      const left = reduceField({\n        field,\n        reducers: [reducer],\n      })[reducer];\n\n      if (isBoolean) {\n        return Boolean(left); // boolean\n      }\n      return compareValues(left, op!, value);\n    };\n  },\n\n  getOptionsDisplayText: (props) => {\n    return `By value (${props.reducer})`;\n  },\n};\n","// This needs to be in its own file to avoid circular references\n\n// Builtin Predicates\n// not using 'any' and 'never' since they are reserved keywords\nexport enum MatcherID {\n  anyMatch = 'anyMatch', // checks children\n  allMatch = 'allMatch', // checks children\n  invertMatch = 'invertMatch', // checks child\n  alwaysMatch = 'alwaysMatch',\n  neverMatch = 'neverMatch',\n}\n\nexport enum FieldMatcherID {\n  // Specific Types\n  numeric = 'numeric',\n  time = 'time', // Can be multiple times\n  first = 'first',\n  firstTimeField = 'firstTimeField', // Only the first time field\n\n  // With arguments\n  byType = 'byType',\n  byTypes = 'byTypes',\n  byName = 'byName',\n  byNames = 'byNames',\n  byRegexp = 'byRegexp',\n  byRegexpOrNames = 'byRegexpOrNames',\n  byFrameRefID = 'byFrameRefID',\n  byValue = 'byValue',\n  // byIndex = 'byIndex',\n  // byLabel = 'byLabel',\n}\n\n/**\n * Field name matchers\n */\nexport enum FrameMatcherID {\n  byName = 'byName',\n  byRefId = 'byRefId',\n  byIndex = 'byIndex',\n}\n\n/**\n * @public\n */\nexport enum ValueMatcherID {\n  regex = 'regex',\n  isNull = 'isNull',\n  isNotNull = 'isNotNull',\n  greater = 'greater',\n  greaterOrEqual = 'greaterOrEqual',\n  lower = 'lower',\n  lowerOrEqual = 'lowerOrEqual',\n  equal = 'equal',\n  notEqual = 'notEqual',\n  substring = 'substring',\n  notSubstring = 'notSubstring',\n  between = 'between',\n}\n","import { stringToJsRegex } from '../../text/string';\nimport { DataFrame } from '../../types/dataFrame';\nimport { FrameMatcherInfo } from '../../types/transformations';\n\nimport { FrameMatcherID } from './ids';\n\n// General Field matcher\nconst refIdMatcher: FrameMatcherInfo<string> = {\n  id: FrameMatcherID.byRefId,\n  name: 'Query refId',\n  description: 'match the refId',\n  defaultOptions: 'A',\n\n  get: (pattern: string) => {\n    const regex = stringToJsRegex(pattern);\n    return (frame: DataFrame) => {\n      return regex.test(frame.refId || '');\n    };\n  },\n\n  getOptionsDisplayText: (pattern: string) => {\n    return `RefID: ${pattern}`;\n  },\n};\n\nexport function getRefIdMatchers(): FrameMatcherInfo[] {\n  return [refIdMatcher];\n}\n","import { Field, FieldType, DataFrame } from '../../types/dataFrame';\nimport { FieldMatcherInfo } from '../../types/transformations';\n\nimport { FieldMatcherID } from './ids';\n\nconst firstFieldMatcher: FieldMatcherInfo = {\n  id: FieldMatcherID.first,\n  name: 'First Field',\n  description: 'The first field in the frame',\n\n  get: (type: FieldType) => {\n    return (field: Field, frame: DataFrame, allFrames: DataFrame[]) => {\n      return field === frame.fields[0];\n    };\n  },\n\n  getOptionsDisplayText: () => {\n    return `First field`;\n  },\n};\n\nconst firstTimeFieldMatcher: FieldMatcherInfo = {\n  id: FieldMatcherID.firstTimeField,\n  name: 'First time field',\n  description: 'The first field of type time in a frame',\n\n  get: (type: FieldType) => {\n    return (field: Field, frame: DataFrame, allFrames: DataFrame[]) => {\n      return field.type === FieldType.time && field === frame.fields.find((f) => f.type === FieldType.time);\n    };\n  },\n\n  getOptionsDisplayText: () => {\n    return `First time field`;\n  },\n};\n\n/**\n * Registry Initialization\n */\nexport function getSimpleFieldMatchers(): FieldMatcherInfo[] {\n  return [firstFieldMatcher, firstTimeFieldMatcher];\n}\n","import { Field } from '../../../types/dataFrame';\nimport { ValueMatcherInfo } from '../../../types/transformations';\nimport { ValueMatcherID } from '../ids';\n\nimport { BasicValueMatcherOptions } from './types';\n\nconst isEqualValueMatcher: ValueMatcherInfo<BasicValueMatcherOptions> = {\n  id: ValueMatcherID.equal,\n  name: 'Is equal',\n  description: 'Match where value for given field is equal to options value.',\n  get: (options) => {\n    return (valueIndex: number, field: Field) => {\n      const value = field.values[valueIndex];\n      // eslint-disable-next-line eqeqeq\n      return value == options.value;\n    };\n  },\n  getOptionsDisplayText: () => {\n    return `Matches all rows where field is null.`;\n  },\n  isApplicable: () => true,\n  getDefaultOptions: () => ({ value: '' }),\n};\n\nconst isNotEqualValueMatcher: ValueMatcherInfo<BasicValueMatcherOptions> = {\n  id: ValueMatcherID.notEqual,\n  name: 'Is not equal',\n  description: 'Match where value for given field is not equal to options value.',\n  get: (options) => {\n    return (valueIndex: number, field: Field) => {\n      const value = field.values[valueIndex];\n      // eslint-disable-next-line eqeqeq\n      return value != options.value;\n    };\n  },\n  getOptionsDisplayText: () => {\n    return `Matches all rows where field is not null.`;\n  },\n  isApplicable: () => true,\n  getDefaultOptions: () => ({ value: '' }),\n};\n\nexport const getEqualValueMatchers = (): ValueMatcherInfo[] => [isEqualValueMatcher, isNotEqualValueMatcher];\n","import { Field } from '../../../types/dataFrame';\nimport { ValueMatcherInfo } from '../../../types/transformations';\nimport { ValueMatcherID } from '../ids';\n\nimport { ValueMatcherOptions } from './types';\n\nconst isNullValueMatcher: ValueMatcherInfo<ValueMatcherOptions> = {\n  id: ValueMatcherID.isNull,\n  name: 'Is null',\n  description: 'Match where value for given field is null.',\n  get: () => {\n    return (valueIndex: number, field: Field) => {\n      const value = field.values[valueIndex];\n      return value == null;\n    };\n  },\n  getOptionsDisplayText: () => {\n    return `Matches all rows where field is null.`;\n  },\n  isApplicable: () => true,\n  getDefaultOptions: () => ({}),\n};\n\nconst isNotNullValueMatcher: ValueMatcherInfo<ValueMatcherOptions> = {\n  id: ValueMatcherID.isNotNull,\n  name: 'Is not null',\n  description: 'Match where value for given field is not null.',\n  get: () => {\n    return (valueIndex: number, field: Field) => {\n      const value = field.values[valueIndex];\n      return value != null;\n    };\n  },\n  getOptionsDisplayText: () => {\n    return `Matches all rows where field is not null.`;\n  },\n  isApplicable: () => true,\n  getDefaultOptions: () => ({}),\n};\n\nexport const getNullValueMatchers = (): ValueMatcherInfo[] => [isNullValueMatcher, isNotNullValueMatcher];\n","import { Field, FieldType } from '../../../types/dataFrame';\nimport { ValueMatcherInfo } from '../../../types/transformations';\nimport { ValueMatcherID } from '../ids';\n\nimport { BasicValueMatcherOptions } from './types';\n\nconst isGreaterValueMatcher: ValueMatcherInfo<BasicValueMatcherOptions> = {\n  id: ValueMatcherID.greater,\n  name: 'Is greater',\n  description: 'Match when field value is greater than option.',\n  get: (options) => {\n    return (valueIndex: number, field: Field) => {\n      const value = field.values[valueIndex];\n      if (isNaN(value)) {\n        return false;\n      }\n      return value > options.value;\n    };\n  },\n  getOptionsDisplayText: (options) => {\n    return `Matches all rows where field value is greater than: ${options.value}.`;\n  },\n  isApplicable: (field) => field.type === FieldType.number,\n  getDefaultOptions: () => ({ value: 0 }),\n};\n\nconst isGreaterOrEqualValueMatcher: ValueMatcherInfo<BasicValueMatcherOptions> = {\n  id: ValueMatcherID.greaterOrEqual,\n  name: 'Is greater or equal',\n  description: 'Match when field value is greater than or equal to option.',\n  get: (options) => {\n    return (valueIndex: number, field: Field) => {\n      const value = field.values[valueIndex];\n      if (isNaN(value)) {\n        return false;\n      }\n      return value >= options.value;\n    };\n  },\n  getOptionsDisplayText: (options) => {\n    return `Matches all rows where field value is greater than or equal to: ${options.value}.`;\n  },\n  isApplicable: (field) => field.type === FieldType.number,\n  getDefaultOptions: () => ({ value: 0 }),\n};\n\nconst isLowerValueMatcher: ValueMatcherInfo<BasicValueMatcherOptions> = {\n  id: ValueMatcherID.lower,\n  name: 'Is lower',\n  description: 'Match when field value is lower than option.',\n  get: (options) => {\n    return (valueIndex: number, field: Field) => {\n      const value = field.values[valueIndex];\n      if (isNaN(value)) {\n        return false;\n      }\n      return value < options.value;\n    };\n  },\n  getOptionsDisplayText: (options) => {\n    return `Matches all rows where field value is lower than: ${options.value}.`;\n  },\n  isApplicable: (field) => field.type === FieldType.number,\n  getDefaultOptions: () => ({ value: 0 }),\n};\n\nconst isLowerOrEqualValueMatcher: ValueMatcherInfo<BasicValueMatcherOptions> = {\n  id: ValueMatcherID.lowerOrEqual,\n  name: 'Is lower or equal',\n  description: 'Match when field value is lower or equal than option.',\n  get: (options) => {\n    return (valueIndex: number, field: Field) => {\n      const value = field.values[valueIndex];\n      if (isNaN(value)) {\n        return false;\n      }\n      return value <= options.value;\n    };\n  },\n  getOptionsDisplayText: (options) => {\n    return `Matches all rows where field value is lower or equal than: ${options.value}.`;\n  },\n  isApplicable: (field) => field.type === FieldType.number,\n  getDefaultOptions: () => ({ value: 0 }),\n};\n\nexport const getNumericValueMatchers = (): ValueMatcherInfo[] => [\n  isGreaterValueMatcher,\n  isGreaterOrEqualValueMatcher,\n  isLowerValueMatcher,\n  isLowerOrEqualValueMatcher,\n];\n","import { Field, FieldType } from '../../../types/dataFrame';\nimport { ValueMatcherInfo } from '../../../types/transformations';\nimport { ValueMatcherID } from '../ids';\n\nimport { RangeValueMatcherOptions } from './types';\n\nconst isBetweenValueMatcher: ValueMatcherInfo<RangeValueMatcherOptions> = {\n  id: ValueMatcherID.between,\n  name: 'Is between',\n  description: 'Match when field value is between given option values.',\n  get: (options) => {\n    return (valueIndex: number, field: Field) => {\n      const value = field.values[valueIndex];\n      if (isNaN(value)) {\n        return false;\n      }\n      return value > options.from && value < options.to;\n    };\n  },\n  getOptionsDisplayText: (options) => {\n    return `Matches all rows where field value is between ${options.from} and ${options.to}.`;\n  },\n  isApplicable: (field) => field.type === FieldType.number,\n  getDefaultOptions: () => ({ from: 0, to: 100 }),\n};\n\nexport const getRangeValueMatchers = (): ValueMatcherInfo[] => [isBetweenValueMatcher];\n","import { Field } from '../../../types/dataFrame';\nimport { ValueMatcherInfo } from '../../../types/transformations';\nimport { ValueMatcherID } from '../ids';\n\nimport { BasicValueMatcherOptions } from './types';\n\nconst regexValueMatcher: ValueMatcherInfo<BasicValueMatcherOptions<string>> = {\n  id: ValueMatcherID.regex,\n  name: 'Regex',\n  description: 'Match when field value is matching regex.',\n  get: (options) => {\n    const regex = new RegExp(options.value);\n\n    return (valueIndex: number, field: Field) => {\n      const value = field.values[valueIndex];\n      return regex.test(value);\n    };\n  },\n  getOptionsDisplayText: (options) => {\n    return `Matches all rows where field value is matching regex: ${options.value}`;\n  },\n  isApplicable: () => true,\n  getDefaultOptions: () => ({ value: '.*' }),\n};\n\nexport const getRegexValueMatcher = (): ValueMatcherInfo[] => [regexValueMatcher];\n","import { Field, FieldType } from '../../../types/dataFrame';\nimport { ValueMatcherInfo } from '../../../types/transformations';\nimport { ValueMatcherID } from '../ids';\n\nimport { BasicValueMatcherOptions } from './types';\n\nconst isSubstringMatcher: ValueMatcherInfo<BasicValueMatcherOptions> = {\n  id: ValueMatcherID.substring,\n  name: 'Contains substring',\n  description: 'Match where value for given field is a substring to options value.',\n  get: (options) => {\n    return (valueIndex: number, field: Field) => {\n      const value = field.values[valueIndex];\n      return (\n        (value &&\n          options.value &&\n          typeof value === 'string' &&\n          value.toLowerCase().includes(options.value.toLowerCase())) ||\n        options.value === ''\n      );\n    };\n  },\n  getOptionsDisplayText: () => {\n    return `Matches all rows where field is similar to the value.`;\n  },\n  isApplicable: (field) => field.type === FieldType.string,\n  getDefaultOptions: () => ({ value: '' }),\n};\n\nconst isNotSubstringValueMatcher: ValueMatcherInfo<BasicValueMatcherOptions> = {\n  id: ValueMatcherID.notSubstring,\n  name: 'Does not contain substring',\n  description: 'Match where value for given field is not a substring to options value.',\n  get: (options) => {\n    return (valueIndex: number, field: Field) => {\n      const value = field.values[valueIndex];\n      return (\n        typeof value === 'string' &&\n        options.value &&\n        value &&\n        options.value !== '' &&\n        !value.toLowerCase().includes(options.value.toLowerCase())\n      );\n    };\n  },\n  getOptionsDisplayText: () => {\n    return `Matches all rows where field is not similar to the value.`;\n  },\n  isApplicable: (field) => field.type === FieldType.string,\n  getDefaultOptions: () => ({ value: '' }),\n};\n\nexport const getSubstringValueMatchers = (): ValueMatcherInfo[] => [isSubstringMatcher, isNotSubstringValueMatcher];\n","export enum DataTransformerID {\n  append = 'append',\n  //  rotate = 'rotate', // Columns to rows\n  reduce = 'reduce',\n  order = 'order',\n  organize = 'organize',\n  rename = 'rename',\n  calculateField = 'calculateField',\n  /** @deprecated use joinByField */\n  seriesToColumns = 'seriesToColumns',\n  seriesToRows = 'seriesToRows',\n  merge = 'merge',\n  concatenate = 'concatenate',\n  labelsToFields = 'labelsToFields',\n  filterFields = 'filterFields',\n  filterFieldsByName = 'filterFieldsByName',\n  filterFrames = 'filterFrames',\n  filterByRefId = 'filterByRefId',\n  renameByRegex = 'renameByRegex',\n  filterByValue = 'filterByValue',\n  noop = 'noop',\n  ensureColumns = 'ensureColumns',\n  groupBy = 'groupBy',\n  sortBy = 'sortBy',\n  histogram = 'histogram',\n  configFromData = 'configFromData',\n  rowsToFields = 'rowsToFields',\n  prepareTimeSeries = 'prepareTimeSeries',\n  convertFieldType = 'convertFieldType',\n  fieldLookup = 'fieldLookup',\n  heatmap = 'heatmap',\n  spatial = 'spatial',\n  joinByField = 'joinByField',\n  joinByLabels = 'joinByLabels',\n  extractFields = 'extractFields',\n  groupingToMatrix = 'groupingToMatrix',\n  limit = 'limit',\n  partitionByValues = 'partitionByValues',\n  timeSeriesTable = 'timeSeriesTable',\n  transpose = 'transpose',\n  formatTime = 'formatTime',\n  formatString = 'formatString',\n  regression = 'regression',\n  groupToNestedTable = 'groupToNestedTable',\n}\n","import { Labels } from '../types/data';\n\n/** replace labels in a string.  Used for loki+prometheus legend formats */\nexport function renderLegendFormat(aliasPattern: string, aliasData: Labels): string {\n  const aliasRegex = /\\{\\{\\s*(.+?)\\s*\\}\\}/g;\n  return aliasPattern.replace(aliasRegex, (_, g1) => (aliasData[g1] ? aliasData[g1] : g1));\n}\n","import { DataQueryError } from '@grafana/data';\n\n/**\n * Convert an object into a DataQueryError -- if this is an HTTP response,\n * it will put the correct values in the error field\n *\n * @public\n */\nexport function toDataQueryError(err: DataQueryError | string | unknown): DataQueryError {\n  const error: DataQueryError = err || {};\n\n  if (!error.message) {\n    if (typeof err === 'string') {\n      return { message: err };\n    }\n\n    let message = 'Query error';\n    if (error.message) {\n      message = error.message;\n    } else if (error.data && error.data.message && error.data?.message !== 'Query data error') {\n      message = error.data.message;\n    } else if (error?.data?.message === 'Query data error' && error?.data?.error) {\n      message = error.data.error;\n    } else if (error.data && error.data.error) {\n      message = error.data.error;\n    } else if (error.status) {\n      message = `Query error: ${error.status} ${error.statusText}`;\n    }\n    error.message = message;\n  }\n\n  return error;\n}\n","import { map, Observable, ReplaySubject, Subject, Subscriber, Subscription } from 'rxjs';\n\nimport {\n  DataFrameJSON,\n  DataQueryError,\n  Field,\n  isLiveChannelMessageEvent,\n  isLiveChannelStatusEvent,\n  LiveChannelConnectionState,\n  LiveChannelEvent,\n  LiveChannelId,\n  LoadingState,\n  StreamingDataFrame,\n} from '@grafana/data';\nimport { getStreamingFrameOptions } from '@grafana/data/src/dataframe/StreamingDataFrame';\nimport { LiveDataStreamOptions, StreamingFrameAction, StreamingFrameOptions } from '@grafana/runtime/src/services/live';\nimport { toDataQueryError } from '@grafana/runtime/src/utils/toDataQueryError';\n\nimport { StreamingResponseDataType } from '../data/utils';\n\nimport { DataStreamSubscriptionKey, StreamingDataQueryResponse } from './service';\n\nconst bufferIfNot =\n  (canEmitObservable: Observable<boolean>) =>\n  <T>(source: Observable<T>): Observable<T[]> => {\n    return new Observable((subscriber: Subscriber<T[]>) => {\n      let buffer: T[] = [];\n      let canEmit = true;\n\n      const emitBuffer = () => {\n        subscriber.next(buffer);\n        buffer = [];\n      };\n\n      const canEmitSub = canEmitObservable.subscribe({\n        next: (val) => {\n          canEmit = val;\n\n          if (canEmit && buffer.length) {\n            emitBuffer();\n          }\n        },\n      });\n\n      const sourceSub = source.subscribe({\n        next(value) {\n          if (canEmit) {\n            if (!buffer.length) {\n              subscriber.next([value]);\n            } else {\n              emitBuffer();\n            }\n          } else {\n            buffer.push(value);\n          }\n        },\n        error(error) {\n          subscriber.error(error);\n        },\n        complete() {\n          subscriber.complete();\n        },\n      });\n\n      return () => {\n        sourceSub.unsubscribe();\n        canEmitSub.unsubscribe();\n      };\n    });\n  };\n\nexport type DataStreamHandlerDeps<T> = {\n  channelId: LiveChannelId;\n  liveEventsObservable: Observable<LiveChannelEvent<T>>;\n  onShutdown: () => void;\n  subscriberReadiness: Observable<boolean>;\n  defaultStreamingFrameOptions: Readonly<StreamingFrameOptions>;\n  shutdownDelayInMs: number;\n};\n\nenum InternalStreamMessageType {\n  Error,\n  NewValuesSameSchema,\n  ChangedSchema,\n}\n\ntype InternalStreamMessageTypeToData = {\n  [InternalStreamMessageType.Error]: {\n    error: DataQueryError;\n  };\n  [InternalStreamMessageType.ChangedSchema]: {};\n  [InternalStreamMessageType.NewValuesSameSchema]: {\n    values: unknown[][];\n  };\n};\n\ntype InternalStreamMessage<T = InternalStreamMessageType> = T extends InternalStreamMessageType\n  ? {\n      type: T;\n    } & InternalStreamMessageTypeToData[T]\n  : never;\n\nconst reduceNewValuesSameSchemaMessages = (\n  packets: Array<InternalStreamMessage<InternalStreamMessageType.NewValuesSameSchema>>\n) => ({\n  values: packets.reduce<unknown[][]>((acc, { values }) => {\n    for (let i = 0; i < values.length; i++) {\n      if (!acc[i]) {\n        acc[i] = [];\n      }\n      for (let j = 0; j < values[i].length; j++) {\n        acc[i].push(values[i][j]);\n      }\n    }\n    return acc;\n  }, []),\n  type: InternalStreamMessageType.NewValuesSameSchema,\n});\n\nconst filterMessages = <T extends InternalStreamMessageType>(\n  packets: InternalStreamMessage[],\n  type: T\n): Array<InternalStreamMessage<T>> => packets.filter((p) => p.type === type) as Array<InternalStreamMessage<T>>;\n\nexport class LiveDataStream<T = unknown> {\n  private frameBuffer: StreamingDataFrame;\n  private liveEventsSubscription: Subscription;\n  private stream: Subject<InternalStreamMessage> = new ReplaySubject(1);\n  private shutdownTimeoutId: ReturnType<typeof setTimeout> | undefined;\n\n  constructor(private deps: DataStreamHandlerDeps<T>) {\n    this.frameBuffer = StreamingDataFrame.empty(deps.defaultStreamingFrameOptions);\n    this.liveEventsSubscription = deps.liveEventsObservable.subscribe({\n      error: this.onError,\n      complete: this.onComplete,\n      next: this.onNext,\n    });\n  }\n\n  private shutdown = () => {\n    this.stream.complete();\n    this.liveEventsSubscription.unsubscribe();\n    this.deps.onShutdown();\n  };\n\n  private shutdownIfNoSubscribers = () => {\n    if (!this.stream.observed) {\n      this.shutdown();\n    }\n  };\n\n  private onError = (err: unknown) => {\n    console.log('LiveQuery [error]', { err }, this.deps.channelId);\n    this.stream.next({\n      type: InternalStreamMessageType.Error,\n      error: toDataQueryError(err),\n    });\n    this.shutdown();\n  };\n\n  private onComplete = () => {\n    console.log('LiveQuery [complete]', this.deps.channelId);\n    this.shutdown();\n  };\n\n  private onNext = (evt: LiveChannelEvent) => {\n    if (isLiveChannelMessageEvent(evt)) {\n      this.process(evt.message);\n      return;\n    }\n\n    const liveChannelStatusEvent = isLiveChannelStatusEvent(evt);\n    if (liveChannelStatusEvent && evt.error) {\n      const err = toDataQueryError(evt.error);\n      this.stream.next({\n        type: InternalStreamMessageType.Error,\n        error: {\n          ...err,\n          message: `Streaming channel error: ${err.message}`,\n        },\n      });\n    }\n\n    if (\n      liveChannelStatusEvent &&\n      (evt.state === LiveChannelConnectionState.Connected || evt.state === LiveChannelConnectionState.Pending) &&\n      evt.message\n    ) {\n      this.process(evt.message);\n    }\n  };\n\n  private process = (msg: DataFrameJSON) => {\n    const packetInfo = this.frameBuffer.push(msg);\n\n    if (packetInfo.schemaChanged) {\n      this.stream.next({\n        type: InternalStreamMessageType.ChangedSchema,\n      });\n    } else {\n      this.stream.next({\n        type: InternalStreamMessageType.NewValuesSameSchema,\n        values: this.frameBuffer.getValuesFromLastPacket(),\n      });\n    }\n  };\n\n  private resizeBuffer = (bufferOptions: StreamingFrameOptions) => {\n    if (bufferOptions && this.frameBuffer.needsResizing(bufferOptions)) {\n      this.frameBuffer.resize(bufferOptions);\n    }\n  };\n\n  private prepareInternalStreamForNewSubscription = (options: LiveDataStreamOptions): void => {\n    if (!this.frameBuffer.hasAtLeastOnePacket() && options.frame) {\n      // will skip initial frames from subsequent subscribers\n      this.process(options.frame);\n    }\n  };\n\n  private clearShutdownTimeout = () => {\n    if (this.shutdownTimeoutId) {\n      clearTimeout(this.shutdownTimeoutId);\n      this.shutdownTimeoutId = undefined;\n    }\n  };\n\n  get = (options: LiveDataStreamOptions, subKey: DataStreamSubscriptionKey): Observable<StreamingDataQueryResponse> => {\n    this.clearShutdownTimeout();\n    const buffer = getStreamingFrameOptions(options.buffer);\n\n    this.resizeBuffer(buffer);\n    this.prepareInternalStreamForNewSubscription(options);\n\n    const shouldSendLastPacketOnly = options?.buffer?.action === StreamingFrameAction.Replace;\n    const fieldsNamesFilter = options.filter?.fields;\n    const dataNeedsFiltering = fieldsNamesFilter?.length;\n    const fieldFilterPredicate = dataNeedsFiltering ? ({ name }: Field) => fieldsNamesFilter.includes(name) : undefined;\n    let matchingFieldIndexes: number[] | undefined = undefined;\n\n    const getFullFrameResponseData = <T>(\n      messages: InternalStreamMessage[],\n      error?: DataQueryError\n    ): StreamingDataQueryResponse => {\n      matchingFieldIndexes = fieldFilterPredicate\n        ? this.frameBuffer.getMatchingFieldIndexes(fieldFilterPredicate)\n        : undefined;\n\n      if (!shouldSendLastPacketOnly) {\n        return {\n          key: subKey,\n          state: error ? LoadingState.Error : LoadingState.Streaming,\n          data: [\n            {\n              type: StreamingResponseDataType.FullFrame,\n              frame: this.frameBuffer.serialize(fieldFilterPredicate, buffer),\n            },\n          ],\n          error,\n        };\n      }\n\n      if (error) {\n        // send empty frame with error\n        return {\n          key: subKey,\n          state: LoadingState.Error,\n          data: [\n            {\n              type: StreamingResponseDataType.FullFrame,\n              frame: this.frameBuffer.serialize(fieldFilterPredicate, buffer, { maxLength: 0 }),\n            },\n          ],\n          error,\n        };\n      }\n\n      if (!messages.length) {\n        console.warn(`expected to find at least one non error message ${messages.map(({ type }) => type)}`);\n        // send empty frame\n        return {\n          key: subKey,\n          state: LoadingState.Streaming,\n          data: [\n            {\n              type: StreamingResponseDataType.FullFrame,\n              frame: this.frameBuffer.serialize(fieldFilterPredicate, buffer, { maxLength: 0 }),\n            },\n          ],\n          error,\n        };\n      }\n\n      return {\n        key: subKey,\n        state: LoadingState.Streaming,\n        data: [\n          {\n            type: StreamingResponseDataType.FullFrame,\n            frame: this.frameBuffer.serialize(fieldFilterPredicate, buffer, {\n              maxLength: this.frameBuffer.packetInfo.length,\n            }),\n          },\n        ],\n        error,\n      };\n    };\n\n    const getNewValuesSameSchemaResponseData = (\n      messages: Array<InternalStreamMessage<InternalStreamMessageType.NewValuesSameSchema>>\n    ): StreamingDataQueryResponse => {\n      const lastMessage = messages.length ? messages[messages.length - 1] : undefined;\n      const values =\n        shouldSendLastPacketOnly && lastMessage\n          ? lastMessage.values\n          : reduceNewValuesSameSchemaMessages(messages).values;\n\n      const filteredValues = matchingFieldIndexes ? values.filter((v, i) => matchingFieldIndexes?.includes(i)) : values;\n\n      return {\n        key: subKey,\n        state: LoadingState.Streaming,\n        data: [\n          {\n            type: StreamingResponseDataType.NewValuesSameSchema,\n            values: filteredValues,\n          },\n        ],\n      };\n    };\n\n    let shouldSendFullFrame = true;\n    const transformedInternalStream = this.stream.pipe(\n      bufferIfNot(this.deps.subscriberReadiness),\n      map((messages, i) => {\n        const errors = filterMessages(messages, InternalStreamMessageType.Error);\n        const lastError = errors.length ? errors[errors.length - 1].error : undefined;\n\n        if (shouldSendFullFrame) {\n          shouldSendFullFrame = false;\n          return getFullFrameResponseData(messages, lastError);\n        }\n\n        if (errors.length) {\n          // send the latest frame with the last error, discard everything else\n          return getFullFrameResponseData(messages, lastError);\n        }\n\n        const schemaChanged = messages.some((n) => n.type === InternalStreamMessageType.ChangedSchema);\n        if (schemaChanged) {\n          // send the latest frame, discard intermediate appends\n          return getFullFrameResponseData(messages, undefined);\n        }\n\n        const newValueSameSchemaMessages = filterMessages(messages, InternalStreamMessageType.NewValuesSameSchema);\n        if (newValueSameSchemaMessages.length !== messages.length) {\n          console.warn(`unsupported message type ${messages.map(({ type }) => type)}`);\n        }\n\n        return getNewValuesSameSchemaResponseData(newValueSameSchemaMessages);\n      })\n    );\n\n    return new Observable<StreamingDataQueryResponse>((subscriber) => {\n      const sub = transformedInternalStream.subscribe({\n        next: (n) => {\n          subscriber.next(n);\n        },\n        error: (err) => {\n          subscriber.error(err);\n        },\n        complete: () => {\n          subscriber.complete();\n        },\n      });\n\n      return () => {\n        // TODO: potentially resize (downsize) the buffer on unsubscribe\n        sub.unsubscribe();\n        if (!this.stream.observed) {\n          this.clearShutdownTimeout();\n          this.shutdownTimeoutId = setTimeout(this.shutdownIfNoSubscribers, this.deps.shutdownDelayInMs);\n        }\n      };\n    });\n  };\n}\n","import {\n  Subscription,\n  JoinContext,\n  LeaveContext,\n  PublicationContext,\n  SubscriptionErrorContext,\n  SubscribedContext,\n} from 'centrifuge';\nimport { Subject, of, Observable } from 'rxjs';\n\nimport {\n  LiveChannelStatusEvent,\n  LiveChannelEvent,\n  LiveChannelEventType,\n  LiveChannelConnectionState,\n  LiveChannelPresenceStatus,\n  LiveChannelAddress,\n  DataFrameJSON,\n  isValidLiveChannelAddress,\n} from '@grafana/data';\n\n/**\n * Internal class that maps Centrifuge support to GrafanaLive\n */\nexport class CentrifugeLiveChannel<T = any> {\n  readonly currentStatus: LiveChannelStatusEvent;\n\n  readonly opened = Date.now();\n  readonly id: string;\n  readonly addr: LiveChannelAddress;\n\n  readonly stream = new Subject<LiveChannelEvent<T>>();\n\n  // Hold on to the last header with schema\n  lastMessageWithSchema?: DataFrameJSON;\n\n  subscription?: Subscription;\n  shutdownCallback?: () => void;\n  initalized?: boolean;\n\n  constructor(id: string, addr: LiveChannelAddress) {\n    this.id = id;\n    this.addr = addr;\n    this.currentStatus = {\n      type: LiveChannelEventType.Status,\n      id,\n      timestamp: this.opened,\n      state: LiveChannelConnectionState.Pending,\n    };\n    if (!isValidLiveChannelAddress(addr)) {\n      this.currentStatus.state = LiveChannelConnectionState.Invalid;\n      this.currentStatus.error = 'invalid channel address';\n    }\n  }\n\n  // This should only be called when centrifuge is connected\n  initalize(): void {\n    if (this.initalized) {\n      throw new Error('Channel already initalized: ' + this.id);\n    }\n    this.initalized = true;\n\n    this.subscription!.on('publication', (ctx: PublicationContext) => {\n      try {\n        if (ctx.data) {\n          if (ctx.data.schema) {\n            this.lastMessageWithSchema = ctx.data;\n          }\n\n          this.stream.next({\n            type: LiveChannelEventType.Message,\n            message: ctx.data,\n          });\n        }\n\n        // Clear any error messages\n        if (this.currentStatus.error) {\n          this.currentStatus.timestamp = Date.now();\n          delete this.currentStatus.error;\n          this.sendStatus();\n        }\n      } catch (err) {\n        console.log('publish error', this.addr, err);\n        this.currentStatus.error = err;\n        this.currentStatus.timestamp = Date.now();\n        this.sendStatus();\n      }\n    })\n      .on('error', (ctx: SubscriptionErrorContext) => {\n        this.currentStatus.timestamp = Date.now();\n        this.currentStatus.error = ctx.error.message;\n        this.sendStatus();\n      })\n      .on('subscribed', (ctx: SubscribedContext) => {\n        this.currentStatus.timestamp = Date.now();\n        this.currentStatus.state = LiveChannelConnectionState.Connected;\n        delete this.currentStatus.error;\n\n        if (ctx.data?.schema) {\n          this.lastMessageWithSchema = ctx.data;\n        }\n        this.sendStatus(ctx.data);\n      })\n      .on('unsubscribed', () => {\n        this.currentStatus.timestamp = Date.now();\n        this.currentStatus.state = LiveChannelConnectionState.Disconnected;\n        this.sendStatus();\n      })\n      .on('subscribing', () => {\n        this.currentStatus.timestamp = Date.now();\n        this.currentStatus.state = LiveChannelConnectionState.Connecting;\n        this.sendStatus();\n      })\n      .on('join', (ctx: JoinContext) => {\n        this.stream.next({ type: LiveChannelEventType.Join, user: ctx.info.user });\n      })\n      .on('leave', (ctx: LeaveContext) => {\n        this.stream.next({ type: LiveChannelEventType.Leave, user: ctx.info.user });\n      });\n  }\n\n  private sendStatus(message?: unknown) {\n    const copy = { ...this.currentStatus };\n    if (message) {\n      copy.message = message;\n    }\n    this.stream.next(copy);\n  }\n\n  disconnectIfNoListeners = () => {\n    const count = this.stream.observers.length;\n    if (count === 0) {\n      this.disconnect();\n    }\n  };\n\n  /**\n   * Get the stream of events and\n   */\n  getStream() {\n    return new Observable<LiveChannelEvent<T>>((subscriber) => {\n      const initialMessage = { ...this.currentStatus };\n      if (this.lastMessageWithSchema?.schema) {\n        // send just schema instead of schema+data to avoid having data gaps\n        initialMessage.message = { schema: this.lastMessageWithSchema?.schema };\n      }\n\n      subscriber.next({ ...this.currentStatus, message: this.lastMessageWithSchema });\n\n      const sub = this.stream.subscribe(subscriber);\n      return () => {\n        sub.unsubscribe();\n        const count = this.stream.observers.length;\n\n        // Wait 1/4 second to fully disconnect\n        if (count === 0) {\n          setTimeout(this.disconnectIfNoListeners, 250);\n        }\n      };\n    });\n  }\n\n  /**\n   * This is configured by the server when the config supports presence\n   */\n  async getPresence(): Promise<LiveChannelPresenceStatus> {\n    if (!this.subscription) {\n      return Promise.reject('not subscribed');\n    }\n\n    return this.subscription!.presence().then((v) => {\n      return {\n        users: Object.keys(v.clients),\n      };\n    });\n  }\n\n  /**\n   * This will close and terminate all streams for this channel\n   */\n  disconnect() {\n    this.currentStatus.state = LiveChannelConnectionState.Shutdown;\n    this.currentStatus.timestamp = Date.now();\n\n    if (this.subscription) {\n      this.subscription.unsubscribe();\n      this.subscription.removeAllListeners(); // they keep all listeners attached after unsubscribe\n      this.subscription = undefined;\n    }\n\n    this.stream.complete();\n\n    this.stream.next({ ...this.currentStatus });\n    this.stream.complete();\n\n    if (this.shutdownCallback) {\n      this.shutdownCallback();\n    }\n  }\n\n  shutdownWithError(err: string) {\n    this.currentStatus.error = err;\n    this.sendStatus();\n    this.disconnect();\n  }\n}\n\nexport function getErrorChannel<TMessage>(msg: string, id: string, addr: LiveChannelAddress) {\n  return {\n    id,\n    opened: Date.now(),\n    addr,\n\n    // return an error\n    getStream: () =>\n      of({\n        type: LiveChannelEventType.Status,\n        id,\n        timestamp: Date.now(),\n        state: LiveChannelConnectionState.Invalid,\n        error: msg,\n      }),\n\n    // already disconnected\n    disconnect: () => {},\n  };\n}\n","import {\n  Centrifuge,\n  ConnectedContext,\n  ConnectingContext,\n  DisconnectedContext,\n  ServerPublicationContext,\n  State,\n} from 'centrifuge';\nimport { BehaviorSubject, Observable, share, startWith } from 'rxjs';\n\nimport {\n  DataQueryError,\n  DataQueryResponse,\n  LiveChannelAddress,\n  LiveChannelConnectionState,\n  LiveChannelId,\n  toLiveChannelId,\n} from '@grafana/data';\nimport { FetchResponse } from '@grafana/runtime/src/services/backendSrv';\nimport {\n  GrafanaLiveSrv,\n  LiveDataStreamOptions,\n  LiveQueryDataOptions,\n  StreamingFrameAction,\n  StreamingFrameOptions,\n} from '@grafana/runtime/src/services/live';\nimport { BackendDataSourceResponse } from '@grafana/runtime/src/utils/queryResponse';\n\nimport { StreamingResponseData } from '../data/utils';\n\nimport { LiveDataStream } from './LiveDataStream';\nimport { CentrifugeLiveChannel } from './channel';\n\nexport type CentrifugeSrvDeps = {\n  grafanaAuthToken: string | null;\n  appUrl: string;\n  orgId: number;\n  orgRole: string;\n  liveEnabled: boolean;\n  dataStreamSubscriberReadiness: Observable<boolean>;\n};\n\nexport type StreamingDataQueryResponse = Omit<DataQueryResponse, 'data'> & { data: [StreamingResponseData] };\n\nexport type CentrifugeSrv = Omit<GrafanaLiveSrv, 'publish' | 'getDataStream' | 'getQueryData'> & {\n  getDataStream: (options: LiveDataStreamOptions) => Observable<StreamingDataQueryResponse>;\n  getQueryData: (\n    options: LiveQueryDataOptions\n  ) => Promise<\n    | { data: BackendDataSourceResponse | undefined }\n    | FetchResponse<BackendDataSourceResponse | undefined>\n    | DataQueryError\n  >;\n};\n\nexport type DataStreamSubscriptionKey = string;\n\nconst defaultStreamingFrameOptions: Readonly<StreamingFrameOptions> = {\n  maxLength: 100,\n  maxDelta: Infinity,\n  action: StreamingFrameAction.Append,\n};\n\nconst dataStreamShutdownDelayInMs = 5000;\n\nexport class CentrifugeService implements CentrifugeSrv {\n  readonly open = new Map<string, CentrifugeLiveChannel>();\n  private readonly liveDataStreamByChannelId: Record<LiveChannelId, LiveDataStream> = {};\n  readonly centrifuge: Centrifuge;\n  readonly connectionState: BehaviorSubject<boolean>;\n  readonly connectionBlocker: Promise<void>;\n  private readonly dataStreamSubscriberReadiness: Observable<boolean>;\n\n  constructor(private deps: CentrifugeSrvDeps) {\n    this.dataStreamSubscriberReadiness = deps.dataStreamSubscriberReadiness.pipe(share(), startWith(true));\n\n    let liveUrl = `${deps.appUrl.replace(/^http/, 'ws')}/api/live/ws`;\n\n    const token = deps.grafanaAuthToken;\n    if (token !== null && token !== '') {\n      liveUrl += '?auth_token=' + token;\n    }\n\n    this.centrifuge = new Centrifuge(liveUrl, {\n      timeout: 30000,\n    });\n    // orgRole is set when logged in *or* anonymous users can use grafana\n    if (deps.liveEnabled && deps.orgRole !== '') {\n      this.centrifuge.connect(); // do connection\n    }\n    this.connectionState = new BehaviorSubject<boolean>(this.centrifuge.state === State.Connected);\n    this.connectionBlocker = new Promise<void>((resolve) => {\n      if (this.centrifuge.state === State.Connected) {\n        return resolve();\n      }\n      const connectListener = () => {\n        resolve();\n        this.centrifuge.removeListener('connected', connectListener);\n      };\n      this.centrifuge.addListener('connected', connectListener);\n    });\n\n    // Register global listeners\n    this.centrifuge.on('connected', this.onConnect);\n    this.centrifuge.on('connecting', this.onDisconnect);\n    this.centrifuge.on('disconnected', this.onDisconnect);\n    this.centrifuge.on('publication', this.onServerSideMessage);\n  }\n\n  //----------------------------------------------------------\n  // Internal functions\n  //----------------------------------------------------------\n\n  private onConnect = (context: ConnectedContext) => {\n    this.connectionState.next(true);\n  };\n\n  private onDisconnect = (context: ConnectingContext | DisconnectedContext) => {\n    this.connectionState.next(false);\n  };\n\n  private onServerSideMessage = (context: ServerPublicationContext) => {\n    console.log('Publication from server-side channel', context);\n  };\n\n  /**\n   * Get a channel.  If the scope, namespace, or path is invalid, a shutdown\n   * channel will be returned with an error state indicated in its status\n   */\n  private getChannel<TMessage>(addr: LiveChannelAddress): CentrifugeLiveChannel<TMessage> {\n    const id = `${this.deps.orgId}/${addr.scope}/${addr.namespace}/${addr.path}`;\n    let channel = this.open.get(id);\n    if (channel != null) {\n      return channel;\n    }\n\n    channel = new CentrifugeLiveChannel(id, addr);\n    if (channel.currentStatus.state === LiveChannelConnectionState.Invalid) {\n      return channel;\n    }\n    channel.shutdownCallback = () => {\n      this.open.delete(id);\n\n      // without a call to `removeSubscription`, the subscription will remain in centrifuge's internal registry\n      this.centrifuge.removeSubscription(this.centrifuge.getSubscription(id));\n    };\n    this.open.set(id, channel);\n\n    // Initialize the channel in the background\n    this.initChannel(channel).catch((err) => {\n      if (channel) {\n        channel.currentStatus.state = LiveChannelConnectionState.Invalid;\n        channel.shutdownWithError(err);\n      }\n      this.open.delete(id);\n    });\n\n    // return the not-yet initialized channel\n    return channel;\n  }\n\n  private async initChannel(channel: CentrifugeLiveChannel): Promise<void> {\n    if (this.centrifuge.state !== State.Connected) {\n      await this.connectionBlocker;\n    }\n    const subscription = this.centrifuge.newSubscription(channel.id, {\n      data: channel.addr.data,\n    });\n    channel.subscription = subscription;\n    channel.initalize();\n    subscription.subscribe();\n    return;\n  }\n\n  //----------------------------------------------------------\n  // Exported functions\n  //----------------------------------------------------------\n\n  /**\n   * Listen for changes to the connection state\n   */\n  getConnectionState = () => {\n    return this.connectionState.asObservable();\n  };\n\n  /**\n   * Watch for messages in a channel\n   */\n  getStream: CentrifugeSrv['getStream'] = <T>(address: LiveChannelAddress) => {\n    return this.getChannel<T>(address).getStream();\n  };\n\n  private createSubscriptionKey = (options: LiveDataStreamOptions): DataStreamSubscriptionKey =>\n    options.key ?? `xstr/${streamCounter++}`;\n\n  private getLiveDataStream = (options: LiveDataStreamOptions): LiveDataStream => {\n    const channelId = toLiveChannelId(options.addr);\n    const existingStream = this.liveDataStreamByChannelId[channelId];\n\n    if (existingStream) {\n      return existingStream;\n    }\n\n    const channel = this.getChannel(options.addr);\n    this.liveDataStreamByChannelId[channelId] = new LiveDataStream({\n      channelId,\n      onShutdown: () => {\n        delete this.liveDataStreamByChannelId[channelId];\n      },\n      liveEventsObservable: channel.getStream(),\n      subscriberReadiness: this.dataStreamSubscriberReadiness,\n      defaultStreamingFrameOptions,\n      shutdownDelayInMs: dataStreamShutdownDelayInMs,\n    });\n    return this.liveDataStreamByChannelId[channelId];\n  };\n  /**\n   * Connect to a channel and return results as DataFrames\n   */\n  getDataStream: CentrifugeSrv['getDataStream'] = (options) => {\n    const subscriptionKey = this.createSubscriptionKey(options);\n\n    const stream = this.getLiveDataStream(options);\n    return stream.get(options, subscriptionKey);\n  };\n\n  /**\n   * Executes a query over the live websocket. Query response can contain live channels we can subscribe to for further updates\n   *\n   * Since the initial request and subscription are on the same socket, this will support HA setups\n   */\n  getQueryData: CentrifugeSrv['getQueryData'] = async (options) => {\n    if (this.centrifuge.state !== State.Connected) {\n      await this.connectionBlocker;\n    }\n    return this.centrifuge.rpc('grafana.query', options.body);\n  };\n\n  /**\n   * For channels that support presence, this will request the current state from the server.\n   *\n   * Join and leave messages will be sent to the open stream\n   */\n  getPresence: CentrifugeSrv['getPresence'] = (address) => {\n    return this.getChannel(address).getPresence();\n  };\n}\n\n// This is used to give a unique key for each stream.  The actual value does not matter\nlet streamCounter = 0;\n","import * as comlink from 'comlink';\nimport { Subscriber } from 'rxjs';\n\n// Observers, ie. functions passed to `observable.subscribe(...)`, are converted to a subclass of `Subscriber` before they are sent to the source Observable.\n// The conversion happens internally in the RxJS library - this transfer handler is catches them and wraps them with a proxy\nconst subscriberTransferHandler = {\n  canHandle(value: unknown): value is Subscriber<unknown> {\n    return Boolean(value && value instanceof Subscriber);\n  },\n\n  serialize(value: Function): [MessagePort, Transferable[]] {\n    const obj = comlink.proxy(value);\n\n    const { port1, port2 } = new MessageChannel();\n\n    comlink.expose(obj, port1);\n\n    return [port2, [port2]];\n  },\n\n  deserialize(value: MessagePort): comlink.Remote<MessagePort> {\n    value.start();\n\n    return comlink.wrap<MessagePort>(value);\n  },\n};\ncomlink.transferHandlers.set('SubscriberHandler', subscriberTransferHandler);\n"],"names":["fieldIndexComparer","field","reverse","values","numericIndexComparer","stringIndexComparer","booleanIndexComparer","timestampIndexComparer","timeIndexComparer","naturalIndexComparer","timeComparer","a","b","falsyComparer","numericComparer","stringComparer","booleanComparer","mult","vA","vB","compareValues","left","op","right","fieldTypeMatcher","type","frame","allFrames","fieldTypesMatcher","types","numericMatcher","timeMatcher","getFieldTypeMatchers","isBooleanReducer","r","fieldValueMatcherInfo","props","reducer","value","isBoolean","MatcherID","FieldMatcherID","FrameMatcherID","ValueMatcherID","refIdMatcher","pattern","regex","getRefIdMatchers","firstFieldMatcher","firstTimeFieldMatcher","f","getSimpleFieldMatchers","isEqualValueMatcher","options","valueIndex","isNotEqualValueMatcher","getEqualValueMatchers","isNullValueMatcher","isNotNullValueMatcher","getNullValueMatchers","isGreaterValueMatcher","isGreaterOrEqualValueMatcher","isLowerValueMatcher","isLowerOrEqualValueMatcher","getNumericValueMatchers","isBetweenValueMatcher","getRangeValueMatchers","regexValueMatcher","getRegexValueMatcher","isSubstringMatcher","isNotSubstringValueMatcher","getSubstringValueMatchers","DataTransformerID","renderLegendFormat","aliasPattern","aliasData","aliasRegex","_","g1","toDataQueryError","err","error","message","bufferIfNot","canEmitObservable","source","Observable","subscriber","buffer","canEmit","emitBuffer","canEmitSub","val","sourceSub","InternalStreamMessageType","reduceNewValuesSameSchemaMessages","packets","acc","i","j","filterMessages","p","LiveDataStream","deps","ReplaySubject","evt","liveChannelStatusEvent","msg","bufferOptions","subKey","shouldSendLastPacketOnly","fieldsNamesFilter","fieldFilterPredicate","name","matchingFieldIndexes","getFullFrameResponseData","messages","getNewValuesSameSchemaResponseData","lastMessage","filteredValues","v","shouldSendFullFrame","transformedInternalStream","map","errors","lastError","n","newValueSameSchemaMessages","sub","StreamingDataFrame","CentrifugeLiveChannel","id","addr","Subject","ctx","copy","initialMessage","getErrorChannel","defaultStreamingFrameOptions","dataStreamShutdownDelayInMs","CentrifugeService","context","address","streamCounter","channelId","existingStream","channel","subscriptionKey","share","startWith","liveUrl","token","BehaviorSubject","resolve","connectListener","subscription","subscriberTransferHandler","obj","port1","port2"],"sourceRoot":""}