{"version":3,"sources":["webpack:///./public/app/plugins/datasource/elasticsearch/query_def.ts","webpack:///./public/app/plugins/datasource/elasticsearch/elastic_response.ts","webpack:///./public/app/plugins/datasource/elasticsearch/index_pattern.ts","webpack:///./public/app/plugins/datasource/elasticsearch/query_builder.ts","webpack:///./public/app/plugins/datasource/elasticsearch/datasource.ts","webpack:///./public/app/plugins/datasource/elasticsearch/bucket_agg.ts","webpack:///./public/app/plugins/datasource/elasticsearch/metric_agg.ts","webpack:///./public/app/plugins/datasource/elasticsearch/pipeline_variables.ts","webpack:///./public/app/plugins/datasource/elasticsearch/query_ctrl.ts","webpack:///./public/app/plugins/datasource/elasticsearch/config_ctrl.ts","webpack:///./public/app/plugins/datasource/elasticsearch/components/ElasticsearchQueryField.tsx","webpack:///./public/app/plugins/datasource/elasticsearch/module.ts"],"names":["query_def_metricAggTypes","text","value","requiresField","supportsInlineScript","supportsMissing","isPipelineAgg","minVersion","supportsMultipleBucketPaths","query_def_bucketAggTypes","orderByOptions","orderOptions","sizeOptions","extendedStats","intervalOptions","movingAvgModelOptions","query_def_pipelineOptions","moving_avg","default","undefined","derivative","bucket_script","movingAvgModelSettings","simple","linear","ewma","holt","holt_winters","isCheckbox","getMetricAggTypes","esVersion","lodash_default","a","filter","f","metricType","po","isPipelineAggWithMultipleBucketPaths","find","t","getMovingAvgSettings","model","filtered","filteredResult","each","setting","push","describeMetric","metric","def","type","field","findMetricById","metrics","id","elastic_response_ElasticResponse","ElasticResponse","targets","response","this","prototype","processMetrics","esAgg","target","seriesList","props","y","i","newSeries","bucket","length","hide","datapoints","buckets","doc_count","key","percentiles","values","percentileName","statName","meta","stats","std_deviation_bounds_upper","std_deviation_bounds","upper","std_deviation_bounds_lower","lower","metricId","normalized_value","processAggregationDocs","aggDef","table","columns","_e","tslib_es6","keys","_f","next","done","propKey","addColumn","filterable","addMetricValue","metricName","_g","_h","_j","e_3","_k","propValues","_l","e_4","_m","getMetricName","rows","processBuckets","aggs","depth","aggId","maxDepth","bucketAggs","nameIndex","clone","key_as_string","metricDef","getSeriesName","series","metricTypeCount","alias","replace","match","g1","g2","group","indexOf","substring","agg","settings","script","_b","pipelineVariables","_c","pv","appliedAgg","pipelineAgg","name","propName","trim","nameSeries","uniq","map","processHits","hits","hit","doc","total","_id","_type","_index","_source","fields","trimDatapoints","aggregations","histogram","trimEdges","prop","points","slice","getErrorFromElasticResponse","err","result","data","JSON","stringify","root_cause","reason","message","$$config","config","getTimeSeries","responses","error","tmpSeriesList","table_model","getLogs","logMessageField","logLevelField","dataFrame","docs","n","propNames","flattened","Object","flatten","timeField","sort","grafana_data_src","addField","time","parse","v","string","propNames_1","e_6","propNames_1_1","propName_1","docs_1","e_7","docs_1_1","doc_1","add","labels","intervalMap","Hourly","startOf","amount","Daily","Weekly","Monthly","Yearly","index_pattern_IndexPattern","IndexPattern","pattern","interval","getIndexForToday","format","getIndexList","from","to","intervalInfo","start","utc","endEpoch","valueOf","indexList","query_builder_ElasticQueryBuilder","ElasticQueryBuilder","options","getRangeFilter","gte","lte","buildTermsAgg","queryNode","metricRef","terms","size","parseInt","orderBy","order","isNaN","min_doc_count","missing","getDateHistogramAgg","extended_bounds","min","max","offset","getHistogramAgg","getFiltersAgg","filterObj","filters","query","label","query_string","analyze_wildcard","documentQuery","unmapped_type","script_fields","fielddata_fields","docvalue_fields","addAdhocFilters","adhocFilters","condition","queryCondition","operator","bool","must","match_phrase","must_not","lt","range","gt","regexp","build","queryString","j","nestedAggs","precision","aggField","metricAgg","buckets_path","test","hasOwnProperty","getTermsQuery","queryDef","1","_a","keyname","getLogsQuery","querystring","datasource_ElasticDatasource","_super","ElasticDatasource","instanceSettings","$q","backendSrv","templateSrv","timeSrv","_this","call","basicAuth","withCredentials","url","index","database","settingsData","jsonData","indexPattern","timeInterval","maxConcurrentShardRequests","queryBuilder","$inject","request","method","headers","Authorization","datasourceRequest","get","timeRange","isArray","then","results","post","catch","annotationQuery","annotation","tagsField","textField","header","search_type","ignore_unavailable","payload","angular_default","toJson","res","list","getFieldFromSource","source","fieldName","fieldNames","split","fieldValue","console","log","isString","isNumber","event","tags","titleField","title","testDatasource","getFields","dateFields","status","getQueryHeader","searchType","timeFrom","timeTo","queryHeader","e_1","cloneDeep","sentTargets","targets_1","targets_1_1","scopedVars","queryObj","isLogsQuery","esQuery","Promise","resolve","toString","getMultiSearchUrl","er","some","configuredEsVersion","typeMap","float","double","integer","long","date","scaled_float","nested","shouldAddField","obj","fieldNameParts","getFieldsRecursively","subObj","isObject","properties","concat","join","pop","indexName","mappings","typeName","getTerms","metricFindQuery","fromJson","when","getTagKeys","getTagValues","e_2","variableExists","_d","bucketAgg","objectContainsTemplate","isPrimitive","e_5","item","bucket_agg_ElasticBucketAggCtrl","ElasticBucketAggCtrl","$scope","uiSegmentSrv","$rootScope","getBucketAggTypes","getOrderOptions","getSizeOptions","onAppEvent","validateModel","init","onChangeInternal","onChange","onTypeChanged","showOptions","isFirst","bucketAggCount","settingsLinkText","describeOrderBy","reduce","memo","substr","defaultTo","Math","addFiltersQuery","removeFiltersQuery","without","toggleOptions","getOrderByOptions","metricRefs","$fieldType","getIntervalOptions","transformToSegments","addBucketAgg","lastBucket","addIndex","val","splice","fake","removeBucketAgg","templateUrl","controller","metric_agg_ElasticMetricAggCtrl","ElasticMetricAggCtrl","metricAggs","metricAggTypes","pipelineAggOptions","modelSettingsValues","updatePipelineAggOptions","isSingle","variablesLinkText","RegExp","pipelineOptions","opt","precisionThreshold","precision_threshold","percents","movingAvgModelTypes","modelSettings","updateMovingAvgModelSettings","inlineScript","inline","toggleVariables","showVariables","modelSettingsKeys","onChangeClearInternal","minimize","onTypeChange","getFieldsInternal","removeMetricAgg","core_module","directive","ElasticPipelineVariablesCtrl","variables","newVariable","remove","ElasticQueryCtrl","$injector","datasource","refresh","queryUpdated","jsonStr","handleQueryError","bind","newJson","rawQueryOld","appEvent","getCollapsedText","bucketAggTypes","__webpack_require__","ElasticConfigCtrl","indexPatternTypes","example","esVersions","current","defaultMaxConcurrentShardRequests","indexPatternTypeChanged","startsWith","versionChanged","QueryField","components_ElasticsearchQueryField","context","override","onRunQuery","plugins","src","onlyIn","node","state","syntaxLoaded","ElasticsearchQueryField","componentDidMount","onChangeQuery","componentWillUnmount","componentDidUpdate","prevProps","render","queryResponse","react_default","createElement","Fragment","className","PureComponent","d","__webpack_exports__","module_plugin","ElasticAnnotationsQueryCtrl"],"mappings":"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","file":"elasticsearchPlugin.3932bda029d2299a9d96.js","sourcesContent":["import _ from 'lodash';\n\nexport const metricAggTypes = [\n  { text: 'Count', value: 'count', requiresField: false },\n  {\n    text: 'Average',\n    value: 'avg',\n    requiresField: true,\n    supportsInlineScript: true,\n    supportsMissing: true,\n  },\n  {\n    text: 'Sum',\n    value: 'sum',\n    requiresField: true,\n    supportsInlineScript: true,\n    supportsMissing: true,\n  },\n  {\n    text: 'Max',\n    value: 'max',\n    requiresField: true,\n    supportsInlineScript: true,\n    supportsMissing: true,\n  },\n  {\n    text: 'Min',\n    value: 'min',\n    requiresField: true,\n    supportsInlineScript: true,\n    supportsMissing: true,\n  },\n  {\n    text: 'Extended Stats',\n    value: 'extended_stats',\n    requiresField: true,\n    supportsMissing: true,\n    supportsInlineScript: true,\n  },\n  {\n    text: 'Percentiles',\n    value: 'percentiles',\n    requiresField: true,\n    supportsMissing: true,\n    supportsInlineScript: true,\n  },\n  {\n    text: 'Unique Count',\n    value: 'cardinality',\n    requiresField: true,\n    supportsMissing: true,\n  },\n  {\n    text: 'Moving Average',\n    value: 'moving_avg',\n    requiresField: false,\n    isPipelineAgg: true,\n    minVersion: 2,\n  },\n  {\n    text: 'Derivative',\n    value: 'derivative',\n    requiresField: false,\n    isPipelineAgg: true,\n    minVersion: 2,\n  },\n  {\n    text: 'Bucket Script',\n    value: 'bucket_script',\n    requiresField: false,\n    isPipelineAgg: true,\n    supportsMultipleBucketPaths: true,\n    minVersion: 2,\n  },\n  { text: 'Raw Document', value: 'raw_document', requiresField: false },\n];\n\nexport const bucketAggTypes = [\n  { text: 'Terms', value: 'terms', requiresField: true },\n  { text: 'Filters', value: 'filters' },\n  { text: 'Geo Hash Grid', value: 'geohash_grid', requiresField: true },\n  { text: 'Date Histogram', value: 'date_histogram', requiresField: true },\n  { text: 'Histogram', value: 'histogram', requiresField: true },\n];\n\nexport const orderByOptions = [{ text: 'Doc Count', value: '_count' }, { text: 'Term value', value: '_term' }];\n\nexport const orderOptions = [{ text: 'Top', value: 'desc' }, { text: 'Bottom', value: 'asc' }];\n\nexport const sizeOptions = [\n  { text: 'No limit', value: '0' },\n  { text: '1', value: '1' },\n  { text: '2', value: '2' },\n  { text: '3', value: '3' },\n  { text: '5', value: '5' },\n  { text: '10', value: '10' },\n  { text: '15', value: '15' },\n  { text: '20', value: '20' },\n];\n\nexport const extendedStats = [\n  { text: 'Avg', value: 'avg' },\n  { text: 'Min', value: 'min' },\n  { text: 'Max', value: 'max' },\n  { text: 'Sum', value: 'sum' },\n  { text: 'Count', value: 'count' },\n  { text: 'Std Dev', value: 'std_deviation' },\n  { text: 'Std Dev Upper', value: 'std_deviation_bounds_upper' },\n  { text: 'Std Dev Lower', value: 'std_deviation_bounds_lower' },\n];\n\nexport const intervalOptions = [\n  { text: 'auto', value: 'auto' },\n  { text: '10s', value: '10s' },\n  { text: '1m', value: '1m' },\n  { text: '5m', value: '5m' },\n  { text: '10m', value: '10m' },\n  { text: '20m', value: '20m' },\n  { text: '1h', value: '1h' },\n  { text: '1d', value: '1d' },\n];\n\nexport const movingAvgModelOptions = [\n  { text: 'Simple', value: 'simple' },\n  { text: 'Linear', value: 'linear' },\n  { text: 'Exponentially Weighted', value: 'ewma' },\n  { text: 'Holt Linear', value: 'holt' },\n  { text: 'Holt Winters', value: 'holt_winters' },\n];\n\nexport const pipelineOptions: any = {\n  moving_avg: [\n    { text: 'window', default: 5 },\n    { text: 'model', default: 'simple' },\n    { text: 'predict', default: undefined },\n    { text: 'minimize', default: false },\n  ],\n  derivative: [{ text: 'unit', default: undefined }],\n  bucket_script: [],\n};\n\nexport const movingAvgModelSettings: any = {\n  simple: [],\n  linear: [],\n  ewma: [{ text: 'Alpha', value: 'alpha', default: undefined }],\n  holt: [{ text: 'Alpha', value: 'alpha', default: undefined }, { text: 'Beta', value: 'beta', default: undefined }],\n  holt_winters: [\n    { text: 'Alpha', value: 'alpha', default: undefined },\n    { text: 'Beta', value: 'beta', default: undefined },\n    { text: 'Gamma', value: 'gamma', default: undefined },\n    { text: 'Period', value: 'period', default: undefined },\n    { text: 'Pad', value: 'pad', default: undefined, isCheckbox: true },\n  ],\n};\n\nexport function getMetricAggTypes(esVersion: any) {\n  return _.filter(metricAggTypes, f => {\n    if (f.minVersion) {\n      return f.minVersion <= esVersion;\n    } else {\n      return true;\n    }\n  });\n}\n\nexport function getPipelineOptions(metric: any) {\n  if (!isPipelineAgg(metric.type)) {\n    return [];\n  }\n\n  return pipelineOptions[metric.type];\n}\n\nexport function isPipelineAgg(metricType: any) {\n  if (metricType) {\n    const po = pipelineOptions[metricType];\n    return po !== null && po !== undefined;\n  }\n\n  return false;\n}\n\nexport function isPipelineAggWithMultipleBucketPaths(metricType: any) {\n  if (metricType) {\n    return metricAggTypes.find(t => t.value === metricType && t.supportsMultipleBucketPaths) !== undefined;\n  }\n\n  return false;\n}\n\nexport function getPipelineAggOptions(targets: any) {\n  const result: any[] = [];\n  _.each(targets.metrics, metric => {\n    if (!isPipelineAgg(metric.type)) {\n      result.push({ text: describeMetric(metric), value: metric.id });\n    }\n  });\n\n  return result;\n}\n\nexport function getMovingAvgSettings(model: any, filtered: boolean) {\n  const filteredResult: any[] = [];\n  if (filtered) {\n    _.each(movingAvgModelSettings[model], setting => {\n      if (!setting.isCheckbox) {\n        filteredResult.push(setting);\n      }\n    });\n    return filteredResult;\n  }\n  return movingAvgModelSettings[model];\n}\n\nexport function getOrderByOptions(target: any) {\n  const metricRefs: any[] = [];\n  _.each(target.metrics, metric => {\n    if (metric.type !== 'count') {\n      metricRefs.push({ text: describeMetric(metric), value: metric.id });\n    }\n  });\n\n  return orderByOptions.concat(metricRefs);\n}\n\nexport function describeOrder(order: string) {\n  const def: any = _.find(orderOptions, { value: order });\n  return def.text;\n}\n\nexport function describeMetric(metric: { type: string; field: string }) {\n  const def: any = _.find(metricAggTypes, { value: metric.type });\n  if (!def.requiresField && !isPipelineAgg(metric.type)) {\n    return def.text;\n  }\n  return def.text + ' ' + metric.field;\n}\n\nexport function describeOrderBy(orderBy: any, target: any) {\n  const def: any = _.find(orderByOptions, { value: orderBy });\n  if (def) {\n    return def.text;\n  }\n  const metric: any = _.find(target.metrics, { id: orderBy });\n  if (metric) {\n    return describeMetric(metric);\n  } else {\n    return 'metric not found';\n  }\n}\n\nexport function defaultMetricAgg() {\n  return { type: 'count', id: '1' };\n}\n\nexport function defaultBucketAgg() {\n  return { type: 'date_histogram', id: '2', settings: { interval: 'auto' } };\n}\n\nexport const findMetricById = (metrics: any[], id: any) => {\n  return _.find(metrics, { id: id });\n};\n","import _ from 'lodash';\nimport flatten from 'app/core/utils/flatten';\nimport * as queryDef from './query_def';\nimport TableModel from 'app/core/table_model';\nimport { DataFrame, toDataFrame, FieldType, MutableDataFrame } from '@grafana/data';\nimport { DataQueryResponse } from '@grafana/ui';\nimport { ElasticsearchAggregation } from './types';\n\nexport class ElasticResponse {\n  constructor(private targets: any, private response: any) {\n    this.targets = targets;\n    this.response = response;\n  }\n\n  processMetrics(esAgg: any, target: any, seriesList: any, props: any) {\n    let metric, y, i, newSeries, bucket, value;\n\n    for (y = 0; y < target.metrics.length; y++) {\n      metric = target.metrics[y];\n      if (metric.hide) {\n        continue;\n      }\n\n      switch (metric.type) {\n        case 'count': {\n          newSeries = { datapoints: [], metric: 'count', props: props };\n          for (i = 0; i < esAgg.buckets.length; i++) {\n            bucket = esAgg.buckets[i];\n            value = bucket.doc_count;\n            newSeries.datapoints.push([value, bucket.key]);\n          }\n          seriesList.push(newSeries);\n          break;\n        }\n        case 'percentiles': {\n          if (esAgg.buckets.length === 0) {\n            break;\n          }\n\n          const firstBucket = esAgg.buckets[0];\n          const percentiles = firstBucket[metric.id].values;\n\n          for (const percentileName in percentiles) {\n            newSeries = {\n              datapoints: [],\n              metric: 'p' + percentileName,\n              props: props,\n              field: metric.field,\n            };\n\n            for (i = 0; i < esAgg.buckets.length; i++) {\n              bucket = esAgg.buckets[i];\n              const values = bucket[metric.id].values;\n              newSeries.datapoints.push([values[percentileName], bucket.key]);\n            }\n            seriesList.push(newSeries);\n          }\n\n          break;\n        }\n        case 'extended_stats': {\n          for (const statName in metric.meta) {\n            if (!metric.meta[statName]) {\n              continue;\n            }\n\n            newSeries = {\n              datapoints: [],\n              metric: statName,\n              props: props,\n              field: metric.field,\n            };\n\n            for (i = 0; i < esAgg.buckets.length; i++) {\n              bucket = esAgg.buckets[i];\n              const stats = bucket[metric.id];\n\n              // add stats that are in nested obj to top level obj\n              stats.std_deviation_bounds_upper = stats.std_deviation_bounds.upper;\n              stats.std_deviation_bounds_lower = stats.std_deviation_bounds.lower;\n\n              newSeries.datapoints.push([stats[statName], bucket.key]);\n            }\n\n            seriesList.push(newSeries);\n          }\n\n          break;\n        }\n        default: {\n          newSeries = {\n            datapoints: [],\n            metric: metric.type,\n            field: metric.field,\n            metricId: metric.id,\n            props: props,\n          };\n          for (i = 0; i < esAgg.buckets.length; i++) {\n            bucket = esAgg.buckets[i];\n\n            value = bucket[metric.id];\n            if (value !== undefined) {\n              if (value.normalized_value) {\n                newSeries.datapoints.push([value.normalized_value, bucket.key]);\n              } else {\n                newSeries.datapoints.push([value.value, bucket.key]);\n              }\n            }\n          }\n          seriesList.push(newSeries);\n          break;\n        }\n      }\n    }\n  }\n\n  processAggregationDocs(esAgg: any, aggDef: ElasticsearchAggregation, target: any, table: any, props: any) {\n    // add columns\n    if (table.columns.length === 0) {\n      for (const propKey of _.keys(props)) {\n        table.addColumn({ text: propKey, filterable: true });\n      }\n      table.addColumn({ text: aggDef.field, filterable: true });\n    }\n\n    // helper func to add values to value array\n    const addMetricValue = (values: any[], metricName: string, value: any) => {\n      table.addColumn({ text: metricName });\n      values.push(value);\n    };\n\n    for (const bucket of esAgg.buckets) {\n      const values = [];\n\n      for (const propValues of _.values(props)) {\n        values.push(propValues);\n      }\n\n      // add bucket key (value)\n      values.push(bucket.key);\n\n      for (const metric of target.metrics) {\n        switch (metric.type) {\n          case 'count': {\n            addMetricValue(values, this.getMetricName(metric.type), bucket.doc_count);\n            break;\n          }\n          case 'extended_stats': {\n            for (const statName in metric.meta) {\n              if (!metric.meta[statName]) {\n                continue;\n              }\n\n              const stats = bucket[metric.id];\n              // add stats that are in nested obj to top level obj\n              stats.std_deviation_bounds_upper = stats.std_deviation_bounds.upper;\n              stats.std_deviation_bounds_lower = stats.std_deviation_bounds.lower;\n\n              addMetricValue(values, this.getMetricName(statName), stats[statName]);\n            }\n            break;\n          }\n          case 'percentiles': {\n            const percentiles = bucket[metric.id].values;\n\n            for (const percentileName in percentiles) {\n              addMetricValue(values, `p${percentileName} ${metric.field}`, percentiles[percentileName]);\n            }\n            break;\n          }\n          default: {\n            let metricName = this.getMetricName(metric.type);\n            const otherMetrics = _.filter(target.metrics, { type: metric.type });\n\n            // if more of the same metric type include field field name in property\n            if (otherMetrics.length > 1) {\n              metricName += ' ' + metric.field;\n            }\n\n            addMetricValue(values, metricName, bucket[metric.id].value);\n            break;\n          }\n        }\n      }\n\n      table.rows.push(values);\n    }\n  }\n\n  // This is quite complex\n  // need to recurse down the nested buckets to build series\n  processBuckets(aggs: any, target: any, seriesList: any, table: any, props: any, depth: any) {\n    let bucket, aggDef: any, esAgg, aggId;\n    const maxDepth = target.bucketAggs.length - 1;\n\n    for (aggId in aggs) {\n      aggDef = _.find(target.bucketAggs, { id: aggId });\n      esAgg = aggs[aggId];\n\n      if (!aggDef) {\n        continue;\n      }\n\n      if (depth === maxDepth) {\n        if (aggDef.type === 'date_histogram') {\n          this.processMetrics(esAgg, target, seriesList, props);\n        } else {\n          this.processAggregationDocs(esAgg, aggDef, target, table, props);\n        }\n      } else {\n        for (const nameIndex in esAgg.buckets) {\n          bucket = esAgg.buckets[nameIndex];\n          props = _.clone(props);\n          if (bucket.key !== void 0) {\n            props[aggDef.field] = bucket.key;\n          } else {\n            props['filter'] = nameIndex;\n          }\n          if (bucket.key_as_string) {\n            props[aggDef.field] = bucket.key_as_string;\n          }\n          this.processBuckets(bucket, target, seriesList, table, props, depth + 1);\n        }\n      }\n    }\n  }\n\n  private getMetricName(metric: any) {\n    let metricDef: any = _.find(queryDef.metricAggTypes, { value: metric });\n    if (!metricDef) {\n      metricDef = _.find(queryDef.extendedStats, { value: metric });\n    }\n\n    return metricDef ? metricDef.text : metric;\n  }\n\n  private getSeriesName(series: any, target: any, metricTypeCount: any) {\n    let metricName = this.getMetricName(series.metric);\n\n    if (target.alias) {\n      const regex = /\\{\\{([\\s\\S]+?)\\}\\}/g;\n\n      return target.alias.replace(regex, (match: any, g1: any, g2: any) => {\n        const group = g1 || g2;\n\n        if (group.indexOf('term ') === 0) {\n          return series.props[group.substring(5)];\n        }\n        if (series.props[group] !== void 0) {\n          return series.props[group];\n        }\n        if (group === 'metric') {\n          return metricName;\n        }\n        if (group === 'field') {\n          return series.field || '';\n        }\n\n        return match;\n      });\n    }\n\n    if (series.field && queryDef.isPipelineAgg(series.metric)) {\n      if (series.metric && queryDef.isPipelineAggWithMultipleBucketPaths(series.metric)) {\n        const agg: any = _.find(target.metrics, { id: series.metricId });\n        if (agg && agg.settings.script) {\n          metricName = agg.settings.script;\n\n          for (const pv of agg.pipelineVariables) {\n            const appliedAgg: any = _.find(target.metrics, { id: pv.pipelineAgg });\n            if (appliedAgg) {\n              metricName = metricName.replace('params.' + pv.name, queryDef.describeMetric(appliedAgg));\n            }\n          }\n        } else {\n          metricName = 'Unset';\n        }\n      } else {\n        const appliedAgg: any = _.find(target.metrics, { id: series.field });\n        if (appliedAgg) {\n          metricName += ' ' + queryDef.describeMetric(appliedAgg);\n        } else {\n          metricName = 'Unset';\n        }\n      }\n    } else if (series.field) {\n      metricName += ' ' + series.field;\n    }\n\n    const propKeys = _.keys(series.props);\n    if (propKeys.length === 0) {\n      return metricName;\n    }\n\n    let name = '';\n    for (const propName in series.props) {\n      name += series.props[propName] + ' ';\n    }\n\n    if (metricTypeCount === 1) {\n      return name.trim();\n    }\n\n    return name.trim() + ' ' + metricName;\n  }\n\n  nameSeries(seriesList: any, target: any) {\n    const metricTypeCount = _.uniq(_.map(seriesList, 'metric')).length;\n\n    for (let i = 0; i < seriesList.length; i++) {\n      const series = seriesList[i];\n      series.target = this.getSeriesName(series, target, metricTypeCount);\n    }\n  }\n\n  processHits(hits: { total: { value: any }; hits: any[] }, seriesList: any[]) {\n    const hitsTotal = typeof hits.total === 'number' ? hits.total : hits.total.value; // <- Works with Elasticsearch 7.0+\n\n    const series: any = {\n      target: 'docs',\n      type: 'docs',\n      datapoints: [],\n      total: hitsTotal,\n      filterable: true,\n    };\n    let propName, hit, doc: any, i;\n\n    for (i = 0; i < hits.hits.length; i++) {\n      hit = hits.hits[i];\n      doc = {\n        _id: hit._id,\n        _type: hit._type,\n        _index: hit._index,\n      };\n\n      if (hit._source) {\n        for (propName in hit._source) {\n          doc[propName] = hit._source[propName];\n        }\n      }\n\n      for (propName in hit.fields) {\n        doc[propName] = hit.fields[propName];\n      }\n      series.datapoints.push(doc);\n    }\n\n    seriesList.push(series);\n  }\n\n  trimDatapoints(aggregations: any, target: any) {\n    const histogram: any = _.find(target.bucketAggs, { type: 'date_histogram' });\n\n    const shouldDropFirstAndLast = histogram && histogram.settings && histogram.settings.trimEdges;\n    if (shouldDropFirstAndLast) {\n      const trim = histogram.settings.trimEdges;\n      for (const prop in aggregations) {\n        const points = aggregations[prop];\n        if (points.datapoints.length > trim * 2) {\n          points.datapoints = points.datapoints.slice(trim, points.datapoints.length - trim);\n        }\n      }\n    }\n  }\n\n  getErrorFromElasticResponse(response: any, err: any) {\n    const result: any = {};\n    result.data = JSON.stringify(err, null, 4);\n    if (err.root_cause && err.root_cause.length > 0 && err.root_cause[0].reason) {\n      result.message = err.root_cause[0].reason;\n    } else {\n      result.message = err.reason || 'Unkown elastic error response';\n    }\n\n    if (response.$$config) {\n      result.config = response.$$config;\n    }\n\n    return result;\n  }\n\n  getTimeSeries() {\n    const seriesList = [];\n\n    for (let i = 0; i < this.response.responses.length; i++) {\n      const response = this.response.responses[i];\n      if (response.error) {\n        throw this.getErrorFromElasticResponse(this.response, response.error);\n      }\n\n      if (response.hits && response.hits.hits.length > 0) {\n        this.processHits(response.hits, seriesList);\n      }\n\n      if (response.aggregations) {\n        const aggregations = response.aggregations;\n        const target = this.targets[i];\n        const tmpSeriesList: any[] = [];\n        const table = new TableModel();\n\n        this.processBuckets(aggregations, target, tmpSeriesList, table, {}, 0);\n        this.trimDatapoints(tmpSeriesList, target);\n        this.nameSeries(tmpSeriesList, target);\n\n        for (let y = 0; y < tmpSeriesList.length; y++) {\n          seriesList.push(tmpSeriesList[y]);\n        }\n\n        if (table.rows.length > 0) {\n          seriesList.push(table);\n        }\n      }\n    }\n\n    return { data: seriesList };\n  }\n\n  getLogs(logMessageField?: string, logLevelField?: string): DataQueryResponse {\n    const dataFrame: DataFrame[] = [];\n    const docs: any[] = [];\n\n    for (let n = 0; n < this.response.responses.length; n++) {\n      const response = this.response.responses[n];\n      if (response.error) {\n        throw this.getErrorFromElasticResponse(this.response, response.error);\n      }\n\n      const hits = response.hits;\n      let propNames: string[] = [];\n      let propName, hit, doc: any, i;\n\n      for (i = 0; i < hits.hits.length; i++) {\n        hit = hits.hits[i];\n        const flattened = hit._source ? flatten(hit._source, null) : {};\n        doc = {};\n        doc[this.targets[0].timeField] = null;\n        doc = {\n          ...doc,\n          _id: hit._id,\n          _type: hit._type,\n          _index: hit._index,\n          ...flattened,\n        };\n\n        // Note: the order of for...in is arbitrary amd implementation dependant\n        // and should probably not be relied upon.\n        for (propName in hit.fields) {\n          if (propNames.indexOf(propName) === -1) {\n            propNames.push(propName);\n          }\n          doc[propName] = hit.fields[propName];\n        }\n\n        for (propName in doc) {\n          if (propNames.indexOf(propName) === -1) {\n            propNames.push(propName);\n          }\n        }\n\n        doc._source = { ...flattened };\n\n        docs.push(doc);\n      }\n\n      if (docs.length > 0) {\n        propNames = propNames.sort();\n        const series = new MutableDataFrame({ fields: [] });\n\n        series.addField({\n          name: this.targets[0].timeField,\n          type: FieldType.time,\n        }).parse = (v: any) => {\n          return v[0] || '';\n        };\n\n        if (logMessageField) {\n          series.addField({\n            name: logMessageField,\n            type: FieldType.string,\n          }).parse = (v: any) => {\n            return v || '';\n          };\n        } else {\n          series.addField({\n            name: '_source',\n            type: FieldType.string,\n          }).parse = (v: any) => {\n            return JSON.stringify(v, null, 2);\n          };\n        }\n\n        if (logLevelField) {\n          series.addField({\n            name: 'level',\n            type: FieldType.string,\n          }).parse = (v: any) => {\n            return v || '';\n          };\n        }\n\n        for (const propName of propNames) {\n          if (propName === this.targets[0].timeField || propName === '_source') {\n            continue;\n          }\n\n          series.addField({\n            name: propName,\n            type: FieldType.string,\n          }).parse = (v: any) => {\n            return v || '';\n          };\n        }\n\n        // Add a row for each document\n        for (const doc of docs) {\n          series.add(doc);\n        }\n\n        dataFrame.push(series);\n      }\n\n      if (response.aggregations) {\n        const aggregations = response.aggregations;\n        const target = this.targets[n];\n        const tmpSeriesList: any[] = [];\n        const table = new TableModel();\n\n        this.processBuckets(aggregations, target, tmpSeriesList, table, {}, 0);\n        this.trimDatapoints(tmpSeriesList, target);\n        this.nameSeries(tmpSeriesList, target);\n\n        for (let y = 0; y < tmpSeriesList.length; y++) {\n          const series = toDataFrame(tmpSeriesList[y]);\n          series.labels = {};\n          dataFrame.push(series);\n        }\n      }\n    }\n\n    return { data: dataFrame };\n  }\n}\n","import { toUtc, dateTime } from '@grafana/data';\n\nconst intervalMap: any = {\n  Hourly: { startOf: 'hour', amount: 'hours' },\n  Daily: { startOf: 'day', amount: 'days' },\n  Weekly: { startOf: 'isoWeek', amount: 'weeks' },\n  Monthly: { startOf: 'month', amount: 'months' },\n  Yearly: { startOf: 'year', amount: 'years' },\n};\n\nexport class IndexPattern {\n  constructor(private pattern: any, private interval: string | null) {}\n\n  getIndexForToday() {\n    if (this.interval) {\n      return toUtc().format(this.pattern);\n    } else {\n      return this.pattern;\n    }\n  }\n\n  getIndexList(from: any, to: any) {\n    if (!this.interval) {\n      return this.pattern;\n    }\n\n    const intervalInfo = intervalMap[this.interval];\n    const start = dateTime(from)\n      .utc()\n      .startOf(intervalInfo.startOf);\n    const endEpoch = dateTime(to)\n      .utc()\n      .startOf(intervalInfo.startOf)\n      .valueOf();\n    const indexList = [];\n\n    while (start.valueOf() <= endEpoch) {\n      indexList.push(start.format(this.pattern));\n      start.add(1, intervalInfo.amount);\n    }\n\n    return indexList;\n  }\n}\n","import * as queryDef from './query_def';\nimport { ElasticsearchAggregation } from './types';\n\nexport class ElasticQueryBuilder {\n  timeField: string;\n  esVersion: number;\n\n  constructor(options: any) {\n    this.timeField = options.timeField;\n    this.esVersion = options.esVersion;\n  }\n\n  getRangeFilter() {\n    const filter: any = {};\n    filter[this.timeField] = {\n      gte: '$timeFrom',\n      lte: '$timeTo',\n      format: 'epoch_millis',\n    };\n\n    return filter;\n  }\n\n  buildTermsAgg(aggDef: ElasticsearchAggregation, queryNode: { terms?: any; aggs?: any }, target: { metrics: any[] }) {\n    let metricRef, metric, y;\n    queryNode.terms = { field: aggDef.field };\n\n    if (!aggDef.settings) {\n      return queryNode;\n    }\n\n    queryNode.terms.size = parseInt(aggDef.settings.size, 10) === 0 ? 500 : parseInt(aggDef.settings.size, 10);\n    if (aggDef.settings.orderBy !== void 0) {\n      queryNode.terms.order = {};\n      if (aggDef.settings.orderBy === '_term' && this.esVersion >= 60) {\n        queryNode.terms.order['_key'] = aggDef.settings.order;\n      } else {\n        queryNode.terms.order[aggDef.settings.orderBy] = aggDef.settings.order;\n      }\n\n      // if metric ref, look it up and add it to this agg level\n      metricRef = parseInt(aggDef.settings.orderBy, 10);\n      if (!isNaN(metricRef)) {\n        for (y = 0; y < target.metrics.length; y++) {\n          metric = target.metrics[y];\n          if (metric.id === aggDef.settings.orderBy) {\n            queryNode.aggs = {};\n            queryNode.aggs[metric.id] = {};\n            queryNode.aggs[metric.id][metric.type] = { field: metric.field };\n            break;\n          }\n        }\n      }\n    }\n\n    if (aggDef.settings.min_doc_count !== void 0) {\n      queryNode.terms.min_doc_count = parseInt(aggDef.settings.min_doc_count, 10);\n    }\n\n    if (aggDef.settings.missing) {\n      queryNode.terms.missing = aggDef.settings.missing;\n    }\n\n    return queryNode;\n  }\n\n  getDateHistogramAgg(aggDef: ElasticsearchAggregation) {\n    const esAgg: any = {};\n    const settings = aggDef.settings || {};\n    esAgg.interval = settings.interval;\n    esAgg.field = this.timeField;\n    esAgg.min_doc_count = settings.min_doc_count || 0;\n    esAgg.extended_bounds = { min: '$timeFrom', max: '$timeTo' };\n    esAgg.format = 'epoch_millis';\n\n    if (settings.offset !== '') {\n      esAgg.offset = settings.offset;\n    }\n\n    if (esAgg.interval === 'auto') {\n      esAgg.interval = '$__interval';\n    }\n\n    if (settings.missing) {\n      esAgg.missing = settings.missing;\n    }\n\n    return esAgg;\n  }\n\n  getHistogramAgg(aggDef: ElasticsearchAggregation) {\n    const esAgg: any = {};\n    const settings = aggDef.settings || {};\n    esAgg.interval = settings.interval;\n    esAgg.field = aggDef.field;\n    esAgg.min_doc_count = settings.min_doc_count || 0;\n\n    if (settings.missing) {\n      esAgg.missing = settings.missing;\n    }\n    return esAgg;\n  }\n\n  getFiltersAgg(aggDef: ElasticsearchAggregation) {\n    const filterObj: any = {};\n    for (let i = 0; i < aggDef.settings.filters.length; i++) {\n      const query = aggDef.settings.filters[i].query;\n      let label = aggDef.settings.filters[i].label;\n      label = label === '' || label === undefined ? query : label;\n      filterObj[label] = {\n        query_string: {\n          query: query,\n          analyze_wildcard: true,\n        },\n      };\n    }\n\n    return filterObj;\n  }\n\n  documentQuery(query: any, size: number) {\n    query.size = size;\n    query.sort = {};\n    query.sort[this.timeField] = { order: 'desc', unmapped_type: 'boolean' };\n\n    // fields field not supported on ES 5.x\n    if (this.esVersion < 5) {\n      query.fields = ['*', '_source'];\n    }\n\n    query.script_fields = {};\n    if (this.esVersion < 5) {\n      query.fielddata_fields = [this.timeField];\n    } else {\n      query.docvalue_fields = [this.timeField];\n    }\n    return query;\n  }\n\n  addAdhocFilters(query: any, adhocFilters: any) {\n    if (!adhocFilters) {\n      return;\n    }\n\n    let i, filter, condition: any, queryCondition: any;\n\n    for (i = 0; i < adhocFilters.length; i++) {\n      filter = adhocFilters[i];\n      condition = {};\n      condition[filter.key] = filter.value;\n      queryCondition = {};\n      queryCondition[filter.key] = { query: filter.value };\n\n      switch (filter.operator) {\n        case '=':\n          if (!query.query.bool.must) {\n            query.query.bool.must = [];\n          }\n          query.query.bool.must.push({ match_phrase: queryCondition });\n          break;\n        case '!=':\n          if (!query.query.bool.must_not) {\n            query.query.bool.must_not = [];\n          }\n          query.query.bool.must_not.push({ match_phrase: queryCondition });\n          break;\n        case '<':\n          condition[filter.key] = { lt: filter.value };\n          query.query.bool.filter.push({ range: condition });\n          break;\n        case '>':\n          condition[filter.key] = { gt: filter.value };\n          query.query.bool.filter.push({ range: condition });\n          break;\n        case '=~':\n          query.query.bool.filter.push({ regexp: condition });\n          break;\n        case '!~':\n          query.query.bool.filter.push({\n            bool: { must_not: { regexp: condition } },\n          });\n          break;\n      }\n    }\n  }\n\n  build(target: any, adhocFilters?: any, queryString?: string) {\n    // make sure query has defaults;\n    target.metrics = target.metrics || [queryDef.defaultMetricAgg()];\n    target.bucketAggs = target.bucketAggs || [queryDef.defaultBucketAgg()];\n    target.timeField = this.timeField;\n\n    let i, j, pv, nestedAggs, metric;\n    const query = {\n      size: 0,\n      query: {\n        bool: {\n          filter: [\n            { range: this.getRangeFilter() },\n            {\n              query_string: {\n                analyze_wildcard: true,\n                query: queryString,\n              },\n            },\n          ],\n        },\n      },\n    };\n\n    this.addAdhocFilters(query, adhocFilters);\n\n    // handle document query\n    if (target.bucketAggs.length === 0) {\n      metric = target.metrics[0];\n      if (!metric || metric.type !== 'raw_document') {\n        throw { message: 'Invalid query' };\n      }\n\n      const size = (metric.settings && metric.settings.size) || 500;\n      return this.documentQuery(query, size);\n    }\n\n    nestedAggs = query;\n\n    for (i = 0; i < target.bucketAggs.length; i++) {\n      const aggDef = target.bucketAggs[i];\n      const esAgg: any = {};\n\n      switch (aggDef.type) {\n        case 'date_histogram': {\n          esAgg['date_histogram'] = this.getDateHistogramAgg(aggDef);\n          break;\n        }\n        case 'histogram': {\n          esAgg['histogram'] = this.getHistogramAgg(aggDef);\n          break;\n        }\n        case 'filters': {\n          esAgg['filters'] = { filters: this.getFiltersAgg(aggDef) };\n          break;\n        }\n        case 'terms': {\n          this.buildTermsAgg(aggDef, esAgg, target);\n          break;\n        }\n        case 'geohash_grid': {\n          esAgg['geohash_grid'] = {\n            field: aggDef.field,\n            precision: aggDef.settings.precision,\n          };\n          break;\n        }\n      }\n\n      nestedAggs.aggs = nestedAggs.aggs || {};\n      nestedAggs.aggs[aggDef.id] = esAgg;\n      nestedAggs = esAgg;\n    }\n\n    nestedAggs.aggs = {};\n\n    for (i = 0; i < target.metrics.length; i++) {\n      metric = target.metrics[i];\n      if (metric.type === 'count') {\n        continue;\n      }\n\n      const aggField: any = {};\n      let metricAgg: any = null;\n\n      if (queryDef.isPipelineAgg(metric.type)) {\n        if (queryDef.isPipelineAggWithMultipleBucketPaths(metric.type)) {\n          if (metric.pipelineVariables) {\n            metricAgg = {\n              buckets_path: {},\n            };\n\n            for (j = 0; j < metric.pipelineVariables.length; j++) {\n              pv = metric.pipelineVariables[j];\n\n              if (pv.name && pv.pipelineAgg && /^\\d*$/.test(pv.pipelineAgg)) {\n                const appliedAgg = queryDef.findMetricById(target.metrics, pv.pipelineAgg);\n                if (appliedAgg) {\n                  if (appliedAgg.type === 'count') {\n                    metricAgg.buckets_path[pv.name] = '_count';\n                  } else {\n                    metricAgg.buckets_path[pv.name] = pv.pipelineAgg;\n                  }\n                }\n              }\n            }\n          } else {\n            continue;\n          }\n        } else {\n          if (metric.pipelineAgg && /^\\d*$/.test(metric.pipelineAgg)) {\n            const appliedAgg = queryDef.findMetricById(target.metrics, metric.pipelineAgg);\n            if (appliedAgg) {\n              if (appliedAgg.type === 'count') {\n                metricAgg = { buckets_path: '_count' };\n              } else {\n                metricAgg = { buckets_path: metric.pipelineAgg };\n              }\n            }\n          } else {\n            continue;\n          }\n        }\n      } else {\n        metricAgg = { field: metric.field };\n      }\n\n      for (const prop in metric.settings) {\n        if (metric.settings.hasOwnProperty(prop) && metric.settings[prop] !== null) {\n          metricAgg[prop] = metric.settings[prop];\n        }\n      }\n\n      aggField[metric.type] = metricAgg;\n      nestedAggs.aggs[metric.id] = aggField;\n    }\n\n    return query;\n  }\n\n  getTermsQuery(queryDef: any) {\n    const query: any = {\n      size: 0,\n      query: {\n        bool: {\n          filter: [{ range: this.getRangeFilter() }],\n        },\n      },\n    };\n\n    if (queryDef.query) {\n      query.query.bool.filter.push({\n        query_string: {\n          analyze_wildcard: true,\n          query: queryDef.query,\n        },\n      });\n    }\n\n    let size = 500;\n    if (queryDef.size) {\n      size = queryDef.size;\n    }\n\n    query.aggs = {\n      '1': {\n        terms: {\n          field: queryDef.field,\n          size: size,\n          order: {},\n        },\n      },\n    };\n\n    // Default behaviour is to order results by { _key: asc }\n    // queryDef.order allows selection of asc/desc\n    // queryDef.orderBy allows selection of doc_count ordering (defaults desc)\n\n    const { orderBy = 'key', order = orderBy === 'doc_count' ? 'desc' : 'asc' } = queryDef;\n\n    if (['asc', 'desc'].indexOf(order) < 0) {\n      throw { message: `Invalid query sort order ${order}` };\n    }\n\n    switch (orderBy) {\n      case 'key':\n      case 'term':\n        const keyname = this.esVersion >= 60 ? '_key' : '_term';\n        query.aggs['1'].terms.order[keyname] = order;\n        break;\n      case 'doc_count':\n        query.aggs['1'].terms.order['_count'] = order;\n        break;\n      default:\n        throw { message: `Invalid query sort type ${orderBy}` };\n    }\n\n    return query;\n  }\n\n  getLogsQuery(target: any, querystring: string) {\n    let query: any = {\n      size: 0,\n      query: {\n        bool: {\n          filter: [{ range: this.getRangeFilter() }],\n        },\n      },\n    };\n\n    if (target.query) {\n      query.query.bool.filter.push({\n        query_string: {\n          analyze_wildcard: true,\n          query: target.query,\n        },\n      });\n    }\n\n    query = this.documentQuery(query, 500);\n\n    return {\n      ...query,\n      aggs: this.build(target, null, querystring).aggs,\n    };\n  }\n}\n","import angular, { IQService } from 'angular';\nimport _ from 'lodash';\nimport { DataSourceApi, DataSourceInstanceSettings, DataQueryRequest, DataQueryResponse } from '@grafana/ui';\nimport { ElasticResponse } from './elastic_response';\nimport { IndexPattern } from './index_pattern';\nimport { ElasticQueryBuilder } from './query_builder';\nimport { toUtc } from '@grafana/data';\nimport * as queryDef from './query_def';\nimport { BackendSrv } from 'app/core/services/backend_srv';\nimport { TemplateSrv } from 'app/features/templating/template_srv';\nimport { TimeSrv } from 'app/features/dashboard/services/TimeSrv';\nimport { ElasticsearchOptions, ElasticsearchQuery } from './types';\n\nexport class ElasticDatasource extends DataSourceApi<ElasticsearchQuery, ElasticsearchOptions> {\n  basicAuth: string;\n  withCredentials: boolean;\n  url: string;\n  name: string;\n  index: string;\n  timeField: string;\n  esVersion: number;\n  interval: string;\n  maxConcurrentShardRequests: number;\n  queryBuilder: ElasticQueryBuilder;\n  indexPattern: IndexPattern;\n  logMessageField?: string;\n  logLevelField?: string;\n\n  /** @ngInject */\n  constructor(\n    instanceSettings: DataSourceInstanceSettings<ElasticsearchOptions>,\n    private $q: IQService,\n    private backendSrv: BackendSrv,\n    private templateSrv: TemplateSrv,\n    private timeSrv: TimeSrv\n  ) {\n    super(instanceSettings);\n    this.basicAuth = instanceSettings.basicAuth;\n    this.withCredentials = instanceSettings.withCredentials;\n    this.url = instanceSettings.url;\n    this.name = instanceSettings.name;\n    this.index = instanceSettings.database;\n    const settingsData = instanceSettings.jsonData || ({} as ElasticsearchOptions);\n\n    this.timeField = settingsData.timeField;\n    this.esVersion = settingsData.esVersion;\n    this.indexPattern = new IndexPattern(this.index, settingsData.interval);\n    this.interval = settingsData.timeInterval;\n    this.maxConcurrentShardRequests = settingsData.maxConcurrentShardRequests;\n    this.queryBuilder = new ElasticQueryBuilder({\n      timeField: this.timeField,\n      esVersion: this.esVersion,\n    });\n    this.logMessageField = settingsData.logMessageField || '';\n    this.logLevelField = settingsData.logLevelField || '';\n\n    if (this.logMessageField === '') {\n      this.logMessageField = null;\n    }\n\n    if (this.logLevelField === '') {\n      this.logLevelField = null;\n    }\n  }\n\n  private request(method: string, url: string, data?: undefined) {\n    const options: any = {\n      url: this.url + '/' + url,\n      method: method,\n      data: data,\n    };\n\n    if (this.basicAuth || this.withCredentials) {\n      options.withCredentials = true;\n    }\n    if (this.basicAuth) {\n      options.headers = {\n        Authorization: this.basicAuth,\n      };\n    }\n\n    return this.backendSrv.datasourceRequest(options);\n  }\n\n  private get(url: string) {\n    const range = this.timeSrv.timeRange();\n    const indexList = this.indexPattern.getIndexList(range.from.valueOf(), range.to.valueOf());\n    if (_.isArray(indexList) && indexList.length) {\n      return this.request('GET', indexList[0] + url).then((results: any) => {\n        results.data.$$config = results.config;\n        return results.data;\n      });\n    } else {\n      return this.request('GET', this.indexPattern.getIndexForToday() + url).then((results: any) => {\n        results.data.$$config = results.config;\n        return results.data;\n      });\n    }\n  }\n\n  private post(url: string, data: any) {\n    return this.request('POST', url, data)\n      .then((results: any) => {\n        results.data.$$config = results.config;\n        return results.data;\n      })\n      .catch((err: any) => {\n        if (err.data && err.data.error) {\n          throw {\n            message: 'Elasticsearch error: ' + err.data.error.reason,\n            error: err.data.error,\n          };\n        }\n\n        throw err;\n      });\n  }\n\n  annotationQuery(options: any) {\n    const annotation = options.annotation;\n    const timeField = annotation.timeField || '@timestamp';\n    const queryString = annotation.query || '*';\n    const tagsField = annotation.tagsField || 'tags';\n    const textField = annotation.textField || null;\n\n    const range: any = {};\n    range[timeField] = {\n      from: options.range.from.valueOf(),\n      to: options.range.to.valueOf(),\n      format: 'epoch_millis',\n    };\n\n    const queryInterpolated = this.templateSrv.replace(queryString, {}, 'lucene');\n    const query = {\n      bool: {\n        filter: [\n          { range: range },\n          {\n            query_string: {\n              query: queryInterpolated,\n            },\n          },\n        ],\n      },\n    };\n\n    const data: any = {\n      query,\n      size: 10000,\n    };\n\n    // fields field not supported on ES 5.x\n    if (this.esVersion < 5) {\n      data['fields'] = [timeField, '_source'];\n    }\n\n    const header: any = {\n      search_type: 'query_then_fetch',\n      ignore_unavailable: true,\n    };\n\n    // old elastic annotations had index specified on them\n    if (annotation.index) {\n      header.index = annotation.index;\n    } else {\n      header.index = this.indexPattern.getIndexList(options.range.from, options.range.to);\n    }\n\n    const payload = angular.toJson(header) + '\\n' + angular.toJson(data) + '\\n';\n\n    return this.post('_msearch', payload).then((res: any) => {\n      const list = [];\n      const hits = res.responses[0].hits.hits;\n\n      const getFieldFromSource = (source: any, fieldName: any) => {\n        if (!fieldName) {\n          return;\n        }\n\n        const fieldNames = fieldName.split('.');\n        let fieldValue = source;\n\n        for (let i = 0; i < fieldNames.length; i++) {\n          fieldValue = fieldValue[fieldNames[i]];\n          if (!fieldValue) {\n            console.log('could not find field in annotation: ', fieldName);\n            return '';\n          }\n        }\n\n        return fieldValue;\n      };\n\n      for (let i = 0; i < hits.length; i++) {\n        const source = hits[i]._source;\n        let time = getFieldFromSource(source, timeField);\n        if (typeof hits[i].fields !== 'undefined') {\n          const fields = hits[i].fields;\n          if (_.isString(fields[timeField]) || _.isNumber(fields[timeField])) {\n            time = fields[timeField];\n          }\n        }\n\n        const event = {\n          annotation: annotation,\n          time: toUtc(time).valueOf(),\n          text: getFieldFromSource(source, textField),\n          tags: getFieldFromSource(source, tagsField),\n        };\n\n        // legacy support for title tield\n        if (annotation.titleField) {\n          const title = getFieldFromSource(source, annotation.titleField);\n          if (title) {\n            event.text = title + '\\n' + event.text;\n          }\n        }\n\n        if (typeof event.tags === 'string') {\n          event.tags = event.tags.split(',');\n        }\n\n        list.push(event);\n      }\n      return list;\n    });\n  }\n\n  testDatasource() {\n    // validate that the index exist and has date field\n    return this.getFields({ type: 'date' }).then(\n      (dateFields: any) => {\n        const timeField: any = _.find(dateFields, { text: this.timeField });\n        if (!timeField) {\n          return {\n            status: 'error',\n            message: 'No date field named ' + this.timeField + ' found',\n          };\n        }\n        return { status: 'success', message: 'Index OK. Time field name OK.' };\n      },\n      (err: any) => {\n        console.log(err);\n        if (err.data && err.data.error) {\n          let message = angular.toJson(err.data.error);\n          if (err.data.error.reason) {\n            message = err.data.error.reason;\n          }\n          return { status: 'error', message: message };\n        } else {\n          return { status: 'error', message: err.status };\n        }\n      }\n    );\n  }\n\n  getQueryHeader(searchType: any, timeFrom: any, timeTo: any) {\n    const queryHeader: any = {\n      search_type: searchType,\n      ignore_unavailable: true,\n      index: this.indexPattern.getIndexList(timeFrom, timeTo),\n    };\n    if (this.esVersion >= 56 && this.esVersion < 70) {\n      queryHeader['max_concurrent_shard_requests'] = this.maxConcurrentShardRequests;\n    }\n    return angular.toJson(queryHeader);\n  }\n\n  query(options: DataQueryRequest<ElasticsearchQuery>): Promise<DataQueryResponse> {\n    let payload = '';\n    const targets = _.cloneDeep(options.targets);\n    const sentTargets: ElasticsearchQuery[] = [];\n\n    // add global adhoc filters to timeFilter\n    const adhocFilters = this.templateSrv.getAdhocFilters(this.name);\n\n    for (const target of targets) {\n      if (target.hide) {\n        continue;\n      }\n\n      let queryString = this.templateSrv.replace(target.query, options.scopedVars, 'lucene');\n      // Elasticsearch queryString should always be '*' if empty string\n      if (!queryString || queryString === '') {\n        queryString = '*';\n      }\n\n      let queryObj;\n      if (target.isLogsQuery) {\n        target.bucketAggs = [queryDef.defaultBucketAgg()];\n        target.metrics = [queryDef.defaultMetricAgg()];\n        queryObj = this.queryBuilder.getLogsQuery(target, queryString);\n      } else {\n        if (target.alias) {\n          target.alias = this.templateSrv.replace(target.alias, options.scopedVars, 'lucene');\n        }\n\n        queryObj = this.queryBuilder.build(target, adhocFilters, queryString);\n      }\n\n      const esQuery = angular.toJson(queryObj);\n\n      const searchType = queryObj.size === 0 && this.esVersion < 5 ? 'count' : 'query_then_fetch';\n      const header = this.getQueryHeader(searchType, options.range.from, options.range.to);\n      payload += header + '\\n';\n\n      payload += esQuery + '\\n';\n\n      sentTargets.push(target);\n    }\n\n    if (sentTargets.length === 0) {\n      return Promise.resolve({ data: [] });\n    }\n\n    payload = payload.replace(/\\$timeFrom/g, options.range.from.valueOf().toString());\n    payload = payload.replace(/\\$timeTo/g, options.range.to.valueOf().toString());\n    payload = this.templateSrv.replace(payload, options.scopedVars);\n\n    const url = this.getMultiSearchUrl();\n\n    return this.post(url, payload).then((res: any) => {\n      const er = new ElasticResponse(sentTargets, res);\n      if (sentTargets.some(target => target.isLogsQuery)) {\n        return er.getLogs(this.logMessageField, this.logLevelField);\n      }\n\n      return er.getTimeSeries();\n    });\n  }\n\n  getFields(query: any) {\n    const configuredEsVersion = this.esVersion;\n    return this.get('/_mapping').then((result: any) => {\n      const typeMap: any = {\n        float: 'number',\n        double: 'number',\n        integer: 'number',\n        long: 'number',\n        date: 'date',\n        string: 'string',\n        text: 'string',\n        scaled_float: 'number',\n        nested: 'nested',\n      };\n\n      function shouldAddField(obj: any, key: any, query: any) {\n        if (key[0] === '_') {\n          return false;\n        }\n\n        if (!query.type) {\n          return true;\n        }\n\n        // equal query type filter, or via typemap translation\n        return query.type === obj.type || query.type === typeMap[obj.type];\n      }\n\n      // Store subfield names: [system, process, cpu, total] -> system.process.cpu.total\n      const fieldNameParts: any = [];\n      const fields: any = {};\n\n      function getFieldsRecursively(obj: any) {\n        for (const key in obj) {\n          const subObj = obj[key];\n\n          // Check mapping field for nested fields\n          if (_.isObject(subObj.properties)) {\n            fieldNameParts.push(key);\n            getFieldsRecursively(subObj.properties);\n          }\n\n          if (_.isObject(subObj.fields)) {\n            fieldNameParts.push(key);\n            getFieldsRecursively(subObj.fields);\n          }\n\n          if (_.isString(subObj.type)) {\n            const fieldName = fieldNameParts.concat(key).join('.');\n\n            // Hide meta-fields and check field type\n            if (shouldAddField(subObj, key, query)) {\n              fields[fieldName] = {\n                text: fieldName,\n                type: subObj.type,\n              };\n            }\n          }\n        }\n        fieldNameParts.pop();\n      }\n\n      for (const indexName in result) {\n        const index = result[indexName];\n        if (index && index.mappings) {\n          const mappings = index.mappings;\n\n          if (configuredEsVersion < 70) {\n            for (const typeName in mappings) {\n              const properties = mappings[typeName].properties;\n              getFieldsRecursively(properties);\n            }\n          } else {\n            const properties = mappings.properties;\n            getFieldsRecursively(properties);\n          }\n        }\n      }\n\n      // transform to array\n      return _.map(fields, value => {\n        return value;\n      });\n    });\n  }\n\n  getTerms(queryDef: any) {\n    const range = this.timeSrv.timeRange();\n    const searchType = this.esVersion >= 5 ? 'query_then_fetch' : 'count';\n    const header = this.getQueryHeader(searchType, range.from, range.to);\n    let esQuery = angular.toJson(this.queryBuilder.getTermsQuery(queryDef));\n\n    esQuery = esQuery.replace(/\\$timeFrom/g, range.from.valueOf().toString());\n    esQuery = esQuery.replace(/\\$timeTo/g, range.to.valueOf().toString());\n    esQuery = header + '\\n' + esQuery + '\\n';\n\n    const url = this.getMultiSearchUrl();\n\n    return this.post(url, esQuery).then((res: any) => {\n      if (!res.responses[0].aggregations) {\n        return [];\n      }\n\n      const buckets = res.responses[0].aggregations['1'].buckets;\n      return _.map(buckets, bucket => {\n        return {\n          text: bucket.key_as_string || bucket.key,\n          value: bucket.key,\n        };\n      });\n    });\n  }\n\n  getMultiSearchUrl() {\n    if (this.esVersion >= 70 && this.maxConcurrentShardRequests) {\n      return `_msearch?max_concurrent_shard_requests=${this.maxConcurrentShardRequests}`;\n    }\n\n    return '_msearch';\n  }\n\n  metricFindQuery(query: any) {\n    query = angular.fromJson(query);\n    if (!query) {\n      return this.$q.when([]);\n    }\n\n    if (query.find === 'fields') {\n      query.field = this.templateSrv.replace(query.field, {}, 'lucene');\n      return this.getFields(query);\n    }\n\n    if (query.find === 'terms') {\n      query.field = this.templateSrv.replace(query.field, {}, 'lucene');\n      query.query = this.templateSrv.replace(query.query || '*', {}, 'lucene');\n      return this.getTerms(query);\n    }\n  }\n\n  getTagKeys() {\n    return this.getFields({});\n  }\n\n  getTagValues(options: any) {\n    return this.getTerms({ field: options.key, query: '*' });\n  }\n\n  targetContainsTemplate(target: any) {\n    if (this.templateSrv.variableExists(target.query) || this.templateSrv.variableExists(target.alias)) {\n      return true;\n    }\n\n    for (const bucketAgg of target.bucketAggs) {\n      if (this.templateSrv.variableExists(bucketAgg.field) || this.objectContainsTemplate(bucketAgg.settings)) {\n        return true;\n      }\n    }\n\n    for (const metric of target.metrics) {\n      if (\n        this.templateSrv.variableExists(metric.field) ||\n        this.objectContainsTemplate(metric.settings) ||\n        this.objectContainsTemplate(metric.meta)\n      ) {\n        return true;\n      }\n    }\n\n    return false;\n  }\n\n  private isPrimitive(obj: any) {\n    if (obj === null || obj === undefined) {\n      return true;\n    }\n    if (['string', 'number', 'boolean'].some(type => type === typeof true)) {\n      return true;\n    }\n\n    return false;\n  }\n\n  private objectContainsTemplate(obj: any) {\n    if (!obj) {\n      return false;\n    }\n\n    for (const key of Object.keys(obj)) {\n      if (this.isPrimitive(obj[key])) {\n        if (this.templateSrv.variableExists(obj[key])) {\n          return true;\n        }\n      } else if (Array.isArray(obj[key])) {\n        for (const item of obj[key]) {\n          if (this.objectContainsTemplate(item)) {\n            return true;\n          }\n        }\n      } else {\n        if (this.objectContainsTemplate(obj[key])) {\n          return true;\n        }\n      }\n    }\n\n    return false;\n  }\n}\n\nexport function getMaxConcurrenShardRequestOrDefault(options: ElasticsearchOptions): number {\n  if (options.maxConcurrentShardRequests === 5 && options.esVersion < 70) {\n    return 256;\n  }\n\n  if (options.maxConcurrentShardRequests === 256 && options.esVersion >= 70) {\n    return 5;\n  }\n\n  const defaultMaxConcurrentShardRequests = options.esVersion >= 70 ? 5 : 256;\n  return options.maxConcurrentShardRequests || defaultMaxConcurrentShardRequests;\n}\n","import coreModule from 'app/core/core_module';\nimport _ from 'lodash';\nimport * as queryDef from './query_def';\nimport { IQService } from 'angular';\n\nexport class ElasticBucketAggCtrl {\n  /** @ngInject */\n  constructor($scope: any, uiSegmentSrv: any, $q: IQService, $rootScope: any) {\n    const bucketAggs = $scope.target.bucketAggs;\n\n    $scope.orderByOptions = [];\n\n    $scope.getBucketAggTypes = () => {\n      return queryDef.bucketAggTypes;\n    };\n\n    $scope.getOrderOptions = () => {\n      return queryDef.orderOptions;\n    };\n\n    $scope.getSizeOptions = () => {\n      return queryDef.sizeOptions;\n    };\n\n    $rootScope.onAppEvent(\n      'elastic-query-updated',\n      () => {\n        $scope.validateModel();\n      },\n      $scope\n    );\n\n    $scope.init = () => {\n      $scope.agg = bucketAggs[$scope.index];\n      $scope.validateModel();\n    };\n\n    $scope.onChangeInternal = () => {\n      $scope.onChange();\n    };\n\n    $scope.onTypeChanged = () => {\n      $scope.agg.settings = {};\n      $scope.showOptions = false;\n\n      switch ($scope.agg.type) {\n        case 'date_histogram':\n        case 'histogram':\n        case 'terms': {\n          delete $scope.agg.query;\n          $scope.agg.field = 'select field';\n          break;\n        }\n        case 'filters': {\n          delete $scope.agg.field;\n          $scope.agg.query = '*';\n          break;\n        }\n        case 'geohash_grid': {\n          $scope.agg.settings.precision = 3;\n          break;\n        }\n      }\n\n      $scope.validateModel();\n      $scope.onChange();\n    };\n\n    $scope.validateModel = () => {\n      $scope.index = _.indexOf(bucketAggs, $scope.agg);\n      $scope.isFirst = $scope.index === 0;\n      $scope.bucketAggCount = bucketAggs.length;\n\n      let settingsLinkText = '';\n      const settings = $scope.agg.settings || {};\n\n      switch ($scope.agg.type) {\n        case 'terms': {\n          settings.order = settings.order || 'desc';\n          settings.size = settings.size || '10';\n          settings.min_doc_count = settings.min_doc_count || 1;\n          settings.orderBy = settings.orderBy || '_term';\n\n          if (settings.size !== '0') {\n            settingsLinkText = queryDef.describeOrder(settings.order) + ' ' + settings.size + ', ';\n          }\n\n          if (settings.min_doc_count > 0) {\n            settingsLinkText += 'Min Doc Count: ' + settings.min_doc_count + ', ';\n          }\n\n          settingsLinkText += 'Order by: ' + queryDef.describeOrderBy(settings.orderBy, $scope.target);\n\n          if (settings.size === '0') {\n            settingsLinkText += ' (' + settings.order + ')';\n          }\n\n          break;\n        }\n        case 'filters': {\n          settings.filters = settings.filters || [{ query: '*' }];\n          settingsLinkText = _.reduce(\n            settings.filters,\n            (memo, value, index) => {\n              memo += 'Q' + (index + 1) + '  = ' + value.query + ' ';\n              return memo;\n            },\n            ''\n          );\n          if (settingsLinkText.length > 50) {\n            settingsLinkText = settingsLinkText.substr(0, 50) + '...';\n          }\n          settingsLinkText = 'Filter Queries (' + settings.filters.length + ')';\n          break;\n        }\n        case 'date_histogram': {\n          settings.interval = settings.interval || 'auto';\n          settings.min_doc_count = settings.min_doc_count || 0;\n          $scope.agg.field = $scope.target.timeField;\n          settingsLinkText = 'Interval: ' + settings.interval;\n\n          if (settings.min_doc_count > 0) {\n            settingsLinkText += ', Min Doc Count: ' + settings.min_doc_count;\n          }\n\n          if (settings.trimEdges === undefined || settings.trimEdges < 0) {\n            settings.trimEdges = 0;\n          }\n\n          if (settings.trimEdges && settings.trimEdges > 0) {\n            settingsLinkText += ', Trim edges: ' + settings.trimEdges;\n          }\n          break;\n        }\n        case 'histogram': {\n          settings.interval = settings.interval || 1000;\n          settings.min_doc_count = _.defaultTo(settings.min_doc_count, 1);\n          settingsLinkText = 'Interval: ' + settings.interval;\n\n          if (settings.min_doc_count > 0) {\n            settingsLinkText += ', Min Doc Count: ' + settings.min_doc_count;\n          }\n          break;\n        }\n        case 'geohash_grid': {\n          // limit precision to 7\n          settings.precision = Math.max(Math.min(settings.precision, 7), 1);\n          settingsLinkText = 'Precision: ' + settings.precision;\n          break;\n        }\n      }\n\n      $scope.settingsLinkText = settingsLinkText;\n      $scope.agg.settings = settings;\n      return true;\n    };\n\n    $scope.addFiltersQuery = () => {\n      $scope.agg.settings.filters.push({ query: '*' });\n    };\n\n    $scope.removeFiltersQuery = (filter: any) => {\n      $scope.agg.settings.filters = _.without($scope.agg.settings.filters, filter);\n    };\n\n    $scope.toggleOptions = () => {\n      $scope.showOptions = !$scope.showOptions;\n    };\n\n    $scope.getOrderByOptions = () => {\n      return queryDef.getOrderByOptions($scope.target);\n    };\n\n    $scope.getFieldsInternal = () => {\n      if ($scope.agg.type === 'date_histogram') {\n        return $scope.getFields({ $fieldType: 'date' });\n      } else {\n        return $scope.getFields();\n      }\n    };\n\n    $scope.getIntervalOptions = () => {\n      return $q.when(uiSegmentSrv.transformToSegments(true, 'interval')(queryDef.intervalOptions));\n    };\n\n    $scope.addBucketAgg = () => {\n      // if last is date histogram add it before\n      const lastBucket = bucketAggs[bucketAggs.length - 1];\n      let addIndex = bucketAggs.length - 1;\n\n      if (lastBucket && lastBucket.type === 'date_histogram') {\n        addIndex -= 1;\n      }\n\n      const id = _.reduce(\n        $scope.target.bucketAggs.concat($scope.target.metrics),\n        (max, val) => {\n          return parseInt(val.id, 10) > max ? parseInt(val.id, 10) : max;\n        },\n        0\n      );\n\n      bucketAggs.splice(addIndex, 0, { type: 'terms', field: 'select field', id: (id + 1).toString(), fake: true });\n      $scope.onChange();\n    };\n\n    $scope.removeBucketAgg = () => {\n      bucketAggs.splice($scope.index, 1);\n      $scope.onChange();\n    };\n\n    $scope.init();\n  }\n}\n\nexport function elasticBucketAgg() {\n  return {\n    templateUrl: 'public/app/plugins/datasource/elasticsearch/partials/bucket_agg.html',\n    controller: ElasticBucketAggCtrl,\n    restrict: 'E',\n    scope: {\n      target: '=',\n      index: '=',\n      onChange: '&',\n      getFields: '&',\n    },\n  };\n}\n\ncoreModule.directive('elasticBucketAgg', elasticBucketAgg);\n","import coreModule from 'app/core/core_module';\nimport _ from 'lodash';\nimport * as queryDef from './query_def';\nimport { ElasticsearchAggregation } from './types';\nimport { IQService } from 'angular';\n\nexport class ElasticMetricAggCtrl {\n  /** @ngInject */\n  constructor($scope: any, uiSegmentSrv: any, $q: IQService, $rootScope: any) {\n    const metricAggs: ElasticsearchAggregation[] = $scope.target.metrics;\n    $scope.metricAggTypes = queryDef.getMetricAggTypes($scope.esVersion);\n    $scope.extendedStats = queryDef.extendedStats;\n    $scope.pipelineAggOptions = [];\n    $scope.modelSettingsValues = {};\n\n    $scope.init = () => {\n      $scope.agg = metricAggs[$scope.index];\n      $scope.validateModel();\n      $scope.updatePipelineAggOptions();\n    };\n\n    $scope.updatePipelineAggOptions = () => {\n      $scope.pipelineAggOptions = queryDef.getPipelineAggOptions($scope.target);\n    };\n\n    $rootScope.onAppEvent(\n      'elastic-query-updated',\n      () => {\n        $scope.index = _.indexOf(metricAggs, $scope.agg);\n        $scope.updatePipelineAggOptions();\n        $scope.validateModel();\n      },\n      $scope\n    );\n\n    $scope.validateModel = () => {\n      $scope.isFirst = $scope.index === 0;\n      $scope.isSingle = metricAggs.length === 1;\n      $scope.settingsLinkText = '';\n      $scope.variablesLinkText = '';\n      $scope.aggDef = _.find($scope.metricAggTypes, { value: $scope.agg.type });\n\n      if (queryDef.isPipelineAgg($scope.agg.type)) {\n        if (queryDef.isPipelineAggWithMultipleBucketPaths($scope.agg.type)) {\n          $scope.variablesLinkText = 'Options';\n\n          if ($scope.agg.settings.script) {\n            $scope.variablesLinkText = 'Script: ' + $scope.agg.settings.script.replace(new RegExp('params.', 'g'), '');\n          }\n        } else {\n          $scope.agg.pipelineAgg = $scope.agg.pipelineAgg || 'select metric';\n          $scope.agg.field = $scope.agg.pipelineAgg;\n        }\n\n        const pipelineOptions = queryDef.getPipelineOptions($scope.agg);\n        if (pipelineOptions.length > 0) {\n          _.each(pipelineOptions, opt => {\n            $scope.agg.settings[opt.text] = $scope.agg.settings[opt.text] || opt.default;\n          });\n          $scope.settingsLinkText = 'Options';\n        }\n      } else if (!$scope.agg.field) {\n        $scope.agg.field = 'select field';\n      }\n      switch ($scope.agg.type) {\n        case 'cardinality': {\n          const precisionThreshold = $scope.agg.settings.precision_threshold || '';\n          $scope.settingsLinkText = 'Precision threshold: ' + precisionThreshold;\n          break;\n        }\n        case 'percentiles': {\n          $scope.agg.settings.percents = $scope.agg.settings.percents || [25, 50, 75, 95, 99];\n          $scope.settingsLinkText = 'Values: ' + $scope.agg.settings.percents.join(',');\n          break;\n        }\n        case 'extended_stats': {\n          if (_.keys($scope.agg.meta).length === 0) {\n            $scope.agg.meta.std_deviation_bounds_lower = true;\n            $scope.agg.meta.std_deviation_bounds_upper = true;\n          }\n\n          const stats = _.reduce(\n            $scope.agg.meta,\n            (memo, val, key) => {\n              if (val) {\n                const def: any = _.find($scope.extendedStats, { value: key });\n                memo.push(def.text);\n              }\n              return memo;\n            },\n            []\n          );\n\n          $scope.settingsLinkText = 'Stats: ' + stats.join(', ');\n          break;\n        }\n        case 'moving_avg': {\n          $scope.movingAvgModelTypes = queryDef.movingAvgModelOptions;\n          $scope.modelSettings = queryDef.getMovingAvgSettings($scope.agg.settings.model, true);\n          $scope.updateMovingAvgModelSettings();\n          break;\n        }\n        case 'raw_document': {\n          $scope.agg.settings.size = $scope.agg.settings.size || 500;\n          $scope.settingsLinkText = 'Size: ' + $scope.agg.settings.size;\n          $scope.target.metrics.splice(0, $scope.target.metrics.length, $scope.agg);\n\n          $scope.target.bucketAggs = [];\n          break;\n        }\n      }\n      if ($scope.aggDef.supportsInlineScript) {\n        // I know this stores the inline script twice\n        // but having it like this simplifes the query_builder\n        const inlineScript = $scope.agg.inlineScript;\n        if (inlineScript) {\n          $scope.agg.settings.script = { inline: inlineScript };\n        } else {\n          delete $scope.agg.settings.script;\n        }\n\n        if ($scope.settingsLinkText === '') {\n          $scope.settingsLinkText = 'Options';\n        }\n      }\n    };\n\n    $scope.toggleOptions = () => {\n      $scope.showOptions = !$scope.showOptions;\n      $scope.updatePipelineAggOptions();\n    };\n\n    $scope.toggleVariables = () => {\n      $scope.showVariables = !$scope.showVariables;\n    };\n\n    $scope.onChangeInternal = () => {\n      $scope.onChange();\n    };\n\n    $scope.updateMovingAvgModelSettings = () => {\n      const modelSettingsKeys = [];\n      const modelSettings = queryDef.getMovingAvgSettings($scope.agg.settings.model, false);\n      for (let i = 0; i < modelSettings.length; i++) {\n        modelSettingsKeys.push(modelSettings[i].value);\n      }\n\n      for (const key in $scope.agg.settings.settings) {\n        if ($scope.agg.settings.settings[key] === null || modelSettingsKeys.indexOf(key) === -1) {\n          delete $scope.agg.settings.settings[key];\n        }\n      }\n    };\n\n    $scope.onChangeClearInternal = () => {\n      delete $scope.agg.settings.minimize;\n      $scope.onChange();\n    };\n\n    $scope.onTypeChange = () => {\n      $scope.agg.settings = {};\n      $scope.agg.meta = {};\n      $scope.showOptions = false;\n\n      // reset back to metric/group by query\n      if ($scope.target.bucketAggs.length === 0 && $scope.agg.type !== 'raw_document') {\n        $scope.target.bucketAggs = [queryDef.defaultBucketAgg()];\n      }\n\n      $scope.showVariables = queryDef.isPipelineAggWithMultipleBucketPaths($scope.agg.type);\n      $scope.updatePipelineAggOptions();\n      $scope.onChange();\n    };\n\n    $scope.getFieldsInternal = () => {\n      if ($scope.agg.type === 'cardinality') {\n        return $scope.getFields();\n      }\n      return $scope.getFields({ $fieldType: 'number' });\n    };\n\n    $scope.addMetricAgg = () => {\n      const addIndex = metricAggs.length;\n\n      const id = _.reduce(\n        $scope.target.bucketAggs.concat($scope.target.metrics),\n        (max, val) => {\n          return parseInt(val.id, 10) > max ? parseInt(val.id, 10) : max;\n        },\n        0\n      );\n\n      metricAggs.splice(addIndex, 0, { type: 'count', field: 'select field', id: (id + 1).toString() });\n      $scope.onChange();\n    };\n\n    $scope.removeMetricAgg = () => {\n      metricAggs.splice($scope.index, 1);\n      $scope.onChange();\n    };\n\n    $scope.toggleShowMetric = () => {\n      $scope.agg.hide = !$scope.agg.hide;\n      if (!$scope.agg.hide) {\n        delete $scope.agg.hide;\n      }\n      $scope.onChange();\n    };\n\n    $scope.init();\n  }\n}\n\nexport function elasticMetricAgg() {\n  return {\n    templateUrl: 'public/app/plugins/datasource/elasticsearch/partials/metric_agg.html',\n    controller: ElasticMetricAggCtrl,\n    restrict: 'E',\n    scope: {\n      target: '=',\n      index: '=',\n      onChange: '&',\n      getFields: '&',\n      esVersion: '=',\n    },\n  };\n}\n\ncoreModule.directive('elasticMetricAgg', elasticMetricAgg);\n","import coreModule from 'app/core/core_module';\nimport _ from 'lodash';\n\nexport function elasticPipelineVariables() {\n  return {\n    templateUrl: 'public/app/plugins/datasource/elasticsearch/partials/pipeline_variables.html',\n    controller: 'ElasticPipelineVariablesCtrl',\n    restrict: 'E',\n    scope: {\n      onChange: '&',\n      variables: '=',\n      options: '=',\n    },\n  };\n}\n\nconst newVariable = (index: any) => {\n  return {\n    name: 'var' + index,\n    pipelineAgg: 'select metric',\n  };\n};\n\nexport class ElasticPipelineVariablesCtrl {\n  /** @ngInject */\n  constructor($scope: any) {\n    $scope.variables = $scope.variables || [newVariable(1)];\n\n    $scope.onChangeInternal = () => {\n      $scope.onChange();\n    };\n\n    $scope.add = () => {\n      $scope.variables.push(newVariable($scope.variables.length + 1));\n      $scope.onChange();\n    };\n\n    $scope.remove = (index: number) => {\n      $scope.variables.splice(index, 1);\n      $scope.onChange();\n    };\n  }\n}\n\ncoreModule.directive('elasticPipelineVariables', elasticPipelineVariables);\ncoreModule.controller('ElasticPipelineVariablesCtrl', ElasticPipelineVariablesCtrl);\n","import './bucket_agg';\nimport './metric_agg';\nimport './pipeline_variables';\n\nimport angular, { auto } from 'angular';\nimport _ from 'lodash';\nimport * as queryDef from './query_def';\nimport { QueryCtrl } from 'app/plugins/sdk';\nimport { ElasticsearchAggregation } from './types';\n\nexport class ElasticQueryCtrl extends QueryCtrl {\n  static templateUrl = 'partials/query.editor.html';\n\n  esVersion: any;\n  rawQueryOld: string;\n\n  /** @ngInject */\n  constructor($scope: any, $injector: auto.IInjectorService, private $rootScope: any, private uiSegmentSrv: any) {\n    super($scope, $injector);\n\n    this.esVersion = this.datasource.esVersion;\n\n    this.target = this.target || {};\n    this.target.metrics = this.target.metrics || [queryDef.defaultMetricAgg()];\n    this.target.bucketAggs = this.target.bucketAggs || [queryDef.defaultBucketAgg()];\n\n    if (this.target.bucketAggs.length === 0) {\n      const metric = this.target.metrics[0];\n      if (!metric || metric.type !== 'raw_document') {\n        this.target.bucketAggs = [queryDef.defaultBucketAgg()];\n      }\n      this.refresh();\n    }\n\n    this.queryUpdated();\n  }\n\n  getFields(type: any) {\n    const jsonStr = angular.toJson({ find: 'fields', type: type });\n    return this.datasource\n      .metricFindQuery(jsonStr)\n      .then(this.uiSegmentSrv.transformToSegments(false))\n      .catch(this.handleQueryError.bind(this));\n  }\n\n  queryUpdated() {\n    const newJson = angular.toJson(this.datasource.queryBuilder.build(this.target), true);\n    if (this.rawQueryOld && newJson !== this.rawQueryOld) {\n      this.refresh();\n    }\n\n    this.rawQueryOld = newJson;\n    this.$rootScope.appEvent('elastic-query-updated');\n  }\n\n  getCollapsedText() {\n    const metricAggs: ElasticsearchAggregation[] = this.target.metrics;\n    const bucketAggs = this.target.bucketAggs;\n    const metricAggTypes = queryDef.getMetricAggTypes(this.esVersion);\n    const bucketAggTypes = queryDef.bucketAggTypes;\n    let text = '';\n\n    if (this.target.query) {\n      text += 'Query: ' + this.target.query + ', ';\n    }\n\n    text += 'Metrics: ';\n\n    _.each(metricAggs, (metric, index) => {\n      const aggDef: any = _.find(metricAggTypes, { value: metric.type });\n      text += aggDef.text + '(';\n      if (aggDef.requiresField) {\n        text += metric.field;\n      }\n      if (aggDef.supportsMultipleBucketPaths) {\n        text += metric.settings.script.replace(new RegExp('params.', 'g'), '');\n      }\n      text += '), ';\n    });\n\n    _.each(bucketAggs, (bucketAgg: any, index: number) => {\n      if (index === 0) {\n        text += ' Group by: ';\n      }\n\n      const aggDef: any = _.find(bucketAggTypes, { value: bucketAgg.type });\n      text += aggDef.text + '(';\n      if (aggDef.requiresField) {\n        text += bucketAgg.field;\n      }\n      text += '), ';\n    });\n\n    if (this.target.alias) {\n      text += 'Alias: ' + this.target.alias;\n    }\n\n    return text;\n  }\n\n  handleQueryError(err: any): any[] {\n    this.error = err.message || 'Failed to issue metric query';\n    return [];\n  }\n}\n","import _ from 'lodash';\nimport { ElasticsearchOptions } from './types';\nimport { DataSourceInstanceSettings } from '@grafana/ui';\nimport { getMaxConcurrenShardRequestOrDefault } from './datasource';\n\nexport class ElasticConfigCtrl {\n  static templateUrl = 'public/app/plugins/datasource/elasticsearch/partials/config.html';\n  current: DataSourceInstanceSettings<ElasticsearchOptions>;\n\n  /** @ngInject */\n  constructor($scope: any) {\n    this.current.jsonData.timeField = this.current.jsonData.timeField || '@timestamp';\n    this.current.jsonData.esVersion = this.current.jsonData.esVersion || 5;\n    const defaultMaxConcurrentShardRequests = this.current.jsonData.esVersion >= 70 ? 5 : 256;\n    this.current.jsonData.maxConcurrentShardRequests =\n      this.current.jsonData.maxConcurrentShardRequests || defaultMaxConcurrentShardRequests;\n    this.current.jsonData.logMessageField = this.current.jsonData.logMessageField || '';\n    this.current.jsonData.logLevelField = this.current.jsonData.logLevelField || '';\n  }\n\n  indexPatternTypes: any = [\n    { name: 'No pattern', value: undefined },\n    { name: 'Hourly', value: 'Hourly', example: '[logstash-]YYYY.MM.DD.HH' },\n    { name: 'Daily', value: 'Daily', example: '[logstash-]YYYY.MM.DD' },\n    { name: 'Weekly', value: 'Weekly', example: '[logstash-]GGGG.WW' },\n    { name: 'Monthly', value: 'Monthly', example: '[logstash-]YYYY.MM' },\n    { name: 'Yearly', value: 'Yearly', example: '[logstash-]YYYY' },\n  ];\n\n  esVersions = [\n    { name: '2.x', value: 2 },\n    { name: '5.x', value: 5 },\n    { name: '5.6+', value: 56 },\n    { name: '6.0+', value: 60 },\n    { name: '7.0+', value: 70 },\n  ];\n\n  indexPatternTypeChanged() {\n    if (\n      !this.current.database ||\n      this.current.database.length === 0 ||\n      this.current.database.startsWith('[logstash-]')\n    ) {\n      const def: any = _.find(this.indexPatternTypes, {\n        value: this.current.jsonData.interval,\n      });\n      this.current.database = def.example || 'es-index-name';\n    }\n  }\n\n  versionChanged() {\n    this.current.jsonData.maxConcurrentShardRequests = getMaxConcurrenShardRequestOrDefault(this.current.jsonData);\n  }\n}\n","import _ from 'lodash';\nimport React from 'react';\n\nimport { SlatePrism } from '@grafana/ui';\n\n// dom also includes Element polyfills\nimport QueryField from 'app/features/explore/QueryField';\nimport { ExploreQueryFieldProps } from '@grafana/ui';\nimport { ElasticDatasource } from '../datasource';\nimport { ElasticsearchOptions, ElasticsearchQuery } from '../types';\n\ninterface Props extends ExploreQueryFieldProps<ElasticDatasource, ElasticsearchQuery, ElasticsearchOptions> {}\n\ninterface State {\n  syntaxLoaded: boolean;\n}\n\nclass ElasticsearchQueryField extends React.PureComponent<Props, State> {\n  plugins: any[];\n\n  constructor(props: Props, context: React.Context<any>) {\n    super(props, context);\n\n    this.plugins = [\n      SlatePrism({\n        onlyIn: (node: any) => node.type === 'code_block',\n        getSyntax: (node: any) => 'lucene',\n      }),\n    ];\n\n    this.state = {\n      syntaxLoaded: false,\n    };\n  }\n\n  componentDidMount() {\n    if (!this.props.query.isLogsQuery) {\n      this.onChangeQuery('', true);\n    }\n  }\n\n  componentWillUnmount() {}\n\n  componentDidUpdate(prevProps: Props) {\n    // if query changed from the outside (i.e. cleared via explore toolbar)\n    if (!this.props.query.isLogsQuery) {\n      this.onChangeQuery('', true);\n    }\n  }\n\n  onChangeQuery = (value: string, override?: boolean) => {\n    // Send text change to parent\n    const { query, onChange, onRunQuery } = this.props;\n    if (onChange) {\n      const nextQuery: ElasticsearchQuery = { ...query, query: value, isLogsQuery: true };\n      onChange(nextQuery);\n\n      if (override && onRunQuery) {\n        onRunQuery();\n      }\n    }\n  };\n\n  render() {\n    const { queryResponse, query } = this.props;\n    const { syntaxLoaded } = this.state;\n\n    return (\n      <>\n        <div className=\"gf-form-inline gf-form-inline--nowrap\">\n          <div className=\"gf-form gf-form--grow flex-shrink-1\">\n            <QueryField\n              additionalPlugins={this.plugins}\n              initialQuery={query.query}\n              onChange={this.onChangeQuery}\n              onRunQuery={this.props.onRunQuery}\n              placeholder=\"Enter a Lucene query\"\n              portalOrigin=\"elasticsearch\"\n              syntaxLoaded={syntaxLoaded}\n            />\n          </div>\n        </div>\n        {queryResponse && queryResponse.error ? (\n          <div className=\"prom-query-field-info text-error\">{queryResponse.error.message}</div>\n        ) : null}\n      </>\n    );\n  }\n}\n\nexport default ElasticsearchQueryField;\n","import { DataSourcePlugin } from '@grafana/ui';\nimport { ElasticDatasource } from './datasource';\nimport { ElasticQueryCtrl } from './query_ctrl';\nimport { ElasticConfigCtrl } from './config_ctrl';\nimport ElasticsearchQueryField from './components/ElasticsearchQueryField';\n\nclass ElasticAnnotationsQueryCtrl {\n  static templateUrl = 'partials/annotations.editor.html';\n}\n\nexport const plugin = new DataSourcePlugin(ElasticDatasource)\n  .setQueryCtrl(ElasticQueryCtrl)\n  .setConfigCtrl(ElasticConfigCtrl)\n  .setExploreLogsQueryField(ElasticsearchQueryField)\n  .setAnnotationQueryCtrl(ElasticAnnotationsQueryCtrl);\n"],"sourceRoot":""}