{"version":3,"file":"loki-query-field.13966afcbbe7e7f9dc85.js","mappings":"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","sources":["webpack://grafana/./.yarn/__virtual__/@grafana-monaco-logql-virtual-a88ff9128e/3/opt/drone/yarncache/@grafana-monaco-logql-npm-0.0.7-d8a55872d9-cce4a8ed8a.zip/node_modules/@grafana/monaco-logql/index.js","webpack://grafana/./public/app/plugins/datasource/loki/components/monaco-query-field/getOverrideServices.ts","webpack://grafana/./public/app/plugins/datasource/loki/components/monaco-query-field/monaco-completion-provider/NeverCaseError.ts","webpack://grafana/./public/app/plugins/datasource/loki/components/monaco-query-field/monaco-completion-provider/completions.ts","webpack://grafana/./public/app/plugins/datasource/loki/components/monaco-query-field/monaco-completion-provider/situation.ts","webpack://grafana/./public/app/plugins/datasource/loki/components/monaco-query-field/monaco-completion-provider/index.ts","webpack://grafana/./public/app/plugins/datasource/loki/components/monaco-query-field/monaco-completion-provider/CompletionDataProvider.ts","webpack://grafana/./public/app/plugins/datasource/loki/components/monaco-query-field/monaco-completion-provider/validation.ts","webpack://grafana/./public/app/plugins/datasource/loki/components/monaco-query-field/MonacoQueryField.tsx","webpack://grafana/./.yarn/__virtual__/react-use-virtual-720cbd4f86/3/opt/drone/yarncache/react-use-npm-17.4.0-0ef4521544-0889da919b.zip/node_modules/react-use/esm/useLatest.js"],"sourcesContent":["\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.monarchlanguage = exports.languageConfiguration = void 0;\nexports.languageConfiguration = {\n    // the default separators except `@$`\n    wordPattern: /(-?\\d*\\.\\d\\w*)|([^`~!#%^&*()\\-=+\\[{\\]}\\\\|;:'\",.<>\\/?\\s]+)/g,\n    comments: {\n        lineComment: \"#\",\n    },\n    brackets: [\n        [\"{\", \"}\"],\n        [\"[\", \"]\"],\n        [\"(\", \")\"],\n    ],\n    autoClosingPairs: [\n        { open: \"{\", close: \"}\" },\n        { open: \"[\", close: \"]\" },\n        { open: \"(\", close: \")\" },\n        { open: '\"', close: '\"' },\n        { open: \"'\", close: \"'\" },\n        { open: \"`\", close: \"`\" },\n    ],\n    surroundingPairs: [\n        { open: \"{\", close: \"}\" },\n        { open: \"[\", close: \"]\" },\n        { open: \"(\", close: \")\" },\n        { open: '\"', close: '\"' },\n        { open: \"'\", close: \"'\" },\n        { open: \"`\", close: \"`\" },\n        { open: \"<\", close: \">\" },\n    ],\n    folding: {},\n};\n// LogQL built-in aggregation operators\n// https://grafana.com/docs/loki/latest/logql/metric_queries/#built-in-aggregation-operators\nvar aggregations = [\n    \"sum\",\n    \"avg\",\n    \"min\",\n    \"max\",\n    \"stddev\",\n    \"stdvar\",\n    \"count\",\n    \"topk\",\n    \"bottomk\",\n];\n// LogQL parser expressions\n// https://grafana.com/docs/loki/latest/logql/log_queries/#parser-expression\nvar parsers = [\"json\", \"logfmt\", \"regexp\", \"unpack\", \"pattern\"];\n// LogQL format expressions\n// https://grafana.com/docs/loki/latest/logql/log_queries/#parser-expression\nvar format_expressions = [\"line_format\", \"label_format\"];\n// LogQL vector aggregations\n// https://grafana.com/docs/loki/latest/logql/metric_queries/#range-vector-aggregation\nvar vector_aggregations = [\n    \"count_over_time\",\n    \"rate\",\n    \"bytes_over_time\",\n    \"bytes_rate\",\n    \"avg_over_time\",\n    \"sum_over_time\",\n    \"min_over_time\",\n    \"max_over_time\",\n    \"stdvar_over_time\",\n    \"stddev_over_time\",\n    \"quantile_over_time\",\n    \"first_over_time\",\n    \"last_over_time\",\n    \"absent_over_time\",\n];\n// LogQL by and without clauses\nvar vector_matching = [\"by\", \"without\"];\n// Produce a regex matching elements : (by|without)\nvar vectorMatchingRegex = \"(\".concat(vector_matching.reduce(function (prev, curr) { return \"\".concat(prev, \"|\").concat(curr); }), \")\");\n// LogQL Operators\nvar operators = [\n    \"+\",\n    \"-\",\n    \"*\",\n    \"/\",\n    \"%\",\n    \"^\",\n    \"==\",\n    \"!=\",\n    \">\",\n    \"<\",\n    \">=\",\n    \"<=\",\n    \"|=\",\n    \"!=\",\n    \"|~\",\n    \"!~\",\n    \"and\",\n    \"or\",\n    \"unless\",\n    \"|\",\n];\n// Merging all the keywords in one list\nvar keywords = aggregations\n    .concat(parsers)\n    .concat(format_expressions)\n    .concat(vector_aggregations)\n    .concat(vector_matching);\nexports.monarchlanguage = {\n    ignoreCase: false,\n    defaultToken: \"\",\n    tokenPostfix: \".logql\",\n    keywords: keywords,\n    operators: operators,\n    vectorMatching: vectorMatchingRegex,\n    // we include these common regular expressions\n    symbols: /[=><!~?:&|+\\-*\\/^%]+/,\n    escapes: /\\\\(?:[abfnrtv\\\\\"']|x[0-9A-Fa-f]{1,4}|u[0-9A-Fa-f]{4}|U[0-9A-Fa-f]{8})/,\n    digits: /\\d+(_+\\d+)*/,\n    octaldigits: /[0-7]+(_+[0-7]+)*/,\n    binarydigits: /[0-1]+(_+[0-1]+)*/,\n    hexdigits: /[[0-9a-fA-F]+(_+[0-9a-fA-F]+)*/,\n    integersuffix: /(ll|LL|u|U|l|L)?(ll|LL|u|U|l|L)?/,\n    floatsuffix: /[fFlL]?/,\n    // The main tokenizer for our languages\n    tokenizer: {\n        root: [\n            // 'by', 'without' and vector matching\n            [/@vectorMatching\\s*(?=\\()/, \"type\", \"@clauses\"],\n            // labels\n            [/[a-z_]\\w*(?=\\s*(=|!=|=~|!~))/, \"tag\"],\n            // comments\n            [/(^#.*$)/, \"comment\"],\n            // all keywords have the same color\n            [\n                /[a-zA-Z_]\\w*/,\n                {\n                    cases: {\n                        \"@keywords\": \"type\",\n                        \"@default\": \"identifier\",\n                    },\n                },\n            ],\n            // strings\n            [/\"/, \"string\", \"@string_double\"],\n            [/'/, \"string\", \"@string_single\"],\n            [/`/, \"string\", \"@string_backtick\"],\n            // whitespace\n            { include: \"@whitespace\" },\n            // delimiters and operators\n            [/[{}()\\[\\]]/, \"@brackets\"],\n            [/[<>](?!@symbols)/, \"@brackets\"],\n            [\n                /@symbols/,\n                {\n                    cases: {\n                        \"@operators\": \"delimiter\",\n                        \"@default\": \"\",\n                    },\n                },\n            ],\n            // numbers\n            [/\\d+(?:ms|[smhdwy])/, \"number\"],\n            [/\\d*\\d+[eE]([\\-+]?\\d+)?(@floatsuffix)/, \"number.float\"],\n            [/\\d*\\.\\d+([eE][\\-+]?\\d+)?(@floatsuffix)/, \"number.float\"],\n            [/0[xX][0-9a-fA-F']*[0-9a-fA-F](@integersuffix)/, \"number.hex\"],\n            [/0[0-7']*[0-7](@integersuffix)/, \"number.octal\"],\n            [/0[bB][0-1']*[0-1](@integersuffix)/, \"number.binary\"],\n            [/\\d[\\d']*\\d(@integersuffix)/, \"number\"],\n            [/\\d(@integersuffix)/, \"number\"],\n        ],\n        string_double: [\n            // Set to token: number to differentiate color\n            [/\\{\\{(.*?)\\}\\}/, { token: 'number' }],\n            [/[^\\\\\"]/, \"string\"],\n            [/@escapes/, \"string.escape\"],\n            [/\\\\./, \"string.escape.invalid\"],\n            [/\"/, \"string\", \"@pop\"],\n        ],\n        string_single: [\n            [/[^\\\\']+/, \"string\"],\n            [/@escapes/, \"string.escape\"],\n            [/\\\\./, \"string.escape.invalid\"],\n            [/'/, \"string\", \"@pop\"],\n        ],\n        string_backtick: [\n            // Set to token: number to differentiate color\n            [/\\{\\{(.*?)\\}\\}/, { token: 'number' }],\n            [/[^\\\\`]/, \"string\"],\n            [/@escapes/, \"string.escape\"],\n            [/\\\\./, \"string.escape.invalid\"],\n            [/`/, \"string\", \"@pop\"],\n        ],\n        clauses: [\n            [/[^(,)]/, \"tag\"],\n            [/\\)/, \"identifier\", \"@pop\"],\n        ],\n        whitespace: [[/[ \\t\\r\\n]+/, \"white\"]],\n    },\n};\n","import { monacoTypes } from '@grafana/ui';\n\n// this thing here is a workaround in a way.\n// what we want to achieve, is that when the autocomplete-window\n// opens, the \"second, extra popup\" with the extra help,\n// also opens automatically.\n// but there is no API to achieve it.\n// the way to do it is to implement the `storageService`\n// interface, and provide our custom implementation,\n// which will default to `true` for the correct string-key.\n// unfortunately, while the typescript-interface exists,\n// it is not exported from monaco-editor,\n// so we cannot rely on typescript to make sure\n// we do it right. all we can do is to manually\n// lookup the interface, and make sure we code our code right.\n// our code is a \"best effort\" approach,\n// i am not 100% how the `scope` and `target` things work,\n// but so far it seems to work ok.\n// i would use an another approach, if there was one available.\n\nfunction makeStorageService() {\n  // we need to return an object that fulfills this interface:\n  // https://github.com/microsoft/vscode/blob/ff1e16eebb93af79fd6d7af1356c4003a120c563/src/vs/platform/storage/common/storage.ts#L37\n  // unfortunately it is not export from monaco-editor\n\n  const strings = new Map<string, string>();\n\n  // we want this to be true by default\n  strings.set('expandSuggestionDocs', true.toString());\n\n  return {\n    // we do not implement the on* handlers\n    onDidChangeValue: (data: unknown): void => undefined,\n    onDidChangeTarget: (data: unknown): void => undefined,\n    onWillSaveState: (data: unknown): void => undefined,\n\n    get: (key: string, scope: unknown, fallbackValue?: string): string | undefined => {\n      return strings.get(key) ?? fallbackValue;\n    },\n\n    getBoolean: (key: string, scope: unknown, fallbackValue?: boolean): boolean | undefined => {\n      const val = strings.get(key);\n      if (val !== undefined) {\n        // the interface docs say the value will be converted\n        // to a boolean but do not specify how, so we improvise\n        return val === 'true';\n      } else {\n        return fallbackValue;\n      }\n    },\n\n    getNumber: (key: string, scope: unknown, fallbackValue?: number): number | undefined => {\n      const val = strings.get(key);\n      if (val !== undefined) {\n        return parseInt(val, 10);\n      } else {\n        return fallbackValue;\n      }\n    },\n\n    store: (\n      key: string,\n      value: string | boolean | number | undefined | null,\n      scope: unknown,\n      target: unknown\n    ): void => {\n      // the interface docs say if the value is nullish, it should act as delete\n      if (value === null || value === undefined) {\n        strings.delete(key);\n      } else {\n        strings.set(key, value.toString());\n      }\n    },\n\n    remove: (key: string, scope: unknown): void => {\n      strings.delete(key);\n    },\n\n    keys: (scope: unknown, target: unknown): string[] => {\n      return Array.from(strings.keys());\n    },\n\n    logStorage: (): void => {\n      console.log('logStorage: not implemented');\n    },\n\n    migrate: (): Promise<void> => {\n      // we do not implement this\n      return Promise.resolve(undefined);\n    },\n\n    isNew: (scope: unknown): boolean => {\n      // we create a new storage for every session, we do not persist it,\n      // so we return `true`.\n      return true;\n    },\n\n    flush: (reason?: unknown): Promise<void> => {\n      // we do not implement this\n      return Promise.resolve(undefined);\n    },\n  };\n}\n\nlet overrideServices: monacoTypes.editor.IEditorOverrideServices = {\n  storageService: makeStorageService(),\n};\n\nexport function getOverrideServices(): monacoTypes.editor.IEditorOverrideServices {\n  // One instance of this for every query editor\n  return overrideServices;\n}\n","// This helper class is used to make typescript warn you when you miss a case-block in a switch statement.\n// For example:\n//\n// const x:'A'|'B'|'C' = 'A';\n//\n// switch(x) {\n//   case 'A':\n//     // something\n//   case 'B':\n//     // something\n//   default:\n//     throw new NeverCaseError(x);\n// }\n//\n//\n// TypeScript detect the missing case and display an error.\n\nexport class NeverCaseError extends Error {\n  constructor(value: never) {\n    super(`Unexpected case in switch statement: ${JSON.stringify(value)}`);\n  }\n}\n","import { trimEnd } from 'lodash';\n\nimport { escapeLabelValueInExactSelector } from '../../../languageUtils';\nimport { isQueryWithParser } from '../../../queryUtils';\nimport { explainOperator } from '../../../querybuilder/operations';\nimport { LokiOperationId } from '../../../querybuilder/types';\nimport { AGGREGATION_OPERATORS, RANGE_VEC_FUNCTIONS, BUILT_IN_FUNCTIONS } from '../../../syntax';\n\nimport { CompletionDataProvider } from './CompletionDataProvider';\nimport { NeverCaseError } from './NeverCaseError';\nimport type { Situation, Label } from './situation';\n\nexport type CompletionType =\n  | 'HISTORY'\n  | 'FUNCTION'\n  | 'DURATION'\n  | 'LABEL_NAME'\n  | 'LABEL_VALUE'\n  | 'PATTERN'\n  | 'PARSER'\n  | 'LINE_FILTER'\n  | 'PIPE_OPERATION';\n\ntype Completion = {\n  type: CompletionType;\n  label: string;\n  insertText: string;\n  detail?: string;\n  documentation?: string;\n  triggerOnInsert?: boolean;\n  isSnippet?: boolean;\n};\n\nconst LOG_COMPLETIONS: Completion[] = [\n  {\n    type: 'PATTERN',\n    label: '{}',\n    insertText: '{$0}',\n    isSnippet: true,\n    triggerOnInsert: true,\n  },\n];\n\nconst AGGREGATION_COMPLETIONS: Completion[] = AGGREGATION_OPERATORS.map((f) => ({\n  type: 'FUNCTION',\n  label: f.label,\n  insertText: `${f.insertText ?? ''}($0)`, // i don't know what to do when this is nullish. it should not be.\n  isSnippet: true,\n  triggerOnInsert: true,\n  detail: f.detail,\n  documentation: f.documentation,\n}));\n\nconst FUNCTION_COMPLETIONS: Completion[] = RANGE_VEC_FUNCTIONS.map((f) => ({\n  type: 'FUNCTION',\n  label: f.label,\n  insertText: `${f.insertText ?? ''}({$0}[\\\\$__interval])`, // i don't know what to do when this is nullish. it should not be.\n  isSnippet: true,\n  triggerOnInsert: true,\n  detail: f.detail,\n  documentation: f.documentation,\n}));\n\nconst BUILT_IN_FUNCTIONS_COMPLETIONS: Completion[] = BUILT_IN_FUNCTIONS.map((f) => ({\n  type: 'FUNCTION',\n  label: f.label,\n  insertText: `${f.insertText ?? ''}($0)`,\n  isSnippet: true,\n  triggerOnInsert: true,\n  detail: f.detail,\n  documentation: f.documentation,\n}));\n\nconst DURATION_COMPLETIONS: Completion[] = ['$__interval', '$__range', '1m', '5m', '10m', '30m', '1h', '1d'].map(\n  (text) => ({\n    type: 'DURATION',\n    label: text,\n    insertText: text,\n  })\n);\n\nconst UNWRAP_FUNCTION_COMPLETIONS: Completion[] = [\n  {\n    type: 'FUNCTION',\n    label: 'duration_seconds',\n    documentation: 'Will convert the label value in seconds from the go duration format (e.g 5m, 24s30ms).',\n    insertText: 'duration_seconds()',\n  },\n  {\n    type: 'FUNCTION',\n    label: 'duration',\n    documentation: 'Short version of duration_seconds().',\n    insertText: 'duration()',\n  },\n  {\n    type: 'FUNCTION',\n    label: 'bytes',\n    documentation: 'Will convert the label value to raw bytes applying the bytes unit (e.g. 5 MiB, 3k, 1G).',\n    insertText: 'bytes()',\n  },\n];\n\nconst LINE_FILTER_COMPLETIONS = [\n  {\n    operator: '|=',\n    documentation: explainOperator(LokiOperationId.LineContains),\n    afterPipe: true,\n  },\n  {\n    operator: '!=',\n    documentation: explainOperator(LokiOperationId.LineContainsNot),\n  },\n  {\n    operator: '|~',\n    documentation: explainOperator(LokiOperationId.LineMatchesRegex),\n    afterPipe: true,\n  },\n  {\n    operator: '!~',\n    documentation: explainOperator(LokiOperationId.LineMatchesRegexNot),\n  },\n];\n\nfunction getLineFilterCompletions(afterPipe: boolean): Completion[] {\n  return LINE_FILTER_COMPLETIONS.filter((completion) => !afterPipe || completion.afterPipe).map(\n    ({ operator, documentation }) => ({\n      type: 'LINE_FILTER',\n      label: `${operator} \"\"`,\n      insertText: `${afterPipe ? operator.replace('|', '') : operator} \"$0\"`,\n      isSnippet: true,\n      documentation,\n    })\n  );\n}\n\nasync function getAllHistoryCompletions(dataProvider: CompletionDataProvider): Promise<Completion[]> {\n  const history = await dataProvider.getHistory();\n\n  return history.map((expr) => ({\n    type: 'HISTORY',\n    label: expr,\n    insertText: expr,\n  }));\n}\n\nasync function getLabelNamesForSelectorCompletions(\n  otherLabels: Label[],\n  dataProvider: CompletionDataProvider\n): Promise<Completion[]> {\n  const labelNames = await dataProvider.getLabelNames(otherLabels);\n\n  return labelNames.map((label) => ({\n    type: 'LABEL_NAME',\n    label,\n    insertText: `${label}=`,\n    triggerOnInsert: true,\n  }));\n}\n\nasync function getInGroupingCompletions(logQuery: string, dataProvider: CompletionDataProvider): Promise<Completion[]> {\n  const { extractedLabelKeys } = await dataProvider.getParserAndLabelKeys(logQuery);\n\n  return extractedLabelKeys.map((label) => ({\n    type: 'LABEL_NAME',\n    label,\n    insertText: label,\n    triggerOnInsert: false,\n  }));\n}\n\nconst PARSERS = ['json', 'logfmt', 'pattern', 'regexp', 'unpack'];\n\nasync function getParserCompletions(\n  prefix: string,\n  hasJSON: boolean,\n  hasLogfmt: boolean,\n  hasPack: boolean,\n  extractedLabelKeys: string[],\n  hasParserInQuery: boolean\n) {\n  const allParsers = new Set(PARSERS);\n  const completions: Completion[] = [];\n  // We use this to improve documentation specifically for level label as it is tied to showing color-coded logs volume\n  const hasLevelInExtractedLabels = extractedLabelKeys.some((key) => key === 'level');\n\n  if (hasJSON) {\n    // We show \"detected\" label only if there is no previous parser in the query\n    const extra = hasParserInQuery ? '' : ' (detected)';\n    if (hasPack) {\n      allParsers.delete('unpack');\n      completions.push({\n        type: 'PARSER',\n        label: `unpack${extra}`,\n        insertText: `${prefix}unpack`,\n        documentation: explainOperator(LokiOperationId.Unpack),\n      });\n    } else {\n      allParsers.delete('json');\n      completions.push({\n        type: 'PARSER',\n        label: `json${extra}`,\n        insertText: `${prefix}json`,\n        documentation: hasLevelInExtractedLabels\n          ? 'Use it to get log-levels in the histogram'\n          : explainOperator(LokiOperationId.Json),\n      });\n    }\n  }\n\n  if (hasLogfmt) {\n    allParsers.delete('logfmt');\n    // We show \"detected\" label only if there is no previous parser in the query\n    const extra = hasParserInQuery ? '' : ' (detected)';\n    completions.push({\n      type: 'PARSER',\n      label: `logfmt${extra}`,\n      insertText: `${prefix}logfmt`,\n      documentation: hasLevelInExtractedLabels\n        ? 'Get detected levels in the histogram'\n        : explainOperator(LokiOperationId.Logfmt),\n    });\n  }\n\n  const remainingParsers = Array.from(allParsers).sort();\n  remainingParsers.forEach((parser) => {\n    completions.push({\n      type: 'PARSER',\n      label: parser,\n      insertText: `${prefix}${parser}`,\n      documentation: explainOperator(parser),\n    });\n  });\n\n  return completions;\n}\n\nexport async function getAfterSelectorCompletions(\n  logQuery: string,\n  afterPipe: boolean,\n  hasSpace: boolean,\n  dataProvider: CompletionDataProvider\n): Promise<Completion[]> {\n  let query = logQuery;\n  if (afterPipe) {\n    query = trimEnd(logQuery, '| ');\n  }\n\n  const { extractedLabelKeys, hasJSON, hasLogfmt, hasPack } = await dataProvider.getParserAndLabelKeys(query);\n  const hasQueryParser = isQueryWithParser(query).queryWithParser;\n\n  const prefix = `${hasSpace ? '' : ' '}${afterPipe ? '' : '| '}`;\n  const completions: Completion[] = await getParserCompletions(\n    prefix,\n    hasJSON,\n    hasLogfmt,\n    hasPack,\n    extractedLabelKeys,\n    hasQueryParser\n  );\n\n  completions.push({\n    type: 'PIPE_OPERATION',\n    label: 'line_format',\n    insertText: `${prefix}line_format \"{{.$0}}\"`,\n    isSnippet: true,\n    documentation: explainOperator(LokiOperationId.LineFormat),\n  });\n\n  completions.push({\n    type: 'PIPE_OPERATION',\n    label: 'label_format',\n    insertText: `${prefix}label_format`,\n    isSnippet: true,\n    documentation: explainOperator(LokiOperationId.LabelFormat),\n  });\n\n  completions.push({\n    type: 'PIPE_OPERATION',\n    label: 'unwrap',\n    insertText: `${prefix}unwrap`,\n    documentation: explainOperator(LokiOperationId.Unwrap),\n  });\n\n  // Let's show label options only if query has parser\n  if (hasQueryParser) {\n    extractedLabelKeys.forEach((key) => {\n      completions.push({\n        type: 'LABEL_NAME',\n        label: `${key} (detected)`,\n        insertText: `${prefix}${key}`,\n        documentation: `\"${key}\" was suggested based on the content of your log lines for the label filter expression.`,\n      });\n    });\n  }\n\n  // If we have parser, we don't need to consider line filters\n  if (hasQueryParser) {\n    return [...completions];\n  }\n  // With a space between the pipe and the cursor, we omit line filters\n  // E.g. `{label=\"value\"} | `\n  const lineFilters = afterPipe && hasSpace ? [] : getLineFilterCompletions(afterPipe);\n  return [...lineFilters, ...completions];\n}\n\nasync function getLabelValuesForMetricCompletions(\n  labelName: string,\n  betweenQuotes: boolean,\n  otherLabels: Label[],\n  dataProvider: CompletionDataProvider\n): Promise<Completion[]> {\n  const values = await dataProvider.getLabelValues(labelName, otherLabels);\n  return values.map((text) => ({\n    type: 'LABEL_VALUE',\n    label: text,\n    insertText: betweenQuotes ? escapeLabelValueInExactSelector(text) : `\"${escapeLabelValueInExactSelector(text)}\"`,\n  }));\n}\n\nasync function getAfterUnwrapCompletions(\n  logQuery: string,\n  dataProvider: CompletionDataProvider\n): Promise<Completion[]> {\n  const { unwrapLabelKeys } = await dataProvider.getParserAndLabelKeys(logQuery);\n\n  const labelCompletions: Completion[] = unwrapLabelKeys.map((label) => ({\n    type: 'LABEL_NAME',\n    label,\n    insertText: label,\n    triggerOnInsert: false,\n  }));\n\n  return [...labelCompletions, ...UNWRAP_FUNCTION_COMPLETIONS];\n}\n\nexport async function getCompletions(\n  situation: Situation,\n  dataProvider: CompletionDataProvider\n): Promise<Completion[]> {\n  switch (situation.type) {\n    case 'EMPTY':\n    case 'AT_ROOT':\n      const historyCompletions = await getAllHistoryCompletions(dataProvider);\n      return [\n        ...historyCompletions,\n        ...LOG_COMPLETIONS,\n        ...AGGREGATION_COMPLETIONS,\n        ...BUILT_IN_FUNCTIONS_COMPLETIONS,\n        ...FUNCTION_COMPLETIONS,\n      ];\n    case 'IN_RANGE':\n      return DURATION_COMPLETIONS;\n    case 'IN_GROUPING':\n      return getInGroupingCompletions(situation.logQuery, dataProvider);\n    case 'IN_LABEL_SELECTOR_NO_LABEL_NAME':\n      return getLabelNamesForSelectorCompletions(situation.otherLabels, dataProvider);\n    case 'IN_LABEL_SELECTOR_WITH_LABEL_NAME':\n      return getLabelValuesForMetricCompletions(\n        situation.labelName,\n        situation.betweenQuotes,\n        situation.otherLabels,\n        dataProvider\n      );\n    case 'AFTER_SELECTOR':\n      return getAfterSelectorCompletions(situation.logQuery, situation.afterPipe, situation.hasSpace, dataProvider);\n    case 'AFTER_UNWRAP':\n      return getAfterUnwrapCompletions(situation.logQuery, dataProvider);\n    case 'IN_AGGREGATION':\n      return [...FUNCTION_COMPLETIONS, ...AGGREGATION_COMPLETIONS];\n    default:\n      throw new NeverCaseError(situation);\n  }\n}\n","import type { Tree, SyntaxNode } from '@lezer/common';\n\nimport {\n  parser,\n  VectorAggregationExpr,\n  String,\n  Selector,\n  RangeAggregationExpr,\n  Range,\n  PipelineExpr,\n  PipelineStage,\n  Matchers,\n  Matcher,\n  LogQL,\n  LogRangeExpr,\n  LogExpr,\n  Identifier,\n  Grouping,\n  Expr,\n  LiteralExpr,\n  MetricExpr,\n  UnwrapExpr,\n} from '@grafana/lezer-logql';\n\nimport { getLogQueryFromMetricsQuery } from '../../../queryUtils';\n\ntype Direction = 'parent' | 'firstChild' | 'lastChild' | 'nextSibling';\ntype NodeType = number;\n\ntype Path = Array<[Direction, NodeType]>;\n\nfunction move(node: SyntaxNode, direction: Direction): SyntaxNode | null {\n  return node[direction];\n}\n\nfunction walk(node: SyntaxNode, path: Path): SyntaxNode | null {\n  let current: SyntaxNode | null = node;\n  for (const [direction, expectedNode] of path) {\n    current = move(current, direction);\n    if (current === null) {\n      // we could not move in the direction, we stop\n      return null;\n    }\n    if (current.type.id !== expectedNode) {\n      // the reached node has wrong type, we stop\n      return null;\n    }\n  }\n  return current;\n}\n\nfunction getNodeText(node: SyntaxNode, text: string): string {\n  return text.slice(node.from, node.to);\n}\n\nfunction parseStringLiteral(text: string): string {\n  // If it is a string-literal, it is inside quotes of some kind\n  const inside = text.slice(1, text.length - 1);\n\n  // Very simple un-escaping:\n\n  // Double quotes\n  if (text.startsWith('\"') && text.endsWith('\"')) {\n    // NOTE: this is not 100% perfect, we only unescape the double-quote,\n    // there might be other characters too\n    return inside.replace(/\\\\\"/gm, '\"');\n  }\n\n  // Single quotes\n  if (text.startsWith(\"'\") && text.endsWith(\"'\")) {\n    // NOTE: this is not 100% perfect, we only unescape the single-quote,\n    // there might be other characters too\n    return inside.replace(/\\\\'/gm, \"'\");\n  }\n\n  // Backticks\n  if (text.startsWith('`') && text.endsWith('`')) {\n    return inside;\n  }\n\n  throw new Error(`Invalid string literal: ${text}`);\n}\n\nexport type LabelOperator = '=' | '!=' | '=~' | '!~';\n\nexport type Label = {\n  name: string;\n  value: string;\n  op: LabelOperator;\n};\n\nexport type Situation =\n  | {\n      type: 'EMPTY';\n    }\n  | {\n      type: 'AT_ROOT';\n    }\n  | {\n      type: 'IN_RANGE';\n    }\n  | {\n      type: 'IN_AGGREGATION';\n    }\n  | {\n      type: 'IN_GROUPING';\n      logQuery: string;\n    }\n  | {\n      type: 'IN_LABEL_SELECTOR_NO_LABEL_NAME';\n      otherLabels: Label[];\n    }\n  | {\n      type: 'IN_LABEL_SELECTOR_WITH_LABEL_NAME';\n      labelName: string;\n      betweenQuotes: boolean;\n      otherLabels: Label[];\n    }\n  | {\n      type: 'AFTER_SELECTOR';\n      afterPipe: boolean;\n      hasSpace: boolean;\n      logQuery: string;\n    }\n  | {\n      type: 'AFTER_UNWRAP';\n      logQuery: string;\n    };\n\ntype Resolver = {\n  path: NodeType[];\n  fun: (node: SyntaxNode, text: string, pos: number) => Situation | null;\n};\n\nfunction isPathMatch(resolverPath: NodeType[], cursorPath: number[]): boolean {\n  return resolverPath.every((item, index) => item === cursorPath[index]);\n}\n\nconst ERROR_NODE_ID = 0;\n\nconst RESOLVERS: Resolver[] = [\n  {\n    path: [Selector],\n    fun: resolveSelector,\n  },\n  {\n    path: [LogQL],\n    fun: resolveTopLevel,\n  },\n  {\n    path: [String, Matcher],\n    fun: resolveMatcher,\n  },\n  {\n    path: [Grouping],\n    fun: resolveLabelsForGrouping,\n  },\n  {\n    path: [LogRangeExpr],\n    fun: resolveLogRange,\n  },\n  {\n    path: [ERROR_NODE_ID, Matcher],\n    fun: resolveMatcher,\n  },\n  {\n    path: [ERROR_NODE_ID, Range],\n    fun: resolveDurations,\n  },\n  {\n    path: [ERROR_NODE_ID, LogRangeExpr],\n    fun: resolveLogRangeFromError,\n  },\n  {\n    path: [ERROR_NODE_ID, LiteralExpr, MetricExpr, VectorAggregationExpr],\n    fun: () => ({ type: 'IN_AGGREGATION' }),\n  },\n  {\n    path: [ERROR_NODE_ID, PipelineStage, PipelineExpr],\n    fun: resolvePipeError,\n  },\n  {\n    path: [ERROR_NODE_ID, UnwrapExpr],\n    fun: resolveAfterUnwrap,\n  },\n  {\n    path: [UnwrapExpr],\n    fun: resolveAfterUnwrap,\n  },\n];\n\nconst LABEL_OP_MAP = new Map<string, LabelOperator>([\n  ['Eq', '='],\n  ['Re', '=~'],\n  ['Neq', '!='],\n  ['Nre', '!~'],\n]);\n\nfunction getLabelOp(opNode: SyntaxNode): LabelOperator | null {\n  return LABEL_OP_MAP.get(opNode.name) ?? null;\n}\n\nfunction getLabel(matcherNode: SyntaxNode, text: string): Label | null {\n  if (matcherNode.type.id !== Matcher) {\n    return null;\n  }\n\n  const nameNode = walk(matcherNode, [['firstChild', Identifier]]);\n\n  if (nameNode === null) {\n    return null;\n  }\n\n  const opNode = nameNode.nextSibling;\n  if (opNode === null) {\n    return null;\n  }\n\n  const op = getLabelOp(opNode);\n  if (op === null) {\n    return null;\n  }\n\n  const valueNode = walk(matcherNode, [['lastChild', String]]);\n\n  if (valueNode === null) {\n    return null;\n  }\n\n  const name = getNodeText(nameNode, text);\n  const value = parseStringLiteral(getNodeText(valueNode, text));\n\n  return { name, value, op };\n}\n\nfunction getLabels(selectorNode: SyntaxNode, text: string): Label[] {\n  if (selectorNode.type.id !== Selector) {\n    return [];\n  }\n\n  let listNode: SyntaxNode | null = walk(selectorNode, [['firstChild', Matchers]]);\n\n  const labels: Label[] = [];\n\n  while (listNode !== null) {\n    const matcherNode = walk(listNode, [['lastChild', Matcher]]);\n    if (matcherNode === null) {\n      // unexpected, we stop\n      return [];\n    }\n\n    const label = getLabel(matcherNode, text);\n    if (label !== null) {\n      labels.push(label);\n    }\n\n    // there might be more labels\n    listNode = walk(listNode, [['firstChild', Matchers]]);\n  }\n\n  // our labels-list is last-first, so we reverse it\n  labels.reverse();\n\n  return labels;\n}\n\nfunction resolveAfterUnwrap(node: SyntaxNode, text: string, pos: number): Situation | null {\n  return {\n    type: 'AFTER_UNWRAP',\n    logQuery: getLogQueryFromMetricsQuery(text).trim(),\n  };\n}\n\nfunction resolvePipeError(node: SyntaxNode, text: string, pos: number): Situation | null {\n  // for example `{level=\"info\"} |`\n  const exprNode = walk(node, [\n    ['parent', PipelineStage],\n    ['parent', PipelineExpr],\n  ]);\n\n  if (exprNode === null) {\n    return null;\n  }\n\n  const { parent } = exprNode;\n\n  if (parent === null) {\n    return null;\n  }\n\n  if (parent.type.id === LogExpr || parent.type.id === LogRangeExpr) {\n    return resolveLogOrLogRange(parent, text, pos, true);\n  }\n\n  return null;\n}\n\nfunction resolveLabelsForGrouping(node: SyntaxNode, text: string, pos: number): Situation | null {\n  const aggrExpNode = walk(node, [['parent', VectorAggregationExpr]]);\n  if (aggrExpNode === null) {\n    return null;\n  }\n  const bodyNode = aggrExpNode.getChild('MetricExpr');\n  if (bodyNode === null) {\n    return null;\n  }\n\n  const selectorNode = walk(bodyNode, [\n    ['firstChild', RangeAggregationExpr],\n    ['lastChild', LogRangeExpr],\n    ['firstChild', Selector],\n  ]);\n\n  if (selectorNode === null) {\n    return null;\n  }\n\n  return {\n    type: 'IN_GROUPING',\n    logQuery: getLogQueryFromMetricsQuery(text).trim(),\n  };\n}\n\nfunction resolveMatcher(node: SyntaxNode, text: string, pos: number): Situation | null {\n  // we can arrive here for two reasons. `node` is either:\n  // - a StringNode (like in `{job=\"^\"}`)\n  // - or an error node (like in `{job=^}`)\n  const inStringNode = !node.type.isError;\n\n  const parent = walk(node, [['parent', Matcher]]);\n  if (parent === null) {\n    return null;\n  }\n\n  const labelNameNode = walk(parent, [['firstChild', Identifier]]);\n  if (labelNameNode === null) {\n    return null;\n  }\n\n  const labelName = getNodeText(labelNameNode, text);\n\n  // now we need to go up, to the parent of Matcher,\n  // there can be one or many `Matchers` parents, we have\n  // to go through all of them\n\n  const firstListNode = walk(parent, [['parent', Matchers]]);\n  if (firstListNode === null) {\n    return null;\n  }\n\n  let listNode = firstListNode;\n\n  // we keep going through the parent-nodes as long as they are Matchers.\n  // as soon as we reach Selector, we stop\n  let selectorNode: SyntaxNode | null = null;\n  while (selectorNode === null) {\n    const parent = listNode.parent;\n    if (parent === null) {\n      return null;\n    }\n\n    switch (parent.type.id) {\n      case Matchers:\n        //we keep looping\n        listNode = parent;\n        continue;\n      case Selector:\n        // we reached the end, we can stop the loop\n        selectorNode = parent;\n        continue;\n      default:\n        // we reached some other node, we stop\n        return null;\n    }\n  }\n\n  // now we need to find the other names\n  const allLabels = getLabels(selectorNode, text);\n\n  // we need to remove \"our\" label from all-labels, if it is in there\n  const otherLabels = allLabels.filter((label) => label.name !== labelName);\n\n  return {\n    type: 'IN_LABEL_SELECTOR_WITH_LABEL_NAME',\n    labelName,\n    betweenQuotes: inStringNode,\n    otherLabels,\n  };\n}\n\nfunction resolveTopLevel(node: SyntaxNode, text: string, pos: number): Situation | null {\n  // we try a couply specific paths here.\n  // `{x=\"y\"}` situation, with the cursor at the end\n\n  const logExprNode = walk(node, [\n    ['lastChild', Expr],\n    ['lastChild', LogExpr],\n  ]);\n\n  if (logExprNode != null) {\n    return resolveLogOrLogRange(logExprNode, text, pos, false);\n  }\n\n  // `s` situation, with the cursor at the end.\n  // (basically, user enters a non-special characters as first\n  // character in query field)\n  const idNode = walk(node, [\n    ['firstChild', ERROR_NODE_ID],\n    ['firstChild', Identifier],\n  ]);\n\n  if (idNode != null) {\n    return {\n      type: 'AT_ROOT',\n    };\n  }\n\n  // no patterns match\n  return null;\n}\n\nfunction resolveDurations(node: SyntaxNode, text: string, pos: number): Situation {\n  return {\n    type: 'IN_RANGE',\n  };\n}\n\nfunction resolveLogRange(node: SyntaxNode, text: string, pos: number): Situation | null {\n  return resolveLogOrLogRange(node, text, pos, false);\n}\n\nfunction resolveLogRangeFromError(node: SyntaxNode, text: string, pos: number): Situation | null {\n  const parent = walk(node, [['parent', LogRangeExpr]]);\n  if (parent === null) {\n    return null;\n  }\n\n  return resolveLogOrLogRange(parent, text, pos, false);\n}\n\nfunction resolveLogOrLogRange(node: SyntaxNode, text: string, pos: number, afterPipe: boolean): Situation | null {\n  // Here the `node` is either a LogExpr or a LogRangeExpr\n  // We want to handle the case where we are next to a selector\n  const selectorNode = walk(node, [['firstChild', Selector]]);\n\n  // Check that the selector is before the cursor, not after it\n  if (!selectorNode || selectorNode.to > pos) {\n    return null;\n  }\n\n  return {\n    type: 'AFTER_SELECTOR',\n    afterPipe,\n    hasSpace: text.endsWith(' '),\n    logQuery: getLogQueryFromMetricsQuery(text).trim(),\n  };\n}\n\nfunction resolveSelector(node: SyntaxNode, text: string, pos: number): Situation | null {\n  // for example `{^}`\n\n  // false positive:\n  // `{a=\"1\"^}`\n  const child = walk(node, [['firstChild', Matchers]]);\n  if (child !== null) {\n    // means the label-matching part contains at least one label already.\n    //\n    // in this case, we will need to have a `,` character at the end,\n    // to be able to suggest adding the next label.\n    // the area between the end-of-the-child-node and the cursor-pos\n    // must contain a `,` in this case.\n    const textToCheck = text.slice(child.to, pos);\n\n    if (!textToCheck.includes(',')) {\n      return null;\n    }\n  }\n\n  const otherLabels = getLabels(node, text);\n\n  return {\n    type: 'IN_LABEL_SELECTOR_NO_LABEL_NAME',\n    otherLabels,\n  };\n}\n\n// we find the first error-node in the tree that is at the cursor-position.\n// NOTE: this might be too slow, might need to optimize it\n// (ideas: we do not need to go into every subtree, based on from/to)\n// also, only go to places that are in the sub-tree of the node found\n// by default by lezer. problem is, `next()` will go upward too,\n// and we do not want to go higher than our node\nfunction getErrorNode(tree: Tree, text: string, cursorPos: number): SyntaxNode | null {\n  // sometimes the cursor is a couple spaces after the end of the expression.\n  // to account for this situation, we \"move\" the cursor position back,\n  // so that there are no spaces between the end-of-expression and the cursor\n  const trimRightTextLen = text.trimEnd().length;\n  const pos = trimRightTextLen < cursorPos ? trimRightTextLen : cursorPos;\n  const cur = tree.cursorAt(pos);\n  do {\n    if (cur.from === pos && cur.to === pos) {\n      const { node } = cur;\n      if (node.type.isError) {\n        return node;\n      }\n    }\n  } while (cur.next());\n  return null;\n}\n\nexport function getSituation(text: string, pos: number): Situation | null {\n  // there is a special case when we are at the start of writing text,\n  // so we handle that case first\n\n  if (text === '') {\n    return {\n      type: 'EMPTY',\n    };\n  }\n\n  const tree = parser.parse(text);\n\n  // if the tree contains error, it is very probable that\n  // our node is one of those error nodes.\n  // also, if there are errors, the node lezer finds us,\n  // might not be the best node.\n  // so first we check if there is an error node at the cursor position\n  const maybeErrorNode = getErrorNode(tree, text, pos);\n\n  const cur = maybeErrorNode != null ? maybeErrorNode.cursor() : tree.cursorAt(pos);\n\n  const currentNode = cur.node;\n\n  const ids = [cur.type.id];\n  while (cur.parent()) {\n    ids.push(cur.type.id);\n  }\n\n  for (let resolver of RESOLVERS) {\n    if (isPathMatch(resolver.path, ids)) {\n      return resolver.fun(currentNode, text, pos);\n    }\n  }\n\n  return null;\n}\n","import type { Monaco, monacoTypes } from '@grafana/ui';\n\nimport { CompletionDataProvider } from './CompletionDataProvider';\nimport { NeverCaseError } from './NeverCaseError';\nimport { getCompletions, CompletionType } from './completions';\nimport { getSituation } from './situation';\n\n// from: monacoTypes.languages.CompletionItemInsertTextRule.InsertAsSnippet\nconst INSERT_AS_SNIPPET_ENUM_VALUE = 4;\n\nexport function getSuggestOptions(): monacoTypes.editor.ISuggestOptions {\n  return {\n    // monaco-editor sometimes provides suggestions automatically, i am not\n    // sure based on what, seems to be by analyzing the words already\n    // written.\n    // to try it out:\n    // - enter `go_goroutines{job~`\n    // - have the cursor at the end of the string\n    // - press ctrl-enter\n    // - you will get two suggestions\n    // those were not provided by grafana, they are offered automatically.\n    // i want to remove those. the only way i found is:\n    // - every suggestion-item has a `kind` attribute,\n    //   that controls the icon to the left of the suggestion.\n    // - items auto-generated by monaco have `kind` set to `text`.\n    // - we make sure grafana-provided suggestions do not have `kind` set to `text`.\n    // - and then we tell monaco not to show suggestions of kind `text`\n    showWords: false,\n  };\n}\n\nfunction getMonacoCompletionItemKind(type: CompletionType, monaco: Monaco): monacoTypes.languages.CompletionItemKind {\n  switch (type) {\n    case 'DURATION':\n      return monaco.languages.CompletionItemKind.Unit;\n    case 'FUNCTION':\n      return monaco.languages.CompletionItemKind.Variable;\n    case 'HISTORY':\n      return monaco.languages.CompletionItemKind.Snippet;\n    case 'LABEL_NAME':\n      return monaco.languages.CompletionItemKind.Enum;\n    case 'LABEL_VALUE':\n      return monaco.languages.CompletionItemKind.EnumMember;\n    case 'PATTERN':\n      return monaco.languages.CompletionItemKind.Constructor;\n    case 'PARSER':\n      return monaco.languages.CompletionItemKind.Class;\n    case 'LINE_FILTER':\n      return monaco.languages.CompletionItemKind.TypeParameter;\n    case 'PIPE_OPERATION':\n      return monaco.languages.CompletionItemKind.Interface;\n    default:\n      throw new NeverCaseError(type);\n  }\n}\nexport function getCompletionProvider(\n  monaco: Monaco,\n  dataProvider: CompletionDataProvider\n): monacoTypes.languages.CompletionItemProvider {\n  const provideCompletionItems = (\n    model: monacoTypes.editor.ITextModel,\n    position: monacoTypes.Position\n  ): monacoTypes.languages.ProviderResult<monacoTypes.languages.CompletionList> => {\n    const word = model.getWordAtPosition(position);\n    const range =\n      word != null\n        ? monaco.Range.lift({\n            startLineNumber: position.lineNumber,\n            endLineNumber: position.lineNumber,\n            startColumn: word.startColumn,\n            endColumn: word.endColumn,\n          })\n        : monaco.Range.fromPositions(position);\n    // documentation says `position` will be \"adjusted\" in `getOffsetAt`\n    // i don't know what that means, to be sure i clone it\n    const positionClone = {\n      column: position.column,\n      lineNumber: position.lineNumber,\n    };\n    const offset = model.getOffsetAt(positionClone);\n    const situation = getSituation(model.getValue(), offset);\n    const completionsPromise = situation != null ? getCompletions(situation, dataProvider) : Promise.resolve([]);\n    return completionsPromise.then((items) => {\n      // monaco by default alphabetically orders the items.\n      // to stop it, we use a number-as-string sortkey,\n      // so that monaco keeps the order we use\n      const maxIndexDigits = items.length.toString().length;\n      const suggestions: monacoTypes.languages.CompletionItem[] = items.map((item, index) => ({\n        kind: getMonacoCompletionItemKind(item.type, monaco),\n        label: item.label,\n        insertText: item.insertText,\n        insertTextRules: item.isSnippet ? INSERT_AS_SNIPPET_ENUM_VALUE : undefined,\n        detail: item.detail,\n        documentation: item.documentation,\n        sortText: index.toString().padStart(maxIndexDigits, '0'), // to force the order we have\n        range,\n        command: item.triggerOnInsert\n          ? {\n              id: 'editor.action.triggerSuggest',\n              title: '',\n            }\n          : undefined,\n      }));\n      return { suggestions };\n    });\n  };\n\n  return {\n    triggerCharacters: ['{', ',', '[', '(', '=', '~', ' ', '\"', '|'],\n    provideCompletionItems,\n  };\n}\n","import { chain } from 'lodash';\n\nimport { HistoryItem } from '@grafana/data';\nimport { escapeLabelValueInExactSelector } from 'app/plugins/datasource/prometheus/language_utils';\n\nimport LanguageProvider from '../../../LanguageProvider';\nimport { LokiQuery } from '../../../types';\n\nimport { Label } from './situation';\n\ninterface HistoryRef {\n  current: Array<HistoryItem<LokiQuery>>;\n}\n\nexport class CompletionDataProvider {\n  constructor(private languageProvider: LanguageProvider, private historyRef: HistoryRef = { current: [] }) {}\n\n  private buildSelector(labels: Label[]): string {\n    const allLabelTexts = labels.map(\n      (label) => `${label.name}${label.op}\"${escapeLabelValueInExactSelector(label.value)}\"`\n    );\n\n    return `{${allLabelTexts.join(',')}}`;\n  }\n\n  getHistory() {\n    return chain(this.historyRef.current)\n      .map((history: HistoryItem<LokiQuery>) => history.query.expr)\n      .filter()\n      .uniq()\n      .value();\n  }\n\n  async getLabelNames(otherLabels: Label[] = []) {\n    if (otherLabels.length === 0) {\n      // if there is no filtering, we have to use a special endpoint\n      return this.languageProvider.getLabelKeys();\n    }\n    const data = await this.getSeriesLabels(otherLabels);\n    const possibleLabelNames = Object.keys(data); // all names from datasource\n    const usedLabelNames = new Set(otherLabels.map((l) => l.name)); // names used in the query\n    return possibleLabelNames.filter((label) => !usedLabelNames.has(label));\n  }\n\n  async getLabelValues(labelName: string, otherLabels: Label[]) {\n    if (otherLabels.length === 0) {\n      // if there is no filtering, we have to use a special endpoint\n      return await this.languageProvider.getLabelValues(labelName);\n    }\n\n    const data = await this.getSeriesLabels(otherLabels);\n    return data[labelName] ?? [];\n  }\n\n  async getParserAndLabelKeys(logQuery: string) {\n    return await this.languageProvider.getParserAndLabelKeys(logQuery);\n  }\n\n  async getSeriesLabels(labels: Label[]) {\n    return await this.languageProvider.getSeriesLabels(this.buildSelector(labels)).then((data) => data ?? {});\n  }\n}\n","import { SyntaxNode } from '@lezer/common';\n\nimport { parser } from '@grafana/lezer-logql';\nimport { ErrorId } from 'app/plugins/datasource/prometheus/querybuilder/shared/parsingUtils';\n\ninterface ParserErrorBoundary {\n  startLineNumber: number;\n  startColumn: number;\n  endLineNumber: number;\n  endColumn: number;\n  error: string;\n}\n\ninterface ParseError {\n  text: string;\n  node: SyntaxNode;\n}\n\nexport function validateQuery(\n  query: string,\n  interpolatedQuery: string,\n  queryLines: string[]\n): ParserErrorBoundary[] | false {\n  if (!query) {\n    return false;\n  }\n\n  /**\n   * To provide support to variable interpolation in query validation, we run the parser in the interpolated\n   * query. If there are errors there, we trace them back to the original unparsed query, so we can more\n   * accurately highlight the error in the query, since it's likely that the variable name and variable value\n   * have different lengths. With this, we also exclude irrelevant parser errors that are produced by\n   * lezer not understanding $variables and $__variables, which usually generate 2 or 3 error SyntaxNode.\n   */\n  const interpolatedErrors: ParseError[] = parseQuery(interpolatedQuery);\n  if (!interpolatedErrors.length) {\n    return false;\n  }\n\n  let parseErrors: ParseError[] = interpolatedErrors;\n  if (query !== interpolatedQuery) {\n    const queryErrors: ParseError[] = parseQuery(query);\n    parseErrors = interpolatedErrors.flatMap(\n      (interpolatedError) =>\n        queryErrors.filter((queryError) => interpolatedError.text === queryError.text) || interpolatedError\n    );\n  }\n\n  return parseErrors.map((parseError) => findErrorBoundary(query, queryLines, parseError)).filter(isErrorBoundary);\n}\n\nfunction parseQuery(query: string) {\n  const parseErrors: ParseError[] = [];\n  const tree = parser.parse(query);\n  tree.iterate({\n    enter: (nodeRef): false | void => {\n      if (nodeRef.type.id === ErrorId) {\n        const node = nodeRef.node;\n        parseErrors.push({\n          node: node,\n          text: query.substring(node.from, node.to),\n        });\n      }\n    },\n  });\n  return parseErrors;\n}\n\nfunction findErrorBoundary(query: string, queryLines: string[], parseError: ParseError): ParserErrorBoundary | null {\n  if (queryLines.length === 1) {\n    const isEmptyString = parseError.node.from === parseError.node.to;\n    const errorNode = isEmptyString && parseError.node.parent ? parseError.node.parent : parseError.node;\n    const error = isEmptyString ? query.substring(errorNode.from, errorNode.to) : parseError.text;\n    return {\n      startLineNumber: 1,\n      startColumn: errorNode.from + 1,\n      endLineNumber: 1,\n      endColumn: errorNode.to + 1,\n      error,\n    };\n  }\n\n  let startPos = 0,\n    endPos = 0;\n  for (let line = 0; line < queryLines.length; line++) {\n    endPos = startPos + queryLines[line].length;\n\n    if (parseError.node.from > endPos) {\n      startPos += queryLines[line].length + 1;\n      continue;\n    }\n\n    return {\n      startLineNumber: line + 1,\n      startColumn: parseError.node.from - startPos + 1,\n      endLineNumber: line + 1,\n      endColumn: parseError.node.to - startPos + 1,\n      error: parseError.text,\n    };\n  }\n\n  return null;\n}\n\nfunction isErrorBoundary(boundary: ParserErrorBoundary | null): boundary is ParserErrorBoundary {\n  return boundary !== null;\n}\n\nexport const placeHolderScopedVars = {\n  __interval: { text: '1s', value: '1s' },\n  __interval_ms: { text: '1000', value: 1000 },\n  __range_ms: { text: '1000', value: 1000 },\n  __range_s: { text: '1', value: 1 },\n  __range: { text: '1s', value: '1s' },\n};\n","import { css } from '@emotion/css';\nimport { debounce } from 'lodash';\nimport React, { useRef, useEffect } from 'react';\nimport { useLatest } from 'react-use';\nimport { v4 as uuidv4 } from 'uuid';\n\nimport { GrafanaTheme2 } from '@grafana/data';\nimport { selectors } from '@grafana/e2e-selectors';\nimport { languageConfiguration, monarchlanguage } from '@grafana/monaco-logql';\nimport { useTheme2, ReactMonacoEditor, Monaco, monacoTypes, MonacoEditor } from '@grafana/ui';\n\nimport { isValidQuery } from '../../queryUtils';\n\nimport { Props } from './MonacoQueryFieldProps';\nimport { getOverrideServices } from './getOverrideServices';\nimport { getCompletionProvider, getSuggestOptions } from './monaco-completion-provider';\nimport { CompletionDataProvider } from './monaco-completion-provider/CompletionDataProvider';\nimport { placeHolderScopedVars, validateQuery } from './monaco-completion-provider/validation';\n\nconst options: monacoTypes.editor.IStandaloneEditorConstructionOptions = {\n  codeLens: false,\n  contextmenu: false,\n  // we need `fixedOverflowWidgets` because otherwise in grafana-dashboards\n  // the popup is clipped by the panel-visualizations.\n  fixedOverflowWidgets: true,\n  folding: false,\n  fontSize: 14,\n  lineDecorationsWidth: 8, // used as \"padding-left\"\n  lineNumbers: 'off',\n  minimap: { enabled: false },\n  overviewRulerBorder: false,\n  overviewRulerLanes: 0,\n  padding: {\n    // these numbers were picked so that visually this matches the previous version\n    // of the query-editor the best\n    top: 4,\n    bottom: 5,\n  },\n  renderLineHighlight: 'none',\n  scrollbar: {\n    vertical: 'hidden',\n    verticalScrollbarSize: 8, // used as \"padding-right\"\n    horizontal: 'hidden',\n    horizontalScrollbarSize: 0,\n  },\n  scrollBeyondLastLine: false,\n  suggest: getSuggestOptions(),\n  suggestFontSize: 12,\n  wordWrap: 'on',\n};\n\n// this number was chosen by testing various values. it might be necessary\n// because of the width of the border, not sure.\n//it needs to do 2 things:\n// 1. when the editor is single-line, it should make the editor height be visually correct\n// 2. when the editor is multi-line, the editor should not be \"scrollable\" (meaning,\n//    you do a scroll-movement in the editor, and it will scroll the content by a couple pixels\n//    up & down. this we want to avoid)\nconst EDITOR_HEIGHT_OFFSET = 2;\n\nconst LANG_ID = 'logql';\n\n// we must only run the lang-setup code once\nlet LANGUAGE_SETUP_STARTED = false;\n\nfunction ensureLogQL(monaco: Monaco) {\n  if (LANGUAGE_SETUP_STARTED === false) {\n    LANGUAGE_SETUP_STARTED = true;\n    monaco.languages.register({ id: LANG_ID });\n\n    monaco.languages.setMonarchTokensProvider(LANG_ID, monarchlanguage);\n    monaco.languages.setLanguageConfiguration(LANG_ID, languageConfiguration);\n  }\n}\n\nconst getStyles = (theme: GrafanaTheme2, placeholder: string) => {\n  return {\n    container: css`\n      border-radius: ${theme.shape.borderRadius()};\n      border: 1px solid ${theme.components.input.borderColor};\n      width: 100%;\n    `,\n    placeholder: css`\n      ::after {\n        content: '${placeholder}';\n        font-family: ${theme.typography.fontFamilyMonospace};\n        opacity: 0.3;\n      }\n    `,\n  };\n};\n\nconst MonacoQueryField = ({\n  history,\n  onBlur,\n  onRunQuery,\n  initialValue,\n  datasource,\n  placeholder,\n  onQueryType,\n}: Props) => {\n  const id = uuidv4();\n  // we need only one instance of `overrideServices` during the lifetime of the react component\n  const overrideServicesRef = useRef(getOverrideServices());\n  const containerRef = useRef<HTMLDivElement>(null);\n\n  const langProviderRef = useLatest(datasource.languageProvider);\n  const historyRef = useLatest(history);\n  const onRunQueryRef = useLatest(onRunQuery);\n  const onBlurRef = useLatest(onBlur);\n\n  const autocompleteCleanupCallback = useRef<(() => void) | null>(null);\n\n  const theme = useTheme2();\n  const styles = getStyles(theme, placeholder);\n\n  useEffect(() => {\n    // when we unmount, we unregister the autocomplete-function, if it was registered\n    return () => {\n      autocompleteCleanupCallback.current?.();\n    };\n  }, []);\n\n  const setPlaceholder = (monaco: Monaco, editor: MonacoEditor) => {\n    const placeholderDecorators = [\n      {\n        range: new monaco.Range(1, 1, 1, 1),\n        options: {\n          className: styles.placeholder,\n          isWholeLine: true,\n        },\n      },\n    ];\n\n    let decorators: string[] = [];\n\n    const checkDecorators: () => void = () => {\n      const model = editor.getModel();\n\n      if (!model) {\n        return;\n      }\n\n      const newDecorators = model.getValueLength() === 0 ? placeholderDecorators : [];\n      decorators = model.deltaDecorations(decorators, newDecorators);\n    };\n\n    checkDecorators();\n    editor.onDidChangeModelContent(checkDecorators);\n  };\n\n  const onTypeDebounced = debounce(async (query: string) => {\n    if (!onQueryType || (isValidQuery(query) === false && query !== '')) {\n      return;\n    }\n\n    onQueryType(query);\n  }, 1000);\n\n  return (\n    <div\n      aria-label={selectors.components.QueryField.container}\n      className={styles.container}\n      // NOTE: we will be setting inline-style-width/height on this element\n      ref={containerRef}\n    >\n      <ReactMonacoEditor\n        overrideServices={overrideServicesRef.current}\n        options={options}\n        language={LANG_ID}\n        value={initialValue}\n        beforeMount={(monaco) => {\n          ensureLogQL(monaco);\n        }}\n        onMount={(editor, monaco) => {\n          // Monaco has a bug where it runs actions on all instances (https://github.com/microsoft/monaco-editor/issues/2947), so we ensure actions are executed on instance-level with this ContextKey.\n          const isEditorFocused = editor.createContextKey<boolean>('isEditorFocused' + id, false);\n          // we setup on-blur\n          editor.onDidBlurEditorWidget(() => {\n            isEditorFocused.set(false);\n            onBlurRef.current(editor.getValue());\n          });\n          editor.onDidChangeModelContent((e) => {\n            const model = editor.getModel();\n            if (!model) {\n              return;\n            }\n            const query = model.getValue();\n            const errors =\n              validateQuery(\n                query,\n                datasource.interpolateString(query, placeHolderScopedVars),\n                model.getLinesContent()\n              ) || [];\n\n            const markers = errors.map(({ error, ...boundary }) => ({\n              message: `${\n                error ? `Error parsing \"${error}\"` : 'Parse error'\n              }. The query appears to be incorrect and could fail to be executed.`,\n              severity: monaco.MarkerSeverity.Error,\n              ...boundary,\n            }));\n\n            onTypeDebounced(query);\n            monaco.editor.setModelMarkers(model, 'owner', markers);\n          });\n          const dataProvider = new CompletionDataProvider(langProviderRef.current, historyRef);\n          const completionProvider = getCompletionProvider(monaco, dataProvider);\n\n          // completion-providers in monaco are not registered directly to editor-instances,\n          // they are registered to languages. this makes it hard for us to have\n          // separate completion-providers for every query-field-instance\n          // (but we need that, because they might connect to different datasources).\n          // the trick we do is, we wrap the callback in a \"proxy\",\n          // and in the proxy, the first thing is, we check if we are called from\n          // \"our editor instance\", and if not, we just return nothing. if yes,\n          // we call the completion-provider.\n          const filteringCompletionProvider: monacoTypes.languages.CompletionItemProvider = {\n            ...completionProvider,\n            provideCompletionItems: (model, position, context, token) => {\n              // if the model-id does not match, then this call is from a different editor-instance,\n              // not \"our instance\", so return nothing\n              if (editor.getModel()?.id !== model.id) {\n                return { suggestions: [] };\n              }\n              return completionProvider.provideCompletionItems(model, position, context, token);\n            },\n          };\n\n          const { dispose } = monaco.languages.registerCompletionItemProvider(LANG_ID, filteringCompletionProvider);\n\n          autocompleteCleanupCallback.current = dispose;\n          // this code makes the editor resize itself so that the content fits\n          // (it will grow taller when necessary)\n          // FIXME: maybe move this functionality into CodeEditor, like:\n          // <CodeEditor resizingMode=\"single-line\"/>\n          const handleResize = () => {\n            const containerDiv = containerRef.current;\n            if (containerDiv !== null) {\n              const pixelHeight = editor.getContentHeight();\n              containerDiv.style.height = `${pixelHeight + EDITOR_HEIGHT_OFFSET}px`;\n              const pixelWidth = containerDiv.clientWidth;\n              editor.layout({ width: pixelWidth, height: pixelHeight });\n            }\n          };\n\n          editor.onDidContentSizeChange(handleResize);\n          handleResize();\n          // handle: shift + enter\n          // FIXME: maybe move this functionality into CodeEditor?\n          editor.addCommand(\n            monaco.KeyMod.Shift | monaco.KeyCode.Enter,\n            () => {\n              onRunQueryRef.current(editor.getValue());\n            },\n            'isEditorFocused' + id\n          );\n\n          editor.onDidFocusEditorText(() => {\n            isEditorFocused.set(true);\n            if (editor.getValue().trim() === '') {\n              editor.trigger('', 'editor.action.triggerSuggest', {});\n            }\n          });\n\n          setPlaceholder(monaco, editor);\n        }}\n      />\n    </div>\n  );\n};\n\n// Default export for lazy load.\nexport default MonacoQueryField;\n","import { useRef } from 'react';\nvar useLatest = function (value) {\n    var ref = useRef(value);\n    ref.current = value;\n    return ref;\n};\nexport default useLatest;\n"],"names":["exports","aggregations","parsers","format_expressions","vector_aggregations","vector_matching","vectorMatchingRegex","prev","curr","operators","keywords","makeStorageService","strings","data","key","scope","fallbackValue","val","value","target","reason","overrideServices","getOverrideServices","NeverCaseError","LOG_COMPLETIONS","AGGREGATION_COMPLETIONS","f","FUNCTION_COMPLETIONS","BUILT_IN_FUNCTIONS_COMPLETIONS","DURATION_COMPLETIONS","text","UNWRAP_FUNCTION_COMPLETIONS","LINE_FILTER_COMPLETIONS","getLineFilterCompletions","afterPipe","completion","operator","documentation","getAllHistoryCompletions","dataProvider","expr","getLabelNamesForSelectorCompletions","otherLabels","label","getInGroupingCompletions","logQuery","extractedLabelKeys","PARSERS","getParserCompletions","prefix","hasJSON","hasLogfmt","hasPack","hasParserInQuery","allParsers","completions","hasLevelInExtractedLabels","extra","parser","getAfterSelectorCompletions","hasSpace","query","hasQueryParser","getLabelValuesForMetricCompletions","labelName","betweenQuotes","getAfterUnwrapCompletions","unwrapLabelKeys","getCompletions","situation","move","node","direction","walk","path","current","expectedNode","getNodeText","parseStringLiteral","inside","isPathMatch","resolverPath","cursorPath","item","index","ERROR_NODE_ID","RESOLVERS","resolveSelector","resolveTopLevel","resolveMatcher","resolveLabelsForGrouping","resolveLogRange","resolveDurations","resolveLogRangeFromError","resolvePipeError","resolveAfterUnwrap","LABEL_OP_MAP","getLabelOp","opNode","getLabel","matcherNode","nameNode","op","valueNode","name","getLabels","selectorNode","listNode","labels","pos","exprNode","parent","resolveLogOrLogRange","aggrExpNode","bodyNode","inStringNode","labelNameNode","firstListNode","logExprNode","child","getErrorNode","tree","cursorPos","trimRightTextLen","cur","getSituation","maybeErrorNode","currentNode","ids","resolver","INSERT_AS_SNIPPET_ENUM_VALUE","getSuggestOptions","getMonacoCompletionItemKind","type","monaco","getCompletionProvider","model","position","word","range","positionClone","offset","items","maxIndexDigits","CompletionDataProvider","languageProvider","historyRef","history","possibleLabelNames","usedLabelNames","l","validateQuery","interpolatedQuery","queryLines","interpolatedErrors","parseQuery","parseErrors","queryErrors","interpolatedError","queryError","parseError","findErrorBoundary","isErrorBoundary","nodeRef","isEmptyString","errorNode","error","startPos","endPos","line","boundary","placeHolderScopedVars","options","EDITOR_HEIGHT_OFFSET","LANG_ID","LANGUAGE_SETUP_STARTED","ensureLogQL","getStyles","theme","placeholder","onBlur","onRunQuery","initialValue","datasource","onQueryType","id","overrideServicesRef","containerRef","langProviderRef","useLatest","onRunQueryRef","onBlurRef","autocompleteCleanupCallback","styles","setPlaceholder","editor","placeholderDecorators","decorators","checkDecorators","newDecorators","onTypeDebounced","selectors","isEditorFocused","e","markers","completionProvider","filteringCompletionProvider","context","token","dispose","handleResize","containerDiv","pixelHeight","pixelWidth","ref"],"sourceRoot":""}