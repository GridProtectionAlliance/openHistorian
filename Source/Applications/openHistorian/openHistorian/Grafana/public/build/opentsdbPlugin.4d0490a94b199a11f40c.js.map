{"version":3,"sources":["webpack:///./public/app/plugins/datasource/opentsdb/datasource.ts","webpack:///./public/app/plugins/datasource/opentsdb/query_ctrl.ts","webpack:///./public/app/plugins/datasource/opentsdb/components/OpenTsdbDetails.tsx","webpack:///./public/app/plugins/datasource/opentsdb/module.ts","webpack:///./public/app/plugins/datasource/opentsdb/components/ConfigEditor.tsx"],"names":["_super","OpenTsDatasource","instanceSettings","backendSrv","templateSrv","_this","call","this","type","url","name","withCredentials","basicAuth","jsonData","tsdbVersion","tsdbResolution","lookupLimit","tagKeys","aggregatorsPromise","$inject","Object","tslib_es6","prototype","query","options","start","convertToTSDBTime","rangeRaw","from","timezone","end","to","qs","a","each","targets","target","metric","push","convertTargetToQuery","queries","lodash_default","compact","isEmpty","Promise","resolve","data","groupByTags","filters","length","val","tagk","tags","key","filter","hide","performTimeSeriesQuery","then","response","metricToTargetMapping","mapMetricsToTargets","map","metricData","index","_saveTagKeys","transformMetricData","annotationQuery","eventList","aggregator","annotation","results","annotationObject","annotations","isGlobal","globalAnnotations","event","text","description","time","Math","floor","startTime","targetContainsTemplate","i","variableExists","keys","tagKey","msResolution","reqBody","showQuery","method","_addCredentialOptions","datasourceRequest","suggestTagKeys","aggregateTags","tag","_performSuggestQuery","_get","q","max","result","_performMetricKeyValueLookup","keysArray","split","trim","keysQuery","splice","join","m","limit","tagvs","r","indexOf","_performMetricKeyLookup","tagks","tagv","relativeUrl","params","headers","Authorization","metricFindQuery","interpolated","replace","err","reject","responseTransform","value","metricsQuery","match","tagNamesQuery","tagValuesQuery","tagNamesSuggestQuery","tagValuesSuggestQuery","testDatasource","status","message","getAggregators","isArray","sort","getFilterTypes","filterTypesPromise","md","metricLabel","createMetricLabel","dps","v","k","datapoints","alias","scopedVars_1","clone","scopedVars","label","tagData","toPairs","has","shouldComputeRate","rate","rateOptions","counter","isCounter","counterMax","parseInt","counterResetValue","resetValue","dropResets","ResetValue","disableDownsampling","interval","downsampleInterval","parseFloat","downsample","downsampleAggregator","downsampleFillPolicy","angular_default","copy","filterKey","explicitTags","metrics","interpolatedTagValue","arrTagV","findIndex","every","tagV","tagK","includes","date","roundUp","src","parse","valueOf","query_ctrl_OpenTsQueryCtrl","OpenTsQueryCtrl","$scope","$injector","errors","validateTarget","aggregators","fillPolicies","filterTypes","datasource","aggs","callback","getTextValues","targetBlur","refresh","metricFindResult","addTag","addTagMode","currentTagKey","currentTagValue","removeTag","editTag","closeAddTagMode","addFilter","size","addFilterMode","currentFilterType","currentFilterGroupBy","currentFilter","currentFilterKey","currentFilterValue","groupBy","removeFilter","editFilter","fil","closeAddFilterMode","errs","shouldDownsample","describe_interval","templateUrl","tsdbVersions","tsdbResolutions","OpenTsdbDetails","props","_a","_b","_c","onChange","react_default","createElement","Fragment","className","grafana_ui_src","width","find","version","onSelectChangeHandler","resolution","onInputChangeHandler","newValue","__webpack_require__","d","__webpack_exports__","module_plugin","AnnotationsQueryCtrl","setQueryCtrl","onOptionsChange","defaultUrl","dataSourceConfig"],"mappings":"6KAOA,SAAAA,YAeEC,EACEC,EAAMC,EAAiBC,GADkB,IAAAC,EAAAL,EAAAM,KAAAC,KAAsBL,IAAAK,KAgBhE,OAhB0EF,EAAAF,WAAWA,EAGpFE,EAAKD,YAAOA,EACZC,EAAKG,KAAM,WACXH,EAAKI,IAAIP,EAAmBO,IAC5BJ,EAAKK,KAAAR,EAAkBQ,KACvBL,EAAKM,gBAAYT,EAAiBS,gBAClCN,EAAAO,UAAiBV,EAAWU,UAC5BV,EAAgBW,SAAGX,EAAyBW,UAAY,GACxDR,EAAKS,YAAcZ,EAAGW,SAAiBC,aAAS,EAChDT,EAAKU,eAAcb,EAAiBW,SAASE,gBAAoB,EACjEV,EAAKW,YAAad,EAAAW,SAAAG,aAAA,IAElBX,EAAKY,QAAA,GACLZ,EAAKa,mBAAqB,+BAC3Bb,EA/B2C,OAAAJ,EAAAkB,QAAA,iCAA6C,eAczFC,OAAAC,EAAgB,UAAhBD,CAAgBnB,EAAAD,KAoBhBsB,UAiDCC,MAAA,SAAAC,GAhDC,IAAMnB,EAAQE,KACRkB,EAAMlB,KAAKmB,kBAAkBF,EAAQG,SAAWC,MAAM,EAAEJ,EAAQK,UAChEC,EAAYvB,KAAGmB,kBAAAF,EAAAG,SAAAI,IAAA,EAAAP,EAAAK,UAErBG,EAAA,KACaC,EAACC,KAAMV,EAAEW,QAAA,SAAAC,GAClBA,EAAOC,QAGRL,EAAAM,KAAAjC,EAAAkC,qBAAAH,EAAAZ,EAAAnB,EAAAS,gBAIH,IAAA0B,EAAAC,EAAAR,EAAAS,QAAAV,MAEES,EAAeR,EAAAU,QAAUH,GAC1B,OAAAI,QAAAC,QAAA,CAAAC,KAAA,KAGD,IAAAC,EAAE,YACUd,EAAAC,KAAOM,EAAU,SAAQjB,GACjCA,EAAAyB,SAAEzB,EAAKyB,QAAMC,OAAS,IACThB,EAACC,KAAIX,EAAQyB,QAAK,SAAAE,GAC5BH,EAAAG,EAAAC,OAAA,MAGUlB,EAACC,KAAIX,EAAQ6B,KAAA,SAAAF,EAAAG,GACvBN,EAAAM,IAAA,QAKLlB,QAAaM,EAAcR,EAAAqB,OAAA9B,EAAAW,QAAA,SAAAZ,GAC1B,WAAAA,EAAAgC,OAGDhD,KAAMiD,uBAAwBhB,EAAKf,EAAAK,GAAA2B,KAAoB,SAAaC,GACpE,IAAMC,EAAStD,EAAMuD,oBAAeF,EAACZ,KAAetB,EAAenB,EAAAS,aAUlE,OAAAgC,KATSL,EAAAR,EAAA4B,IAAsBH,EAAOZ,KAAA,SAAAgB,EAAAC,GAOpC,OALW,KADZA,EAAIJ,EAAcI,MAEjBA,EAAA,GAGD1D,EAAA2D,aAAYF,GACXzD,EAAA4D,oBAAAH,EAAAf,EAAAvB,EAAAW,QAAA4B,GAAAvC,EAAAnB,EAAAU,wBAMSO,UAAK4C,gBAAkB,SAAgB1C,GACrD,IAAMC,EAAMlB,KAAKmB,kBAAkBF,EAAQG,SAAWC,MAAM,EAAEJ,EAAQK,UAChEC,EAAKvB,KAAGmB,kBAAAF,EAAAG,SAAAI,IAAA,EAAAP,EAAAK,UACRG,EAAA,GAEHmC,EAAO,GAEVnC,EAAAM,KAAM,CAAA8B,WAAU,MAAA/B,OAAEb,EAAY6C,WAAAjC,SAE9B,IAAAI,EAAYC,EAAAR,EAAAS,QAAuBV,UACjCzB,KAAIiD,uBAAiBhB,EAAAf,EAAAK,GAAA2B,KAAA,SAAAa,MACnBA,EAAIxB,KAAA,IACJ,IAAIyB,EAAmBD,EAAQxB,KAAE,GAAA0B,YAC/BhD,EAAA6C,WAAmBI,WACpBF,EAAAD,EAAAxB,KAAA,GAAA4B,mBAECH,KACatC,EAAGC,KAAAqC,EAAA,SAAAF,OACZM,EAAM,CACNC,KAAMP,EAAWQ,YACjBC,KAA8B,IAA9BC,KAAUC,MAAEX,EAAQY,WACpBZ,WAAA7C,EAAA6C,YAGDF,EAAA7B,KAAAqC,KAIN,OAAAR,OAIQ7C,UAAW4D,uBAAyB,SAAE9C,MAC/CA,EAAKY,SAAYZ,EAAGY,QAAOC,OAAc,MACvC,IAAIkC,EAAK,EAAAA,EAAA/C,EAAYY,QAAAC,OAAekC,OAClC5E,KAAAH,YAAYgF,eAAAhD,EAAAY,QAAAmC,GAAA7B,QACb,YAKHlB,EAAKgB,MAAYhC,OAAIiE,KAAOjD,EAAMgB,MAAAH,OAAA,MAChC,IAAIqC,KAAKlD,EAAYgB,QACnB7C,KAAAH,YAAYgF,eAAAhD,EAAAgB,KAAAkC,IACb,SAKN,YAGKhE,UAAekC,uBAAM,SAAAhB,EAAAf,EAAAK,GACzB,IAAIyD,GAAK,EACa,IAApBhF,KAAAQ,iBACDwE,GAAA,OAECC,EAAO,CACP/D,MAAOA,EACPe,UACA+C,eACAb,mBAAA,GAEoB,IAApBnE,KAAAO,cACD0E,EAAAC,WAAA,GAIC3D,IACD0D,EAAA1D,WAGCN,EAAQ,CACRkE,OAAK,OACLjF,IAAIF,KAAEE,IAAO,aACbqC,KAAA0C,GAIH,OADCjF,KAAAoF,sBAAuBnE,GACxBjB,KAAAJ,WAAAyF,kBAAApE,MAGQF,UAAgBuE,eAAa,SAAcxD,GACnD,OAAAO,QAAAC,QAAAtC,KAAAU,QAAAoB,IAAA,OAGcf,UAAU0C,aAAgB,SAAMF,GAC7C,IAAA7C,EAAAG,OAAMiE,KAACvB,EAAWV,QACRnB,EAAKC,KAAK4B,EAAAgC,cAAA,SAAAC,GACjB9E,EAAAqB,KAAAyD,KAGJxF,KAAAU,QAAA6C,EAAAzB,QAAApB,KAGaK,UAAK0E,qBAAsB,SAAUzE,EAAOf,UACtDD,KAAO0F,KAAM,eAAM,CAAAzF,OAAA0F,EAAA3E,EAAA4E,IAAA5F,KAAAS,cAAAyC,KAAA,SAAA2C,GAClB,OAAAA,EAAAtD,UAIQxB,UAAW+E,6BAAA,SAAAhE,EAAAgD,OACpBhD,IAAOgD,EACR,OAAAzC,QAAAC,QAAA,QAGCyD,EAAWjB,EAAMkB,MAAC,KAAA1C,IAAA,SAAAR,GACjB,OAAAA,EAAAmD,SAECnD,EAAAiD,EAAe,GAEfG,EAAUpD,EAAM,KAClBiD,EAASrD,OAAU,IACpBwD,GAAA,IAAAH,EAAAI,OAAA,GAAAC,KAAA,MAID,IAAAC,EAAOvE,EAAU,IAAAoE,EAAA,WACflG,KAAM0F,KAAG,qBAAoB,CAAAW,IAAAC,MAAAtG,KAAAS,cAAAyC,KAAA,SAAA2C,GAC7BA,EAAWA,EAAatD,KAAAwB,QACxB,IAAAwC,EAAA,GAMC,SALW7E,EAAAC,KAAQkE,EAAO,SAAWW,IACV,IAAxBD,EAAME,QAAOD,EAAA3D,KAAQC,KACtByD,EAAAxE,KAAAyE,EAAA3D,KAAAC,MAGFyD,OAIUxF,UAAA2F,wBAAA,SAAA5E,UACXA,EAIA9B,KAAM0F,KAAG,qBAAoB,CAAAW,EAAAvE,EAAAwE,MAAA,MAAApD,KAAA,SAAA2C,GAC7BA,EAAWA,EAAatD,KAAAwB,QACxB,IAAA4C,EAAA,GAQC,SAPCjF,EAAAC,KAAEkE,EAAO,SAAMW,KACH9E,EAAAC,KAAQ6E,EAAA3D,KAAK,SAAS+D,EAAAhE,IACb,IAAjB+D,EAAMF,QAAK7D,IACZ+D,EAAA5E,KAAAa,OAIJ+D,IAbFtE,QAAAC,QAAA,OAiBYvB,UAAG2E,KAAA,SAAAmB,EAAAC,OACd7F,EAAQ,CACRkE,OAAK,MACLjF,IAAAF,KAAQE,IAAM2G,EACdC,UAKH,OADC9G,KAAAoF,sBAAuBnE,GACxBjB,KAAAJ,WAAAyF,kBAAApE,MAGUF,UAAaqE,sBAAsB,SAAAnE,IAC1CjB,KAAAK,WAAQL,KAAeI,mBACxBa,EAAAb,iBAAA,GAECJ,KAAAK,YACDY,EAAA8F,QAAA,CAAAC,cAAAhH,KAAAK,eAIWU,UAAAkG,gBAAA,SAAAjG,OACVA,EACD,OAAAqB,QAAAC,QAAA,IAGD,IAAI4E,MAEHA,EAAAlH,KAAAH,YAAAsH,QAAAnG,EAAA,wBACCoG,GACD,OAAA/E,QAAAgF,OAAAD,OAGCE,EAAO,SAAMzB,UACX3D,EAAeR,EAAK4B,IAAGuC,EAAA,SAAA0B,GACtB,OAAAlD,KAAAkD,MAUDC,EAAcN,EAAAO,MANC,sBAOjBD,EACD,OAAAxH,KAAAyF,qBAAA+B,EAAA,cAAAtE,KAAAoE,GAGD,IAAII,EAAeR,EAAAO,MAVC,wBAWlBC,EACD,OAAA1H,KAAA0G,wBAAAgB,EAAA,IAAAxE,KAAAoE,GAGD,IAAIK,EAAgBT,EAAAO,MAdd,kCAeJE,EACD,OAAA3H,KAAA8F,6BAAA6B,EAAA,GAAAA,EAAA,IAAAzE,KAAAoE,GAGD,IAAIM,EAAsBV,EAAAO,MAlBC,2BAmBzBG,EACD,OAAA5H,KAAAyF,qBAAAmC,EAAA,WAAA1E,KAAAoE,GAGD,IAAIO,EAAuBX,EAAAO,MArBN,+BAsBnBI,EACD7H,KAAAyF,qBAAAoC,EAAA,WAAA3E,KAAAoE,GAGFjF,QAAAC,QAAA,OAGavB,UAAA+G,eAA4B,kBACtC9H,KAAOyF,qBAAqB,MAAO,WAAEvC,KAAA,WACpC,OAAA6E,OAAA,UAAAC,QAAA,+BAIMjH,UAAAkH,eAAoB,kBAC3BjI,KAAAW,mBACDX,KAAAW,yBAGCA,mBAAmBX,KAAA0F,KAAA,oBAAiBxC,KAAK,SAAE2C,UACzCA,EAAOtD,MAAOL,EAAYR,EAAAwG,QAAArC,EAAAtD,MAC3BsD,EAAAtD,KAAA4F,OAEA,KAEJnI,KAAAW,uBAGUI,UAAAqH,eAAoB,kBAC3BpI,KAAAqI,mBACDrI,KAAAqI,yBAGCA,mBAAiBrI,KAAA0F,KAAA,uBAAAxC,KAAA,SAAA2C,UACfA,EAAOtD,KACR1B,OAAAiE,KAAAe,EAAAtD,MAAA4F,OAEA,KAEJnI,KAAAqI,uBAGOtH,UAAmB2C,oBAAsB,SAAQ4E,EAAA9F,EAAaX,EAASZ,EAAAT,GAC7E,IAAM+H,EAAgBvI,KAAAwI,kBAAAF,EAAAzG,EAAAW,EAAAvB,GAEtBwH,EAAA,GAWD,SARO/G,EAAAC,KAAc2G,EAAAG,IAAQ,SAAAC,EAAAC,GACL,IAAnBnI,EACDiI,EAAA1G,KAAA,CAAA2G,EAAA,EAAAC,IAEAF,EAAA1G,KAAA,CAAA2G,EAAA,IAAAC,MAIJ,CAAA9G,OAAA0G,EAAAK,WAAAH,MAQY1H,UAAOyH,kBAAA,SAAAF,EAAAzG,EAAAW,EAAAvB,MAChBY,EAAMgH,MAAA,CACN,IAAAC,EAAE5G,EAAcR,EAAAqH,MAAC9H,EAAO+H,YAAG,IAI5B,SAHGtH,EAAWC,KAAA2G,EAAMzF,KAAO,SAAU0E,EAAOzE,GACxCgG,EAAA,OAAAhG,GAAA,CAAAyE,WAEJvH,KAAAH,YAAAsH,QAAAtF,EAAAgH,MAAAC,GAGD,IAAMG,EAAOX,EAAUxG,OAEnBoH,EAAC,GAaN,OAZGhH,EAACR,EAACU,QAAKkG,EAAAzF,SACDnB,EAAAC,KAAAO,EAAMR,EAAAyH,QAAkBb,EAAEzF,MAAE,SAAA2C,GAC9BtD,EAAaR,EAAI0H,IAAE5G,EAAegD,EAAE,KACrC0D,EAAAnH,KAAAyD,EAAA,OAAAA,EAAA,MAKHtD,EAAeR,EAAAU,QAAQ8G,KACxBD,GAAA,IAAAC,EAAA9C,KAAA,WAGF6C,KAGalI,UAAUiB,qBAAa,SAAAH,EAAAZ,EAAAV,OACjCsB,EAAOC,QAAKD,EAAAmB,KACb,gBAGChC,EAAQ,CACRc,OAAA9B,KAAYH,YAAKsH,QAAAtF,EAAAC,OAAAb,EAAA+H,WAAA,QACjBnF,WAAA,UAGAhC,EAAMgC,aACP7C,EAAA6C,WAAA7D,KAAAH,YAAAsH,QAAAtF,EAAAgC,aAGChC,EAAMwH,oBACNrI,EAAMsI,MAAA,IACJC,YAAW,CACXC,UAAA3H,EAAA4H,WAGA5H,EAAM6H,YAAY7H,EAAU6H,WAAWhH,SACxC1B,EAAAuI,YAAAG,WAAAC,SAAA9H,EAAA6H,WAAA,KAGC7H,EAAM+H,mBAAsB/H,EAAG+H,kBAAgBlH,SAChD1B,EAAAuI,YAAAM,WAAAF,SAAA9H,EAAA+H,kBAAA,KAGCrJ,GAAM,MACHgJ,YAAMO,aACV9I,EAAAuI,YAAAG,YAAA1I,EAAAuI,YAAAQ,YAAA,IAAA/I,EAAAuI,YAAAQ,eAIDlI,EAAImI,oBAAgB,CAEpB,IAAIC,EAASjK,KAAMH,YAAYsH,QAAEtF,EAAAqI,oBAAAjJ,EAAAgJ,UAC/BA,EAAQxC,MAAG,eACZwC,EAAA,IAAAE,WAAAF,GAAA,MAIDjJ,EAAIoJ,WAAOH,EAAA,IAAwBpI,EAAOwI,qBACxCxI,EAAMyI,sBAAgD,SAA5BzI,EAAOyI,uBAClCtJ,EAAAoJ,YAAA,IAAAvI,EAAAyI,yBAIDzI,EAAMY,SAAUZ,EAAAY,QAAOC,OAAM,MAC7B1B,EAAIyB,QAAM8H,EAAS7I,EAAA8I,KAAA3I,EAAAY,SACjBzB,EAAKyB,YACH,IAAKgI,KAASzJ,EAAUyB,QAKzBzB,EAAAyB,QAAAgI,GAAA1H,OAAA/C,KAAAH,YAAAsH,QAAAnG,EAAAyB,QAAAgI,GAAA1H,OAAA9B,EAAA+H,WAAA,gBAIHhI,EAAI6B,KAAM0H,EAAM7I,EAAA8I,KAAA3I,EAAAgB,MACd7B,EAAK6B,SACH,IAAKkC,KAAM/D,EAAU6B,KACtB7B,EAAA6B,KAAAkC,GAAA/E,KAAAH,YAAAsH,QAAAnG,EAAA6B,KAAAkC,GAAA9D,EAAA+H,WAAA,QASN,OAJGnH,EAAM6I,eACP1J,EAAA0J,cAAA,GAGF1J,KAEDD,UAsBCsC,oBAAA,SAAAsH,EAAA1J,EAAAV,GArBC,IACAqK,EAASC,EADL/K,EAAAE,YAEFkC,EAAeR,EAAK4B,IAAGqH,EAAA,SAAApH,UACd,IAAPhD,EACDgD,EAAAvC,MAAAwC,MAEGtB,EAAkBR,EAAAoJ,UAAW7J,EAAQW,QAAU,SAAEC,UAC/CA,EAAOY,SAAOZ,EAAWY,QAAAC,OAAiB,EAC3Cb,EAAAC,SAAAyB,EAAAzB,OAGGD,EAAAC,SAAOyB,EAAQzB,UACbJ,EAAAqJ,MAAAlJ,EAAuBgB,KAAK,SAAYmI,EAAOC,GAIjD,OAHEL,EAAU9K,EAAAD,YAA+BsH,QAAC6D,EAAA/J,EAAA+H,WAAA,QAC1C6B,EAAOD,EAAE5E,MAAS,KAEpB9D,EAAAR,EAAAwJ,SAAAL,EAAAtH,EAAAV,KAAAoI,KAAA,MAAAL,WAQG7J,UAAOI,kBAAA,SAAAgK,EAAAC,EAAA9J,SACX,QAAP6J,EACD,MAGDA,EAAOE,EAAc,SAACC,MAAAH,EAAAC,EAAA9J,IACvBiK,WAhf2C7L,EAA9C,8BCFqC8L,EAAA,SAAA/L,YAqB7BgM,EAAeC,EAAAC,GACnB,IAAA7L,EAAKL,EAAWM,KAAIC,KAAO0L,EAAOC,IAAc3L,KA0DlD,OAzDEF,EAAK8L,OAAA9L,EAAe+L,iBACpB/L,EAAKgM,YAAc,6DACjBC,aAAU,+BACVC,YAAa,CACb,WACA,cACA,kBACA,iBACA,YACA,aAEF,YAGEzL,YAAYT,EAAAmM,WAAmB1L,YAChCT,EAAA+B,OAAAgC,aAEG/D,EAAK+B,OAAOgC,WAAC,OAEhB/D,EAAA+B,OAAAwI,uBAEGvK,EAAK+B,OAAOwI,qBAAuB,OAEtCvK,EAAA+B,OAAAyI,uBAEDxK,EAAK+B,OAAWyI,qBAAsB,qBAE7BrC,iBAAmB/E,KAAA,SAAAgJ,GACzB,IAAAA,EAAAxJ,SACA5C,EAAAgM,YAAAI,kBAIM9D,iBAAclF,KAAW,SAAC8I,GAChC,IAAAA,EAAAtJ,SACA5C,EAAAkM,kCAKE,SAAgBhL,EAAamL,KAC7BF,WACAhF,gBAAe,WAAAjG,EAAA,KAClBkC,KAAApD,EAAAsM,eAEGlJ,KAAAiJ,IAELrM,EAAEwF,eAAA,SAAAtE,EAAAmL,GAEFrM,EAAKmM,WAAA3G,eAAoBxF,EAAe+B,OAAAC,QAAaoB,KAAAiJ,uBAEhC,SAAAnL,EAAemL,KAC/BF,WACAhF,gBAAe,gBAAAjG,EAAA,KAClBkC,KAAApD,EAAAsM,wBAGJtM,EAhF0B,OAiB1B2L,EAAgB7K,QAAA,uBAChBC,OAAAC,EAAY,UAAZD,CAAuB4K,EAAkChM,KAgE3CsB,UAAGsL,WAAA,WAChBrM,KAAA4L,OAAA5L,KAAA6L,iBAED7L,KAAAsM,aAEWvL,UAAWqL,cAAA,SAAAG,GACpB,OAAGrK,EAAAR,EAAA4B,IAAAiJ,EAAA,SAAAhF,GACJ,OAAAA,EAAAlD,UAIQtD,UAAWyL,OAAG,WACpBxM,KAAA6B,OAAAY,SAAAzC,KAAA6B,OAAAY,QAAAC,OAAA,IAEG1C,KAAK4L,OAAC/I,KAAY,+EAEpB7C,KAAAyM,YAKDzM,KAAA6B,OAAAgB,OAEG7C,KAAC6B,OAASgB,KAAK,SAGjB+I,OAAK5L,KAAO6L,iBACZ7L,KAAK4L,OAAO/I,OACZ7C,KAAK6B,OAAOgB,KAAA7C,KAAA6B,OAAe6K,eAAM1M,KAAA6B,OAAA8K,gBACjC3M,KAAK6B,OAAA6K,cAAa,GACnB1M,KAAA6B,OAAA8K,gBAAA,GAEG3M,KAACqM,cAGPrM,KAAAyM,YAAA,GAlBGzM,KAAAyM,YAAA,KAoBI1L,UAAa6L,UAAA,SAAA9J,UACnB9C,KAAA6B,OAAAgB,KAAAC,GAED9C,KAAAqM,gBAEctL,UAAA8L,QAAoB,SAAA/J,EAAAyE,GAChCvH,KAAK4M,UAAO9J,GACZ9C,KAAK6B,OAAM6K,cAAG5J,EACf9C,KAAA6B,OAAA8K,gBAAApF,EAEDvH,KAAAwM,YAESzL,UAAA+L,gBAAA,WACR9M,KAAAyM,YAAA,KAIQ1L,UAAOgM,UAAU,cACvB/M,KAAA6B,OAAAgB,MAAAX,EAAAR,EAAAsL,KAAAhN,KAAA6B,OAAAgB,MAAA,IAEG7C,KAAK4L,OAACnJ,QAAe,+EAEvBzC,KAAAiN,kBAKDjN,KAAA6B,OAAAY,UAEGzC,KAAK6B,OAAOY,QAAC,IAEhBzC,KAAA6B,OAAAqL,oBAEGlN,KAAK6B,OAAOqL,kBAAC,eAEhBlN,KAAA6B,OAAAsL,uBAEGnN,KAAC6B,OAASsL,sBAAsB,QAGlCvB,OAAM5L,KAAA6L,uBACJD,OAAMnJ,QAAY,KAClB2K,EAAW,CACXnN,KAAMD,KAAE6B,OAAKqL,kBACbtK,KAAA5C,KAAS6B,OAAKwL,iBACdtK,OAAA/C,KAAA6B,OAAAyL,mBACEC,QAAQvN,KAAA6B,OAAasL,sBAEzBnN,KAAK6B,OAAOY,QAAAV,KAAAqL,GACZpN,KAAK6B,OAAOqL,kBAAkB,aAC9BlN,KAAK6B,OAAOwL,iBAAA,GACZrN,KAAK6B,OAAAyL,mBAAa,GACnBtN,KAAA6B,OAAAsL,sBAAA,EAEGnN,KAACqM,aAGPrM,KAAAiN,eAAA,OAlCGjN,KAAAiN,eAAA,KAoCIlM,UAAayM,aAAA,SAAAhK,GACnBxD,KAAA6B,OAAAY,QAAA0D,OAAA3C,EAAA,GAEDxD,KAAAqM,gBAEctL,UAAA0M,WAAuB,SAAKC,EAAAlK,GACxCxD,KAAKwN,aAAOhK,GACZxD,KAAK6B,OAAOwL,iBAAiBK,EAAM9K,KACnC5C,KAAK6B,OAAOyL,mBAAoBI,EAAG3K,OACnC/C,KAAK6B,OAAAqL,kBAAYQ,EAAAzN,KAClBD,KAAA6B,OAAAsL,qBAAAO,EAAAH,QAEDvN,KAAA+M,eAEShM,UAAA4M,mBAAA,WACR3N,KAAAiN,eAAA,KAKUlM,UAAO8K,eAAkB,eAChC+B,EAAI,WACF/L,OAAQgM,qBAEP7N,KAAA6B,OAAAqI,qBAAM,EAAA4D,kBAAA9N,KAAA6B,OAAAqI,oBAGR0D,EAAA1D,mBAAA,mEAEA9C,GACFwG,EAAA1D,mBAAA9C,EAAAY,QA/MI,OAmNJhI,KAAA6B,OAAAgB,MAAAX,EAAAR,EAAA0H,IAAApJ,KAAA6B,OAAAgB,KAAA7C,KAAA6B,OAAA6K,iBAEDkB,EAAO/K,KAAK,sBAAA7C,KAAA6B,OAAA6K,cAAA,MArNPkB,GAD4BnC,EAASsC,YAwN7C,6BAxN2BtC,EAAS,uDCEnCuC,EAAS,CACT,CAAE/E,MAAO,QAAS1B,MAAO,GACzB,CAAA0B,MAAA,QAAA1B,MAAA,GAEI,CAAA0B,MAAA,QAAkB1B,MAAA,IAEtB0G,EAAS,CACT,CAAAhF,MAAA,SAAA1B,MAAA,GAOW,CAAA0B,MAAA,cAAkB1B,MAAC,IACtB2G,EAAA,SAAAC,GAER,IAAAC,EACEC,EAAAC,EACEC,EAAAJ,EAAAI,SAAAhH,EAAA4G,EAAA5G,aACAiH,EAAA9M,EAAA+M,cAAAD,EAAc9M,EAACgN,SAAS,OACtBhN,EAAA+M,cAAA,KAAC,4BACD/M,EAAA+M,cAAA,MAAC,CAAAE,UAAA,WAMHH,EAAA9M,EAAA+M,cAAAG,EAAwB,WAAAC,MAAA,cACtBL,EAAA9M,EAAA+M,cAACG,EAAA,QAAS3N,QAAM+M,EAAGzG,OAAwB6G,EAAAJ,EAAAc,KAAA,SAAAC,GAAA,OAAAA,EAAAxH,UAAAjH,SAAAC,cAAA6N,UAAAJ,EAAA,IAAAO,SAAAS,EAAA,cAAAzH,EAAAgH,QAC3C7M,EAAA+M,cAAA,MAAC,CAAAE,UAAA,WAQHH,EAAA9M,EAAA+M,cAAAG,EAAwB,WAAAC,MAAA,iBACtBL,EAAA9M,EAAA+M,cAACG,EAAA,QAAS3N,QAAMgN,EAAG1G,OAA0B8G,EAAAJ,EAAAa,KAAA,SAAAG,GAAA,OAAAA,EAAA1H,UAAAjH,SAAAE,iBAAA6N,UAAAJ,EAAA,IAAAM,SAAAS,EAAA,iBAAAzH,EAAAgH,QAC7C7M,EAAA+M,cAAA,MAAC,CAAAE,UAAA,WAQPH,EAAA9M,EAAA+M,cAAAG,EAAA,WAAAC,MAAA,mBAEIL,EAAqB9M,EAAG+M,cAA2BG,EAAyD,OAAA3O,KAAA,SAChHsH,OAAyB+G,EAAA/G,EAAAjH,SAAAG,YAAA6N,UAAA,KAAAC,SAAAW,EAAA,cAAA3H,EAAAgH,QAEzBS,EAAS,SAAAlM,EAAAyE,EAAAgH,GAAA,gBACJY,GAMN,IAACf,EAEIG,EAAA1N,OAAAC,EAAkD,SAAlDD,CAAoDA,OAAuBC,EAAgC,SAAvDD,CAAuD,GAAA0G,GACxE,CAAAjH,SAAAO,OAAAC,EAAA,SAAAD,QAAAC,EAAA,SAAAD,CAAA,GAAA0G,EAAAjH,WAAA8N,EAAA,GAAAA,EAAAtL,GAAAqM,EAAA5H,MAAA6G,SAEvCc,EAAS,SAAApM,EAAAyE,EAAAgH,GAAA,gBACJnK,GAMN,IAACgK,yJC9E6CgB,EAAAC,EAAAC,EAAA,2BAAAC,QAM/CC,EAAC,WADQ,SAAAA,KAGI,OAFZA,EAAAzB,YAAA,mCAEYyB,EAFZ,KAIiB,IAACnE,EAAa,iBAAAY,GAC7BwD,aAAAjE,mBCFC,SAAA2C,OACElN,EAAAkN,EAAAlN,QAAAyO,EAACvB,EAAAuB,uBAKDlB,EAAA9M,EAAA+M,cAACD,EAAe9M,EAACgN,SAAO,KAG5BF,EAAA9M,EAAA+M,cAAAG,EAAA,wBAAAe,WAAA,wBAAAC,iBAAA3O,EAAAsN,SAAAmB","file":"opentsdbPlugin.4d0490a94b199a11f40c.js","sourcesContent":["import angular from 'angular';\nimport _ from 'lodash';\nimport { dateMath, DataQueryRequest, DataSourceApi } from '@grafana/data';\nimport { BackendSrv } from 'app/core/services/backend_srv';\nimport { TemplateSrv } from 'app/features/templating/template_srv';\nimport { OpenTsdbOptions, OpenTsdbQuery } from './types';\n\nexport default class OpenTsDatasource extends DataSourceApi<OpenTsdbQuery, OpenTsdbOptions> {\n  type: any;\n  url: any;\n  name: any;\n  withCredentials: any;\n  basicAuth: any;\n  tsdbVersion: any;\n  tsdbResolution: any;\n  lookupLimit: any;\n  tagKeys: any;\n\n  aggregatorsPromise: any;\n  filterTypesPromise: any;\n\n  /** @ngInject */\n  constructor(instanceSettings: any, private backendSrv: BackendSrv, private templateSrv: TemplateSrv) {\n    super(instanceSettings);\n\n    this.type = 'opentsdb';\n    this.url = instanceSettings.url;\n    this.name = instanceSettings.name;\n    this.withCredentials = instanceSettings.withCredentials;\n    this.basicAuth = instanceSettings.basicAuth;\n    instanceSettings.jsonData = instanceSettings.jsonData || {};\n    this.tsdbVersion = instanceSettings.jsonData.tsdbVersion || 1;\n    this.tsdbResolution = instanceSettings.jsonData.tsdbResolution || 1;\n    this.lookupLimit = instanceSettings.jsonData.lookupLimit || 1000;\n    this.tagKeys = {};\n\n    this.aggregatorsPromise = null;\n    this.filterTypesPromise = null;\n  }\n\n  // Called once per panel (graph)\n  query(options: DataQueryRequest) {\n    const start = this.convertToTSDBTime(options.rangeRaw.from, false, options.timezone);\n    const end = this.convertToTSDBTime(options.rangeRaw.to, true, options.timezone);\n    const qs: any[] = [];\n\n    _.each(options.targets, target => {\n      if (!target.metric) {\n        return;\n      }\n      qs.push(this.convertTargetToQuery(target, options, this.tsdbVersion));\n    });\n\n    const queries = _.compact(qs);\n\n    // No valid targets, return the empty result to save a round trip.\n    if (_.isEmpty(queries)) {\n      return Promise.resolve({ data: [] });\n    }\n\n    const groupByTags: any = {};\n    _.each(queries, query => {\n      if (query.filters && query.filters.length > 0) {\n        _.each(query.filters, val => {\n          groupByTags[val.tagk] = true;\n        });\n      } else {\n        _.each(query.tags, (val, key) => {\n          groupByTags[key] = true;\n        });\n      }\n    });\n\n    options.targets = _.filter(options.targets, query => {\n      return query.hide !== true;\n    });\n\n    return this.performTimeSeriesQuery(queries, start, end).then((response: any) => {\n      const metricToTargetMapping = this.mapMetricsToTargets(response.data, options, this.tsdbVersion);\n      const result = _.map(response.data, (metricData: any, index: number) => {\n        index = metricToTargetMapping[index];\n        if (index === -1) {\n          index = 0;\n        }\n        this._saveTagKeys(metricData);\n\n        return this.transformMetricData(metricData, groupByTags, options.targets[index], options, this.tsdbResolution);\n      });\n      return { data: result };\n    });\n  }\n\n  annotationQuery(options: any) {\n    const start = this.convertToTSDBTime(options.rangeRaw.from, false, options.timezone);\n    const end = this.convertToTSDBTime(options.rangeRaw.to, true, options.timezone);\n    const qs = [];\n    const eventList: any[] = [];\n\n    qs.push({ aggregator: 'sum', metric: options.annotation.target });\n\n    const queries = _.compact(qs);\n\n    return this.performTimeSeriesQuery(queries, start, end).then((results: any) => {\n      if (results.data[0]) {\n        let annotationObject = results.data[0].annotations;\n        if (options.annotation.isGlobal) {\n          annotationObject = results.data[0].globalAnnotations;\n        }\n        if (annotationObject) {\n          _.each(annotationObject, annotation => {\n            const event = {\n              text: annotation.description,\n              time: Math.floor(annotation.startTime) * 1000,\n              annotation: options.annotation,\n            };\n\n            eventList.push(event);\n          });\n        }\n      }\n      return eventList;\n    });\n  }\n\n  targetContainsTemplate(target: any) {\n    if (target.filters && target.filters.length > 0) {\n      for (let i = 0; i < target.filters.length; i++) {\n        if (this.templateSrv.variableExists(target.filters[i].filter)) {\n          return true;\n        }\n      }\n    }\n\n    if (target.tags && Object.keys(target.tags).length > 0) {\n      for (const tagKey in target.tags) {\n        if (this.templateSrv.variableExists(target.tags[tagKey])) {\n          return true;\n        }\n      }\n    }\n\n    return false;\n  }\n\n  performTimeSeriesQuery(queries: any[], start: any, end: any) {\n    let msResolution = false;\n    if (this.tsdbResolution === 2) {\n      msResolution = true;\n    }\n    const reqBody: any = {\n      start: start,\n      queries: queries,\n      msResolution: msResolution,\n      globalAnnotations: true,\n    };\n    if (this.tsdbVersion === 3) {\n      reqBody.showQuery = true;\n    }\n\n    // Relative queries (e.g. last hour) don't include an end time\n    if (end) {\n      reqBody.end = end;\n    }\n\n    const options = {\n      method: 'POST',\n      url: this.url + '/api/query',\n      data: reqBody,\n    };\n\n    this._addCredentialOptions(options);\n    return this.backendSrv.datasourceRequest(options);\n  }\n\n  suggestTagKeys(metric: string | number) {\n    return Promise.resolve(this.tagKeys[metric] || []);\n  }\n\n  _saveTagKeys(metricData: { tags: {}; aggregateTags: any; metric: string | number }) {\n    const tagKeys = Object.keys(metricData.tags);\n    _.each(metricData.aggregateTags, tag => {\n      tagKeys.push(tag);\n    });\n\n    this.tagKeys[metricData.metric] = tagKeys;\n  }\n\n  _performSuggestQuery(query: string, type: string) {\n    return this._get('/api/suggest', { type, q: query, max: this.lookupLimit }).then((result: any) => {\n      return result.data;\n    });\n  }\n\n  _performMetricKeyValueLookup(metric: string, keys: any) {\n    if (!metric || !keys) {\n      return Promise.resolve([]);\n    }\n\n    const keysArray = keys.split(',').map((key: any) => {\n      return key.trim();\n    });\n    const key = keysArray[0];\n    let keysQuery = key + '=*';\n\n    if (keysArray.length > 1) {\n      keysQuery += ',' + keysArray.splice(1).join(',');\n    }\n\n    const m = metric + '{' + keysQuery + '}';\n\n    return this._get('/api/search/lookup', { m: m, limit: this.lookupLimit }).then((result: any) => {\n      result = result.data.results;\n      const tagvs: any[] = [];\n      _.each(result, r => {\n        if (tagvs.indexOf(r.tags[key]) === -1) {\n          tagvs.push(r.tags[key]);\n        }\n      });\n      return tagvs;\n    });\n  }\n\n  _performMetricKeyLookup(metric: any) {\n    if (!metric) {\n      return Promise.resolve([]);\n    }\n\n    return this._get('/api/search/lookup', { m: metric, limit: 1000 }).then((result: any) => {\n      result = result.data.results;\n      const tagks: any[] = [];\n      _.each(result, r => {\n        _.each(r.tags, (tagv, tagk) => {\n          if (tagks.indexOf(tagk) === -1) {\n            tagks.push(tagk);\n          }\n        });\n      });\n      return tagks;\n    });\n  }\n\n  _get(relativeUrl: string, params?: { type?: string; q?: string; max?: number; m?: any; limit?: number }) {\n    const options = {\n      method: 'GET',\n      url: this.url + relativeUrl,\n      params: params,\n    };\n\n    this._addCredentialOptions(options);\n\n    return this.backendSrv.datasourceRequest(options);\n  }\n\n  _addCredentialOptions(options: any) {\n    if (this.basicAuth || this.withCredentials) {\n      options.withCredentials = true;\n    }\n    if (this.basicAuth) {\n      options.headers = { Authorization: this.basicAuth };\n    }\n  }\n\n  metricFindQuery(query: string) {\n    if (!query) {\n      return Promise.resolve([]);\n    }\n\n    let interpolated;\n    try {\n      interpolated = this.templateSrv.replace(query, {}, 'distributed');\n    } catch (err) {\n      return Promise.reject(err);\n    }\n\n    const responseTransform = (result: any) => {\n      return _.map(result, value => {\n        return { text: value };\n      });\n    };\n\n    const metricsRegex = /metrics\\((.*)\\)/;\n    const tagNamesRegex = /tag_names\\((.*)\\)/;\n    const tagValuesRegex = /tag_values\\((.*?),\\s?(.*)\\)/;\n    const tagNamesSuggestRegex = /suggest_tagk\\((.*)\\)/;\n    const tagValuesSuggestRegex = /suggest_tagv\\((.*)\\)/;\n\n    const metricsQuery = interpolated.match(metricsRegex);\n    if (metricsQuery) {\n      return this._performSuggestQuery(metricsQuery[1], 'metrics').then(responseTransform);\n    }\n\n    const tagNamesQuery = interpolated.match(tagNamesRegex);\n    if (tagNamesQuery) {\n      return this._performMetricKeyLookup(tagNamesQuery[1]).then(responseTransform);\n    }\n\n    const tagValuesQuery = interpolated.match(tagValuesRegex);\n    if (tagValuesQuery) {\n      return this._performMetricKeyValueLookup(tagValuesQuery[1], tagValuesQuery[2]).then(responseTransform);\n    }\n\n    const tagNamesSuggestQuery = interpolated.match(tagNamesSuggestRegex);\n    if (tagNamesSuggestQuery) {\n      return this._performSuggestQuery(tagNamesSuggestQuery[1], 'tagk').then(responseTransform);\n    }\n\n    const tagValuesSuggestQuery = interpolated.match(tagValuesSuggestRegex);\n    if (tagValuesSuggestQuery) {\n      return this._performSuggestQuery(tagValuesSuggestQuery[1], 'tagv').then(responseTransform);\n    }\n\n    return Promise.resolve([]);\n  }\n\n  testDatasource() {\n    return this._performSuggestQuery('cpu', 'metrics').then(() => {\n      return { status: 'success', message: 'Data source is working' };\n    });\n  }\n\n  getAggregators() {\n    if (this.aggregatorsPromise) {\n      return this.aggregatorsPromise;\n    }\n\n    this.aggregatorsPromise = this._get('/api/aggregators').then((result: any) => {\n      if (result.data && _.isArray(result.data)) {\n        return result.data.sort();\n      }\n      return [];\n    });\n    return this.aggregatorsPromise;\n  }\n\n  getFilterTypes() {\n    if (this.filterTypesPromise) {\n      return this.filterTypesPromise;\n    }\n\n    this.filterTypesPromise = this._get('/api/config/filters').then((result: any) => {\n      if (result.data) {\n        return Object.keys(result.data).sort();\n      }\n      return [];\n    });\n    return this.filterTypesPromise;\n  }\n\n  transformMetricData(md: { dps: any }, groupByTags: any, target: any, options: any, tsdbResolution: number) {\n    const metricLabel = this.createMetricLabel(md, target, groupByTags, options);\n    const dps: any[] = [];\n\n    // TSDB returns datapoints has a hash of ts => value.\n    // Can't use _.pairs(invert()) because it stringifies keys/values\n    _.each(md.dps, (v: any, k: number) => {\n      if (tsdbResolution === 2) {\n        dps.push([v, k * 1]);\n      } else {\n        dps.push([v, k * 1000]);\n      }\n    });\n\n    return { target: metricLabel, datapoints: dps };\n  }\n\n  createMetricLabel(\n    md: { dps?: any; tags?: any; metric?: any },\n    target: { alias: string },\n    groupByTags: any,\n    options: { scopedVars: any }\n  ) {\n    if (target.alias) {\n      const scopedVars = _.clone(options.scopedVars || {});\n      _.each(md.tags, (value, key) => {\n        scopedVars['tag_' + key] = { value: value };\n      });\n      return this.templateSrv.replace(target.alias, scopedVars);\n    }\n\n    let label = md.metric;\n    const tagData: any[] = [];\n\n    if (!_.isEmpty(md.tags)) {\n      _.each(_.toPairs(md.tags), tag => {\n        if (_.has(groupByTags, tag[0])) {\n          tagData.push(tag[0] + '=' + tag[1]);\n        }\n      });\n    }\n\n    if (!_.isEmpty(tagData)) {\n      label += '{' + tagData.join(', ') + '}';\n    }\n\n    return label;\n  }\n\n  convertTargetToQuery(target: any, options: any, tsdbVersion: number) {\n    if (!target.metric || target.hide) {\n      return null;\n    }\n\n    const query: any = {\n      metric: this.templateSrv.replace(target.metric, options.scopedVars, 'pipe'),\n      aggregator: 'avg',\n    };\n\n    if (target.aggregator) {\n      query.aggregator = this.templateSrv.replace(target.aggregator);\n    }\n\n    if (target.shouldComputeRate) {\n      query.rate = true;\n      query.rateOptions = {\n        counter: !!target.isCounter,\n      };\n\n      if (target.counterMax && target.counterMax.length) {\n        query.rateOptions.counterMax = parseInt(target.counterMax, 10);\n      }\n\n      if (target.counterResetValue && target.counterResetValue.length) {\n        query.rateOptions.resetValue = parseInt(target.counterResetValue, 10);\n      }\n\n      if (tsdbVersion >= 2) {\n        query.rateOptions.dropResets =\n          !query.rateOptions.counterMax && (!query.rateOptions.ResetValue || query.rateOptions.ResetValue === 0);\n      }\n    }\n\n    if (!target.disableDownsampling) {\n      let interval = this.templateSrv.replace(target.downsampleInterval || options.interval);\n\n      if (interval.match(/\\.[0-9]+s/)) {\n        interval = parseFloat(interval) * 1000 + 'ms';\n      }\n\n      query.downsample = interval + '-' + target.downsampleAggregator;\n\n      if (target.downsampleFillPolicy && target.downsampleFillPolicy !== 'none') {\n        query.downsample += '-' + target.downsampleFillPolicy;\n      }\n    }\n\n    if (target.filters && target.filters.length > 0) {\n      query.filters = angular.copy(target.filters);\n      if (query.filters) {\n        for (const filterKey in query.filters) {\n          query.filters[filterKey].filter = this.templateSrv.replace(\n            query.filters[filterKey].filter,\n            options.scopedVars,\n            'pipe'\n          );\n        }\n      }\n    } else {\n      query.tags = angular.copy(target.tags);\n      if (query.tags) {\n        for (const tagKey in query.tags) {\n          query.tags[tagKey] = this.templateSrv.replace(query.tags[tagKey], options.scopedVars, 'pipe');\n        }\n      }\n    }\n\n    if (target.explicitTags) {\n      query.explicitTags = true;\n    }\n\n    return query;\n  }\n\n  mapMetricsToTargets(metrics: any, options: any, tsdbVersion: number) {\n    let interpolatedTagValue, arrTagV;\n    return _.map(metrics, metricData => {\n      if (tsdbVersion === 3) {\n        return metricData.query.index;\n      } else {\n        return _.findIndex(options.targets as any[], target => {\n          if (target.filters && target.filters.length > 0) {\n            return target.metric === metricData.metric;\n          } else {\n            return (\n              target.metric === metricData.metric &&\n              _.every(target.tags, (tagV, tagK) => {\n                interpolatedTagValue = this.templateSrv.replace(tagV, options.scopedVars, 'pipe');\n                arrTagV = interpolatedTagValue.split('|');\n                return _.includes(arrTagV, metricData.tags[tagK]) || interpolatedTagValue === '*';\n              })\n            );\n          }\n        });\n      }\n    });\n  }\n\n  convertToTSDBTime(date: any, roundUp: any, timezone: any) {\n    if (date === 'now') {\n      return null;\n    }\n\n    date = dateMath.parse(date, roundUp, timezone);\n    return date.valueOf();\n  }\n}\n","import _ from 'lodash';\nimport kbn from 'app/core/utils/kbn';\nimport { QueryCtrl } from 'app/plugins/sdk';\nimport { auto } from 'angular';\n\nexport class OpenTsQueryCtrl extends QueryCtrl {\n  static templateUrl = 'partials/query.editor.html';\n  aggregators: any;\n  fillPolicies: any;\n  filterTypes: any;\n  tsdbVersion: any;\n  aggregator: any;\n  downsampleInterval: any;\n  downsampleAggregator: any;\n  downsampleFillPolicy: any;\n  errors: any;\n  suggestMetrics: any;\n  suggestTagKeys: any;\n  suggestTagValues: any;\n  addTagMode: boolean;\n  addFilterMode: boolean;\n\n  /** @ngInject */\n  constructor($scope: any, $injector: auto.IInjectorService) {\n    super($scope, $injector);\n\n    this.errors = this.validateTarget();\n    this.aggregators = ['avg', 'sum', 'min', 'max', 'dev', 'zimsum', 'mimmin', 'mimmax'];\n    this.fillPolicies = ['none', 'nan', 'null', 'zero'];\n    this.filterTypes = [\n      'wildcard',\n      'iliteral_or',\n      'not_iliteral_or',\n      'not_literal_or',\n      'iwildcard',\n      'literal_or',\n      'regexp',\n    ];\n\n    this.tsdbVersion = this.datasource.tsdbVersion;\n\n    if (!this.target.aggregator) {\n      this.target.aggregator = 'sum';\n    }\n\n    if (!this.target.downsampleAggregator) {\n      this.target.downsampleAggregator = 'avg';\n    }\n\n    if (!this.target.downsampleFillPolicy) {\n      this.target.downsampleFillPolicy = 'none';\n    }\n\n    this.datasource.getAggregators().then((aggs: { length: number }) => {\n      if (aggs.length !== 0) {\n        this.aggregators = aggs;\n      }\n    });\n\n    this.datasource.getFilterTypes().then((filterTypes: { length: number }) => {\n      if (filterTypes.length !== 0) {\n        this.filterTypes = filterTypes;\n      }\n    });\n\n    // needs to be defined here as it is called from typeahead\n    this.suggestMetrics = (query: string, callback: any) => {\n      this.datasource\n        .metricFindQuery('metrics(' + query + ')')\n        .then(this.getTextValues)\n        .then(callback);\n    };\n\n    this.suggestTagKeys = (query: any, callback: any) => {\n      this.datasource.suggestTagKeys(this.target.metric).then(callback);\n    };\n\n    this.suggestTagValues = (query: string, callback: any) => {\n      this.datasource\n        .metricFindQuery('suggest_tagv(' + query + ')')\n        .then(this.getTextValues)\n        .then(callback);\n    };\n  }\n\n  targetBlur() {\n    this.errors = this.validateTarget();\n    this.refresh();\n  }\n\n  getTextValues(metricFindResult: any) {\n    return _.map(metricFindResult, value => {\n      return value.text;\n    });\n  }\n\n  addTag() {\n    if (this.target.filters && this.target.filters.length > 0) {\n      this.errors.tags = 'Please remove filters to use tags, tags and filters are mutually exclusive.';\n    }\n\n    if (!this.addTagMode) {\n      this.addTagMode = true;\n      return;\n    }\n\n    if (!this.target.tags) {\n      this.target.tags = {};\n    }\n\n    this.errors = this.validateTarget();\n\n    if (!this.errors.tags) {\n      this.target.tags[this.target.currentTagKey] = this.target.currentTagValue;\n      this.target.currentTagKey = '';\n      this.target.currentTagValue = '';\n      this.targetBlur();\n    }\n\n    this.addTagMode = false;\n  }\n\n  removeTag(key: string | number) {\n    delete this.target.tags[key];\n    this.targetBlur();\n  }\n\n  editTag(key: string | number, value: any) {\n    this.removeTag(key);\n    this.target.currentTagKey = key;\n    this.target.currentTagValue = value;\n    this.addTag();\n  }\n\n  closeAddTagMode() {\n    this.addTagMode = false;\n    return;\n  }\n\n  addFilter() {\n    if (this.target.tags && _.size(this.target.tags) > 0) {\n      this.errors.filters = 'Please remove tags to use filters, tags and filters are mutually exclusive.';\n    }\n\n    if (!this.addFilterMode) {\n      this.addFilterMode = true;\n      return;\n    }\n\n    if (!this.target.filters) {\n      this.target.filters = [];\n    }\n\n    if (!this.target.currentFilterType) {\n      this.target.currentFilterType = 'iliteral_or';\n    }\n\n    if (!this.target.currentFilterGroupBy) {\n      this.target.currentFilterGroupBy = false;\n    }\n\n    this.errors = this.validateTarget();\n\n    if (!this.errors.filters) {\n      const currentFilter = {\n        type: this.target.currentFilterType,\n        tagk: this.target.currentFilterKey,\n        filter: this.target.currentFilterValue,\n        groupBy: this.target.currentFilterGroupBy,\n      };\n      this.target.filters.push(currentFilter);\n      this.target.currentFilterType = 'literal_or';\n      this.target.currentFilterKey = '';\n      this.target.currentFilterValue = '';\n      this.target.currentFilterGroupBy = false;\n      this.targetBlur();\n    }\n\n    this.addFilterMode = false;\n  }\n\n  removeFilter(index: number) {\n    this.target.filters.splice(index, 1);\n    this.targetBlur();\n  }\n\n  editFilter(fil: { tagk: any; filter: any; type: any; groupBy: any }, index: number) {\n    this.removeFilter(index);\n    this.target.currentFilterKey = fil.tagk;\n    this.target.currentFilterValue = fil.filter;\n    this.target.currentFilterType = fil.type;\n    this.target.currentFilterGroupBy = fil.groupBy;\n    this.addFilter();\n  }\n\n  closeAddFilterMode() {\n    this.addFilterMode = false;\n    return;\n  }\n\n  validateTarget() {\n    const errs: any = {};\n\n    if (this.target.shouldDownsample) {\n      try {\n        if (this.target.downsampleInterval) {\n          kbn.describe_interval(this.target.downsampleInterval);\n        } else {\n          errs.downsampleInterval = \"You must supply a downsample interval (e.g. '1m' or '1h').\";\n        }\n      } catch (err) {\n        errs.downsampleInterval = err.message;\n      }\n    }\n\n    if (this.target.tags && _.has(this.target.tags, this.target.currentTagKey)) {\n      errs.tags = \"Duplicate tag key '\" + this.target.currentTagKey + \"'.\";\n    }\n\n    return errs;\n  }\n}\n","import React, { SyntheticEvent } from 'react';\nimport { FormLabel, Select, Input } from '@grafana/ui';\nimport { DataSourceSettings, SelectableValue } from '@grafana/data';\nimport { OpenTsdbOptions } from '../types';\n\nconst tsdbVersions = [\n  { label: '<=2.1', value: 1 },\n  { label: '==2.2', value: 2 },\n  { label: '==2.3', value: 3 },\n];\n\nconst tsdbResolutions = [\n  { label: 'second', value: 1 },\n  { label: 'millisecond', value: 2 },\n];\n\ninterface Props {\n  value: DataSourceSettings<OpenTsdbOptions>;\n  onChange: (value: DataSourceSettings<OpenTsdbOptions>) => void;\n}\n\nexport const OpenTsdbDetails = (props: Props) => {\n  const { onChange, value } = props;\n\n  return (\n    <>\n      <h5>OpenTSDB settings</h5>\n      <div className=\"gf-form\">\n        <FormLabel width={7}>Version</FormLabel>\n        <Select\n          options={tsdbVersions}\n          value={tsdbVersions.find(version => version.value === value.jsonData.tsdbVersion) ?? tsdbVersions[0]}\n          onChange={onSelectChangeHandler('tsdbVersion', value, onChange)}\n        />\n      </div>\n      <div className=\"gf-form\">\n        <FormLabel width={7}>Resolution</FormLabel>\n        <Select\n          options={tsdbResolutions}\n          value={\n            tsdbResolutions.find(resolution => resolution.value === value.jsonData.tsdbResolution) ?? tsdbResolutions[0]\n          }\n          onChange={onSelectChangeHandler('tsdbResolution', value, onChange)}\n        />\n      </div>\n      <div className=\"gf-form\">\n        <FormLabel width={7}>Lookup Limit</FormLabel>\n        <Input\n          type=\"number\"\n          value={value.jsonData.lookupLimit ?? 1000}\n          onChange={onInputChangeHandler('lookupLimit', value, onChange)}\n        />\n      </div>\n    </>\n  );\n};\n\nconst onSelectChangeHandler = (key: keyof OpenTsdbOptions, value: Props['value'], onChange: Props['onChange']) => (\n  newValue: SelectableValue\n) => {\n  onChange({\n    ...value,\n    jsonData: {\n      ...value.jsonData,\n      [key]: newValue.value,\n    },\n  });\n};\n\nconst onInputChangeHandler = (key: keyof OpenTsdbOptions, value: Props['value'], onChange: Props['onChange']) => (\n  event: SyntheticEvent<HTMLInputElement>\n) => {\n  onChange({\n    ...value,\n    jsonData: {\n      ...value.jsonData,\n      [key]: event.currentTarget.value,\n    },\n  });\n};\n","import OpenTsDatasource from './datasource';\nimport { OpenTsQueryCtrl } from './query_ctrl';\nimport { DataSourcePlugin } from '@grafana/data';\nimport { ConfigEditor } from './components/ConfigEditor';\n\nclass AnnotationsQueryCtrl {\n  static templateUrl = 'partials/annotations.editor.html';\n}\n\nexport const plugin = new DataSourcePlugin(OpenTsDatasource)\n  .setQueryCtrl(OpenTsQueryCtrl)\n  .setConfigEditor(ConfigEditor)\n  .setAnnotationQueryCtrl(AnnotationsQueryCtrl);\n","import React from 'react';\nimport { DataSourceHttpSettings } from '@grafana/ui';\nimport { DataSourcePluginOptionsEditorProps } from '@grafana/data';\nimport { OpenTsdbDetails } from './OpenTsdbDetails';\nimport { OpenTsdbOptions } from '../types';\n\nexport const ConfigEditor = (props: DataSourcePluginOptionsEditorProps<OpenTsdbOptions>) => {\n  const { options, onOptionsChange } = props;\n\n  return (\n    <>\n      <DataSourceHttpSettings\n        defaultUrl=\"http://localhost:4242\"\n        dataSourceConfig={options}\n        onChange={onOptionsChange}\n      />\n      <OpenTsdbDetails value={options} onChange={onOptionsChange} />\n    </>\n  );\n};\n"],"sourceRoot":""}