{"version":3,"file":"AlertingRuleForm.840179cc969ca1b5ecc2.js","mappings":"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","sources":["webpack://grafana/./public/app/features/alerting/unified/AlertWarning.tsx","webpack://grafana/./public/app/features/alerting/unified/CloneRuleEditor.tsx","webpack://grafana/./public/app/features/alerting/unified/ExistingRuleEditor.tsx","webpack://grafana/./public/app/features/alerting/unified/RuleEditor.tsx","webpack://grafana/./public/app/features/alerting/unified/hooks/useFolder.ts","webpack://grafana/./public/app/features/alerting/unified/hooks/useIsRuleEditable.ts","webpack://grafana/./public/app/features/alerting/unified/hooks/useURLSearchParams.ts","webpack://grafana/./public/app/features/alerting/unified/utils/accessControlHooks.ts","webpack://grafana/./public/app/features/alerting/unified/utils/duplicate.ts"],"sourcesContent":["import { css } from '@emotion/css';\nimport React from 'react';\n\nimport { GrafanaTheme2 } from '@grafana/data';\nimport { Alert, LinkButton, useStyles2 } from '@grafana/ui';\n\ninterface AlertWarningProps {\n  title: string;\n  children: React.ReactNode;\n}\nexport function AlertWarning({ title, children }: AlertWarningProps) {\n  return (\n    <Alert className={useStyles2(warningStyles).warning} severity=\"warning\" title={title}>\n      <p>{children}</p>\n      <LinkButton href=\"alerting/list\">To rule list</LinkButton>\n    </Alert>\n  );\n}\n\nconst warningStyles = (theme: GrafanaTheme2) => ({\n  warning: css`\n    margin: ${theme.spacing(4)};\n  `,\n});\n","import { cloneDeep } from 'lodash';\nimport React from 'react';\nimport { useAsync } from 'react-use';\n\nimport { locationService } from '@grafana/runtime/src';\nimport { Alert, LoadingPlaceholder } from '@grafana/ui/src';\n\nimport { useDispatch } from '../../../types';\nimport { RuleIdentifier } from '../../../types/unified-alerting';\nimport { RulerRuleDTO } from '../../../types/unified-alerting-dto';\n\nimport { AlertRuleForm } from './components/rule-editor/AlertRuleForm';\nimport { fetchEditableRuleAction } from './state/actions';\nimport { generateCopiedName } from './utils/duplicate';\nimport { rulerRuleToFormValues } from './utils/rule-form';\nimport { getRuleName, isAlertingRulerRule, isGrafanaRulerRule, isRecordingRulerRule } from './utils/rules';\nimport { createUrl } from './utils/url';\n\nexport function CloneRuleEditor({ sourceRuleId }: { sourceRuleId: RuleIdentifier }) {\n  const dispatch = useDispatch();\n\n  const {\n    loading,\n    value: rule,\n    error,\n  } = useAsync(() => dispatch(fetchEditableRuleAction(sourceRuleId)).unwrap(), [sourceRuleId]);\n\n  if (loading) {\n    return <LoadingPlaceholder text=\"Loading the rule\" />;\n  }\n\n  if (rule) {\n    const ruleClone = cloneDeep(rule);\n    changeRuleName(\n      ruleClone.rule,\n      generateCopiedName(getRuleName(ruleClone.rule), ruleClone.group.rules.map(getRuleName))\n    );\n    const formPrefill = rulerRuleToFormValues(ruleClone);\n\n    // Provisioned alert rules have provisioned alert group which cannot be used in UI\n    if (isGrafanaRulerRule(rule.rule) && Boolean(rule.rule.grafana_alert.provenance)) {\n      formPrefill.group = '';\n    }\n\n    return <AlertRuleForm prefill={formPrefill} />;\n  }\n\n  if (error) {\n    return (\n      <Alert title=\"Error\" severity=\"error\">\n        {error.message}\n      </Alert>\n    );\n  }\n\n  return (\n    <Alert\n      title=\"Cannot copy the rule. The rule does not exist\"\n      buttonContent=\"Go back to alert list\"\n      onRemove={() => locationService.replace(createUrl('/alerting/list'))}\n    />\n  );\n}\n\nfunction changeRuleName(rule: RulerRuleDTO, newName: string) {\n  if (isGrafanaRulerRule(rule)) {\n    rule.grafana_alert.title = newName;\n  }\n  if (isAlertingRulerRule(rule)) {\n    rule.alert = newName;\n  }\n\n  if (isRecordingRulerRule(rule)) {\n    rule.record = newName;\n  }\n}\n","import React, { useEffect } from 'react';\n\nimport { Alert, LoadingPlaceholder } from '@grafana/ui';\nimport { useCleanup } from 'app/core/hooks/useCleanup';\nimport { useDispatch } from 'app/types';\nimport { RuleIdentifier } from 'app/types/unified-alerting';\n\nimport { AlertWarning } from './AlertWarning';\nimport { AlertRuleForm } from './components/rule-editor/AlertRuleForm';\nimport { useIsRuleEditable } from './hooks/useIsRuleEditable';\nimport { useUnifiedAlertingSelector } from './hooks/useUnifiedAlertingSelector';\nimport { fetchEditableRuleAction } from './state/actions';\nimport { initialAsyncRequestState } from './utils/redux';\nimport * as ruleId from './utils/rule-id';\n\ninterface ExistingRuleEditorProps {\n  identifier: RuleIdentifier;\n}\n\nexport function ExistingRuleEditor({ identifier }: ExistingRuleEditorProps) {\n  useCleanup((state) => (state.unifiedAlerting.ruleForm.existingRule = initialAsyncRequestState));\n\n  const {\n    loading: loadingAlertRule,\n    result,\n    error,\n    dispatched,\n  } = useUnifiedAlertingSelector((state) => state.ruleForm.existingRule);\n\n  const dispatch = useDispatch();\n  const { isEditable, loading: loadingEditable } = useIsRuleEditable(\n    ruleId.ruleIdentifierToRuleSourceName(identifier),\n    result?.rule\n  );\n\n  const loading = loadingAlertRule || loadingEditable;\n\n  useEffect(() => {\n    if (!dispatched) {\n      dispatch(fetchEditableRuleAction(identifier));\n    }\n  }, [dispatched, dispatch, identifier]);\n\n  if (loading || isEditable === undefined) {\n    return <LoadingPlaceholder text=\"Loading rule...\" />;\n  }\n\n  if (error) {\n    return (\n      <Alert severity=\"error\" title=\"Failed to load rule\">\n        {error.message}\n      </Alert>\n    );\n  }\n\n  if (!result) {\n    return <AlertWarning title=\"Rule not found\">Sorry! This rule does not exist.</AlertWarning>;\n  }\n\n  if (isEditable === false) {\n    return <AlertWarning title=\"Cannot edit rule\">Sorry! You do not have permission to edit this rule.</AlertWarning>;\n  }\n\n  return <AlertRuleForm existing={result} />;\n}\n","import React, { useCallback } from 'react';\nimport { useAsync } from 'react-use';\n\nimport { NavModelItem } from '@grafana/data';\nimport { withErrorBoundary } from '@grafana/ui';\nimport { GrafanaRouteComponentProps } from 'app/core/navigation/types';\nimport { useDispatch } from 'app/types';\n\nimport { AlertWarning } from './AlertWarning';\nimport { CloneRuleEditor } from './CloneRuleEditor';\nimport { ExistingRuleEditor } from './ExistingRuleEditor';\nimport { AlertingPageWrapper } from './components/AlertingPageWrapper';\nimport { AlertRuleForm } from './components/rule-editor/AlertRuleForm';\nimport { useURLSearchParams } from './hooks/useURLSearchParams';\nimport { fetchRulesSourceBuildInfoAction } from './state/actions';\nimport { useRulesAccess } from './utils/accessControlHooks';\nimport * as ruleId from './utils/rule-id';\n\ntype RuleEditorProps = GrafanaRouteComponentProps<{ id?: string }>;\n\nconst defaultPageNav: Partial<NavModelItem> = {\n  icon: 'bell',\n  id: 'alert-rule-view',\n  breadcrumbs: [{ title: 'Alert rules', url: 'alerting/list' }],\n};\n\nconst getPageNav = (state: 'edit' | 'add') => {\n  if (state === 'edit') {\n    return { ...defaultPageNav, id: 'alert-rule-edit', text: 'Edit rule' };\n  } else if (state === 'add') {\n    return { ...defaultPageNav, id: 'alert-rule-add', text: 'Add rule' };\n  }\n  return undefined;\n};\n\nconst RuleEditor = ({ match }: RuleEditorProps) => {\n  const dispatch = useDispatch();\n  const [searchParams] = useURLSearchParams();\n\n  const { id } = match.params;\n  const identifier = ruleId.tryParse(id, true);\n\n  const copyFromId = searchParams.get('copyFrom') ?? undefined;\n  const copyFromIdentifier = ruleId.tryParse(copyFromId);\n\n  const { loading = true } = useAsync(async () => {\n    if (identifier) {\n      await dispatch(fetchRulesSourceBuildInfoAction({ rulesSourceName: identifier.ruleSourceName }));\n    }\n  }, [dispatch]);\n\n  const { canCreateGrafanaRules, canCreateCloudRules, canEditRules } = useRulesAccess();\n\n  const getContent = useCallback(() => {\n    if (loading) {\n      return;\n    }\n\n    if (!identifier && !canCreateGrafanaRules && !canCreateCloudRules) {\n      return <AlertWarning title=\"Cannot create rules\">Sorry! You are not allowed to create rules.</AlertWarning>;\n    }\n\n    if (identifier && !canEditRules(identifier.ruleSourceName)) {\n      return <AlertWarning title=\"Cannot edit rules\">Sorry! You are not allowed to edit rules.</AlertWarning>;\n    }\n\n    if (identifier) {\n      return <ExistingRuleEditor key={id} identifier={identifier} />;\n    }\n\n    if (copyFromIdentifier) {\n      return <CloneRuleEditor sourceRuleId={copyFromIdentifier} />;\n    }\n\n    return <AlertRuleForm />;\n  }, [canCreateCloudRules, canCreateGrafanaRules, canEditRules, copyFromIdentifier, id, identifier, loading]);\n\n  return (\n    <AlertingPageWrapper isLoading={loading} pageId=\"alert-list\" pageNav={getPageNav(identifier ? 'edit' : 'add')}>\n      {getContent()}\n    </AlertingPageWrapper>\n  );\n};\n\nexport default withErrorBoundary(RuleEditor, { style: 'page' });\n","import { useEffect } from 'react';\n\nimport { FolderDTO, useDispatch } from 'app/types';\n\nimport { fetchFolderIfNotFetchedAction } from '../state/actions';\nimport { initialAsyncRequestState } from '../utils/redux';\n\nimport { useUnifiedAlertingSelector } from './useUnifiedAlertingSelector';\n\ninterface ReturnBag {\n  folder?: FolderDTO;\n  loading: boolean;\n}\n\nexport function useFolder(uid?: string): ReturnBag {\n  const dispatch = useDispatch();\n  const folderRequests = useUnifiedAlertingSelector((state) => state.folders);\n  useEffect(() => {\n    if (uid) {\n      dispatch(fetchFolderIfNotFetchedAction(uid));\n    }\n  }, [dispatch, uid]);\n\n  if (uid) {\n    const request = folderRequests[uid] || initialAsyncRequestState;\n    return {\n      folder: request.result,\n      loading: request.loading,\n    };\n  }\n  return {\n    loading: false,\n  };\n}\n","import { contextSrv } from 'app/core/services/context_srv';\nimport { RulerRuleDTO } from 'app/types/unified-alerting-dto';\n\nimport { getRulesPermissions } from '../utils/access-control';\nimport { isGrafanaRulerRule } from '../utils/rules';\n\nimport { useFolder } from './useFolder';\nimport { useUnifiedAlertingSelector } from './useUnifiedAlertingSelector';\n\ninterface ResultBag {\n  isEditable?: boolean;\n  isRemovable?: boolean;\n  loading: boolean;\n}\n\nexport function useIsRuleEditable(rulesSourceName: string, rule?: RulerRuleDTO): ResultBag {\n  const dataSources = useUnifiedAlertingSelector((state) => state.dataSources);\n  const folderUID = rule && isGrafanaRulerRule(rule) ? rule.grafana_alert.namespace_uid : undefined;\n\n  const rulePermission = getRulesPermissions(rulesSourceName);\n  const { folder, loading } = useFolder(folderUID);\n\n  if (!rule) {\n    return { isEditable: false, isRemovable: false, loading: false };\n  }\n\n  // Grafana rules can be edited if user can edit the folder they're in\n  // When RBAC is disabled access to a folder is the only requirement for managing rules\n  // When RBAC is enabled the appropriate alerting permissions need to be met\n  if (isGrafanaRulerRule(rule)) {\n    if (!folderUID) {\n      throw new Error(\n        `Rule ${rule.grafana_alert.title} does not have a folder uid, cannot determine if it is editable.`\n      );\n    }\n\n    if (!folder) {\n      // Loading or invalid folder UID\n      return {\n        isEditable: false,\n        isRemovable: false,\n        loading,\n      };\n    }\n    const rbacDisabledFallback = folder.canSave;\n\n    const canEditGrafanaRules = contextSrv.hasAccessInMetadata(rulePermission.update, folder, rbacDisabledFallback);\n    const canRemoveGrafanaRules = contextSrv.hasAccessInMetadata(rulePermission.delete, folder, rbacDisabledFallback);\n\n    return {\n      isEditable: canEditGrafanaRules,\n      isRemovable: canRemoveGrafanaRules,\n      loading,\n    };\n  }\n\n  // prom rules are only editable by users with Editor role and only if rules source supports editing\n  const isRulerAvailable = Boolean(dataSources[rulesSourceName]?.result?.rulerConfig);\n  const canEditCloudRules = contextSrv.hasAccess(rulePermission.update, contextSrv.isEditor);\n  const canRemoveCloudRules = contextSrv.hasAccess(rulePermission.delete, contextSrv.isEditor);\n\n  return {\n    isEditable: canEditCloudRules && isRulerAvailable,\n    isRemovable: canRemoveCloudRules && isRulerAvailable,\n    loading: dataSources[rulesSourceName]?.loading,\n  };\n}\n","import { useCallback, useMemo } from 'react';\nimport { useLocation } from 'react-router-dom';\n\nimport { locationService } from '@grafana/runtime';\n\nexport function useURLSearchParams(): [\n  URLSearchParams,\n  (searchValues: Record<string, string | string[] | undefined>, replace?: boolean) => void\n] {\n  const { search } = useLocation();\n  const queryParams = useMemo(() => new URLSearchParams(search), [search]);\n\n  const update = useCallback((searchValues: Record<string, string | string[] | undefined>, replace?: boolean) => {\n    locationService.partial(searchValues, replace);\n  }, []);\n\n  return [queryParams, update];\n}\n","import { useMemo } from 'react';\n\nimport { getRulesAccess } from './access-control';\n\nexport function useRulesAccess() {\n  return useMemo(() => getRulesAccess(), []);\n}\n","export function generateCopiedName(originalName: string, exisitingNames: string[]) {\n  const nonDuplicateName = originalName.replace(/\\(copy( [0-9]+)?\\)$/, '').trim();\n\n  let newName = `${nonDuplicateName} (copy)`;\n\n  for (let i = 2; exisitingNames.includes(newName); i++) {\n    newName = `${nonDuplicateName} (copy ${i})`;\n  }\n\n  return newName;\n}\n"],"names":["AlertWarning","title","children","Alert","warningStyles","theme","CloneRuleEditor","sourceRuleId","dispatch","loading","rule","error","useAsync","LoadingPlaceholder","ruleClone","changeRuleName","formPrefill","AlertRuleForm","newName","ExistingRuleEditor","identifier","useCleanup","state","loadingAlertRule","result","dispatched","useUnifiedAlertingSelector","isEditable","loadingEditable","useIsRuleEditable","defaultPageNav","getPageNav","RuleEditor","match","searchParams","useURLSearchParams","id","copyFromId","copyFromIdentifier","canCreateGrafanaRules","canCreateCloudRules","canEditRules","getContent","AlertingPageWrapper","useFolder","uid","folderRequests","request","rulesSourceName","dataSources","folderUID","rulePermission","folder","rbacDisabledFallback","canEditGrafanaRules","canRemoveGrafanaRules","isRulerAvailable","canEditCloudRules","canRemoveCloudRules","search","queryParams","update","searchValues","replace","useRulesAccess","generateCopiedName","originalName","exisitingNames","nonDuplicateName","i"],"sourceRoot":""}