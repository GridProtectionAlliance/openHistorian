{"version":3,"sources":["webpack:///./public/app/plugins/datasource/influxdb/influx_series.ts","webpack:///./public/app/plugins/datasource/influxdb/query_part.ts","webpack:///./public/app/plugins/datasource/influxdb/influx_query_model.ts","webpack:///./public/app/plugins/datasource/influxdb/response_parser.ts","webpack:///./public/app/plugins/datasource/influxdb/query_builder.ts","webpack:///./public/app/plugins/datasource/influxdb/types.ts","webpack:///./public/app/plugins/datasource/influxdb/components/FluxQueryEditor.tsx","webpack:///./public/app/plugins/datasource/influxdb/datasource.ts","webpack:///./public/app/plugins/datasource/influxdb/query_ctrl.ts","webpack:///./public/app/plugins/datasource/influxdb/components/InfluxCheatSheet.tsx","webpack:///./public/app/plugins/datasource/influxdb/components/InfluxStartPage.tsx","webpack:///./public/app/plugins/datasource/influxdb/components/ConfigEditor.tsx","webpack:///./public/app/plugins/datasource/influxdb/components/VariableQueryEditor.tsx","webpack:///./public/app/plugins/datasource/influxdb/module.ts"],"names":["InfluxSeries","options","this","series","alias","annotation","meta","refId","i","j","output","length","_","each","columns","tags","map","value","key","seriesName","name","columnName","_getSeriesName","join","datapoints","values","push","target","index","segments","split","replace","match","g1","g2","group","segIndex","parseInt","isNaN","indexOf","tag","list","titleCol","timeCol","tagsCol","textCol","column","titleColumn","includes","tagsColumn","textColumn","data","time","Date","title","flatten","filter","t","text","table","TableModel","seriesIndex","type","FieldType","keys","reordered","hasOwnProperty","rows","categories","Aggregations","Selectors","Transformations","Predictors","Math","Aliasing","Fields","createPart","part","def","message","QueryPart","register","QueryPartDef","category","groupByTimeFunctions","fieldRenderer","innerExpr","params","replaceAggregationAddStrategy","selectParts","partModel","morePartsAvailable","splice","addTransformationStrategy","addStrategy","query","parts","clone","selectModels","dynamicLookup","defaultParams","renderer","functionRenderer","partCount","suffixRenderer","quote","renderMode","create","getCategories","replaceAggregationAdd","InfluxQueryModel","templateSrv","scopedVars","policy","resultFormat","orderByTime","groupBy","select","updateProjection","queryPart","groupByParts","find","g","stringParts","typePart","arg","s","modelsIndex","partIndex","updatePersistedParts","interpolate","str","operator","condition","test","measurement","variable","defaultFormatFn","multi","includeAll","kbn","regexEscape","rawQuery","interpolateQueryStr","y","selectText","render","getMeasurementAndPolicy","conditions","renderTagCondition","groupBySection","fill","limit","slimit","tz","filters","ResponseParser","results","influxResults","normalizedQuery","toLowerCase","isValueFirst","res","serie","isArray","addUnique","undefined","toString","arr","InfluxVersion","InfluxQueryBuilder","database","withKey","withMeasurementFilter","whereConditions","reduce","memo","samples","label","description","FluxQueryEditor","onFluxQueryChange","props","onChange","onRunQuery","onSampleChange","val","forceUpdate","getSuggestions","sugs","kind","CodeEditorSuggestionItemKind","Property","detail","getTemplateSrv","getVariables","forEach","Text","editorDidMountCallbackHack","editor","setTimeout","layout","helpTooltip","height","language","onBlur","onSave","showMiniMap","showLineNumbers","onEditorDidMount","className","cx","css","icon","variant","href","width","tooltip","PureComponent","coreModule","directive","reactDirective","InfluxDatasource","instanceSettings","urls","url","trim","username","password","basicAuth","withCredentials","settingsData","jsonData","interval","timeInterval","httpMode","responseParser","isFlux","version","Flux","annotations","QueryEditor","request","from","classicQuery","timeFilter","getTimeFilter","targets","cloneDeep","queryTargets","allQueries","hide","__interval","acc","current","Promise","resolve","adhocFilters","getAdhocFilters","tmpQuery","renderAdhocFilters","_seriesQuery","then","seriesList","result","executedQueryString","influxSeries","preferredVisualisationType","getTable","timeSeries","getTimeSeries","reject","rangeRaw","timezone","dashboard","getAnnotations","param","variableExists","queries","expandedQueries","expandedQuery","datasource","expandedTags","toPromise","rsp","frameToMetricFindValue","interpolated","resp","parse","queryBuilder","buildExploreQuery","metricFindQuery","range","_influxRequest","q","epoch","encodeURIComponent","requestId","id","uuidv4","dashboardId","panelId","intervalMs","maxDataPoints","dateTime","to","state","LoadingState","Done","console","error","status","first","catch","err","get","method","currentUrl","shift","u","p","db","has","extend","omit","serializeParams","pick","req","precision","inspect","paramSerializer","headers","Authorization","getBackendSrv","datasourceRequest","errors","elem","Number","isInteger","config","statusText","getInfluxTime","until","fromIsAbsolute","date","roundUp","isString","exec","dateMath","valueOf","DataSourceWithBackend","InfluxQueryCtrl","$scope","$injector","uiSegmentSrv","panelCtrl","refresh","queryModel","panel","groupBySegment","newPlusButton","resultFormats","policySegment","newSegment","measurementSegment","newSelectMeasurement","tagSegments","newCondition","newKey","newOperator","newKeyValue","fixTagSegments","buildSelectMenu","removeTagFilterSegment","fake","selectMenu","cat","menu","submenu","item","hasFill","hasGroupByTime","handleQueryError","bind","addGroupBy","plusButton","html","subitem","addSelectPart","evt","fieldsQuery","transformToSegments","removeSelectPart","tagsQuery","removeGroupByPart","count","lastSegment","max","policiesQuery","measurementFilter","addTemplateVars","segment","expandable","unshift","nextValue","newOperators","angular","copy","newFake","cssClass","rebuildTargetTagConditions","tagIndex","tagOperator","segment2","getTagValueOperator","tagValue","QueryCtrl","templateUrl","CHEAT_SHEET_ITEMS","InfluxStartPage","InfluxCheatSheet","onClickExample","Select","LegacyForms","Input","SecretFormField","httpModes","versions","InfluxQL","ConfigEditor","onResetPassword","updateDatasourcePluginResetOption","onResetToken","onVersionChanged","selected","onOptionsChange","access","user","onUpdateInflux2xURL","e","currentTarget","secureJsonFields","secureJsonData","placeholder","organization","onUpdateDatasourceJsonDataOption","isConfigured","token","labelWidth","inputWidth","onReset","onUpdateDatasourceSecureJsonDataOption","defaultBucket","showAccessOptions","dataSourceConfig","defaultUrl","onUpdateDatasourceOption","defaultValue","onUpdateDatasourceJsonDataOptionSelect","renderInflux2x","renderInflux1x","VariableQueryEditor","onRefresh","v","InfluxAnnotationsQueryCtrl","plugin","DataSourcePlugin","setConfigEditor","setQueryCtrl","setAnnotationQueryCtrl","setVariableQueryEditor","setExploreStartPage"],"mappings":"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","file":"influxdbPlugin.591ee81e63053ad31983.js","sourcesContent":["import _ from 'lodash';\nimport TableModel from 'app/core/table_model';\nimport { FieldType, QueryResultMeta, TimeSeries, TableData } from '@grafana/data';\n\nexport default class InfluxSeries {\n  refId?: string;\n  series: any;\n  alias: any;\n  annotation: any;\n  meta?: QueryResultMeta;\n\n  constructor(options: { series: any; alias?: any; annotation?: any; meta?: QueryResultMeta; refId?: string }) {\n    this.series = options.series;\n    this.alias = options.alias;\n    this.annotation = options.annotation;\n    this.meta = options.meta;\n    this.refId = options.refId;\n  }\n\n  getTimeSeries(): TimeSeries[] {\n    const output: TimeSeries[] = [];\n    let i, j;\n\n    if (this.series.length === 0) {\n      return output;\n    }\n\n    _.each(this.series, series => {\n      const columns = series.columns.length;\n      const tags = _.map(series.tags, (value, key) => {\n        return key + ': ' + value;\n      });\n\n      for (j = 1; j < columns; j++) {\n        let seriesName = series.name;\n        const columnName = series.columns[j];\n        if (columnName !== 'value') {\n          seriesName = seriesName + '.' + columnName;\n        }\n\n        if (this.alias) {\n          seriesName = this._getSeriesName(series, j);\n        } else if (series.tags) {\n          seriesName = seriesName + ' {' + tags.join(', ') + '}';\n        }\n\n        const datapoints = [];\n        if (series.values) {\n          for (i = 0; i < series.values.length; i++) {\n            datapoints[i] = [series.values[i][j], series.values[i][0]];\n          }\n        }\n\n        output.push({ target: seriesName, datapoints: datapoints, meta: this.meta, refId: this.refId });\n      }\n    });\n\n    return output;\n  }\n\n  _getSeriesName(series: any, index: number) {\n    const regex = /\\$(\\w+)|\\[\\[([\\s\\S]+?)\\]\\]/g;\n    const segments = series.name.split('.');\n\n    return this.alias.replace(regex, (match: any, g1: any, g2: any) => {\n      const group = g1 || g2;\n      const segIndex = parseInt(group, 10);\n\n      if (group === 'm' || group === 'measurement') {\n        return series.name;\n      }\n      if (group === 'col') {\n        return series.columns[index];\n      }\n      if (!isNaN(segIndex)) {\n        return segments[segIndex];\n      }\n      if (group.indexOf('tag_') !== 0) {\n        return match;\n      }\n\n      const tag = group.replace('tag_', '');\n      if (!series.tags) {\n        return match;\n      }\n      return series.tags[tag];\n    });\n  }\n\n  getAnnotations() {\n    const list: any[] = [];\n\n    _.each(this.series, series => {\n      let titleCol: any = null;\n      let timeCol: any = null;\n      const tagsCol: any = [];\n      let textCol: any = null;\n\n      _.each(series.columns, (column, index) => {\n        if (column === 'time') {\n          timeCol = index;\n          return;\n        }\n        if (column === 'sequence_number') {\n          return;\n        }\n        if (column === this.annotation.titleColumn) {\n          titleCol = index;\n          return;\n        }\n        if (_.includes((this.annotation.tagsColumn || '').replace(' ', '').split(','), column)) {\n          tagsCol.push(index);\n          return;\n        }\n        if (column === this.annotation.textColumn) {\n          textCol = index;\n          return;\n        }\n        // legacy case\n        if (!titleCol && textCol !== index) {\n          titleCol = index;\n        }\n      });\n\n      _.each(series.values, value => {\n        const data = {\n          annotation: this.annotation,\n          time: +new Date(value[timeCol]),\n          title: value[titleCol],\n          // Remove empty values, then split in different tags for comma separated values\n          tags: _.flatten(\n            tagsCol\n              .filter((t: any) => {\n                return value[t];\n              })\n              .map((t: any) => {\n                return value[t].split(',');\n              })\n          ),\n          text: value[textCol],\n        };\n\n        list.push(data);\n      });\n    });\n\n    return list;\n  }\n\n  getTable(): TableData {\n    const table = new TableModel();\n    let i, j;\n\n    table.refId = this.refId;\n    table.meta = this.meta;\n\n    if (this.series.length === 0) {\n      return table;\n    }\n\n    _.each(this.series, (series: any, seriesIndex: number) => {\n      if (seriesIndex === 0) {\n        j = 0;\n        // Check that the first column is indeed 'time'\n        if (series.columns[0] === 'time') {\n          // Push this now before the tags and with the right type\n          table.columns.push({ text: 'Time', type: FieldType.time });\n          j++;\n        }\n        _.each(_.keys(series.tags), key => {\n          table.columns.push({ text: key });\n        });\n        for (; j < series.columns.length; j++) {\n          table.columns.push({ text: series.columns[j] });\n        }\n      }\n\n      if (series.values) {\n        for (i = 0; i < series.values.length; i++) {\n          const values = series.values[i];\n          const reordered = [values[0]];\n          if (series.tags) {\n            for (const key in series.tags) {\n              if (series.tags.hasOwnProperty(key)) {\n                reordered.push(series.tags[key]);\n              }\n            }\n          }\n          for (j = 1; j < values.length; j++) {\n            reordered.push(values[j]);\n          }\n          table.rows.push(reordered);\n        }\n      }\n    });\n\n    return table;\n  }\n}\n","import _ from 'lodash';\nimport { QueryPartDef, QueryPart, functionRenderer, suffixRenderer } from 'app/core/components/query_part/query_part';\n\nconst index: any[] = [];\nconst categories: any = {\n  Aggregations: [],\n  Selectors: [],\n  Transformations: [],\n  Predictors: [],\n  Math: [],\n  Aliasing: [],\n  Fields: [],\n};\n\nfunction createPart(part: any): any {\n  const def = index[part.type];\n  if (!def) {\n    throw { message: 'Could not find query part ' + part.type };\n  }\n\n  return new QueryPart(part, def);\n}\n\nfunction register(options: any) {\n  index[options.type] = new QueryPartDef(options);\n  options.category.push(index[options.type]);\n}\n\nconst groupByTimeFunctions: any[] = [];\n\nfunction aliasRenderer(part: { params: string[] }, innerExpr: string) {\n  return innerExpr + ' AS ' + '\"' + part.params[0] + '\"';\n}\n\nfunction fieldRenderer(part: { params: string[] }, innerExpr: any) {\n  if (part.params[0] === '*') {\n    return '*';\n  }\n  return '\"' + part.params[0] + '\"';\n}\n\nfunction replaceAggregationAddStrategy(selectParts: any[], partModel: { def: { type: string } }) {\n  // look for existing aggregation\n  for (let i = 0; i < selectParts.length; i++) {\n    const part = selectParts[i];\n    if (part.def.category === categories.Aggregations) {\n      if (part.def.type === partModel.def.type) {\n        return;\n      }\n      // count distinct is allowed\n      if (part.def.type === 'count' && partModel.def.type === 'distinct') {\n        break;\n      }\n      // remove next aggregation if distinct was replaced\n      if (part.def.type === 'distinct') {\n        const morePartsAvailable = selectParts.length >= i + 2;\n        if (partModel.def.type !== 'count' && morePartsAvailable) {\n          const nextPart = selectParts[i + 1];\n          if (nextPart.def.category === categories.Aggregations) {\n            selectParts.splice(i + 1, 1);\n          }\n        } else if (partModel.def.type === 'count') {\n          if (!morePartsAvailable || selectParts[i + 1].def.type !== 'count') {\n            selectParts.splice(i + 1, 0, partModel);\n          }\n          return;\n        }\n      }\n      selectParts[i] = partModel;\n      return;\n    }\n    if (part.def.category === categories.Selectors) {\n      selectParts[i] = partModel;\n      return;\n    }\n  }\n\n  selectParts.splice(1, 0, partModel);\n}\n\nfunction addTransformationStrategy(selectParts: any[], partModel: any) {\n  let i;\n  // look for index to add transformation\n  for (i = 0; i < selectParts.length; i++) {\n    const part = selectParts[i];\n    if (part.def.category === categories.Math || part.def.category === categories.Aliasing) {\n      break;\n    }\n  }\n\n  selectParts.splice(i, 0, partModel);\n}\n\nfunction addMathStrategy(selectParts: any[], partModel: any) {\n  const partCount = selectParts.length;\n  if (partCount > 0) {\n    // if last is math, replace it\n    if (selectParts[partCount - 1].def.type === 'math') {\n      selectParts[partCount - 1] = partModel;\n      return;\n    }\n    // if next to last is math, replace it\n    if (partCount > 1 && selectParts[partCount - 2].def.type === 'math') {\n      selectParts[partCount - 2] = partModel;\n      return;\n    } else if (selectParts[partCount - 1].def.type === 'alias') {\n      // if last is alias add it before\n      selectParts.splice(partCount - 1, 0, partModel);\n      return;\n    }\n  }\n  selectParts.push(partModel);\n}\n\nfunction addAliasStrategy(selectParts: any[], partModel: any) {\n  const partCount = selectParts.length;\n  if (partCount > 0) {\n    // if last is alias, replace it\n    if (selectParts[partCount - 1].def.type === 'alias') {\n      selectParts[partCount - 1] = partModel;\n      return;\n    }\n  }\n  selectParts.push(partModel);\n}\n\nfunction addFieldStrategy(selectParts: any, partModel: any, query: { selectModels: any[][] }) {\n  // copy all parts\n  const parts = _.map(selectParts, (part: any) => {\n    return createPart({ type: part.def.type, params: _.clone(part.params) });\n  });\n\n  query.selectModels.push(parts);\n}\n\nregister({\n  type: 'field',\n  addStrategy: addFieldStrategy,\n  category: categories.Fields,\n  params: [{ type: 'field', dynamicLookup: true }],\n  defaultParams: ['value'],\n  renderer: fieldRenderer,\n});\n\n// Aggregations\nregister({\n  type: 'count',\n  addStrategy: replaceAggregationAddStrategy,\n  category: categories.Aggregations,\n  params: [],\n  defaultParams: [],\n  renderer: functionRenderer,\n});\n\nregister({\n  type: 'distinct',\n  addStrategy: replaceAggregationAddStrategy,\n  category: categories.Aggregations,\n  params: [],\n  defaultParams: [],\n  renderer: functionRenderer,\n});\n\nregister({\n  type: 'integral',\n  addStrategy: replaceAggregationAddStrategy,\n  category: categories.Aggregations,\n  params: [],\n  defaultParams: [],\n  renderer: functionRenderer,\n});\n\nregister({\n  type: 'mean',\n  addStrategy: replaceAggregationAddStrategy,\n  category: categories.Aggregations,\n  params: [],\n  defaultParams: [],\n  renderer: functionRenderer,\n});\n\nregister({\n  type: 'median',\n  addStrategy: replaceAggregationAddStrategy,\n  category: categories.Aggregations,\n  params: [],\n  defaultParams: [],\n  renderer: functionRenderer,\n});\n\nregister({\n  type: 'mode',\n  addStrategy: replaceAggregationAddStrategy,\n  category: categories.Aggregations,\n  params: [],\n  defaultParams: [],\n  renderer: functionRenderer,\n});\n\nregister({\n  type: 'sum',\n  addStrategy: replaceAggregationAddStrategy,\n  category: categories.Aggregations,\n  params: [],\n  defaultParams: [],\n  renderer: functionRenderer,\n});\n\n// transformations\n\nregister({\n  type: 'derivative',\n  addStrategy: addTransformationStrategy,\n  category: categories.Transformations,\n  params: [\n    {\n      name: 'duration',\n      type: 'interval',\n      options: ['1s', '10s', '1m', '5m', '10m', '15m', '1h'],\n    },\n  ],\n  defaultParams: ['10s'],\n  renderer: functionRenderer,\n});\n\nregister({\n  type: 'spread',\n  addStrategy: addTransformationStrategy,\n  category: categories.Transformations,\n  params: [],\n  defaultParams: [],\n  renderer: functionRenderer,\n});\n\nregister({\n  type: 'non_negative_derivative',\n  addStrategy: addTransformationStrategy,\n  category: categories.Transformations,\n  params: [\n    {\n      name: 'duration',\n      type: 'interval',\n      options: ['1s', '10s', '1m', '5m', '10m', '15m', '1h'],\n    },\n  ],\n  defaultParams: ['10s'],\n  renderer: functionRenderer,\n});\n\nregister({\n  type: 'difference',\n  addStrategy: addTransformationStrategy,\n  category: categories.Transformations,\n  params: [],\n  defaultParams: [],\n  renderer: functionRenderer,\n});\n\nregister({\n  type: 'non_negative_difference',\n  addStrategy: addTransformationStrategy,\n  category: categories.Transformations,\n  params: [],\n  defaultParams: [],\n  renderer: functionRenderer,\n});\n\nregister({\n  type: 'moving_average',\n  addStrategy: addTransformationStrategy,\n  category: categories.Transformations,\n  params: [{ name: 'window', type: 'int', options: [5, 10, 20, 30, 40] }],\n  defaultParams: [10],\n  renderer: functionRenderer,\n});\n\nregister({\n  type: 'cumulative_sum',\n  addStrategy: addTransformationStrategy,\n  category: categories.Transformations,\n  params: [],\n  defaultParams: [],\n  renderer: functionRenderer,\n});\n\nregister({\n  type: 'stddev',\n  addStrategy: addTransformationStrategy,\n  category: categories.Transformations,\n  params: [],\n  defaultParams: [],\n  renderer: functionRenderer,\n});\n\nregister({\n  type: 'time',\n  category: groupByTimeFunctions,\n  params: [\n    {\n      name: 'interval',\n      type: 'time',\n      options: ['$__interval', '1s', '10s', '1m', '5m', '10m', '15m', '1h'],\n    },\n  ],\n  defaultParams: ['$__interval'],\n  renderer: functionRenderer,\n});\n\nregister({\n  type: 'fill',\n  category: groupByTimeFunctions,\n  params: [\n    {\n      name: 'fill',\n      type: 'string',\n      options: ['none', 'null', '0', 'previous', 'linear'],\n    },\n  ],\n  defaultParams: ['null'],\n  renderer: functionRenderer,\n});\n\nregister({\n  type: 'elapsed',\n  addStrategy: addTransformationStrategy,\n  category: categories.Transformations,\n  params: [\n    {\n      name: 'duration',\n      type: 'interval',\n      options: ['1s', '10s', '1m', '5m', '10m', '15m', '1h'],\n    },\n  ],\n  defaultParams: ['10s'],\n  renderer: functionRenderer,\n});\n\n// predictions\nregister({\n  type: 'holt_winters',\n  addStrategy: addTransformationStrategy,\n  category: categories.Predictors,\n  params: [\n    { name: 'number', type: 'int', options: [5, 10, 20, 30, 40] },\n    { name: 'season', type: 'int', options: [0, 1, 2, 5, 10] },\n  ],\n  defaultParams: [10, 2],\n  renderer: functionRenderer,\n});\n\nregister({\n  type: 'holt_winters_with_fit',\n  addStrategy: addTransformationStrategy,\n  category: categories.Predictors,\n  params: [\n    { name: 'number', type: 'int', options: [5, 10, 20, 30, 40] },\n    { name: 'season', type: 'int', options: [0, 1, 2, 5, 10] },\n  ],\n  defaultParams: [10, 2],\n  renderer: functionRenderer,\n});\n\n// Selectors\nregister({\n  type: 'bottom',\n  addStrategy: replaceAggregationAddStrategy,\n  category: categories.Selectors,\n  params: [{ name: 'count', type: 'int' }],\n  defaultParams: [3],\n  renderer: functionRenderer,\n});\n\nregister({\n  type: 'first',\n  addStrategy: replaceAggregationAddStrategy,\n  category: categories.Selectors,\n  params: [],\n  defaultParams: [],\n  renderer: functionRenderer,\n});\n\nregister({\n  type: 'last',\n  addStrategy: replaceAggregationAddStrategy,\n  category: categories.Selectors,\n  params: [],\n  defaultParams: [],\n  renderer: functionRenderer,\n});\n\nregister({\n  type: 'max',\n  addStrategy: replaceAggregationAddStrategy,\n  category: categories.Selectors,\n  params: [],\n  defaultParams: [],\n  renderer: functionRenderer,\n});\n\nregister({\n  type: 'min',\n  addStrategy: replaceAggregationAddStrategy,\n  category: categories.Selectors,\n  params: [],\n  defaultParams: [],\n  renderer: functionRenderer,\n});\n\nregister({\n  type: 'percentile',\n  addStrategy: replaceAggregationAddStrategy,\n  category: categories.Selectors,\n  params: [{ name: 'nth', type: 'int' }],\n  defaultParams: [95],\n  renderer: functionRenderer,\n});\n\nregister({\n  type: 'top',\n  addStrategy: replaceAggregationAddStrategy,\n  category: categories.Selectors,\n  params: [{ name: 'count', type: 'int' }],\n  defaultParams: [3],\n  renderer: functionRenderer,\n});\n\nregister({\n  type: 'tag',\n  category: groupByTimeFunctions,\n  params: [{ name: 'tag', type: 'string', dynamicLookup: true }],\n  defaultParams: ['tag'],\n  renderer: fieldRenderer,\n});\n\nregister({\n  type: 'math',\n  addStrategy: addMathStrategy,\n  category: categories.Math,\n  params: [{ name: 'expr', type: 'string' }],\n  defaultParams: [' / 100'],\n  renderer: suffixRenderer,\n});\n\nregister({\n  type: 'alias',\n  addStrategy: addAliasStrategy,\n  category: categories.Aliasing,\n  params: [{ name: 'name', type: 'string', quote: 'double' }],\n  defaultParams: ['alias'],\n  renderMode: 'suffix',\n  renderer: aliasRenderer,\n});\n\nexport default {\n  create: createPart,\n  getCategories: () => {\n    return categories;\n  },\n  replaceAggregationAdd: replaceAggregationAddStrategy,\n};\n","import _ from 'lodash';\nimport queryPart from './query_part';\nimport kbn from 'app/core/utils/kbn';\nimport { InfluxQuery, InfluxQueryTag } from './types';\nimport { ScopedVars } from '@grafana/data';\nimport { TemplateSrv } from '@grafana/runtime';\n\nexport default class InfluxQueryModel {\n  target: InfluxQuery;\n  selectModels: any[];\n  queryBuilder: any;\n  groupByParts: any;\n  templateSrv: any;\n  scopedVars: any;\n  refId?: string;\n\n  /** @ngInject */\n  constructor(target: InfluxQuery, templateSrv?: TemplateSrv, scopedVars?: ScopedVars) {\n    this.target = target;\n    this.templateSrv = templateSrv;\n    this.scopedVars = scopedVars;\n\n    target.policy = target.policy || 'default';\n    target.resultFormat = target.resultFormat || 'time_series';\n    target.orderByTime = target.orderByTime || 'ASC';\n    target.tags = target.tags || [];\n    target.groupBy = target.groupBy || [\n      { type: 'time', params: ['$__interval'] },\n      { type: 'fill', params: ['null'] },\n    ];\n    target.select = target.select || [\n      [\n        { type: 'field', params: ['value'] },\n        { type: 'mean', params: [] },\n      ],\n    ];\n\n    this.updateProjection();\n  }\n\n  updateProjection() {\n    this.selectModels = _.map(this.target.select, (parts: any) => {\n      return _.map(parts, queryPart.create);\n    });\n    this.groupByParts = _.map(this.target.groupBy, queryPart.create);\n  }\n\n  updatePersistedParts() {\n    this.target.select = _.map(this.selectModels, selectParts => {\n      return _.map(selectParts, (part: any) => {\n        return { type: part.def.type, params: part.params };\n      });\n    });\n  }\n\n  hasGroupByTime() {\n    return _.find(this.target.groupBy, (g: any) => g.type === 'time');\n  }\n\n  hasFill() {\n    return _.find(this.target.groupBy, (g: any) => g.type === 'fill');\n  }\n\n  addGroupBy(value: string) {\n    let stringParts = value.match(/^(\\w+)\\((.*)\\)$/);\n\n    if (!stringParts || !this.target.groupBy) {\n      return;\n    }\n\n    const typePart = stringParts[1];\n    const arg = stringParts[2];\n    const partModel = queryPart.create({ type: typePart, params: [arg] });\n    const partCount = this.target.groupBy.length;\n\n    if (partCount === 0) {\n      this.target.groupBy.push(partModel.part);\n    } else if (typePart === 'time') {\n      this.target.groupBy.splice(0, 0, partModel.part);\n    } else if (typePart === 'tag') {\n      if (this.target.groupBy[partCount - 1].type === 'fill') {\n        this.target.groupBy.splice(partCount - 1, 0, partModel.part);\n      } else {\n        this.target.groupBy.push(partModel.part);\n      }\n    } else {\n      this.target.groupBy.push(partModel.part);\n    }\n\n    this.updateProjection();\n  }\n\n  removeGroupByPart(part: { def: { type: string } }, index: number) {\n    const categories = queryPart.getCategories();\n\n    if (part.def.type === 'time') {\n      // remove fill\n      this.target.groupBy = _.filter(this.target.groupBy, (g: any) => g.type !== 'fill');\n      // remove aggregations\n      this.target.select = _.map(this.target.select, (s: any) => {\n        return _.filter(s, (part: any) => {\n          const partModel = queryPart.create(part);\n          if (partModel.def.category === categories.Aggregations) {\n            return false;\n          }\n          if (partModel.def.category === categories.Selectors) {\n            return false;\n          }\n          return true;\n        });\n      });\n    }\n\n    this.target.groupBy!.splice(index, 1);\n    this.updateProjection();\n  }\n\n  removeSelect(index: number) {\n    this.target.select!.splice(index, 1);\n    this.updateProjection();\n  }\n\n  removeSelectPart(selectParts: any[], part: any) {\n    // if we remove the field remove the whole statement\n    if (part.def.type === 'field') {\n      if (this.selectModels.length > 1) {\n        const modelsIndex = _.indexOf(this.selectModels, selectParts);\n        this.selectModels.splice(modelsIndex, 1);\n      }\n    } else {\n      const partIndex = _.indexOf(selectParts, part);\n      selectParts.splice(partIndex, 1);\n    }\n\n    this.updatePersistedParts();\n  }\n\n  addSelectPart(selectParts: any[], type: string) {\n    const partModel = queryPart.create({ type: type });\n    partModel.def.addStrategy(selectParts, partModel, this);\n    this.updatePersistedParts();\n  }\n\n  private renderTagCondition(tag: InfluxQueryTag, index: number, interpolate?: boolean) {\n    let str = '';\n    let operator = tag.operator;\n    let value = tag.value;\n    if (index > 0) {\n      str = (tag.condition || 'AND') + ' ';\n    }\n\n    if (!operator) {\n      if (/^\\/.*\\/$/.test(value)) {\n        operator = '=~';\n      } else {\n        operator = '=';\n      }\n    }\n\n    // quote value unless regex\n    if (operator !== '=~' && operator !== '!~') {\n      if (interpolate) {\n        value = this.templateSrv.replace(value, this.scopedVars);\n      }\n      if (operator !== '>' && operator !== '<') {\n        value = \"'\" + value.replace(/\\\\/g, '\\\\\\\\').replace(/\\'/g, \"\\\\'\") + \"'\";\n      }\n    } else if (interpolate) {\n      value = this.templateSrv.replace(value, this.scopedVars, 'regex');\n    }\n\n    return str + '\"' + tag.key + '\" ' + operator + ' ' + value;\n  }\n\n  getMeasurementAndPolicy(interpolate: any) {\n    let policy = this.target.policy;\n    let measurement = this.target.measurement || 'measurement';\n\n    if (!measurement.match('^/.*/$')) {\n      measurement = '\"' + measurement + '\"';\n    } else if (interpolate) {\n      measurement = this.templateSrv.replace(measurement, this.scopedVars, 'regex');\n    }\n\n    if (policy !== 'default') {\n      policy = '\"' + this.target.policy + '\".';\n    } else {\n      policy = '';\n    }\n\n    return policy + measurement;\n  }\n\n  interpolateQueryStr(value: any[], variable: { multi: any; includeAll: any }, defaultFormatFn: any) {\n    // if no multi or include all do not regexEscape\n    if (!variable.multi && !variable.includeAll) {\n      return value;\n    }\n\n    if (typeof value === 'string') {\n      return kbn.regexEscape(value);\n    }\n\n    const escapedValues = _.map(value, kbn.regexEscape);\n    return '(' + escapedValues.join('|') + ')';\n  }\n\n  render(interpolate?: boolean) {\n    const target = this.target;\n\n    if (target.rawQuery) {\n      if (interpolate) {\n        return this.templateSrv.replace(target.query, this.scopedVars, this.interpolateQueryStr);\n      } else {\n        return target.query;\n      }\n    }\n\n    let query = 'SELECT ';\n    let i, y;\n    for (i = 0; i < this.selectModels.length; i++) {\n      const parts = this.selectModels[i];\n      let selectText = '';\n      for (y = 0; y < parts.length; y++) {\n        const part = parts[y];\n        selectText = part.render(selectText);\n      }\n\n      if (i > 0) {\n        query += ', ';\n      }\n      query += selectText;\n    }\n\n    query += ' FROM ' + this.getMeasurementAndPolicy(interpolate) + ' WHERE ';\n    const conditions = _.map(target.tags, (tag, index) => {\n      return this.renderTagCondition(tag, index, interpolate);\n    });\n\n    if (conditions.length > 0) {\n      query += '(' + conditions.join(' ') + ') AND ';\n    }\n\n    query += '$timeFilter';\n\n    let groupBySection = '';\n    for (i = 0; i < this.groupByParts.length; i++) {\n      const part = this.groupByParts[i];\n      if (i > 0) {\n        // for some reason fill has no separator\n        groupBySection += part.def.type === 'fill' ? ' ' : ', ';\n      }\n      groupBySection += part.render('');\n    }\n\n    if (groupBySection.length) {\n      query += ' GROUP BY ' + groupBySection;\n    }\n\n    if (target.fill) {\n      query += ' fill(' + target.fill + ')';\n    }\n\n    if (target.orderByTime === 'DESC') {\n      query += ' ORDER BY time DESC';\n    }\n\n    if (target.limit) {\n      query += ' LIMIT ' + target.limit;\n    }\n\n    if (target.slimit) {\n      query += ' SLIMIT ' + target.slimit;\n    }\n\n    if (target.tz) {\n      query += \" tz('\" + target.tz + \"')\";\n    }\n\n    return query;\n  }\n\n  renderAdhocFilters(filters: any[]) {\n    const conditions = _.map(filters, (tag, index) => {\n      return this.renderTagCondition(tag, index, true);\n    });\n    return conditions.join(' ');\n  }\n}\n","import _ from 'lodash';\n\nexport default class ResponseParser {\n  parse(query: string, results: { results: any }) {\n    if (!results || results.results.length === 0) {\n      return [];\n    }\n\n    const influxResults = results.results[0];\n    if (!influxResults.series) {\n      return [];\n    }\n\n    const normalizedQuery = query.toLowerCase();\n    const isValueFirst =\n      normalizedQuery.indexOf('show field keys') >= 0 || normalizedQuery.indexOf('show retention policies') >= 0;\n\n    const res = {};\n    _.each(influxResults.series, serie => {\n      _.each(serie.values, value => {\n        if (_.isArray(value)) {\n          // In general, there are 2 possible shapes for the returned value.\n          // The first one is a two-element array,\n          // where the first element is somewhat a metadata value:\n          // the tag name for SHOW TAG VALUES queries,\n          // the time field for SELECT queries, etc.\n          // The second shape is an one-element array,\n          // that is containing an immediate value.\n          // For example, SHOW FIELD KEYS queries return such shape.\n          // Note, pre-0.11 versions return\n          // the second shape for SHOW TAG VALUES queries\n          // (while the newer versions—first).\n\n          if (isValueFirst) {\n            addUnique(res, value[0]);\n          } else if (value[1] !== undefined) {\n            addUnique(res, value[1]);\n          } else {\n            addUnique(res, value[0]);\n          }\n        } else {\n          addUnique(res, value);\n        }\n      });\n    });\n\n    // @ts-ignore problems with typings for this _.map only accepts [] but this needs to be object\n    return _.map(res, value => {\n      // @ts-ignore\n      return { text: value.toString() };\n    });\n  }\n}\n\nfunction addUnique(arr: { [x: string]: any }, value: string | number) {\n  arr[value] = value;\n}\n","import _ from 'lodash';\nimport kbn from 'app/core/utils/kbn';\n\nfunction renderTagCondition(tag: { operator: any; value: string; condition: any; key: string }, index: number) {\n  let str = '';\n  let operator = tag.operator;\n  let value = tag.value;\n  if (index > 0) {\n    str = (tag.condition || 'AND') + ' ';\n  }\n\n  if (!operator) {\n    if (/^\\/.*\\/$/.test(tag.value)) {\n      operator = '=~';\n    } else {\n      operator = '=';\n    }\n  }\n\n  // quote value unless regex or number\n  if (operator !== '=~' && operator !== '!~' && isNaN(+value)) {\n    value = \"'\" + value + \"'\";\n  }\n\n  return str + '\"' + tag.key + '\" ' + operator + ' ' + value;\n}\n\nexport class InfluxQueryBuilder {\n  constructor(private target: { measurement: any; tags: any; policy?: any }, private database?: string) {}\n\n  buildExploreQuery(type: string, withKey?: string, withMeasurementFilter?: string): string {\n    let query = '';\n    let measurement;\n    let policy;\n\n    if (type === 'TAG_KEYS') {\n      query = 'SHOW TAG KEYS';\n      measurement = this.target.measurement;\n      policy = this.target.policy;\n    } else if (type === 'TAG_VALUES') {\n      query = 'SHOW TAG VALUES';\n      measurement = this.target.measurement;\n      policy = this.target.policy;\n    } else if (type === 'MEASUREMENTS') {\n      query = 'SHOW MEASUREMENTS';\n      if (withMeasurementFilter) {\n        query += ' WITH MEASUREMENT =~ /' + kbn.regexEscape(withMeasurementFilter) + '/';\n      }\n    } else if (type === 'FIELDS') {\n      measurement = this.target.measurement;\n      policy = this.target.policy;\n\n      if (!measurement.match('^/.*/')) {\n        measurement = '\"' + measurement + '\"';\n\n        if (policy && policy !== 'default') {\n          policy = '\"' + policy + '\"';\n          measurement = policy + '.' + measurement;\n        }\n      }\n\n      return 'SHOW FIELD KEYS FROM ' + measurement;\n    } else if (type === 'RETENTION POLICIES') {\n      query = 'SHOW RETENTION POLICIES on \"' + this.database + '\"';\n      return query;\n    }\n\n    if (measurement) {\n      if (!measurement.match('^/.*/') && !measurement.match(/^merge\\(.*\\)/)) {\n        measurement = '\"' + measurement + '\"';\n      }\n\n      if (policy && policy !== 'default') {\n        policy = '\"' + policy + '\"';\n        measurement = policy + '.' + measurement;\n      }\n\n      query += ' FROM ' + measurement;\n    }\n\n    if (withKey) {\n      query += ' WITH KEY = \"' + withKey + '\"';\n    }\n\n    if (this.target.tags && this.target.tags.length > 0) {\n      const whereConditions = _.reduce(\n        this.target.tags,\n        (memo, tag) => {\n          // do not add a condition for the key we want to explore for\n          if (tag.key === withKey) {\n            return memo;\n          }\n\n          // value operators not supported in these types of queries\n          if (tag.operator === '>' || tag.operator === '<') {\n            return memo;\n          }\n\n          memo.push(renderTagCondition(tag, memo.length));\n          return memo;\n        },\n        [] as string[]\n      );\n\n      if (whereConditions.length > 0) {\n        query += ' WHERE ' + whereConditions.join(' ');\n      }\n    }\n\n    if (type === 'MEASUREMENTS') {\n      query += ' LIMIT 100';\n      //Solve issue #2524 by limiting the number of measurements returned\n      //LIMIT must be after WITH MEASUREMENT and WHERE clauses\n      //This also could be used for TAG KEYS and TAG VALUES, if desired\n    }\n\n    return query;\n  }\n}\n","import { DataQuery, DataSourceJsonData } from '@grafana/data';\n\nexport enum InfluxVersion {\n  InfluxQL = 'InfluxQL',\n  Flux = 'Flux',\n}\n\nexport interface InfluxOptions extends DataSourceJsonData {\n  version?: InfluxVersion;\n\n  timeInterval: string;\n  httpMode: string;\n\n  // With Flux\n  organization?: string;\n  defaultBucket?: string;\n  maxSeries?: number;\n}\n\nexport interface InfluxSecureJsonData {\n  // For Flux\n  token?: string;\n\n  // In 1x a different password can be sent than then HTTP auth\n  password?: string;\n}\n\nexport interface InfluxQueryPart {\n  type: string;\n  params?: string[];\n  interval?: string;\n}\n\nexport interface InfluxQueryTag {\n  key: string;\n  operator?: string;\n  condition?: string;\n  value: string;\n}\n\nexport interface InfluxQuery extends DataQuery {\n  policy?: string;\n  measurement?: string;\n  resultFormat?: 'time_series' | 'table';\n  orderByTime?: string;\n  tags?: InfluxQueryTag[];\n  groupBy?: InfluxQueryPart[];\n  select?: InfluxQueryPart[][];\n  limit?: string;\n  slimit?: string;\n  tz?: string;\n  fill?: string;\n  rawQuery?: boolean;\n  query?: string;\n}\n","import React, { PureComponent } from 'react';\nimport coreModule from 'app/core/core_module';\nimport { InfluxQuery } from '../types';\nimport { SelectableValue, QueryEditorProps } from '@grafana/data';\nimport { cx, css } from 'emotion';\nimport {\n  InlineFormLabel,\n  LinkButton,\n  Segment,\n  CodeEditor,\n  CodeEditorSuggestionItem,\n  CodeEditorSuggestionItemKind,\n} from '@grafana/ui';\nimport { getTemplateSrv } from '@grafana/runtime';\nimport InfluxDatasource from '../datasource';\n\n// @ts-ignore -- complicated since the datasource is not really reactified yet!\ntype Props = QueryEditorProps<InfluxDatasource, InfluxQuery>;\n\nconst samples: Array<SelectableValue<string>> = [\n  { label: 'Show buckets', description: 'List the available buckets (table)', value: 'buckets()' },\n  {\n    label: 'Simple query',\n    description: 'filter by measurement and field',\n    value: `from(bucket: \"db/rp\")\n  |> range(start: v.timeRangeStart, stop:v.timeRangeStop)\n  |> filter(fn: (r) =>\n    r._measurement == \"example-measurement\" and\n    r._field == \"example-field\"\n  )`,\n  },\n  {\n    label: 'Grouped Query',\n    description: 'Group by (min/max/sum/median)',\n    value: `// v.windowPeriod is a variable referring to the current optimized window period (currently: $interval)\nfrom(bucket: v.bucket)\n  |> range(start: v.timeRangeStart, stop: v.timeRangeStop)\n  |> filter(fn: (r) => r[\"_measurement\"] == \"measurement1\" or r[\"_measurement\"] =~ /^.*?regex.*$/)\n  |> filter(fn: (r) => r[\"_field\"] == \"field2\" or r[\"_field\"] =~ /^.*?regex.*$/)\n  |> aggregateWindow(every: v.windowPeriod, fn: mean|median|max|count|derivative|sum)\n  |> yield(name: \"some-name\")`,\n  },\n  {\n    label: 'Filter by value',\n    description: 'Results between a min/max',\n    value: `// v.bucket, v.timeRangeStart, and v.timeRange stop are all variables supported by the flux plugin and influxdb\nfrom(bucket: v.bucket)\n  |> range(start: v.timeRangeStart, stop: v.timeRangeStop)\n  |> filter(fn: (r) => r[\"_value\"] >= 10 and r[\"_value\"] <= 20)`,\n  },\n  {\n    label: 'Schema Exploration: (measurements)',\n    description: 'Get a list of measurement using flux',\n    value: `import \"influxdata/influxdb/v1\"\nv1.measurements(bucket: v.bucket)`,\n  },\n  {\n    label: 'Schema Exploration: (fields)',\n    description: 'Return every possible key in a single table',\n    value: `from(bucket: v.bucket)\n  |> range(start: v.timeRangeStart, stop:v.timeRangeStop)\n  |> keys()\n  |> keep(columns: [\"_value\"])\n  |> group()\n  |> distinct()`,\n  },\n  {\n    label: 'Schema Exploration: (tag keys)',\n    description: 'Get a list of tag keys using flux',\n    value: `import \"influxdata/influxdb/v1\"\nv1.tagKeys(bucket: v.bucket)`,\n  },\n  {\n    label: 'Schema Exploration: (tag values)',\n    description: 'Get a list of tag values using flux',\n    value: `import \"influxdata/influxdb/v1\"\nv1.tagValues(\n    bucket: v.bucket,\n    tag: \"host\",\n    predicate: (r) => true,\n    start: -1d\n)`,\n  },\n];\n\nexport class FluxQueryEditor extends PureComponent<Props> {\n  onFluxQueryChange = (query: string) => {\n    this.props.onChange({ ...this.props.query, query });\n    this.props.onRunQuery();\n  };\n\n  onSampleChange = (val: SelectableValue<string>) => {\n    this.props.onChange({\n      ...this.props.query,\n      query: val.value!,\n    });\n\n    // Angular HACK: Since the target does not actually change!\n    this.forceUpdate();\n    this.props.onRunQuery();\n  };\n\n  getSuggestions = (): CodeEditorSuggestionItem[] => {\n    const sugs: CodeEditorSuggestionItem[] = [\n      {\n        label: 'v.timeRangeStart',\n        kind: CodeEditorSuggestionItemKind.Property,\n        detail: 'The start time',\n      },\n      {\n        label: 'v.timeRangeStop',\n        kind: CodeEditorSuggestionItemKind.Property,\n        detail: 'The stop time',\n      },\n      {\n        label: 'v.windowPeriod',\n        kind: CodeEditorSuggestionItemKind.Property,\n        detail: 'based on max data points',\n      },\n      {\n        label: 'v.defaultBucket',\n        kind: CodeEditorSuggestionItemKind.Property,\n        detail: 'bucket configured in the datsource',\n      },\n      {\n        label: 'v.organization',\n        kind: CodeEditorSuggestionItemKind.Property,\n        detail: 'org configured for the datsource',\n      },\n    ];\n\n    const templateSrv = getTemplateSrv();\n    templateSrv.getVariables().forEach(variable => {\n      const label = '${' + variable.name + '}';\n      let val = templateSrv.replace(label);\n      if (val === label) {\n        val = '';\n      }\n      sugs.push({\n        label,\n        kind: CodeEditorSuggestionItemKind.Text,\n        detail: `(Template Variable) ${val}`,\n      });\n    });\n\n    return sugs;\n  };\n\n  // For some reason in angular, when this component gets re-mounted, the width\n  // is not set properly.  This forces the layout shortly after mount so that it\n  // displays OK.  Note: this is not an issue when used directly in react\n  editorDidMountCallbackHack = (editor: any) => {\n    setTimeout(() => editor.layout(), 100);\n  };\n\n  render() {\n    const { query } = this.props;\n\n    const helpTooltip = (\n      <div>\n        Type: <i>ctrl+space</i> to show template variable suggestions <br />\n        Many queries can be copied from chronograph\n      </div>\n    );\n\n    return (\n      <>\n        <CodeEditor\n          height={'200px'}\n          language=\"sql\"\n          value={query.query || ''}\n          onBlur={this.onFluxQueryChange}\n          onSave={this.onFluxQueryChange}\n          showMiniMap={false}\n          showLineNumbers={true}\n          getSuggestions={this.getSuggestions}\n          onEditorDidMount={this.editorDidMountCallbackHack}\n        />\n        <div\n          className={cx(\n            'gf-form-inline',\n            css`\n              margin-top: 6px;\n            `\n          )}\n        >\n          <LinkButton\n            icon=\"external-link-alt\"\n            variant=\"secondary\"\n            target=\"blank\"\n            href=\"https://docs.influxdata.com/flux/latest/introduction/getting-started/\"\n          >\n            Flux language syntax\n          </LinkButton>\n          <Segment options={samples} value=\"Sample Query\" onChange={this.onSampleChange} />\n          <div className=\"gf-form gf-form--grow\">\n            <div className=\"gf-form-label gf-form-label--grow\"></div>\n          </div>\n          <InlineFormLabel width={5} tooltip={helpTooltip}>\n            Help\n          </InlineFormLabel>\n        </div>\n      </>\n    );\n  }\n}\n\ncoreModule.directive('fluxQueryEditor', [\n  'reactDirective',\n  (reactDirective: any) => {\n    return reactDirective(FluxQueryEditor, ['query', 'onChange', 'onRunQuery']);\n  },\n]);\n","import _ from 'lodash';\n\nimport {\n  dateMath,\n  DataSourceInstanceSettings,\n  ScopedVars,\n  DataQueryRequest,\n  DataQueryResponse,\n  dateTime,\n  LoadingState,\n  QueryResultMeta,\n  MetricFindValue,\n  AnnotationQueryRequest,\n  AnnotationEvent,\n} from '@grafana/data';\nimport { v4 as uuidv4 } from 'uuid';\nimport InfluxSeries from './influx_series';\nimport InfluxQueryModel from './influx_query_model';\nimport ResponseParser from './response_parser';\nimport { InfluxQueryBuilder } from './query_builder';\nimport { InfluxQuery, InfluxOptions, InfluxVersion } from './types';\nimport { getTemplateSrv, TemplateSrv } from 'app/features/templating/template_srv';\nimport { getBackendSrv, DataSourceWithBackend, frameToMetricFindValue } from '@grafana/runtime';\nimport { Observable, from } from 'rxjs';\nimport { FluxQueryEditor } from './components/FluxQueryEditor';\n\nexport default class InfluxDatasource extends DataSourceWithBackend<InfluxQuery, InfluxOptions> {\n  type: string;\n  urls: string[];\n  username: string;\n  password: string;\n  name: string;\n  database: any;\n  basicAuth: any;\n  withCredentials: any;\n  interval: any;\n  responseParser: any;\n  httpMode: string;\n  isFlux: boolean;\n\n  constructor(\n    instanceSettings: DataSourceInstanceSettings<InfluxOptions>,\n    private readonly templateSrv: TemplateSrv = getTemplateSrv()\n  ) {\n    super(instanceSettings);\n\n    this.type = 'influxdb';\n    this.urls = (instanceSettings.url ?? '').split(',').map(url => {\n      return url.trim();\n    });\n\n    this.username = instanceSettings.username ?? '';\n    this.password = instanceSettings.password ?? '';\n    this.name = instanceSettings.name;\n    this.database = instanceSettings.database;\n    this.basicAuth = instanceSettings.basicAuth;\n    this.withCredentials = instanceSettings.withCredentials;\n    const settingsData = instanceSettings.jsonData || ({} as InfluxOptions);\n    this.interval = settingsData.timeInterval;\n    this.httpMode = settingsData.httpMode || 'GET';\n    this.responseParser = new ResponseParser();\n    this.isFlux = settingsData.version === InfluxVersion.Flux;\n\n    if (this.isFlux) {\n      // When flux, use an annotation processor rather than the `annotationQuery` lifecycle\n      this.annotations = {\n        QueryEditor: FluxQueryEditor,\n      };\n    }\n  }\n\n  query(request: DataQueryRequest<InfluxQuery>): Observable<DataQueryResponse> {\n    if (this.isFlux) {\n      return super.query(request);\n    }\n\n    // Fallback to classic query support\n    return from(this.classicQuery(request));\n  }\n\n  getQueryDisplayText(query: InfluxQuery) {\n    if (this.isFlux) {\n      return query.query;\n    }\n    return new InfluxQueryModel(query).render(false);\n  }\n\n  /**\n   * Returns false if the query should be skipped\n   */\n  filterQuery(query: InfluxQuery): boolean {\n    if (this.isFlux) {\n      return !!query.query;\n    }\n    return true;\n  }\n\n  /**\n   * Only applied on flux queries\n   */\n  applyTemplateVariables(query: InfluxQuery, scopedVars: ScopedVars): Record<string, any> {\n    return {\n      ...query,\n      query: this.templateSrv.replace(query.query ?? '', scopedVars), // The raw query text\n    };\n  }\n\n  /**\n   * The unchanged pre 7.1 query implementation\n   */\n  async classicQuery(options: any): Promise<DataQueryResponse> {\n    let timeFilter = this.getTimeFilter(options);\n    const scopedVars = options.scopedVars;\n    const targets = _.cloneDeep(options.targets);\n    const queryTargets: any[] = [];\n\n    let i, y;\n\n    let allQueries = _.map(targets, target => {\n      if (target.hide) {\n        return '';\n      }\n\n      queryTargets.push(target);\n\n      // backward compatibility\n      scopedVars.interval = scopedVars.__interval;\n\n      return new InfluxQueryModel(target, this.templateSrv, scopedVars).render(true);\n    }).reduce((acc, current) => {\n      if (current !== '') {\n        acc += ';' + current;\n      }\n      return acc;\n    });\n\n    if (allQueries === '') {\n      return Promise.resolve({ data: [] });\n    }\n\n    // add global adhoc filters to timeFilter\n    const adhocFilters = this.templateSrv.getAdhocFilters(this.name);\n    if (adhocFilters.length > 0) {\n      const tmpQuery = new InfluxQueryModel({ refId: 'A' }, this.templateSrv, scopedVars);\n      timeFilter += ' AND ' + tmpQuery.renderAdhocFilters(adhocFilters);\n    }\n\n    // replace grafana variables\n    scopedVars.timeFilter = { value: timeFilter };\n\n    // replace templated variables\n    allQueries = this.templateSrv.replace(allQueries, scopedVars);\n\n    return this._seriesQuery(allQueries, options).then((data: any): any => {\n      if (!data || !data.results) {\n        return [];\n      }\n\n      const seriesList = [];\n      for (i = 0; i < data.results.length; i++) {\n        const result = data.results[i];\n        if (!result || !result.series) {\n          continue;\n        }\n\n        const target = queryTargets[i];\n        let alias = target.alias;\n        if (alias) {\n          alias = this.templateSrv.replace(target.alias, options.scopedVars);\n        }\n\n        const meta: QueryResultMeta = {\n          executedQueryString: data.executedQueryString,\n        };\n\n        const influxSeries = new InfluxSeries({\n          refId: target.refId,\n          series: data.results[i].series,\n          alias: alias,\n          meta,\n        });\n\n        switch (target.resultFormat) {\n          case 'logs':\n            meta.preferredVisualisationType = 'logs';\n          case 'table': {\n            seriesList.push(influxSeries.getTable());\n            break;\n          }\n          default: {\n            const timeSeries = influxSeries.getTimeSeries();\n            for (y = 0; y < timeSeries.length; y++) {\n              seriesList.push(timeSeries[y]);\n            }\n            break;\n          }\n        }\n      }\n\n      return { data: seriesList };\n    });\n  }\n\n  async annotationQuery(options: AnnotationQueryRequest<any>): Promise<AnnotationEvent[]> {\n    if (this.isFlux) {\n      return Promise.reject({\n        message: 'Flux requires the standard annotation query',\n      });\n    }\n\n    // InfluxQL puts a query string on the annotation\n    if (!options.annotation.query) {\n      return Promise.reject({\n        message: 'Query missing in annotation definition',\n      });\n    }\n\n    const timeFilter = this.getTimeFilter({ rangeRaw: options.rangeRaw, timezone: options.dashboard.timezone });\n    let query = options.annotation.query.replace('$timeFilter', timeFilter);\n    query = this.templateSrv.replace(query, undefined, 'regex');\n\n    return this._seriesQuery(query, options).then((data: any) => {\n      if (!data || !data.results || !data.results[0]) {\n        throw { message: 'No results in response from InfluxDB' };\n      }\n      return new InfluxSeries({\n        series: data.results[0].series,\n        annotation: options.annotation,\n      }).getAnnotations();\n    });\n  }\n\n  targetContainsTemplate(target: any) {\n    for (const group of target.groupBy) {\n      for (const param of group.params) {\n        if (this.templateSrv.variableExists(param)) {\n          return true;\n        }\n      }\n    }\n\n    for (const i in target.tags) {\n      if (this.templateSrv.variableExists(target.tags[i].value)) {\n        return true;\n      }\n    }\n\n    return false;\n  }\n\n  interpolateVariablesInQueries(queries: InfluxQuery[], scopedVars: ScopedVars): InfluxQuery[] {\n    if (!queries || queries.length === 0) {\n      return [];\n    }\n\n    let expandedQueries = queries;\n    if (queries && queries.length > 0) {\n      expandedQueries = queries.map(query => {\n        const expandedQuery = {\n          ...query,\n          datasource: this.name,\n          measurement: this.templateSrv.replace(query.measurement ?? '', scopedVars, 'regex'),\n          policy: this.templateSrv.replace(query.policy ?? '', scopedVars, 'regex'),\n        };\n\n        if (query.rawQuery) {\n          expandedQuery.query = this.templateSrv.replace(query.query ?? '', scopedVars, 'regex');\n        }\n\n        if (query.tags) {\n          const expandedTags = query.tags.map(tag => {\n            const expandedTag = {\n              ...tag,\n              value: this.templateSrv.replace(tag.value, undefined, 'regex'),\n            };\n            return expandedTag;\n          });\n          expandedQuery.tags = expandedTags;\n        }\n        return expandedQuery;\n      });\n    }\n    return expandedQueries;\n  }\n\n  async metricFindQuery(query: string, options?: any): Promise<MetricFindValue[]> {\n    if (this.isFlux) {\n      const target: InfluxQuery = {\n        refId: 'metricFindQuery',\n        query,\n      };\n      return super\n        .query({\n          ...options, // includes 'range'\n          targets: [target],\n        } as DataQueryRequest)\n        .toPromise()\n        .then(rsp => {\n          if (rsp.data?.length) {\n            return frameToMetricFindValue(rsp.data[0]);\n          }\n          return [];\n        });\n    }\n\n    const interpolated = this.templateSrv.replace(query, undefined, 'regex');\n\n    return this._seriesQuery(interpolated, options).then(resp => {\n      return this.responseParser.parse(query, resp);\n    });\n  }\n\n  getTagKeys(options: any = {}) {\n    const queryBuilder = new InfluxQueryBuilder({ measurement: options.measurement || '', tags: [] }, this.database);\n    const query = queryBuilder.buildExploreQuery('TAG_KEYS');\n    return this.metricFindQuery(query, options);\n  }\n\n  getTagValues(options: any = {}) {\n    const queryBuilder = new InfluxQueryBuilder({ measurement: options.measurement || '', tags: [] }, this.database);\n    const query = queryBuilder.buildExploreQuery('TAG_VALUES', options.key);\n    return this.metricFindQuery(query, options);\n  }\n\n  _seriesQuery(query: string, options?: any) {\n    if (!query) {\n      return Promise.resolve({ results: [] });\n    }\n\n    if (options && options.range) {\n      const timeFilter = this.getTimeFilter({ rangeRaw: options.range, timezone: options.timezone });\n      query = query.replace('$timeFilter', timeFilter);\n    }\n\n    return this._influxRequest(this.httpMode, '/query', { q: query, epoch: 'ms' }, options);\n  }\n\n  serializeParams(params: any) {\n    if (!params) {\n      return '';\n    }\n\n    return _.reduce(\n      params,\n      (memo, value, key) => {\n        if (value === null || value === undefined) {\n          return memo;\n        }\n        memo.push(encodeURIComponent(key) + '=' + encodeURIComponent(value));\n        return memo;\n      },\n      [] as string[]\n    ).join('&');\n  }\n\n  testDatasource() {\n    if (this.isFlux) {\n      // TODO: eventually use the real /health endpoint\n      const request: DataQueryRequest<InfluxQuery> = {\n        targets: [{ refId: 'test', query: 'buckets()' }],\n        requestId: `${this.id}-health-${uuidv4()}`,\n        dashboardId: 0,\n        panelId: 0,\n        interval: '1m',\n        intervalMs: 60000,\n        maxDataPoints: 423,\n        range: {\n          from: dateTime(1000),\n          to: dateTime(2000),\n        },\n      } as DataQueryRequest<InfluxQuery>;\n\n      return super\n        .query(request)\n        .toPromise()\n        .then((res: DataQueryResponse) => {\n          if (!res || !res.data || res.state !== LoadingState.Done) {\n            console.error('InfluxDB Error', res);\n            return { status: 'error', message: 'Error reading InfluxDB' };\n          }\n          const first = res.data[0];\n          if (first && first.length) {\n            return { status: 'success', message: `${first.length} buckets found` };\n          }\n          console.error('InfluxDB Error', res);\n          return { status: 'error', message: 'Error reading buckets' };\n        })\n        .catch((err: any) => {\n          console.error('InfluxDB Error', err);\n          return { status: 'error', message: err.message };\n        });\n    }\n\n    const queryBuilder = new InfluxQueryBuilder({ measurement: '', tags: [] }, this.database);\n    const query = queryBuilder.buildExploreQuery('RETENTION POLICIES');\n\n    return this._seriesQuery(query)\n      .then((res: any) => {\n        const error = _.get(res, 'results[0].error');\n        if (error) {\n          return { status: 'error', message: error };\n        }\n        return { status: 'success', message: 'Data source is working' };\n      })\n      .catch((err: any) => {\n        return { status: 'error', message: err.message };\n      });\n  }\n\n  _influxRequest(method: string, url: string, data: any, options?: any) {\n    const currentUrl = this.urls.shift()!;\n    this.urls.push(currentUrl);\n\n    const params: any = {};\n\n    if (this.username) {\n      params.u = this.username;\n      params.p = this.password;\n    }\n\n    if (options && options.database) {\n      params.db = options.database;\n    } else if (this.database) {\n      params.db = this.database;\n    }\n\n    const { q } = data;\n\n    if (method === 'POST' && _.has(data, 'q')) {\n      // verb is POST and 'q' param is defined\n      _.extend(params, _.omit(data, ['q']));\n      data = this.serializeParams(_.pick(data, ['q']));\n    } else if (method === 'GET' || method === 'POST') {\n      // verb is GET, or POST without 'q' param\n      _.extend(params, data);\n      data = null;\n    }\n\n    const req: any = {\n      method: method,\n      url: currentUrl + url,\n      params: params,\n      data: data,\n      precision: 'ms',\n      inspect: { type: 'influxdb' },\n      paramSerializer: this.serializeParams,\n    };\n\n    req.headers = req.headers || {};\n    if (this.basicAuth || this.withCredentials) {\n      req.withCredentials = true;\n    }\n    if (this.basicAuth) {\n      req.headers.Authorization = this.basicAuth;\n    }\n\n    if (method === 'POST') {\n      req.headers['Content-type'] = 'application/x-www-form-urlencoded';\n    }\n\n    return getBackendSrv()\n      .datasourceRequest(req)\n      .then(\n        (result: any) => {\n          const { data } = result;\n          if (data) {\n            data.executedQueryString = q;\n            if (data.results) {\n              const errors = result.data.results.filter((elem: any) => elem.error);\n              if (errors.length > 0) {\n                throw {\n                  message: 'InfluxDB Error: ' + errors[0].error,\n                  data,\n                };\n              }\n            }\n          }\n          return data;\n        },\n        (err: any) => {\n          if ((Number.isInteger(err.status) && err.status !== 0) || err.status >= 300) {\n            if (err.data && err.data.error) {\n              throw {\n                message: 'InfluxDB Error: ' + err.data.error,\n                data: err.data,\n                config: err.config,\n              };\n            } else {\n              throw {\n                message: 'Network Error: ' + err.statusText + '(' + err.status + ')',\n                data: err.data,\n                config: err.config,\n              };\n            }\n          } else {\n            throw err;\n          }\n        }\n      );\n  }\n\n  getTimeFilter(options: any) {\n    const from = this.getInfluxTime(options.rangeRaw.from, false, options.timezone);\n    const until = this.getInfluxTime(options.rangeRaw.to, true, options.timezone);\n    const fromIsAbsolute = from[from.length - 1] === 'ms';\n\n    if (until === 'now()' && !fromIsAbsolute) {\n      return 'time >= ' + from;\n    }\n\n    return 'time >= ' + from + ' and time <= ' + until;\n  }\n\n  getInfluxTime(date: any, roundUp: any, timezone: any) {\n    if (_.isString(date)) {\n      if (date === 'now') {\n        return 'now()';\n      }\n\n      const parts = /^now-(\\d+)([dhms])$/.exec(date);\n      if (parts) {\n        const amount = parseInt(parts[1], 10);\n        const unit = parts[2];\n        return 'now() - ' + amount + unit;\n      }\n      date = dateMath.parse(date, roundUp, timezone);\n    }\n\n    return date.valueOf() + 'ms';\n  }\n}\n","import angular, { auto } from 'angular';\nimport _ from 'lodash';\nimport { InfluxQueryBuilder } from './query_builder';\nimport InfluxQueryModel from './influx_query_model';\nimport queryPart from './query_part';\nimport { QueryCtrl } from 'app/plugins/sdk';\nimport { TemplateSrv } from '@grafana/runtime';\nimport { InfluxQuery } from './types';\nimport InfluxDatasource from './datasource';\n\nexport class InfluxQueryCtrl extends QueryCtrl {\n  static templateUrl = 'partials/query.editor.html';\n\n  datasource: InfluxDatasource;\n  queryModel: InfluxQueryModel;\n  queryBuilder: any;\n  groupBySegment: any;\n  resultFormats: any[];\n  orderByTime: any[];\n  policySegment: any;\n  tagSegments: any[];\n  selectMenu: any;\n  measurementSegment: any;\n  removeTagFilterSegment: any;\n\n  /** @ngInject */\n  constructor(\n    $scope: any,\n    $injector: auto.IInjectorService,\n    private templateSrv: TemplateSrv,\n    private uiSegmentSrv: any\n  ) {\n    super($scope, $injector);\n    this.target = this.target;\n    this.queryModel = new InfluxQueryModel(this.target, templateSrv, this.panel.scopedVars);\n    this.queryBuilder = new InfluxQueryBuilder(this.target, this.datasource.database);\n    this.groupBySegment = this.uiSegmentSrv.newPlusButton();\n    this.resultFormats = [\n      { text: 'Time series', value: 'time_series' },\n      { text: 'Table', value: 'table' },\n      { text: 'Logs', value: 'logs' },\n    ];\n\n    this.policySegment = uiSegmentSrv.newSegment(this.target.policy);\n\n    if (!this.target.measurement) {\n      this.measurementSegment = uiSegmentSrv.newSelectMeasurement();\n    } else {\n      this.measurementSegment = uiSegmentSrv.newSegment(this.target.measurement);\n    }\n\n    this.tagSegments = [];\n    for (const tag of this.target.tags) {\n      if (!tag.operator) {\n        if (/^\\/.*\\/$/.test(tag.value)) {\n          tag.operator = '=~';\n        } else {\n          tag.operator = '=';\n        }\n      }\n\n      if (tag.condition) {\n        this.tagSegments.push(uiSegmentSrv.newCondition(tag.condition));\n      }\n\n      this.tagSegments.push(uiSegmentSrv.newKey(tag.key));\n      this.tagSegments.push(uiSegmentSrv.newOperator(tag.operator));\n      this.tagSegments.push(uiSegmentSrv.newKeyValue(tag.value));\n    }\n\n    this.fixTagSegments();\n    this.buildSelectMenu();\n    this.removeTagFilterSegment = uiSegmentSrv.newSegment({\n      fake: true,\n      value: '-- remove tag filter --',\n    });\n  }\n\n  /**\n   * Only called for flux\n   */\n  onChange = (target: InfluxQuery) => {\n    this.target.query = target.query;\n  };\n\n  onRunQuery = () => {\n    this.panelCtrl.refresh();\n  };\n\n  removeOrderByTime() {\n    this.target.orderByTime = 'ASC';\n  }\n\n  buildSelectMenu() {\n    const categories = queryPart.getCategories();\n    this.selectMenu = _.reduce(\n      categories,\n      (memo, cat, key) => {\n        const menu = {\n          text: key,\n          submenu: cat.map((item: any) => {\n            return { text: item.type, value: item.type };\n          }),\n        };\n        memo.push(menu);\n        return memo;\n      },\n      [] as any\n    );\n  }\n\n  getGroupByOptions() {\n    const query = this.queryBuilder.buildExploreQuery('TAG_KEYS');\n\n    return this.datasource\n      .metricFindQuery(query)\n      .then((tags: any) => {\n        const options = [];\n        if (!this.queryModel.hasFill()) {\n          options.push(this.uiSegmentSrv.newSegment({ value: 'fill(null)' }));\n        }\n        if (!this.target.limit) {\n          options.push(this.uiSegmentSrv.newSegment({ value: 'LIMIT' }));\n        }\n        if (!this.target.slimit) {\n          options.push(this.uiSegmentSrv.newSegment({ value: 'SLIMIT' }));\n        }\n        if (!this.target.tz) {\n          options.push(this.uiSegmentSrv.newSegment({ value: 'tz' }));\n        }\n        if (this.target.orderByTime === 'ASC') {\n          options.push(this.uiSegmentSrv.newSegment({ value: 'ORDER BY time DESC' }));\n        }\n        if (!this.queryModel.hasGroupByTime()) {\n          options.push(this.uiSegmentSrv.newSegment({ value: 'time($interval)' }));\n        }\n        for (const tag of tags) {\n          options.push(this.uiSegmentSrv.newSegment({ value: 'tag(' + tag.text + ')' }));\n        }\n        return options;\n      })\n      .catch(this.handleQueryError.bind(this));\n  }\n\n  groupByAction() {\n    switch (this.groupBySegment.value) {\n      case 'LIMIT': {\n        this.target.limit = 10;\n        break;\n      }\n      case 'SLIMIT': {\n        this.target.slimit = 10;\n        break;\n      }\n      case 'tz': {\n        this.target.tz = 'UTC';\n        break;\n      }\n      case 'ORDER BY time DESC': {\n        this.target.orderByTime = 'DESC';\n        break;\n      }\n      default: {\n        this.queryModel.addGroupBy(this.groupBySegment.value);\n      }\n    }\n\n    const plusButton = this.uiSegmentSrv.newPlusButton();\n    this.groupBySegment.value = plusButton.value;\n    this.groupBySegment.html = plusButton.html;\n    this.groupBySegment.fake = true;\n    this.panelCtrl.refresh();\n  }\n\n  addSelectPart(selectParts: any, cat: any, subitem: { value: any }) {\n    this.queryModel.addSelectPart(selectParts, subitem.value);\n    this.panelCtrl.refresh();\n  }\n\n  handleSelectPartEvent(selectParts: any, part: any, evt: { name: any }) {\n    switch (evt.name) {\n      case 'get-param-options': {\n        const fieldsQuery = this.queryBuilder.buildExploreQuery('FIELDS');\n        return this.datasource\n          .metricFindQuery(fieldsQuery)\n          .then(this.transformToSegments(true))\n          .catch(this.handleQueryError.bind(this));\n      }\n      case 'part-param-changed': {\n        this.panelCtrl.refresh();\n        break;\n      }\n      case 'action': {\n        this.queryModel.removeSelectPart(selectParts, part);\n        this.panelCtrl.refresh();\n        break;\n      }\n      case 'get-part-actions': {\n        return Promise.resolve([{ text: 'Remove', value: 'remove-part' }]);\n      }\n    }\n    return Promise.resolve();\n  }\n\n  handleGroupByPartEvent(part: any, index: any, evt: { name: any }) {\n    switch (evt.name) {\n      case 'get-param-options': {\n        const tagsQuery = this.queryBuilder.buildExploreQuery('TAG_KEYS');\n        return this.datasource\n          .metricFindQuery(tagsQuery)\n          .then(this.transformToSegments(true))\n          .catch(this.handleQueryError.bind(this));\n      }\n      case 'part-param-changed': {\n        this.panelCtrl.refresh();\n        break;\n      }\n      case 'action': {\n        this.queryModel.removeGroupByPart(part, index);\n        this.panelCtrl.refresh();\n        break;\n      }\n      case 'get-part-actions': {\n        return Promise.resolve([{ text: 'Remove', value: 'remove-part' }]);\n      }\n    }\n    return Promise.resolve();\n  }\n\n  fixTagSegments() {\n    const count = this.tagSegments.length;\n    const lastSegment = this.tagSegments[Math.max(count - 1, 0)];\n\n    if (!lastSegment || lastSegment.type !== 'plus-button') {\n      this.tagSegments.push(this.uiSegmentSrv.newPlusButton());\n    }\n  }\n\n  measurementChanged() {\n    this.target.measurement = this.measurementSegment.value;\n    this.panelCtrl.refresh();\n  }\n\n  getPolicySegments() {\n    const policiesQuery = this.queryBuilder.buildExploreQuery('RETENTION POLICIES');\n    return this.datasource\n      .metricFindQuery(policiesQuery)\n      .then(this.transformToSegments(false))\n      .catch(this.handleQueryError.bind(this));\n  }\n\n  policyChanged() {\n    this.target.policy = this.policySegment.value;\n    this.panelCtrl.refresh();\n  }\n\n  // Only valid for InfluxQL queries\n  toggleEditorMode() {\n    if (this.datasource.isFlux) {\n      return; // nothing\n    }\n\n    try {\n      this.target.query = this.queryModel.render(false);\n    } catch (err) {\n      console.error('query render error');\n    }\n    this.target.rawQuery = !this.target.rawQuery;\n  }\n\n  getMeasurements(measurementFilter: any) {\n    const query = this.queryBuilder.buildExploreQuery('MEASUREMENTS', undefined, measurementFilter);\n    return this.datasource\n      .metricFindQuery(query)\n      .then(this.transformToSegments(true))\n      .catch(this.handleQueryError.bind(this));\n  }\n\n  handleQueryError(err: any): any[] {\n    this.error = err.message || 'Failed to issue metric query';\n    return [];\n  }\n\n  transformToSegments(addTemplateVars: any) {\n    return (results: any) => {\n      const segments = _.map(results, segment => {\n        return this.uiSegmentSrv.newSegment({\n          value: segment.text,\n          expandable: segment.expandable,\n        });\n      });\n\n      if (addTemplateVars) {\n        for (const variable of this.templateSrv.getVariables()) {\n          segments.unshift(\n            this.uiSegmentSrv.newSegment({\n              type: 'value',\n              value: '/^$' + variable.name + '$/',\n              expandable: true,\n            })\n          );\n        }\n      }\n\n      return segments;\n    };\n  }\n\n  getTagsOrValues(segment: { type: string }, index: number) {\n    if (segment.type === 'condition') {\n      return Promise.resolve([this.uiSegmentSrv.newSegment('AND'), this.uiSegmentSrv.newSegment('OR')]);\n    }\n\n    if (segment.type === 'operator') {\n      const nextValue = this.tagSegments[index + 1].value;\n      if (/^\\/.*\\/$/.test(nextValue)) {\n        return Promise.resolve(this.uiSegmentSrv.newOperators(['=~', '!~']));\n      } else {\n        return Promise.resolve(this.uiSegmentSrv.newOperators(['=', '!=', '<>', '<', '>']));\n      }\n    }\n\n    let query, addTemplateVars;\n    if (segment.type === 'key' || segment.type === 'plus-button') {\n      query = this.queryBuilder.buildExploreQuery('TAG_KEYS');\n      addTemplateVars = false;\n    } else if (segment.type === 'value') {\n      query = this.queryBuilder.buildExploreQuery('TAG_VALUES', this.tagSegments[index - 2].value);\n      addTemplateVars = true;\n    }\n\n    return this.datasource\n      .metricFindQuery(query)\n      .then(this.transformToSegments(addTemplateVars))\n      .then((results: any) => {\n        if (segment.type === 'key') {\n          results.splice(0, 0, angular.copy(this.removeTagFilterSegment));\n        }\n        return results;\n      })\n      .catch(this.handleQueryError.bind(this));\n  }\n\n  getFieldSegments() {\n    const fieldsQuery = this.queryBuilder.buildExploreQuery('FIELDS');\n    return this.datasource\n      .metricFindQuery(fieldsQuery)\n      .then(this.transformToSegments(false))\n      .catch(this.handleQueryError);\n  }\n\n  tagSegmentUpdated(segment: { value: any; type: string; cssClass: string }, index: number) {\n    this.tagSegments[index] = segment;\n\n    // handle remove tag condition\n    if (segment.value === this.removeTagFilterSegment.value) {\n      this.tagSegments.splice(index, 3);\n      if (this.tagSegments.length === 0) {\n        this.tagSegments.push(this.uiSegmentSrv.newPlusButton());\n      } else if (this.tagSegments.length > 2) {\n        this.tagSegments.splice(Math.max(index - 1, 0), 1);\n        if (this.tagSegments[this.tagSegments.length - 1].type !== 'plus-button') {\n          this.tagSegments.push(this.uiSegmentSrv.newPlusButton());\n        }\n      }\n    } else {\n      if (segment.type === 'plus-button') {\n        if (index > 2) {\n          this.tagSegments.splice(index, 0, this.uiSegmentSrv.newCondition('AND'));\n        }\n        this.tagSegments.push(this.uiSegmentSrv.newOperator('='));\n        this.tagSegments.push(this.uiSegmentSrv.newFake('select tag value', 'value', 'query-segment-value'));\n        segment.type = 'key';\n        segment.cssClass = 'query-segment-key';\n      }\n\n      if (index + 1 === this.tagSegments.length) {\n        this.tagSegments.push(this.uiSegmentSrv.newPlusButton());\n      }\n    }\n\n    this.rebuildTargetTagConditions();\n  }\n\n  rebuildTargetTagConditions() {\n    const tags: any[] = [];\n    let tagIndex = 0;\n    let tagOperator: string | null = '';\n\n    _.each(this.tagSegments, (segment2, index) => {\n      if (segment2.type === 'key') {\n        if (tags.length === 0) {\n          tags.push({});\n        }\n        tags[tagIndex].key = segment2.value;\n      } else if (segment2.type === 'value') {\n        tagOperator = this.getTagValueOperator(segment2.value, tags[tagIndex].operator);\n        if (tagOperator) {\n          this.tagSegments[index - 1] = this.uiSegmentSrv.newOperator(tagOperator);\n          tags[tagIndex].operator = tagOperator;\n        }\n        tags[tagIndex].value = segment2.value;\n      } else if (segment2.type === 'condition') {\n        tags.push({ condition: segment2.value });\n        tagIndex += 1;\n      } else if (segment2.type === 'operator') {\n        tags[tagIndex].operator = segment2.value;\n      }\n    });\n\n    this.target.tags = tags;\n    this.panelCtrl.refresh();\n  }\n\n  getTagValueOperator(tagValue: string, tagOperator: string): string | null {\n    if (tagOperator !== '=~' && tagOperator !== '!~' && /^\\/.*\\/$/.test(tagValue)) {\n      return '=~';\n    } else if ((tagOperator === '=~' || tagOperator === '!~') && /^(?!\\/.*\\/$)/.test(tagValue)) {\n      return '=';\n    }\n    return null;\n  }\n}\n","import React from 'react';\n\nconst CHEAT_SHEET_ITEMS = [\n  {\n    title: 'Getting started',\n    label:\n      'Start by selecting a measurement and field from the dropdown above. You can then use the tag selector to further narrow your search.',\n  },\n];\n\nexport default (props: any) => (\n  <div>\n    <h2>InfluxDB Cheat Sheet</h2>\n    {CHEAT_SHEET_ITEMS.map(item => (\n      <div className=\"cheat-sheet-item\" key={item.title}>\n        <div className=\"cheat-sheet-item__title\">{item.title}</div>\n        <div className=\"cheat-sheet-item__label\">{item.label}</div>\n      </div>\n    ))}\n  </div>\n);\n","import React, { PureComponent } from 'react';\nimport { ExploreStartPageProps } from '@grafana/data';\nimport InfluxCheatSheet from './InfluxCheatSheet';\n\nexport default class InfluxStartPage extends PureComponent<ExploreStartPageProps> {\n  render() {\n    return <InfluxCheatSheet onClickExample={this.props.onClickExample} />;\n  }\n}\n","import React, { PureComponent } from 'react';\nimport {\n  DataSourcePluginOptionsEditorProps,\n  SelectableValue,\n  onUpdateDatasourceOption,\n  updateDatasourcePluginResetOption,\n  onUpdateDatasourceJsonDataOption,\n  onUpdateDatasourceJsonDataOptionSelect,\n  onUpdateDatasourceSecureJsonDataOption,\n} from '@grafana/data';\nimport { DataSourceHttpSettings, InlineFormLabel, LegacyForms } from '@grafana/ui';\nconst { Select, Input, SecretFormField } = LegacyForms;\nimport { InfluxOptions, InfluxSecureJsonData, InfluxVersion } from '../types';\n\nconst httpModes = [\n  { label: 'GET', value: 'GET' },\n  { label: 'POST', value: 'POST' },\n] as SelectableValue[];\n\nconst versions = [\n  {\n    label: 'InfluxQL',\n    value: InfluxVersion.InfluxQL,\n    description: 'The InfluxDB SQL-like query language.  Supported in InfluxDB 1.x',\n  },\n  {\n    label: 'Flux',\n    value: InfluxVersion.Flux,\n    description: 'Advanced data scripting and query language.  Supported in InfluxDB 2.x and 1.8+ (beta)',\n  },\n] as Array<SelectableValue<InfluxVersion>>;\n\nexport type Props = DataSourcePluginOptionsEditorProps<InfluxOptions>;\n\nexport class ConfigEditor extends PureComponent<Props> {\n  // 1x\n  onResetPassword = () => {\n    updateDatasourcePluginResetOption(this.props, 'password');\n  };\n\n  // 2x\n  onResetToken = () => {\n    updateDatasourcePluginResetOption(this.props, 'token');\n  };\n\n  onVersionChanged = (selected: SelectableValue<InfluxVersion>) => {\n    const { options, onOptionsChange } = this.props;\n\n    const copy: any = {\n      ...options,\n      jsonData: {\n        ...options.jsonData,\n        version: selected.value,\n      },\n    };\n    if (selected.value === InfluxVersion.Flux) {\n      copy.access = 'proxy';\n      copy.basicAuth = true;\n      copy.jsonData.httpMode = 'POST';\n\n      // Remove old 1x configs\n      delete copy.user;\n      delete copy.database;\n    }\n    onOptionsChange(copy);\n  };\n\n  onUpdateInflux2xURL = (e: React.SyntheticEvent<HTMLInputElement>) => {\n    const { options, onOptionsChange } = this.props;\n    onOptionsChange({\n      ...options,\n      url: e.currentTarget.value,\n      access: 'proxy',\n      basicAuth: true,\n    });\n  };\n\n  renderInflux2x() {\n    const { options } = this.props;\n    const { secureJsonFields } = options;\n    const secureJsonData = (options.secureJsonData || {}) as InfluxSecureJsonData;\n\n    return (\n      <div>\n        <div className=\"gf-form-group\">\n          <div className=\"width-30 grafana-info-box\">\n            <h5>Support for flux in Grafana is currently in beta</h5>\n            <p>\n              Please report any issues to: <br />\n              <a href=\"https://github.com/grafana/grafana/issues/new/choose\">\n                https://github.com/grafana/grafana/issues\n              </a>\n            </p>\n          </div>\n        </div>\n        <br />\n\n        <h3 className=\"page-heading\">Connection</h3>\n        <div className=\"gf-form-inline\">\n          <div className=\"gf-form\">\n            <InlineFormLabel\n              className=\"width-10\"\n              tooltip=\"This URL needs to be accessible from the grafana backend/server.\"\n            >\n              URL\n            </InlineFormLabel>\n            <div className=\"width-20\">\n              <Input\n                className=\"width-20\"\n                value={options.url || ''}\n                placeholder=\"http://localhost:9999\"\n                onChange={this.onUpdateInflux2xURL}\n              />\n            </div>\n          </div>\n        </div>\n        <div className=\"gf-form-inline\">\n          <div className=\"gf-form\">\n            <InlineFormLabel className=\"width-10\">Organization</InlineFormLabel>\n            <div className=\"width-10\">\n              <Input\n                className=\"width-20\"\n                value={options.jsonData.organization || ''}\n                onChange={onUpdateDatasourceJsonDataOption(this.props, 'organization')}\n              />\n            </div>\n          </div>\n        </div>\n        <div className=\"gf-form-inline\">\n          <div className=\"gf-form\">\n            <SecretFormField\n              isConfigured={(secureJsonFields && secureJsonFields.token) as boolean}\n              value={secureJsonData.token || ''}\n              label=\"Token\"\n              labelWidth={10}\n              inputWidth={20}\n              onReset={this.onResetToken}\n              onChange={onUpdateDatasourceSecureJsonDataOption(this.props, 'token')}\n            />\n          </div>\n        </div>\n        <div className=\"gf-form-inline\">\n          <div className=\"gf-form\">\n            <InlineFormLabel className=\"width-10\">Default Bucket</InlineFormLabel>\n            <div className=\"width-10\">\n              <Input\n                className=\"width-20\"\n                placeholder=\"default bucket\"\n                value={options.jsonData.defaultBucket || ''}\n                onChange={onUpdateDatasourceJsonDataOption(this.props, 'defaultBucket')}\n              />\n            </div>\n          </div>\n        </div>\n\n        <div className=\"gf-form-inline\">\n          <div className=\"gf-form\">\n            <InlineFormLabel\n              className=\"width-10\"\n              tooltip=\"A lower limit for the auto group by time interval. Recommended to be set to write frequency,\n\t\t\t\tfor example 1m if your data is written every minute.\"\n            >\n              Min time interval\n            </InlineFormLabel>\n            <div className=\"width-10\">\n              <Input\n                className=\"width-10\"\n                placeholder=\"10s\"\n                value={options.jsonData.timeInterval || ''}\n                onChange={onUpdateDatasourceJsonDataOption(this.props, 'timeInterval')}\n              />\n            </div>\n          </div>\n        </div>\n      </div>\n    );\n  }\n\n  renderInflux1x() {\n    const { options, onOptionsChange } = this.props;\n    const { secureJsonFields } = options;\n    const secureJsonData = (options.secureJsonData || {}) as InfluxSecureJsonData;\n\n    return (\n      <div>\n        <DataSourceHttpSettings\n          showAccessOptions={true}\n          dataSourceConfig={options}\n          defaultUrl=\"http://localhost:8086\"\n          onChange={onOptionsChange}\n        />\n\n        <h3 className=\"page-heading\">InfluxDB Details</h3>\n        <div className=\"gf-form-group\">\n          <div className=\"gf-form-inline\">\n            <div className=\"gf-form\">\n              <InlineFormLabel className=\"width-10\">Database</InlineFormLabel>\n              <div className=\"width-20\">\n                <Input\n                  className=\"width-20\"\n                  value={options.database || ''}\n                  onChange={onUpdateDatasourceOption(this.props, 'database')}\n                />\n              </div>\n            </div>\n          </div>\n          <div className=\"gf-form-inline\">\n            <div className=\"gf-form\">\n              <InlineFormLabel className=\"width-10\">User</InlineFormLabel>\n              <div className=\"width-10\">\n                <Input\n                  className=\"width-20\"\n                  value={options.user || ''}\n                  onChange={onUpdateDatasourceOption(this.props, 'user')}\n                />\n              </div>\n            </div>\n          </div>\n          <div className=\"gf-form-inline\">\n            <div className=\"gf-form\">\n              <SecretFormField\n                isConfigured={(secureJsonFields && secureJsonFields.password) as boolean}\n                value={secureJsonData.password || ''}\n                label=\"Password\"\n                labelWidth={10}\n                inputWidth={20}\n                onReset={this.onResetPassword}\n                onChange={onUpdateDatasourceSecureJsonDataOption(this.props, 'password')}\n              />\n            </div>\n          </div>\n          <div className=\"gf-form-inline\">\n            <div className=\"gf-form\">\n              <InlineFormLabel\n                className=\"width-10\"\n                tooltip=\"You can use either GET or POST HTTP method to query your InfluxDB database. The POST\n          method allows you to perform heavy requests (with a lots of WHERE clause) while the GET method\n          will restrict you and return an error if the query is too large.\"\n              >\n                HTTP Method\n              </InlineFormLabel>\n              <Select\n                className=\"width-10\"\n                value={httpModes.find(httpMode => httpMode.value === options.jsonData.httpMode)}\n                options={httpModes}\n                defaultValue={options.jsonData.httpMode}\n                onChange={onUpdateDatasourceJsonDataOptionSelect(this.props, 'httpMode')}\n              />\n            </div>\n          </div>\n        </div>\n\n        <div className=\"gf-form-group\">\n          <div className=\"grafana-info-box\">\n            <h5>Database Access</h5>\n            <p>\n              Setting the database for this datasource does not deny access to other databases. The InfluxDB query\n              syntax allows switching the database in the query. For example:\n              <code>SHOW MEASUREMENTS ON _internal</code> or <code>SELECT * FROM \"_internal\"..\"database\" LIMIT 10</code>\n              <br />\n              <br />\n              To support data isolation and security, make sure appropriate permissions are configured in InfluxDB.\n            </p>\n          </div>\n        </div>\n        <div className=\"gf-form-group\">\n          <div className=\"gf-form-inline\">\n            <div className=\"gf-form\">\n              <InlineFormLabel\n                className=\"width-10\"\n                tooltip=\"A lower limit for the auto group by time interval. Recommended to be set to write frequency,\n\t\t\t\tfor example 1m if your data is written every minute.\"\n              >\n                Min time interval\n              </InlineFormLabel>\n              <div className=\"width-10\">\n                <Input\n                  className=\"width-10\"\n                  placeholder=\"10s\"\n                  value={options.jsonData.timeInterval || ''}\n                  onChange={onUpdateDatasourceJsonDataOption(this.props, 'timeInterval')}\n                />\n              </div>\n            </div>\n          </div>\n        </div>\n      </div>\n    );\n  }\n\n  render() {\n    const { options } = this.props;\n\n    return (\n      <>\n        <h3 className=\"page-heading\">Query Language</h3>\n        <div className=\"gf-form-group\">\n          <div className=\"gf-form-inline\">\n            <div className=\"gf-form\">\n              <Select\n                className=\"width-30\"\n                value={options.jsonData.version === InfluxVersion.Flux ? versions[1] : versions[0]}\n                options={versions}\n                defaultValue={versions[0]}\n                onChange={this.onVersionChanged}\n              />\n            </div>\n          </div>\n        </div>\n\n        {options.jsonData.version === InfluxVersion.Flux ? this.renderInflux2x() : this.renderInflux1x()}\n      </>\n    );\n  }\n}\n\nexport default ConfigEditor;\n","import React, { PureComponent } from 'react';\nimport InfluxDatasource from '../datasource';\nimport { InlineFormLabel, TextArea } from '@grafana/ui';\nimport { FluxQueryEditor } from './FluxQueryEditor';\n\ninterface Props {\n  query: string; // before flux, it was always a string\n  onChange: (query?: string) => void;\n  datasource: InfluxDatasource;\n}\n\nexport default class VariableQueryEditor extends PureComponent<Props> {\n  onRefresh = () => {\n    // noop\n  };\n\n  render() {\n    let { query, datasource, onChange } = this.props;\n    if (datasource.isFlux) {\n      return (\n        <FluxQueryEditor\n          datasource={datasource}\n          query={{\n            refId: 'A',\n            query,\n          }}\n          onRunQuery={this.onRefresh}\n          onChange={v => onChange(v.query)}\n        />\n      );\n    }\n\n    return (\n      <div className=\"gf-form-inline\">\n        <InlineFormLabel width={10}>Query</InlineFormLabel>\n        <div className=\"gf-form-inline gf-form--grow\">\n          <TextArea\n            value={query || ''}\n            placeholder=\"metric name or tags query\"\n            rows={1}\n            className=\"gf-form-input\"\n            onChange={e => onChange(e.currentTarget.value)}\n          />\n        </div>\n      </div>\n    );\n  }\n}\n","import InfluxDatasource from './datasource';\nimport { InfluxQueryCtrl } from './query_ctrl';\nimport InfluxStartPage from './components/InfluxStartPage';\nimport { DataSourcePlugin } from '@grafana/data';\nimport ConfigEditor from './components/ConfigEditor';\nimport VariableQueryEditor from './components/VariableQueryEditor';\n\n// This adds a directive that is used in the query editor\nimport './components/FluxQueryEditor';\n\nclass InfluxAnnotationsQueryCtrl {\n  static templateUrl = 'partials/annotations.editor.html';\n}\n\nexport const plugin = new DataSourcePlugin(InfluxDatasource)\n  .setConfigEditor(ConfigEditor)\n  .setQueryCtrl(InfluxQueryCtrl)\n  .setAnnotationQueryCtrl(InfluxAnnotationsQueryCtrl)\n  .setVariableQueryEditor(VariableQueryEditor)\n  .setExploreStartPage(InfluxStartPage);\n"],"sourceRoot":""}