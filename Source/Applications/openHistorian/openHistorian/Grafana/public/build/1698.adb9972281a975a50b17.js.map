{"version":3,"file":"1698.adb9972281a975a50b17.js","mappings":"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","sources":["webpack://grafana/./public/app/plugins/panel/nodeGraph/Node.tsx","webpack://grafana/./public/app/plugins/panel/nodeGraph/utils.ts"],"sourcesContent":["import { css } from '@emotion/css';\nimport cx from 'classnames';\nimport { MouseEvent, memo } from 'react';\nimport tinycolor from 'tinycolor2';\n\nimport { Field, getFieldColorModeForField, GrafanaTheme2 } from '@grafana/data';\nimport { Icon, useTheme2 } from '@grafana/ui';\n\nimport { HoverState } from './NodeGraph';\nimport { NodeDatum } from './types';\nimport { statToString } from './utils';\n\nexport const nodeR = 40;\nexport const highlightedNodeColor = '#a00';\n\nconst getStyles = (theme: GrafanaTheme2, hovering: HoverState) => ({\n  mainGroup: css`\n    cursor: pointer;\n    font-size: 10px;\n    transition: opacity 300ms;\n    opacity: ${hovering === 'inactive' ? 0.5 : 1};\n  `,\n\n  mainCircle: css`\n    fill: ${theme.components.panel.background};\n  `,\n\n  filledCircle: css`\n    fill: ${highlightedNodeColor};\n  `,\n\n  hoverCircle: css`\n    opacity: 0.5;\n    fill: transparent;\n    stroke: ${theme.colors.primary.text};\n  `,\n\n  text: css`\n    fill: ${theme.colors.text.primary};\n    pointer-events: none;\n  `,\n\n  titleText: css`\n    text-align: center;\n    text-overflow: ellipsis;\n    overflow: hidden;\n    white-space: nowrap;\n    background-color: ${tinycolor(theme.colors.background.primary).setAlpha(0.6).toHex8String()};\n    width: 140px;\n  `,\n\n  statsText: css`\n    text-align: center;\n    text-overflow: ellipsis;\n    overflow: hidden;\n    white-space: nowrap;\n    width: 70px;\n  `,\n\n  textHovering: css`\n    width: 200px;\n    & span {\n      background-color: ${tinycolor(theme.colors.background.primary).setAlpha(0.8).toHex8String()};\n    }\n  `,\n\n  clickTarget: css`\n    fill: none;\n    stroke: none;\n    pointer-events: fill;\n  `,\n});\n\nexport const computeNodeCircumferenceStrokeWidth = (nodeRadius: number) => Math.ceil(nodeRadius * 0.075);\n\nexport const Node = memo(function Node(props: {\n  node: NodeDatum;\n  hovering: HoverState;\n  onMouseEnter: (id: string) => void;\n  onMouseLeave: (id: string) => void;\n  onClick: (event: MouseEvent<SVGElement>, node: NodeDatum) => void;\n}) {\n  const { node, onMouseEnter, onMouseLeave, onClick, hovering } = props;\n  const theme = useTheme2();\n  const styles = getStyles(theme, hovering);\n  const isHovered = hovering === 'active';\n  const nodeRadius = node.nodeRadius?.values[node.dataFrameRowIndex] || nodeR;\n  const strokeWidth = computeNodeCircumferenceStrokeWidth(nodeRadius);\n\n  if (!(node.x !== undefined && node.y !== undefined)) {\n    return null;\n  }\n\n  return (\n    <g data-node-id={node.id} className={styles.mainGroup} aria-label={`Node: ${node.title}`}>\n      <circle\n        data-testid={`node-circle-${node.id}`}\n        className={node.highlighted ? styles.filledCircle : styles.mainCircle}\n        r={nodeRadius}\n        cx={node.x}\n        cy={node.y}\n      />\n      {isHovered && (\n        <circle className={styles.hoverCircle} r={nodeRadius - 3} cx={node.x} cy={node.y} strokeWidth={strokeWidth} />\n      )}\n      <ColorCircle node={node} />\n      <g className={styles.text} style={{ pointerEvents: 'none' }}>\n        <NodeContents node={node} hovering={hovering} />\n        <foreignObject\n          x={node.x - (isHovered ? 100 : 70)}\n          y={node.y + nodeRadius + 5}\n          width={isHovered ? '200' : '140'}\n          height=\"40\"\n        >\n          <div className={cx(styles.titleText, isHovered && styles.textHovering)}>\n            <span>{node.title}</span>\n            <br />\n            <span>{node.subTitle}</span>\n          </div>\n        </foreignObject>\n      </g>\n      <rect\n        data-testid={`node-click-rect-${node.id}`}\n        onMouseEnter={() => {\n          onMouseEnter(node.id);\n        }}\n        onMouseLeave={() => {\n          onMouseLeave(node.id);\n        }}\n        onClick={(event) => {\n          onClick(event, node);\n        }}\n        className={styles.clickTarget}\n        x={node.x - nodeRadius - 5}\n        y={node.y - nodeRadius - 5}\n        width={nodeRadius * 2 + 10}\n        height={nodeRadius * 2 + 50}\n      />\n    </g>\n  );\n});\n\n/**\n * Shows contents of the node which can be either an Icon or a main and secondary stat values.\n */\nfunction NodeContents({ node, hovering }: { node: NodeDatum; hovering: HoverState }) {\n  const theme = useTheme2();\n  const styles = getStyles(theme, hovering);\n  const isHovered = hovering === 'active';\n\n  if (!(node.x !== undefined && node.y !== undefined)) {\n    return null;\n  }\n\n  return node.icon ? (\n    <foreignObject x={node.x - 35} y={node.y - 20} width=\"70\" height=\"40\">\n      <div style={{ width: 70, overflow: 'hidden', display: 'flex', justifyContent: 'center', marginTop: -4 }}>\n        <Icon data-testid={`node-icon-${node.icon}`} name={node.icon} size={'xxxl'} />\n      </div>\n    </foreignObject>\n  ) : (\n    <foreignObject x={node.x - (isHovered ? 100 : 35)} y={node.y - 15} width={isHovered ? '200' : '70'} height=\"40\">\n      <div className={cx(styles.statsText, isHovered && styles.textHovering)}>\n        <span>{node.mainStat && statToString(node.mainStat.config, node.mainStat.values[node.dataFrameRowIndex])}</span>\n        <br />\n        <span>\n          {node.secondaryStat &&\n            statToString(node.secondaryStat.config, node.secondaryStat.values[node.dataFrameRowIndex])}\n        </span>\n      </div>\n    </foreignObject>\n  );\n}\n\n/**\n * Shows the outer segmented circle with different colors based on the supplied data.\n */\nfunction ColorCircle(props: { node: NodeDatum }) {\n  const { node } = props;\n  const fullStat = node.arcSections.find((s) => s.values[node.dataFrameRowIndex] >= 1);\n  const theme = useTheme2();\n  const nodeRadius = node.nodeRadius?.values[node.dataFrameRowIndex] || nodeR;\n  const strokeWidth = computeNodeCircumferenceStrokeWidth(nodeRadius);\n\n  if (fullStat) {\n    // Drawing a full circle with a `path` tag does not work well, it's better to use a `circle` tag in that case\n    return (\n      <circle\n        fill=\"none\"\n        stroke={theme.visualization.getColorByName(fullStat.config.color?.fixedColor || '')}\n        strokeWidth={strokeWidth}\n        r={nodeRadius}\n        cx={node.x}\n        cy={node.y}\n      />\n    );\n  }\n\n  const nonZero = node.arcSections.filter((s) => s.values[node.dataFrameRowIndex] !== 0);\n  if (nonZero.length === 0) {\n    // Fallback if no arc is defined\n    return (\n      <circle\n        fill=\"none\"\n        stroke={node.color ? getColor(node.color, node.dataFrameRowIndex, theme) : 'gray'}\n        strokeWidth={strokeWidth}\n        r={nodeRadius}\n        cx={node.x}\n        cy={node.y}\n      />\n    );\n  }\n\n  const { elements } = nonZero.reduce<{\n    elements: React.ReactNode[];\n    percent: number;\n  }>(\n    (acc, section, index) => {\n      const color = section.config.color?.fixedColor || '';\n      const value = section.values[node.dataFrameRowIndex];\n\n      const el = (\n        <ArcSection\n          key={index}\n          r={nodeRadius}\n          x={node.x!}\n          y={node.y!}\n          startPercent={acc.percent}\n          percent={\n            value + acc.percent > 1\n              ? // If the values aren't correct and add up to more than 100% lets still render correctly the amounts we\n                // already have and cap it at 100%\n                1 - acc.percent\n              : value\n          }\n          color={theme.visualization.getColorByName(color)}\n          strokeWidth={strokeWidth}\n        />\n      );\n      acc.elements.push(el);\n      acc.percent = acc.percent + value;\n      return acc;\n    },\n    { elements: [], percent: 0 }\n  );\n\n  return <>{elements}</>;\n}\n\nfunction ArcSection({\n  r,\n  x,\n  y,\n  startPercent,\n  percent,\n  color,\n  strokeWidth = 2,\n}: {\n  r: number;\n  x: number;\n  y: number;\n  startPercent: number;\n  percent: number;\n  color: string;\n  strokeWidth?: number;\n}) {\n  const endPercent = startPercent + percent;\n  const startXPos = x + Math.sin(2 * Math.PI * startPercent) * r;\n  const startYPos = y - Math.cos(2 * Math.PI * startPercent) * r;\n  const endXPos = x + Math.sin(2 * Math.PI * endPercent) * r;\n  const endYPos = y - Math.cos(2 * Math.PI * endPercent) * r;\n  const largeArc = percent > 0.5 ? '1' : '0';\n  return (\n    <path\n      fill=\"none\"\n      d={`M ${startXPos} ${startYPos} A ${r} ${r} 0 ${largeArc} 1 ${endXPos} ${endYPos}`}\n      stroke={color}\n      strokeWidth={strokeWidth}\n    />\n  );\n}\n\nfunction getColor(field: Field, index: number, theme: GrafanaTheme2): string {\n  if (!field.config.color) {\n    return field.values[index];\n  }\n\n  return getFieldColorModeForField(field).getCalculator(field, theme)(0, field.values[index]);\n}\n","import {\n  DataFrame,\n  Field,\n  FieldCache,\n  FieldColorModeId,\n  FieldConfig,\n  FieldType,\n  MutableDataFrame,\n  NodeGraphDataFrameFieldNames,\n} from '@grafana/data';\n\nimport { nodeR } from './Node';\nimport { EdgeDatum, GraphFrame, NodeDatum, NodeDatumFromEdge, NodeGraphOptions } from './types';\n\ntype Line = { x1: number; y1: number; x2: number; y2: number };\n\n/**\n * Makes line shorter while keeping its middle in the same place.\n * This is manly used to add some empty space between an edge line and its source and target nodes, to make it nicer.\n *\n * @param line a line, where x1 and y1 are the coordinates of the source node center, and x2 and y2 are the coordinates of the target node center\n * @param sourceNodeRadius radius of the source node (possibly taking into account the thickness of the node circumference line, etc.)\n * @param targetNodeRadius radius of the target node (possibly taking into account the thickness of the node circumference line, etc.)\n * @param arrowHeadHeight height of the arrow head (in pixels)\n */\nexport function shortenLine(line: Line, sourceNodeRadius: number, targetNodeRadius: number, arrowHeadHeight = 1): Line {\n  const vx = line.x2 - line.x1;\n  const vy = line.y2 - line.y1;\n  const mag = Math.sqrt(vx * vx + vy * vy);\n  const cosine = (line.x2 - line.x1) / mag;\n  const sine = (line.y2 - line.y1) / mag;\n  const scaledThickness = arrowHeadHeight - arrowHeadHeight / 10;\n\n  // Reduce the line length (along its main direction) by:\n  // - the radius of the source node\n  // - the radius of the target node,\n  // - a constant value, just to add some empty space\n  // - the height of the arrow head; the bigger the arrow head, the better is to add even more empty space\n  return {\n    x1: line.x1 + cosine * (sourceNodeRadius + 5),\n    y1: line.y1 + sine * (sourceNodeRadius + 5),\n    x2: line.x2 - cosine * (targetNodeRadius + 3 + scaledThickness),\n    y2: line.y2 - sine * (targetNodeRadius + 3 + scaledThickness),\n  };\n}\n\nexport type NodeFields = {\n  fixedX?: Field;\n  fixedY?: Field;\n  id?: Field;\n  title?: Field;\n  subTitle?: Field;\n  mainStat?: Field;\n  secondaryStat?: Field;\n  arc: Field[];\n  details: Field[];\n  color?: Field;\n  icon?: Field;\n  nodeRadius?: Field;\n  highlighted?: Field;\n};\n\nexport function getNodeFields(nodes: DataFrame): NodeFields {\n  const normalizedFrames = {\n    ...nodes,\n    fields: nodes.fields.map((field) => ({ ...field, name: field.name.toLowerCase() })),\n  };\n  const fieldsCache = new FieldCache(normalizedFrames);\n  return {\n    id: fieldsCache.getFieldByName(NodeGraphDataFrameFieldNames.id.toLowerCase()),\n    title: fieldsCache.getFieldByName(NodeGraphDataFrameFieldNames.title.toLowerCase()),\n    subTitle: fieldsCache.getFieldByName(NodeGraphDataFrameFieldNames.subTitle.toLowerCase()),\n    mainStat: fieldsCache.getFieldByName(NodeGraphDataFrameFieldNames.mainStat.toLowerCase()),\n    secondaryStat: fieldsCache.getFieldByName(NodeGraphDataFrameFieldNames.secondaryStat.toLowerCase()),\n    arc: findFieldsByPrefix(nodes, NodeGraphDataFrameFieldNames.arc),\n    details: findFieldsByPrefix(nodes, NodeGraphDataFrameFieldNames.detail),\n    color: fieldsCache.getFieldByName(NodeGraphDataFrameFieldNames.color),\n    icon: fieldsCache.getFieldByName(NodeGraphDataFrameFieldNames.icon),\n    nodeRadius: fieldsCache.getFieldByName(NodeGraphDataFrameFieldNames.nodeRadius.toLowerCase()),\n    highlighted: fieldsCache.getFieldByName(NodeGraphDataFrameFieldNames.highlighted.toLowerCase()),\n    fixedX: fieldsCache.getFieldByName(NodeGraphDataFrameFieldNames.fixedX.toLowerCase()),\n    fixedY: fieldsCache.getFieldByName(NodeGraphDataFrameFieldNames.fixedY.toLowerCase()),\n  };\n}\n\nexport type EdgeFields = {\n  id?: Field;\n  source?: Field;\n  target?: Field;\n  mainStat?: Field;\n  secondaryStat?: Field;\n  details: Field[];\n  /**\n   * @deprecated use `color` instead\n   */\n  highlighted?: Field;\n  thickness?: Field;\n  color?: Field;\n  strokeDasharray?: Field;\n};\n\nexport function getEdgeFields(edges: DataFrame): EdgeFields {\n  const normalizedFrames = {\n    ...edges,\n    fields: edges.fields.map((field) => ({ ...field, name: field.name.toLowerCase() })),\n  };\n  const fieldsCache = new FieldCache(normalizedFrames);\n  return {\n    id: fieldsCache.getFieldByName(NodeGraphDataFrameFieldNames.id.toLowerCase()),\n    source: fieldsCache.getFieldByName(NodeGraphDataFrameFieldNames.source.toLowerCase()),\n    target: fieldsCache.getFieldByName(NodeGraphDataFrameFieldNames.target.toLowerCase()),\n    mainStat: fieldsCache.getFieldByName(NodeGraphDataFrameFieldNames.mainStat.toLowerCase()),\n    secondaryStat: fieldsCache.getFieldByName(NodeGraphDataFrameFieldNames.secondaryStat.toLowerCase()),\n    details: findFieldsByPrefix(edges, NodeGraphDataFrameFieldNames.detail.toLowerCase()),\n    // @deprecated -- for edges use color instead\n    highlighted: fieldsCache.getFieldByName(NodeGraphDataFrameFieldNames.highlighted.toLowerCase()),\n    thickness: fieldsCache.getFieldByName(NodeGraphDataFrameFieldNames.thickness.toLowerCase()),\n    color: fieldsCache.getFieldByName(NodeGraphDataFrameFieldNames.color.toLowerCase()),\n    strokeDasharray: fieldsCache.getFieldByName(NodeGraphDataFrameFieldNames.strokeDasharray.toLowerCase()),\n  };\n}\n\nfunction findFieldsByPrefix(frame: DataFrame, prefix: string): Field[] {\n  return frame.fields.filter((f) => f.name.match(new RegExp('^' + prefix)));\n}\n\n/**\n * Transform nodes and edges dataframes into array of objects that the layout code can then work with.\n */\nexport function processNodes(\n  nodes: DataFrame | undefined,\n  edges: DataFrame | undefined\n): {\n  nodes: NodeDatum[];\n  edges: EdgeDatum[];\n  hasFixedPositions?: boolean;\n  legend?: Array<{\n    color: string;\n    name: string;\n  }>;\n} {\n  if (!(edges || nodes)) {\n    return { nodes: [], edges: [] };\n  }\n\n  if (nodes) {\n    const nodeFields = getNodeFields(nodes);\n    if (!nodeFields.id) {\n      throw new Error('id field is required for nodes data frame.');\n    }\n\n    const hasFixedPositions =\n      nodeFields.fixedX &&\n      nodeFields.fixedX.values.every((v) => Number.isFinite(v)) &&\n      nodeFields.fixedY &&\n      nodeFields.fixedY.values.every((v) => Number.isFinite(v));\n\n    // Throw an error if somebody is using fixedX and fixedY fields incorrectly. Other option is to ignore this but we\n    // are not able to easily combine fixed and non-fixed position in layout so that behaviour would be undefined\n    // and silent.\n    if (!hasFixedPositions) {\n      const somePosFilled =\n        (nodeFields.fixedX && nodeFields.fixedX.values.some((v) => Number.isFinite(v))) ||\n        (nodeFields.fixedY && nodeFields.fixedY.values.some((v) => Number.isFinite(v)));\n      if (somePosFilled) {\n        throw new Error('If fixedX and fixedY fields are present, the values have to be all filled and valid');\n      }\n    }\n\n    // Create the nodes here\n    const nodesMap: { [id: string]: NodeDatum } = {};\n    for (let i = 0; i < nodeFields.id.values.length; i++) {\n      const id = nodeFields.id.values[i];\n      nodesMap[id] = makeNodeDatum(id, nodeFields, i);\n    }\n\n    // We may not have edges in case of single node\n    let edgeDatums: EdgeDatum[] = edges ? processEdges(edges, getEdgeFields(edges), nodesMap) : [];\n\n    for (const e of edgeDatums) {\n      // We are adding incoming edges count, so we can later on find out which nodes are the roots\n      nodesMap[e.target].incoming++;\n    }\n\n    return {\n      nodes: Object.values(nodesMap),\n      edges: edgeDatums,\n      hasFixedPositions,\n      legend: nodeFields.arc.map((f) => {\n        return {\n          color: f.config.color?.fixedColor ?? '',\n          name: f.config.displayName || f.name,\n        };\n      }),\n    };\n  } else {\n    // We have only edges here, so we have to construct also nodes out of them\n\n    // We checked that either node || edges has to be defined and if nodes aren't edges has to be defined\n    edges = edges!;\n\n    const nodesMap: { [id: string]: NodeDatumFromEdge } = {};\n\n    const edgeFields = getEdgeFields(edges);\n\n    // Turn edges into reasonable filled in nodes\n    for (let i = 0; i < edges.length; i++) {\n      const { source, target } = makeNodeDatumsFromEdge(edgeFields, i);\n\n      nodesMap[target.id] = nodesMap[target.id] || target;\n      nodesMap[source.id] = nodesMap[source.id] || source;\n\n      // Check the stats fields. They can be also strings which we cannot really aggregate so only aggregate in case\n      // they are numbers. Here we just sum all incoming edges to get the final value for node.\n      if (computableField(edgeFields.mainStat)) {\n        nodesMap[target.id].mainStatNumeric =\n          (nodesMap[target.id].mainStatNumeric ?? 0) + edgeFields.mainStat!.values[i];\n      }\n\n      if (computableField(edgeFields.secondaryStat)) {\n        nodesMap[target.id].secondaryStatNumeric =\n          (nodesMap[target.id].secondaryStatNumeric ?? 0) + edgeFields.secondaryStat!.values[i];\n      }\n\n      // We are adding incoming edges count, so we can later on find out which nodes are the roots\n      nodesMap[target.id].incoming++;\n    }\n\n    let edgeDatums = processEdges(edges, edgeFields, nodesMap);\n\n    // It is expected for stats to be Field, so we have to create them.\n    const nodes = normalizeStatsForNodes(nodesMap, edgeFields);\n\n    return {\n      nodes,\n      edges: edgeDatums,\n      // Edge-only datasets never have fixedX/fixedY\n      hasFixedPositions: false,\n    };\n  }\n}\n\n/**\n * Turn data frame data into EdgeDatum that node graph understands\n * @param edges\n * @param edgeFields\n */\nfunction processEdges(edges: DataFrame, edgeFields: EdgeFields, nodesMap: { [id: string]: NodeDatum }): EdgeDatum[] {\n  if (!edgeFields.id) {\n    throw new Error('id field is required for edges data frame.');\n  }\n\n  return edgeFields.id.values.map((id, index) => {\n    const target = edgeFields.target?.values[index];\n    const source = edgeFields.source?.values[index];\n\n    const sourceNode = nodesMap[source];\n    const targetNode = nodesMap[target];\n\n    return {\n      id,\n      dataFrameRowIndex: index,\n      source,\n      target,\n      sourceNodeRadius: !sourceNode.nodeRadius ? nodeR : sourceNode.nodeRadius.values[sourceNode.dataFrameRowIndex],\n      targetNodeRadius: !targetNode.nodeRadius ? nodeR : targetNode.nodeRadius.values[targetNode.dataFrameRowIndex],\n      mainStat: edgeFields.mainStat ? statToString(edgeFields.mainStat.config, edgeFields.mainStat.values[index]) : '',\n      secondaryStat: edgeFields.secondaryStat\n        ? statToString(edgeFields.secondaryStat.config, edgeFields.secondaryStat.values[index])\n        : '',\n      // @deprecated -- for edges use color instead\n      highlighted: edgeFields.highlighted?.values[index] || false,\n      thickness: edgeFields.thickness?.values[index] || 1,\n      color: edgeFields.color?.values[index],\n      strokeDasharray: edgeFields.strokeDasharray?.values[index],\n    };\n  });\n}\n\nfunction computableField(field?: Field) {\n  return field && field.type === FieldType.number;\n}\n\n/**\n * Instead of just simple numbers node graph requires to have Field in NodeDatum (probably for some formatting info in\n * config). So we create them here and fill with correct data.\n * @param nodesMap\n * @param edgeFields\n */\nfunction normalizeStatsForNodes(nodesMap: { [id: string]: NodeDatumFromEdge }, edgeFields: EdgeFields): NodeDatum[] {\n  const secondaryStatValues: Array<number | undefined> = [];\n  const mainStatValues: Array<number | undefined> = [];\n  const secondaryStatField = computableField(edgeFields.secondaryStat)\n    ? {\n        ...edgeFields.secondaryStat!,\n        values: secondaryStatValues,\n      }\n    : undefined;\n\n  const mainStatField = computableField(edgeFields.mainStat)\n    ? {\n        ...edgeFields.mainStat!,\n        values: mainStatValues,\n      }\n    : undefined;\n\n  return Object.values(nodesMap).map((node, index) => {\n    if (mainStatField || secondaryStatField) {\n      const newNode = {\n        ...node,\n      };\n\n      if (mainStatField) {\n        newNode.mainStat = mainStatField;\n        mainStatValues.push(node.mainStatNumeric);\n        newNode.dataFrameRowIndex = index;\n      }\n\n      if (secondaryStatField) {\n        newNode.secondaryStat = secondaryStatField;\n        secondaryStatValues.push(node.secondaryStatNumeric);\n        newNode.dataFrameRowIndex = index;\n      }\n      return newNode;\n    }\n    return node;\n  });\n}\n\nfunction makeNodeDatumsFromEdge(edgeFields: EdgeFields, index: number) {\n  const targetId = edgeFields.target?.values[index];\n  const sourceId = edgeFields.source?.values[index];\n  return {\n    target: makeSimpleNodeDatum(targetId, index),\n    source: makeSimpleNodeDatum(sourceId, index),\n  };\n}\n\nfunction makeSimpleNodeDatum(name: string, index: number): NodeDatumFromEdge {\n  return {\n    id: name,\n    title: name,\n    subTitle: '',\n    dataFrameRowIndex: index,\n    incoming: 0,\n    arcSections: [],\n    highlighted: false,\n  };\n}\n\nfunction makeNodeDatum(id: string, nodeFields: NodeFields, index: number): NodeDatum {\n  return {\n    id: id,\n    title: nodeFields.title?.values[index] || '',\n    subTitle: nodeFields.subTitle?.values[index] || '',\n    dataFrameRowIndex: index,\n    incoming: 0,\n    mainStat: nodeFields.mainStat,\n    secondaryStat: nodeFields.secondaryStat,\n    arcSections: nodeFields.arc,\n    color: nodeFields.color,\n    icon: nodeFields.icon?.values[index] || '',\n    nodeRadius: nodeFields.nodeRadius,\n    highlighted: nodeFields.highlighted?.values[index] || false,\n    x: nodeFields.fixedX?.values[index] ?? undefined,\n    y: nodeFields.fixedY?.values[index] ?? undefined,\n  };\n}\n\nexport function statToString(config: FieldConfig, value: number | string): string {\n  if (typeof value === 'string') {\n    return value;\n  } else {\n    const decimals = config.decimals || 2;\n    if (Number.isFinite(value)) {\n      return value.toFixed(decimals) + (config.unit ? ' ' + config.unit : '');\n    } else {\n      return '';\n    }\n  }\n}\n\n/**\n * Utilities mainly for testing\n */\n\nexport function makeNodesDataFrame(count: number) {\n  const frame = nodesFrame();\n  for (let i = 0; i < count; i++) {\n    frame.add(makeNode(i));\n  }\n\n  return frame;\n}\n\nfunction makeNode(index: number) {\n  return {\n    id: index.toString(),\n    title: `service:${index}`,\n    subtitle: 'service',\n    arc__success: 0.5,\n    arc__errors: 0.5,\n    mainstat: 0.1,\n    secondarystat: 2,\n    color: 0.5,\n    icon: 'database',\n    noderadius: 40,\n  };\n}\n\nfunction nodesFrame() {\n  const fields = {\n    [NodeGraphDataFrameFieldNames.id]: {\n      values: [],\n      type: FieldType.string,\n    },\n    [NodeGraphDataFrameFieldNames.title]: {\n      values: [],\n      type: FieldType.string,\n    },\n    [NodeGraphDataFrameFieldNames.subTitle]: {\n      values: [],\n      type: FieldType.string,\n    },\n    [NodeGraphDataFrameFieldNames.mainStat]: {\n      values: [],\n      type: FieldType.number,\n    },\n    [NodeGraphDataFrameFieldNames.secondaryStat]: {\n      values: [],\n      type: FieldType.number,\n    },\n    [NodeGraphDataFrameFieldNames.arc + 'success']: {\n      values: [],\n      type: FieldType.number,\n      config: { color: { mode: FieldColorModeId.Fixed, fixedColor: 'green' } },\n    },\n    [NodeGraphDataFrameFieldNames.arc + 'errors']: {\n      values: [],\n      type: FieldType.number,\n      config: { color: { mode: FieldColorModeId.Fixed, fixedColor: 'red' } },\n    },\n    [NodeGraphDataFrameFieldNames.color]: {\n      values: [],\n      type: FieldType.number,\n      config: { color: { mode: FieldColorModeId.ContinuousGrYlRd } },\n    },\n    [NodeGraphDataFrameFieldNames.icon]: {\n      values: [],\n      type: FieldType.string,\n    },\n    [NodeGraphDataFrameFieldNames.nodeRadius]: {\n      values: [],\n      type: FieldType.number,\n    },\n  };\n\n  return new MutableDataFrame({\n    name: 'nodes',\n    fields: Object.entries(fields).map(([key, value]) => ({\n      ...value,\n      name: key,\n    })),\n  });\n}\n\nexport function makeEdgesDataFrame(\n  edges: Array<Partial<{ source: string; target: string; mainstat: number; secondarystat: number }>>\n) {\n  const frame = edgesFrame();\n  for (const edge of edges) {\n    frame.add({\n      id: edge.source + '--' + edge.target,\n      ...edge,\n    });\n  }\n\n  return frame;\n}\n\nfunction edgesFrame() {\n  const fields = {\n    [NodeGraphDataFrameFieldNames.id]: {\n      values: [],\n      type: FieldType.string,\n    },\n    [NodeGraphDataFrameFieldNames.source]: {\n      values: [],\n      type: FieldType.string,\n    },\n    [NodeGraphDataFrameFieldNames.target]: {\n      values: [],\n      type: FieldType.string,\n    },\n    [NodeGraphDataFrameFieldNames.mainStat]: {\n      values: [],\n      type: FieldType.number,\n    },\n    [NodeGraphDataFrameFieldNames.secondaryStat]: {\n      values: [],\n      type: FieldType.number,\n    },\n  };\n\n  return new MutableDataFrame({\n    name: 'edges',\n    fields: Object.entries(fields).map(([key, value]) => ({\n      ...value,\n      name: key,\n    })),\n  });\n}\n\nexport interface Bounds {\n  top: number;\n  right: number;\n  bottom: number;\n  left: number;\n  center: {\n    x: number;\n    y: number;\n  };\n}\n\n/**\n * Get bounds of the graph meaning the extent of the nodes in all directions.\n */\nexport function graphBounds(nodes: NodeDatum[]): Bounds {\n  if (nodes.length === 0) {\n    return { top: 0, right: 0, bottom: 0, left: 0, center: { x: 0, y: 0 } };\n  }\n\n  const bounds = nodes.reduce(\n    (acc, node) => {\n      if (node.x! > acc.right) {\n        acc.right = node.x!;\n      }\n      if (node.x! < acc.left) {\n        acc.left = node.x!;\n      }\n      if (node.y! > acc.bottom) {\n        acc.bottom = node.y!;\n      }\n      if (node.y! < acc.top) {\n        acc.top = node.y!;\n      }\n      return acc;\n    },\n    { top: Infinity, right: -Infinity, bottom: -Infinity, left: Infinity }\n  );\n\n  const y = bounds.top + (bounds.bottom - bounds.top) / 2;\n  const x = bounds.left + (bounds.right - bounds.left) / 2;\n\n  return {\n    ...bounds,\n    center: {\n      x,\n      y,\n    },\n  };\n}\n\nexport function getNodeGraphDataFrames(frames: DataFrame[], options?: NodeGraphOptions) {\n  // TODO: this not in sync with how other types of responses are handled. Other types have a query response\n  //  processing pipeline which ends up populating redux state with proper data. As we move towards more dataFrame\n  //  oriented API it seems like a better direction to move such processing into to visualisations and do minimal\n  //  and lazy processing here. Needs bigger refactor so keeping nodeGraph and Traces as they are for now.\n  let nodeGraphFrames = frames.filter((frame) => {\n    if (frame.meta?.preferredVisualisationType === 'nodeGraph') {\n      return true;\n    }\n\n    if (frame.name === 'nodes' || frame.name === 'edges' || frame.refId === 'nodes' || frame.refId === 'edges') {\n      return true;\n    }\n\n    const fieldsCache = new FieldCache(frame);\n    if (fieldsCache.getFieldByName(NodeGraphDataFrameFieldNames.id)) {\n      return true;\n    }\n\n    return false;\n  });\n\n  // If panel options are provided, interpolate their values in to the data frames\n  if (options) {\n    nodeGraphFrames = applyOptionsToFrames(nodeGraphFrames, options);\n  }\n  return nodeGraphFrames;\n}\n\nexport const applyOptionsToFrames = (frames: DataFrame[], options: NodeGraphOptions): DataFrame[] => {\n  return frames.map((frame) => {\n    const fieldsCache = new FieldCache(frame);\n\n    // Edges frame has source which can be used to identify nodes vs edges frames\n    if (fieldsCache.getFieldByName(NodeGraphDataFrameFieldNames.source.toLowerCase())) {\n      if (options?.edges?.mainStatUnit) {\n        const field = frame.fields.find((field) => field.name.toLowerCase() === NodeGraphDataFrameFieldNames.mainStat);\n        if (field) {\n          field.config = { ...field.config, unit: options.edges.mainStatUnit };\n        }\n      }\n      if (options?.edges?.secondaryStatUnit) {\n        const field = frame.fields.find(\n          (field) => field.name.toLowerCase() === NodeGraphDataFrameFieldNames.secondaryStat\n        );\n        if (field) {\n          field.config = { ...field.config, unit: options.edges.secondaryStatUnit };\n        }\n      }\n    } else {\n      if (options?.nodes?.mainStatUnit) {\n        const field = frame.fields.find((field) => field.name.toLowerCase() === NodeGraphDataFrameFieldNames.mainStat);\n        if (field) {\n          field.config = { ...field.config, unit: options.nodes.mainStatUnit };\n        }\n      }\n      if (options?.nodes?.secondaryStatUnit) {\n        const field = frame.fields.find(\n          (field) => field.name.toLowerCase() === NodeGraphDataFrameFieldNames.secondaryStat\n        );\n        if (field) {\n          field.config = { ...field.config, unit: options.nodes.secondaryStatUnit };\n        }\n      }\n      if (options?.nodes?.arcs?.length) {\n        for (const arc of options.nodes.arcs) {\n          // As the arc__ field suffixes can be custom we compare them case insensitively to be safe.\n          const field = frame.fields.find((field) => field.name.toLowerCase() === arc.field?.toLowerCase());\n          if (field && arc.color) {\n            field.config = { ...field.config, color: { fixedColor: arc.color, mode: FieldColorModeId.Fixed } };\n          }\n        }\n      }\n    }\n    return frame;\n  });\n};\n\n// Returns an array of node ids which are connected to a given edge\nexport const findConnectedNodesForEdge = (nodes: NodeDatum[], edges: EdgeDatum[], edgeId: string): string[] => {\n  const edge = edges.find((edge) => edge.id === edgeId);\n  if (edge) {\n    return [\n      ...new Set(nodes.filter((node) => edge.source === node.id || edge.target === node.id).map((node) => node.id)),\n    ];\n  }\n  return [];\n};\n\n// Returns an array of node ids which are connected to a given node\nexport const findConnectedNodesForNode = (nodes: NodeDatum[], edges: EdgeDatum[], nodeId: string): string[] => {\n  const node = nodes.find((node) => node.id === nodeId);\n  if (node) {\n    const linkedEdges = edges.filter((edge) => edge.source === node.id || edge.target === node.id);\n    return [\n      ...new Set(\n        linkedEdges.flatMap((edge) =>\n          nodes.filter((n) => edge.source === n.id || edge.target === n.id).map((n) => n.id)\n        )\n      ),\n    ];\n  }\n  return [];\n};\n\nexport const getGraphFrame = (frames: DataFrame[]) => {\n  return frames.reduce<GraphFrame>(\n    (acc, frame) => {\n      const sourceField = frame.fields.filter((f) => f.name === 'source');\n      if (frame.name === 'edges' || sourceField.length) {\n        acc.edges.push(frame);\n      } else {\n        acc.nodes.push(frame);\n      }\n      return acc;\n    },\n    { edges: [], nodes: [] }\n  );\n};\n"],"names":["nodeR","highlightedNodeColor","getStyles","theme","hovering","computeNodeCircumferenceStrokeWidth","nodeRadius","Node","props","node","onMouseEnter","onMouseLeave","onClick","styles","isHovered","strokeWidth","ColorCircle","NodeContents","event","fullStat","s","nonZero","getColor","elements","acc","section","index","color","value","el","ArcSection","x","y","startPercent","percent","endPercent","startXPos","startYPos","endXPos","endYPos","largeArc","field","shortenLine","line","sourceNodeRadius","targetNodeRadius","arrowHeadHeight","vx","vy","mag","cosine","sine","scaledThickness","getNodeFields","nodes","normalizedFrames","fieldsCache","findFieldsByPrefix","getEdgeFields","edges","frame","prefix","f","processNodes","nodeFields","hasFixedPositions","v","nodesMap","i","id","makeNodeDatum","edgeDatums","processEdges","e","edgeFields","source","target","makeNodeDatumsFromEdge","computableField","normalizeStatsForNodes","sourceNode","targetNode","statToString","secondaryStatValues","mainStatValues","secondaryStatField","mainStatField","newNode","targetId","sourceId","makeSimpleNodeDatum","name","config","decimals","makeNodesDataFrame","count","nodesFrame","makeNode","fields","key","makeEdgesDataFrame","edgesFrame","edge","graphBounds","bounds","getNodeGraphDataFrames","frames","options","nodeGraphFrames","applyOptionsToFrames","arc","findConnectedNodesForEdge","edgeId","findConnectedNodesForNode","nodeId","linkedEdges","n","getGraphFrame","sourceField"],"sourceRoot":""}