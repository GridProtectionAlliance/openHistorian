{"version":3,"file":"3128.f46babc47764ad7108eb.js","mappings":"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","sources":["webpack://grafana/./public/app/features/live/centrifuge/LiveDataStream.ts","webpack://grafana/./public/app/features/live/centrifuge/channel.ts","webpack://grafana/./public/app/features/live/centrifuge/service.ts","webpack://grafana/./public/app/features/live/centrifuge/transferHandlers.ts","webpack://grafana/../../opt/drone/yarncache/centrifuge-npm-3.1.0-9c1dc8c1d8-24bcf02ad8.zip/node_modules/centrifuge/build/centrifuge.js","webpack://grafana/../../opt/drone/yarncache/centrifuge-npm-3.1.0-9c1dc8c1d8-24bcf02ad8.zip/node_modules/centrifuge/build/codes.js","webpack://grafana/../../opt/drone/yarncache/centrifuge-npm-3.1.0-9c1dc8c1d8-24bcf02ad8.zip/node_modules/centrifuge/build/index.js","webpack://grafana/../../opt/drone/yarncache/centrifuge-npm-3.1.0-9c1dc8c1d8-24bcf02ad8.zip/node_modules/centrifuge/build/json.js","webpack://grafana/../../opt/drone/yarncache/centrifuge-npm-3.1.0-9c1dc8c1d8-24bcf02ad8.zip/node_modules/centrifuge/build/subscription.js","webpack://grafana/../../opt/drone/yarncache/centrifuge-npm-3.1.0-9c1dc8c1d8-24bcf02ad8.zip/node_modules/centrifuge/build/transport_http_stream.js","webpack://grafana/../../opt/drone/yarncache/centrifuge-npm-3.1.0-9c1dc8c1d8-24bcf02ad8.zip/node_modules/centrifuge/build/transport_sockjs.js","webpack://grafana/../../opt/drone/yarncache/centrifuge-npm-3.1.0-9c1dc8c1d8-24bcf02ad8.zip/node_modules/centrifuge/build/transport_sse.js","webpack://grafana/../../opt/drone/yarncache/centrifuge-npm-3.1.0-9c1dc8c1d8-24bcf02ad8.zip/node_modules/centrifuge/build/transport_websocket.js","webpack://grafana/../../opt/drone/yarncache/centrifuge-npm-3.1.0-9c1dc8c1d8-24bcf02ad8.zip/node_modules/centrifuge/build/transport_webtransport.js","webpack://grafana/../../opt/drone/yarncache/centrifuge-npm-3.1.0-9c1dc8c1d8-24bcf02ad8.zip/node_modules/centrifuge/build/types.js","webpack://grafana/../../opt/drone/yarncache/centrifuge-npm-3.1.0-9c1dc8c1d8-24bcf02ad8.zip/node_modules/centrifuge/build/utils.js","webpack://grafana/../../opt/drone/yarncache/events-npm-3.3.0-c280bc7e48-f6f487ad21.zip/node_modules/events/events.js","webpack://grafana/../../opt/drone/yarncache/comlink-npm-4.4.1-b05bb2527d-16d58a8f59.zip/node_modules/comlink/dist/esm/comlink.mjs"],"sourcesContent":["import { map, Observable, ReplaySubject, Subject, Subscriber, Subscription } from 'rxjs';\n\nimport {\n  DataFrameJSON,\n  DataQueryError,\n  Field,\n  isLiveChannelMessageEvent,\n  isLiveChannelStatusEvent,\n  LiveChannelConnectionState,\n  LiveChannelEvent,\n  LiveChannelId,\n  LoadingState,\n} from '@grafana/data';\nimport { LiveDataStreamOptions, StreamingFrameAction, StreamingFrameOptions } from '@grafana/runtime/src/services/live';\nimport { toDataQueryError } from '@grafana/runtime/src/utils/toDataQueryError';\n\nimport { getStreamingFrameOptions, StreamingDataFrame } from '../data/StreamingDataFrame';\nimport { StreamingResponseDataType } from '../data/utils';\n\nimport { DataStreamSubscriptionKey, StreamingDataQueryResponse } from './service';\n\nconst bufferIfNot =\n  (canEmitObservable: Observable<boolean>) =>\n  <T>(source: Observable<T>): Observable<T[]> => {\n    return new Observable((subscriber: Subscriber<T[]>) => {\n      let buffer: T[] = [];\n      let canEmit = true;\n\n      const emitBuffer = () => {\n        subscriber.next(buffer);\n        buffer = [];\n      };\n\n      const canEmitSub = canEmitObservable.subscribe({\n        next: (val) => {\n          canEmit = val;\n\n          if (canEmit && buffer.length) {\n            emitBuffer();\n          }\n        },\n      });\n\n      const sourceSub = source.subscribe({\n        next(value) {\n          if (canEmit) {\n            if (!buffer.length) {\n              subscriber.next([value]);\n            } else {\n              emitBuffer();\n            }\n          } else {\n            buffer.push(value);\n          }\n        },\n        error(error) {\n          subscriber.error(error);\n        },\n        complete() {\n          subscriber.complete();\n        },\n      });\n\n      return () => {\n        sourceSub.unsubscribe();\n        canEmitSub.unsubscribe();\n      };\n    });\n  };\n\nexport type DataStreamHandlerDeps<T> = {\n  channelId: LiveChannelId;\n  liveEventsObservable: Observable<LiveChannelEvent<T>>;\n  onShutdown: () => void;\n  subscriberReadiness: Observable<boolean>;\n  defaultStreamingFrameOptions: Readonly<StreamingFrameOptions>;\n  shutdownDelayInMs: number;\n};\n\nenum InternalStreamMessageType {\n  Error,\n  NewValuesSameSchema,\n  ChangedSchema,\n}\n\ntype InternalStreamMessageTypeToData = {\n  [InternalStreamMessageType.Error]: {\n    error: DataQueryError;\n  };\n  [InternalStreamMessageType.ChangedSchema]: {};\n  [InternalStreamMessageType.NewValuesSameSchema]: {\n    values: unknown[][];\n  };\n};\n\ntype InternalStreamMessage<T = InternalStreamMessageType> = T extends InternalStreamMessageType\n  ? {\n      type: T;\n    } & InternalStreamMessageTypeToData[T]\n  : never;\n\nconst reduceNewValuesSameSchemaMessages = (\n  packets: Array<InternalStreamMessage<InternalStreamMessageType.NewValuesSameSchema>>\n) => ({\n  values: packets.reduce((acc, { values }) => {\n    for (let i = 0; i < values.length; i++) {\n      if (!acc[i]) {\n        acc[i] = [];\n      }\n      for (let j = 0; j < values[i].length; j++) {\n        acc[i].push(values[i][j]);\n      }\n    }\n    return acc;\n  }, [] as unknown[][]),\n  type: InternalStreamMessageType.NewValuesSameSchema,\n});\n\nconst filterMessages = <T extends InternalStreamMessageType>(\n  packets: InternalStreamMessage[],\n  type: T\n): Array<InternalStreamMessage<T>> => packets.filter((p) => p.type === type) as Array<InternalStreamMessage<T>>;\n\nexport class LiveDataStream<T = unknown> {\n  private frameBuffer: StreamingDataFrame;\n  private liveEventsSubscription: Subscription;\n  private stream: Subject<InternalStreamMessage> = new ReplaySubject(1);\n  private shutdownTimeoutId: ReturnType<typeof setTimeout> | undefined;\n\n  constructor(private deps: DataStreamHandlerDeps<T>) {\n    this.frameBuffer = StreamingDataFrame.empty(deps.defaultStreamingFrameOptions);\n    this.liveEventsSubscription = deps.liveEventsObservable.subscribe({\n      error: this.onError,\n      complete: this.onComplete,\n      next: this.onNext,\n    });\n  }\n\n  private shutdown = () => {\n    this.stream.complete();\n    this.liveEventsSubscription.unsubscribe();\n    this.deps.onShutdown();\n  };\n\n  private shutdownIfNoSubscribers = () => {\n    if (!this.stream.observed) {\n      this.shutdown();\n    }\n  };\n\n  private onError = (err: any) => {\n    console.log('LiveQuery [error]', { err }, this.deps.channelId);\n    this.stream.next({\n      type: InternalStreamMessageType.Error,\n      error: toDataQueryError(err),\n    });\n    this.shutdown();\n  };\n\n  private onComplete = () => {\n    console.log('LiveQuery [complete]', this.deps.channelId);\n    this.shutdown();\n  };\n\n  private onNext = (evt: LiveChannelEvent) => {\n    if (isLiveChannelMessageEvent(evt)) {\n      this.process(evt.message);\n      return;\n    }\n\n    const liveChannelStatusEvent = isLiveChannelStatusEvent(evt);\n    if (liveChannelStatusEvent && evt.error) {\n      this.stream.next({\n        type: InternalStreamMessageType.Error,\n        error: {\n          ...toDataQueryError(evt.error),\n          message: `Streaming channel error: ${evt.error.message}`,\n        },\n      });\n      return;\n    }\n\n    if (\n      liveChannelStatusEvent &&\n      (evt.state === LiveChannelConnectionState.Connected || evt.state === LiveChannelConnectionState.Pending) &&\n      evt.message\n    ) {\n      this.process(evt.message);\n    }\n  };\n\n  private process = (msg: DataFrameJSON) => {\n    const packetInfo = this.frameBuffer.push(msg);\n\n    if (packetInfo.schemaChanged) {\n      this.stream.next({\n        type: InternalStreamMessageType.ChangedSchema,\n      });\n    } else {\n      this.stream.next({\n        type: InternalStreamMessageType.NewValuesSameSchema,\n        values: this.frameBuffer.getValuesFromLastPacket(),\n      });\n    }\n  };\n\n  private resizeBuffer = (bufferOptions: StreamingFrameOptions) => {\n    if (bufferOptions && this.frameBuffer.needsResizing(bufferOptions)) {\n      this.frameBuffer.resize(bufferOptions);\n    }\n  };\n\n  private prepareInternalStreamForNewSubscription = (options: LiveDataStreamOptions): void => {\n    if (!this.frameBuffer.hasAtLeastOnePacket() && options.frame) {\n      // will skip initial frames from subsequent subscribers\n      this.process(options.frame);\n    }\n  };\n\n  private clearShutdownTimeout = () => {\n    if (this.shutdownTimeoutId) {\n      clearTimeout(this.shutdownTimeoutId);\n      this.shutdownTimeoutId = undefined;\n    }\n  };\n\n  get = (options: LiveDataStreamOptions, subKey: DataStreamSubscriptionKey): Observable<StreamingDataQueryResponse> => {\n    this.clearShutdownTimeout();\n    const buffer = getStreamingFrameOptions(options.buffer);\n\n    this.resizeBuffer(buffer);\n    this.prepareInternalStreamForNewSubscription(options);\n\n    const shouldSendLastPacketOnly = options?.buffer?.action === StreamingFrameAction.Replace;\n    const fieldsNamesFilter = options.filter?.fields;\n    const dataNeedsFiltering = fieldsNamesFilter?.length;\n    const fieldFilterPredicate = dataNeedsFiltering ? ({ name }: Field) => fieldsNamesFilter.includes(name) : undefined;\n    let matchingFieldIndexes: number[] | undefined = undefined;\n\n    const getFullFrameResponseData = <T>(\n      messages: InternalStreamMessage[],\n      error?: DataQueryError\n    ): StreamingDataQueryResponse => {\n      matchingFieldIndexes = fieldFilterPredicate\n        ? this.frameBuffer.getMatchingFieldIndexes(fieldFilterPredicate)\n        : undefined;\n\n      if (!shouldSendLastPacketOnly) {\n        return {\n          key: subKey,\n          state: error ? LoadingState.Error : LoadingState.Streaming,\n          data: [\n            {\n              type: StreamingResponseDataType.FullFrame,\n              frame: this.frameBuffer.serialize(fieldFilterPredicate, buffer),\n            },\n          ],\n          error,\n        };\n      }\n\n      if (error) {\n        // send empty frame with error\n        return {\n          key: subKey,\n          state: LoadingState.Error,\n          data: [\n            {\n              type: StreamingResponseDataType.FullFrame,\n              frame: this.frameBuffer.serialize(fieldFilterPredicate, buffer, { maxLength: 0 }),\n            },\n          ],\n          error,\n        };\n      }\n\n      if (!messages.length) {\n        console.warn(`expected to find at least one non error message ${messages.map(({ type }) => type)}`);\n        // send empty frame\n        return {\n          key: subKey,\n          state: LoadingState.Streaming,\n          data: [\n            {\n              type: StreamingResponseDataType.FullFrame,\n              frame: this.frameBuffer.serialize(fieldFilterPredicate, buffer, { maxLength: 0 }),\n            },\n          ],\n          error,\n        };\n      }\n\n      return {\n        key: subKey,\n        state: LoadingState.Streaming,\n        data: [\n          {\n            type: StreamingResponseDataType.FullFrame,\n            frame: this.frameBuffer.serialize(fieldFilterPredicate, buffer, {\n              maxLength: this.frameBuffer.packetInfo.length,\n            }),\n          },\n        ],\n        error,\n      };\n    };\n\n    const getNewValuesSameSchemaResponseData = (\n      messages: Array<InternalStreamMessage<InternalStreamMessageType.NewValuesSameSchema>>\n    ): StreamingDataQueryResponse => {\n      const lastMessage = messages.length ? messages[messages.length - 1] : undefined;\n      const values =\n        shouldSendLastPacketOnly && lastMessage\n          ? lastMessage.values\n          : reduceNewValuesSameSchemaMessages(messages).values;\n\n      const filteredValues = matchingFieldIndexes\n        ? values.filter((v, i) => (matchingFieldIndexes as number[]).includes(i))\n        : values;\n\n      return {\n        key: subKey,\n        state: LoadingState.Streaming,\n        data: [\n          {\n            type: StreamingResponseDataType.NewValuesSameSchema,\n            values: filteredValues,\n          },\n        ],\n      };\n    };\n\n    let shouldSendFullFrame = true;\n    const transformedInternalStream = this.stream.pipe(\n      bufferIfNot(this.deps.subscriberReadiness),\n      map((messages, i) => {\n        const errors = filterMessages(messages, InternalStreamMessageType.Error);\n        const lastError = errors.length ? errors[errors.length - 1].error : undefined;\n\n        if (shouldSendFullFrame) {\n          shouldSendFullFrame = false;\n          return getFullFrameResponseData(messages, lastError);\n        }\n\n        if (errors.length) {\n          // send the latest frame with the last error, discard everything else\n          return getFullFrameResponseData(messages, lastError);\n        }\n\n        const schemaChanged = messages.some((n) => n.type === InternalStreamMessageType.ChangedSchema);\n        if (schemaChanged) {\n          // send the latest frame, discard intermediate appends\n          return getFullFrameResponseData(messages, undefined);\n        }\n\n        const newValueSameSchemaMessages = filterMessages(messages, InternalStreamMessageType.NewValuesSameSchema);\n        if (newValueSameSchemaMessages.length !== messages.length) {\n          console.warn(`unsupported message type ${messages.map(({ type }) => type)}`);\n        }\n\n        return getNewValuesSameSchemaResponseData(newValueSameSchemaMessages);\n      })\n    );\n\n    return new Observable<StreamingDataQueryResponse>((subscriber) => {\n      const sub = transformedInternalStream.subscribe({\n        next: (n) => {\n          subscriber.next(n);\n        },\n        error: (err) => {\n          subscriber.error(err);\n        },\n        complete: () => {\n          subscriber.complete();\n        },\n      });\n\n      return () => {\n        // TODO: potentially resize (downsize) the buffer on unsubscribe\n        sub.unsubscribe();\n        if (!this.stream.observed) {\n          this.clearShutdownTimeout();\n          this.shutdownTimeoutId = setTimeout(this.shutdownIfNoSubscribers, this.deps.shutdownDelayInMs);\n        }\n      };\n    });\n  };\n}\n","import {\n  Subscription,\n  JoinContext,\n  LeaveContext,\n  PublicationContext,\n  SubscriptionErrorContext,\n  SubscribedContext,\n} from 'centrifuge';\nimport { Subject, of, Observable } from 'rxjs';\n\nimport {\n  LiveChannelStatusEvent,\n  LiveChannelEvent,\n  LiveChannelEventType,\n  LiveChannelConnectionState,\n  LiveChannelPresenceStatus,\n  LiveChannelAddress,\n  DataFrameJSON,\n  isValidLiveChannelAddress,\n} from '@grafana/data';\n\n/**\n * Internal class that maps Centrifuge support to GrafanaLive\n */\nexport class CentrifugeLiveChannel<T = any> {\n  readonly currentStatus: LiveChannelStatusEvent;\n\n  readonly opened = Date.now();\n  readonly id: string;\n  readonly addr: LiveChannelAddress;\n\n  readonly stream = new Subject<LiveChannelEvent<T>>();\n\n  // Hold on to the last header with schema\n  lastMessageWithSchema?: DataFrameJSON;\n\n  subscription?: Subscription;\n  shutdownCallback?: () => void;\n  initalized?: boolean;\n\n  constructor(id: string, addr: LiveChannelAddress) {\n    this.id = id;\n    this.addr = addr;\n    this.currentStatus = {\n      type: LiveChannelEventType.Status,\n      id,\n      timestamp: this.opened,\n      state: LiveChannelConnectionState.Pending,\n    };\n    if (!isValidLiveChannelAddress(addr)) {\n      this.currentStatus.state = LiveChannelConnectionState.Invalid;\n      this.currentStatus.error = 'invalid channel address';\n    }\n  }\n\n  // This should only be called when centrifuge is connected\n  initalize(): void {\n    if (this.initalized) {\n      throw new Error('Channel already initalized: ' + this.id);\n    }\n    this.initalized = true;\n\n    this.subscription!.on('publication', (ctx: PublicationContext) => {\n      try {\n        if (ctx.data) {\n          if (ctx.data.schema) {\n            this.lastMessageWithSchema = ctx.data as DataFrameJSON;\n          }\n\n          this.stream.next({\n            type: LiveChannelEventType.Message,\n            message: ctx.data,\n          });\n        }\n\n        // Clear any error messages\n        if (this.currentStatus.error) {\n          this.currentStatus.timestamp = Date.now();\n          delete this.currentStatus.error;\n          this.sendStatus();\n        }\n      } catch (err) {\n        console.log('publish error', this.addr, err);\n        this.currentStatus.error = err;\n        this.currentStatus.timestamp = Date.now();\n        this.sendStatus();\n      }\n    })\n      .on('error', (ctx: SubscriptionErrorContext) => {\n        this.currentStatus.timestamp = Date.now();\n        this.currentStatus.error = ctx.error.message;\n        this.sendStatus();\n      })\n      .on('subscribed', (ctx: SubscribedContext) => {\n        this.currentStatus.timestamp = Date.now();\n        this.currentStatus.state = LiveChannelConnectionState.Connected;\n        delete this.currentStatus.error;\n\n        if (ctx.data?.schema) {\n          this.lastMessageWithSchema = ctx.data as DataFrameJSON;\n        }\n        this.sendStatus(ctx.data);\n      })\n      .on('unsubscribed', () => {\n        this.currentStatus.timestamp = Date.now();\n        this.currentStatus.state = LiveChannelConnectionState.Disconnected;\n        this.sendStatus();\n      })\n      .on('subscribing', () => {\n        this.currentStatus.timestamp = Date.now();\n        this.currentStatus.state = LiveChannelConnectionState.Connecting;\n        this.sendStatus();\n      })\n      .on('join', (ctx: JoinContext) => {\n        this.stream.next({ type: LiveChannelEventType.Join, user: ctx.info.user });\n      })\n      .on('leave', (ctx: LeaveContext) => {\n        this.stream.next({ type: LiveChannelEventType.Leave, user: ctx.info.user });\n      });\n  }\n\n  private sendStatus(message?: any) {\n    const copy = { ...this.currentStatus };\n    if (message) {\n      copy.message = message;\n    }\n    this.stream.next(copy);\n  }\n\n  disconnectIfNoListeners = () => {\n    const count = this.stream.observers.length;\n    if (count === 0) {\n      this.disconnect();\n    }\n  };\n\n  /**\n   * Get the stream of events and\n   */\n  getStream() {\n    return new Observable((subscriber) => {\n      const initialMessage = { ...this.currentStatus };\n      if (this.lastMessageWithSchema?.schema) {\n        // send just schema instead of schema+data to avoid having data gaps\n        initialMessage.message = { schema: this.lastMessageWithSchema?.schema };\n      }\n\n      subscriber.next({ ...this.currentStatus, message: this.lastMessageWithSchema });\n\n      const sub = this.stream.subscribe(subscriber);\n      return () => {\n        sub.unsubscribe();\n        const count = this.stream.observers.length;\n\n        // Wait 1/4 second to fully disconnect\n        if (count === 0) {\n          setTimeout(this.disconnectIfNoListeners, 250);\n        }\n      };\n    }) as Observable<LiveChannelEvent<T>>;\n  }\n\n  /**\n   * This is configured by the server when the config supports presence\n   */\n  async getPresence(): Promise<LiveChannelPresenceStatus> {\n    if (!this.subscription) {\n      return Promise.reject('not subscribed');\n    }\n\n    return this.subscription!.presence().then((v) => {\n      return {\n        users: Object.keys(v.clients),\n      };\n    });\n  }\n\n  /**\n   * This will close and terminate all streams for this channel\n   */\n  disconnect() {\n    this.currentStatus.state = LiveChannelConnectionState.Shutdown;\n    this.currentStatus.timestamp = Date.now();\n\n    if (this.subscription) {\n      this.subscription.unsubscribe();\n      this.subscription.removeAllListeners(); // they keep all listeners attached after unsubscribe\n      this.subscription = undefined;\n    }\n\n    this.stream.complete();\n\n    this.stream.next({ ...this.currentStatus });\n    this.stream.complete();\n\n    if (this.shutdownCallback) {\n      this.shutdownCallback();\n    }\n  }\n\n  shutdownWithError(err: string) {\n    this.currentStatus.error = err;\n    this.sendStatus();\n    this.disconnect();\n  }\n}\n\nexport function getErrorChannel<TMessage>(msg: string, id: string, addr: LiveChannelAddress) {\n  return {\n    id,\n    opened: Date.now(),\n    addr,\n\n    // return an error\n    getStream: () =>\n      of({\n        type: LiveChannelEventType.Status,\n        id,\n        timestamp: Date.now(),\n        state: LiveChannelConnectionState.Invalid,\n        error: msg,\n      }),\n\n    // already disconnected\n    disconnect: () => {},\n  };\n}\n","import { Centrifuge, State } from 'centrifuge';\nimport { BehaviorSubject, Observable, share, startWith } from 'rxjs';\n\nimport {\n  DataQueryError,\n  DataQueryResponse,\n  LiveChannelAddress,\n  LiveChannelConnectionState,\n  LiveChannelId,\n  toLiveChannelId,\n} from '@grafana/data';\nimport { FetchResponse } from '@grafana/runtime/src/services/backendSrv';\nimport {\n  GrafanaLiveSrv,\n  LiveDataStreamOptions,\n  LiveQueryDataOptions,\n  StreamingFrameAction,\n  StreamingFrameOptions,\n} from '@grafana/runtime/src/services/live';\nimport { BackendDataSourceResponse } from '@grafana/runtime/src/utils/queryResponse';\n\nimport { StreamingResponseData } from '../data/utils';\n\nimport { LiveDataStream } from './LiveDataStream';\nimport { CentrifugeLiveChannel } from './channel';\n\nexport type CentrifugeSrvDeps = {\n  grafanaAuthToken: string | null;\n  appUrl: string;\n  orgId: number;\n  orgRole: string;\n  liveEnabled: boolean;\n  dataStreamSubscriberReadiness: Observable<boolean>;\n};\n\nexport type StreamingDataQueryResponse = Omit<DataQueryResponse, 'data'> & { data: [StreamingResponseData] };\n\nexport type CentrifugeSrv = Omit<GrafanaLiveSrv, 'publish' | 'getDataStream' | 'getQueryData'> & {\n  getDataStream: (options: LiveDataStreamOptions) => Observable<StreamingDataQueryResponse>;\n  getQueryData: (\n    options: LiveQueryDataOptions\n  ) => Promise<\n    | { data: BackendDataSourceResponse | undefined }\n    | FetchResponse<BackendDataSourceResponse | undefined>\n    | DataQueryError\n  >;\n};\n\nexport type DataStreamSubscriptionKey = string;\n\nconst defaultStreamingFrameOptions: Readonly<StreamingFrameOptions> = {\n  maxLength: 100,\n  maxDelta: Infinity,\n  action: StreamingFrameAction.Append,\n};\n\nconst dataStreamShutdownDelayInMs = 5000;\n\nexport class CentrifugeService implements CentrifugeSrv {\n  readonly open = new Map<string, CentrifugeLiveChannel>();\n  private readonly liveDataStreamByChannelId: Record<LiveChannelId, LiveDataStream> = {};\n  readonly centrifuge: Centrifuge;\n  readonly connectionState: BehaviorSubject<boolean>;\n  readonly connectionBlocker: Promise<void>;\n  private readonly dataStreamSubscriberReadiness: Observable<boolean>;\n\n  constructor(private deps: CentrifugeSrvDeps) {\n    this.dataStreamSubscriberReadiness = deps.dataStreamSubscriberReadiness.pipe(share(), startWith(true));\n\n    let liveUrl = `${deps.appUrl.replace(/^http/, 'ws')}/api/live/ws`;\n\n    const token = deps.grafanaAuthToken;\n    if (token !== null && token !== '') {\n      liveUrl += '?auth_token=' + token;\n    }\n\n    this.centrifuge = new Centrifuge(liveUrl, {\n      timeout: 30000,\n    });\n    // orgRole is set when logged in *or* anonymous users can use grafana\n    if (deps.liveEnabled && deps.orgRole !== '') {\n      this.centrifuge.connect(); // do connection\n    }\n    this.connectionState = new BehaviorSubject<boolean>(this.centrifuge.state === State.Connected);\n    this.connectionBlocker = new Promise<void>((resolve) => {\n      if (this.centrifuge.state === State.Connected) {\n        return resolve();\n      }\n      const connectListener = () => {\n        resolve();\n        this.centrifuge.removeListener('connected', connectListener);\n      };\n      this.centrifuge.addListener('connected', connectListener);\n    });\n\n    // Register global listeners\n    this.centrifuge.on('connected', this.onConnect);\n    this.centrifuge.on('connecting', this.onDisconnect);\n    this.centrifuge.on('disconnected', this.onDisconnect);\n    this.centrifuge.on('publication', this.onServerSideMessage);\n  }\n\n  //----------------------------------------------------------\n  // Internal functions\n  //----------------------------------------------------------\n\n  private onConnect = (context: any) => {\n    this.connectionState.next(true);\n  };\n\n  private onDisconnect = (context: any) => {\n    this.connectionState.next(false);\n  };\n\n  private onServerSideMessage = (context: any) => {\n    console.log('Publication from server-side channel', context);\n  };\n\n  /**\n   * Get a channel.  If the scope, namespace, or path is invalid, a shutdown\n   * channel will be returned with an error state indicated in its status\n   */\n  private getChannel<TMessage>(addr: LiveChannelAddress): CentrifugeLiveChannel<TMessage> {\n    const id = `${this.deps.orgId}/${addr.scope}/${addr.namespace}/${addr.path}`;\n    let channel = this.open.get(id);\n    if (channel != null) {\n      return channel;\n    }\n\n    channel = new CentrifugeLiveChannel(id, addr);\n    if (channel.currentStatus.state === LiveChannelConnectionState.Invalid) {\n      return channel;\n    }\n    channel.shutdownCallback = () => {\n      this.open.delete(id);\n\n      // without a call to `removeSubscription`, the subscription will remain in centrifuge's internal registry\n      this.centrifuge.removeSubscription(this.centrifuge.getSubscription(id));\n    };\n    this.open.set(id, channel);\n\n    // Initialize the channel in the background\n    this.initChannel(channel).catch((err) => {\n      if (channel) {\n        channel.currentStatus.state = LiveChannelConnectionState.Invalid;\n        channel.shutdownWithError(err);\n      }\n      this.open.delete(id);\n    });\n\n    // return the not-yet initialized channel\n    return channel;\n  }\n\n  private async initChannel(channel: CentrifugeLiveChannel): Promise<void> {\n    if (this.centrifuge.state !== State.Connected) {\n      await this.connectionBlocker;\n    }\n    const subscription = this.centrifuge.newSubscription(channel.id, {\n      data: channel.addr.data,\n    });\n    channel.subscription = subscription;\n    channel.initalize();\n    subscription.subscribe();\n    return;\n  }\n\n  //----------------------------------------------------------\n  // Exported functions\n  //----------------------------------------------------------\n\n  /**\n   * Listen for changes to the connection state\n   */\n  getConnectionState = () => {\n    return this.connectionState.asObservable();\n  };\n\n  /**\n   * Watch for messages in a channel\n   */\n  getStream: CentrifugeSrv['getStream'] = <T>(address: LiveChannelAddress) => {\n    return this.getChannel<T>(address).getStream();\n  };\n\n  private createSubscriptionKey = (options: LiveDataStreamOptions): DataStreamSubscriptionKey =>\n    options.key ?? `xstr/${streamCounter++}`;\n\n  private getLiveDataStream = (options: LiveDataStreamOptions): LiveDataStream => {\n    const channelId = toLiveChannelId(options.addr);\n    const existingStream = this.liveDataStreamByChannelId[channelId];\n\n    if (existingStream) {\n      return existingStream;\n    }\n\n    const channel = this.getChannel(options.addr);\n    this.liveDataStreamByChannelId[channelId] = new LiveDataStream({\n      channelId,\n      onShutdown: () => {\n        delete this.liveDataStreamByChannelId[channelId];\n      },\n      liveEventsObservable: channel.getStream(),\n      subscriberReadiness: this.dataStreamSubscriberReadiness,\n      defaultStreamingFrameOptions,\n      shutdownDelayInMs: dataStreamShutdownDelayInMs,\n    });\n    return this.liveDataStreamByChannelId[channelId];\n  };\n  /**\n   * Connect to a channel and return results as DataFrames\n   */\n  getDataStream: CentrifugeSrv['getDataStream'] = (options) => {\n    const subscriptionKey = this.createSubscriptionKey(options);\n\n    const stream = this.getLiveDataStream(options);\n    return stream.get(options, subscriptionKey);\n  };\n\n  /**\n   * Executes a query over the live websocket. Query response can contain live channels we can subscribe to for further updates\n   *\n   * Since the initial request and subscription are on the same socket, this will support HA setups\n   */\n  getQueryData: CentrifugeSrv['getQueryData'] = async (options) => {\n    if (this.centrifuge.state !== State.Connected) {\n      await this.connectionBlocker;\n    }\n    return this.centrifuge.rpc('grafana.query', options.body);\n  };\n\n  /**\n   * For channels that support presence, this will request the current state from the server.\n   *\n   * Join and leave messages will be sent to the open stream\n   */\n  getPresence: CentrifugeSrv['getPresence'] = (address) => {\n    return this.getChannel(address).getPresence();\n  };\n}\n\n// This is used to give a unique key for each stream.  The actual value does not matter\nlet streamCounter = 0;\n","import * as comlink from 'comlink';\nimport { Subscriber } from 'rxjs';\n\n// Observers, ie. functions passed to `observable.subscribe(...)`, are converted to a subclass of `Subscriber` before they are sent to the source Observable.\n// The conversion happens internally in the RxJS library - this transfer handler is catches them and wraps them with a proxy\nconst subscriberTransferHandler: any = {\n  canHandle(value: any): boolean {\n    return value && value instanceof Subscriber;\n  },\n\n  serialize(value: Function): [MessagePort, Transferable[]] {\n    const obj = comlink.proxy(value);\n\n    const { port1, port2 } = new MessageChannel();\n\n    comlink.expose(obj, port1);\n\n    return [port2, [port2]];\n  },\n\n  deserialize(value: MessagePort): comlink.Remote<MessagePort> {\n    value.start();\n\n    return comlink.wrap<MessagePort>(value);\n  },\n};\ncomlink.transferHandlers.set('SubscriberHandler', subscriberTransferHandler);\n","\"use strict\";\nvar __importDefault = (this && this.__importDefault) || function (mod) {\n    return (mod && mod.__esModule) ? mod : { \"default\": mod };\n};\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.Centrifuge = void 0;\nconst subscription_1 = require(\"./subscription\");\nconst codes_1 = require(\"./codes\");\nconst transport_sockjs_1 = require(\"./transport_sockjs\");\nconst transport_websocket_1 = require(\"./transport_websocket\");\nconst transport_http_stream_1 = require(\"./transport_http_stream\");\nconst transport_sse_1 = require(\"./transport_sse\");\nconst transport_webtransport_1 = require(\"./transport_webtransport\");\nconst json_1 = require(\"./json\");\nconst utils_1 = require(\"./utils\");\nconst types_1 = require(\"./types\");\nconst events_1 = __importDefault(require(\"events\"));\nconst defaults = {\n    protocol: 'json',\n    token: null,\n    getToken: null,\n    data: null,\n    debug: false,\n    name: 'js',\n    version: '',\n    fetch: null,\n    readableStream: null,\n    websocket: null,\n    eventsource: null,\n    sockjs: null,\n    sockjsOptions: {},\n    emulationEndpoint: '/emulation',\n    minReconnectDelay: 500,\n    maxReconnectDelay: 20000,\n    timeout: 5000,\n    maxServerPingDelay: 10000,\n    networkEventTarget: null,\n};\n/** Centrifuge is a Centrifuge/Centrifugo bidirectional client. */\nclass Centrifuge extends events_1.default {\n    /** Constructs Centrifuge client. Call connect() method to start connecting. */\n    constructor(endpoint, options) {\n        super();\n        this._reconnectTimeout = null;\n        this._refreshTimeout = null;\n        this._serverPingTimeout = null;\n        this.state = types_1.State.Disconnected;\n        this._endpoint = endpoint;\n        this._emulation = false;\n        this._transports = [];\n        this._currentTransportIndex = 0;\n        this._triedAllTransports = false;\n        this._transportWasOpen = false;\n        this._transport = null;\n        this._transportClosed = true;\n        this._encoder = null;\n        this._decoder = null;\n        this._reconnecting = false;\n        this._reconnectTimeout = null;\n        this._reconnectAttempts = 0;\n        this._client = null;\n        this._session = '';\n        this._node = '';\n        this._subs = {};\n        this._serverSubs = {};\n        this._commandId = 0;\n        this._commands = [];\n        this._batching = false;\n        this._refreshRequired = false;\n        this._refreshTimeout = null;\n        this._callbacks = {};\n        this._token = undefined;\n        this._dispatchPromise = Promise.resolve();\n        this._serverPing = 0;\n        this._serverPingTimeout = null;\n        this._sendPong = false;\n        this._promises = {};\n        this._promiseId = 0;\n        this._debugEnabled = false;\n        this._config = Object.assign(Object.assign({}, defaults), options);\n        this._configure();\n        if (this._debugEnabled) {\n            this.on('state', (ctx) => {\n                this._debug('client state', ctx.oldState, '->', ctx.newState);\n            });\n            this.on('error', (ctx) => {\n                this._debug('client error', ctx);\n            });\n        }\n        else {\n            // Avoid unhandled exception in EventEmitter for non-set error handler.\n            this.on('error', function () { Function.prototype(); });\n        }\n    }\n    /** newSubscription allocates new Subscription to a channel. Since server only allows\n     * one subscription per channel per client this method throws if client already has\n     * channel subscription in internal registry.\n     * */\n    newSubscription(channel, options) {\n        if (this.getSubscription(channel) !== null) {\n            throw new Error('Subscription to the channel ' + channel + ' already exists');\n        }\n        const sub = new subscription_1.Subscription(this, channel, options);\n        this._subs[channel] = sub;\n        return sub;\n    }\n    /** getSubscription returns Subscription if it's registered in the internal\n     * registry or null. */\n    getSubscription(channel) {\n        return this._getSub(channel);\n    }\n    /** removeSubscription allows removing Subcription from the internal registry. Subscrption\n     * must be in unsubscribed state. */\n    removeSubscription(sub) {\n        if (!sub) {\n            return;\n        }\n        if (sub.state !== types_1.SubscriptionState.Unsubscribed) {\n            sub.unsubscribe();\n        }\n        this._removeSubscription(sub);\n    }\n    /** Get a map with all current client-side subscriptions. */\n    subscriptions() {\n        return this._subs;\n    }\n    /** ready returns a Promise which resolves upon client goes to Connected\n     * state and rejects in case of client goes to Disconnected or Failed state.\n     * Users can provide optional timeout in milliseconds. */\n    ready(timeout) {\n        if (this.state === types_1.State.Disconnected) {\n            return Promise.reject({ code: codes_1.errorCodes.clientDisconnected, message: 'client disconnected' });\n        }\n        if (this.state === types_1.State.Connected) {\n            return Promise.resolve();\n        }\n        return new Promise((res, rej) => {\n            const ctx = {\n                resolve: res,\n                reject: rej\n            };\n            if (timeout) {\n                ctx.timeout = setTimeout(function () {\n                    rej({ code: codes_1.errorCodes.timeout, message: 'timeout' });\n                }, timeout);\n            }\n            this._promises[this._nextPromiseId()] = ctx;\n        });\n    }\n    /** connect to a server. */\n    connect() {\n        if (this._isConnected()) {\n            this._debug('connect called when already connected');\n            return;\n        }\n        if (this._isConnecting()) {\n            this._debug('connect called when already connecting');\n            return;\n        }\n        this._reconnectAttempts = 0;\n        this._startConnecting();\n    }\n    /** disconnect from a server. */\n    disconnect() {\n        this._disconnect(codes_1.disconnectedCodes.disconnectCalled, 'disconnect called', false);\n    }\n    /** send asynchronous data to a server (without any response from a server\n     * expected, see rpc method if you need response). */\n    send(data) {\n        const cmd = {\n            send: {\n                data: data\n            }\n        };\n        const self = this;\n        return this._methodCall().then(function () {\n            const sent = self._transportSendCommands([cmd]); // can send message to server without id set\n            if (!sent) {\n                return Promise.reject(self._createErrorObject(codes_1.errorCodes.transportWriteError, 'transport write error'));\n            }\n            return Promise.resolve();\n        });\n    }\n    /** rpc to a server - i.e. a call which waits for a response with data. */\n    rpc(method, data) {\n        const cmd = {\n            rpc: {\n                method: method,\n                data: data\n            }\n        };\n        const self = this;\n        return this._methodCall().then(function () {\n            return self._callPromise(cmd, function (reply) {\n                return {\n                    'data': reply.rpc.data\n                };\n            });\n        });\n    }\n    /** publish data to a channel. */\n    publish(channel, data) {\n        const cmd = {\n            publish: {\n                channel: channel,\n                data: data\n            }\n        };\n        const self = this;\n        return this._methodCall().then(function () {\n            return self._callPromise(cmd, function () {\n                return {};\n            });\n        });\n    }\n    /** history for a channel. By default it does not return publications (only current\n     *  StreamPosition data) – provide an explicit limit > 0 to load publications.*/\n    history(channel, options) {\n        const cmd = {\n            history: this._getHistoryRequest(channel, options)\n        };\n        const self = this;\n        return this._methodCall().then(function () {\n            return self._callPromise(cmd, function (reply) {\n                const result = reply.history;\n                const publications = [];\n                if (result.publications) {\n                    for (let i = 0; i < result.publications.length; i++) {\n                        publications.push(self._getPublicationContext(channel, result.publications[i]));\n                    }\n                }\n                return {\n                    'publications': publications,\n                    'epoch': result.epoch || '',\n                    'offset': result.offset || 0\n                };\n            });\n        });\n    }\n    /** presence for a channel. */\n    presence(channel) {\n        const cmd = {\n            presence: {\n                channel: channel\n            }\n        };\n        const self = this;\n        return this._methodCall().then(function () {\n            return self._callPromise(cmd, function (reply) {\n                return {\n                    'clients': reply.presence.presence\n                };\n            });\n        });\n    }\n    /** presence stats for a channel. */\n    presenceStats(channel) {\n        const cmd = {\n            'presence_stats': {\n                channel: channel\n            }\n        };\n        const self = this;\n        return this._methodCall().then(function () {\n            return self._callPromise(cmd, function (reply) {\n                const result = reply.presence_stats;\n                return {\n                    'numUsers': result.num_users,\n                    'numClients': result.num_clients\n                };\n            });\n        });\n    }\n    /** start command batching (collect into temporary buffer without sending to a server)\n     * until stopBatching called.*/\n    startBatching() {\n        // start collecting messages without sending them to Centrifuge until flush\n        // method called\n        this._batching = true;\n    }\n    /** stop batching commands and flush collected commands to the\n     * network (all in one request/frame).*/\n    stopBatching() {\n        const self = this;\n        // Why so nested? Two levels here requred to deal with promise resolving queue.\n        // In Subscription case we wait 2 futures before sending data to connection.\n        // Otherwise _batching becomes false before batching decision has a chance to be executed.\n        Promise.resolve().then(function () {\n            Promise.resolve().then(function () {\n                self._batching = false;\n                self._flush();\n            });\n        });\n    }\n    _debug(...args) {\n        if (!this._debugEnabled) {\n            return;\n        }\n        (0, utils_1.log)('debug', args);\n    }\n    /** @internal */\n    _setFormat(format) {\n        if (this._formatOverride(format)) {\n            return;\n        }\n        if (format === 'protobuf') {\n            throw new Error('not implemented by JSON-only Centrifuge client, use client with Protobuf support');\n        }\n        this._encoder = new json_1.JsonEncoder();\n        this._decoder = new json_1.JsonDecoder();\n    }\n    /** @internal */\n    _formatOverride(_format) {\n        return false;\n    }\n    _configure() {\n        if (!('Promise' in globalThis)) {\n            throw new Error('Promise polyfill required');\n        }\n        if (!this._endpoint) {\n            throw new Error('endpoint configuration required');\n        }\n        if (this._config.protocol !== 'json' && this._config.protocol !== 'protobuf') {\n            throw new Error('unsupported protocol ' + this._config.protocol);\n        }\n        if (this._config.token !== null) {\n            this._token = this._config.token;\n        }\n        this._setFormat('json');\n        if (this._config.protocol === 'protobuf') {\n            this._setFormat('protobuf');\n        }\n        if (this._config.debug === true ||\n            (typeof localStorage !== 'undefined' && localStorage.getItem('centrifuge.debug'))) {\n            this._debugEnabled = true;\n        }\n        this._debug('config', this._config);\n        if (typeof this._endpoint === 'string') {\n            // Single address.\n        }\n        else if (typeof this._endpoint === 'object' && this._endpoint instanceof Array) {\n            this._transports = this._endpoint;\n            this._emulation = true;\n            for (const i in this._transports) {\n                const transportConfig = this._transports[i];\n                if (!transportConfig.endpoint || !transportConfig.transport) {\n                    throw new Error('malformed transport configuration');\n                }\n                const transportName = transportConfig.transport;\n                if (['websocket', 'http_stream', 'sse', 'sockjs', 'webtransport'].indexOf(transportName) < 0) {\n                    throw new Error('unsupported transport name: ' + transportName);\n                }\n            }\n        }\n        else {\n            throw new Error('unsupported url configuration type: only string or array of objects are supported');\n        }\n    }\n    _setState(newState) {\n        if (this.state !== newState) {\n            this._reconnecting = false;\n            const oldState = this.state;\n            this.state = newState;\n            this.emit('state', { newState, oldState });\n            return true;\n        }\n        return false;\n    }\n    _isDisconnected() {\n        return this.state === types_1.State.Disconnected;\n    }\n    _isConnecting() {\n        return this.state === types_1.State.Connecting;\n    }\n    _isConnected() {\n        return this.state === types_1.State.Connected;\n    }\n    _nextCommandId() {\n        return ++this._commandId;\n    }\n    _setNetworkEvents() {\n        let eventTarget = null;\n        if (this._config.networkEventTarget !== null) {\n            eventTarget = this._config.networkEventTarget;\n        }\n        else if (typeof globalThis.addEventListener !== 'undefined') {\n            eventTarget = globalThis;\n        }\n        if (eventTarget) {\n            eventTarget.addEventListener('offline', () => {\n                this._debug('offline event triggered');\n                if (this.state === types_1.State.Connected && this._transport && !this._transportClosed) {\n                    this._transportClosed = true;\n                    this._transport.close();\n                }\n            });\n            eventTarget.addEventListener('online', () => {\n                this._debug('online event triggered');\n                if (this.state === types_1.State.Connecting) {\n                    this._clearReconnectTimeout();\n                    this._startReconnecting();\n                }\n            });\n        }\n    }\n    _getReconnectDelay() {\n        const delay = (0, utils_1.backoff)(this._reconnectAttempts, this._config.minReconnectDelay, this._config.maxReconnectDelay);\n        this._reconnectAttempts += 1;\n        return delay;\n    }\n    _clearOutgoingRequests() {\n        // fire errbacks of registered outgoing calls.\n        for (const id in this._callbacks) {\n            if (this._callbacks.hasOwnProperty(id)) {\n                const callbacks = this._callbacks[id];\n                clearTimeout(callbacks.timeout);\n                const errback = callbacks.errback;\n                if (!errback) {\n                    continue;\n                }\n                errback({ error: this._createErrorObject(codes_1.errorCodes.connectionClosed, 'connection closed') });\n            }\n        }\n        this._callbacks = {};\n    }\n    _clearConnectedState() {\n        this._client = null;\n        this._clearServerPingTimeout();\n        this._clearRefreshTimeout();\n        // fire events for client-side subscriptions.\n        for (const channel in this._subs) {\n            if (!this._subs.hasOwnProperty(channel)) {\n                continue;\n            }\n            const sub = this._subs[channel];\n            if (sub.state === types_1.SubscriptionState.Subscribed) {\n                // @ts-ignore – we are hiding some symbols from public API autocompletion.\n                sub._setSubscribing(codes_1.subscribingCodes.transportClosed, 'transport closed');\n            }\n        }\n        // fire events for server-side subscriptions.\n        for (const channel in this._serverSubs) {\n            if (this._serverSubs.hasOwnProperty(channel)) {\n                this.emit('subscribing', { channel: channel });\n            }\n        }\n    }\n    _handleWriteError(commands) {\n        for (const command of commands) {\n            const id = command.id;\n            if (!(id in this._callbacks)) {\n                continue;\n            }\n            const callbacks = this._callbacks[id];\n            clearTimeout(this._callbacks[id].timeout);\n            delete this._callbacks[id];\n            const errback = callbacks.errback;\n            errback({ error: this._createErrorObject(codes_1.errorCodes.transportWriteError, 'transport write error') });\n        }\n    }\n    _transportSendCommands(commands) {\n        if (!commands.length) {\n            return true;\n        }\n        if (!this._transport) {\n            return false;\n        }\n        try {\n            this._transport.send(this._encoder.encodeCommands(commands), this._session, this._node);\n        }\n        catch (e) {\n            this._debug('error writing commands', e);\n            this._handleWriteError(commands);\n            return false;\n        }\n        return true;\n    }\n    _initializeTransport() {\n        let websocket;\n        if (this._config.websocket !== null) {\n            websocket = this._config.websocket;\n        }\n        else {\n            if (!(typeof globalThis.WebSocket !== 'function' && typeof globalThis.WebSocket !== 'object')) {\n                websocket = globalThis.WebSocket;\n            }\n        }\n        let sockjs = null;\n        if (this._config.sockjs !== null) {\n            sockjs = this._config.sockjs;\n        }\n        else {\n            if (typeof globalThis.SockJS !== 'undefined') {\n                sockjs = globalThis.SockJS;\n            }\n        }\n        let eventsource = null;\n        if (this._config.eventsource !== null) {\n            eventsource = this._config.eventsource;\n        }\n        else {\n            if (typeof globalThis.EventSource !== 'undefined') {\n                eventsource = globalThis.EventSource;\n            }\n        }\n        let fetchFunc = null;\n        if (this._config.fetch !== null) {\n            fetchFunc = this._config.fetch;\n        }\n        else {\n            if (typeof globalThis.fetch !== 'undefined') {\n                fetchFunc = globalThis.fetch;\n            }\n        }\n        let readableStream = null;\n        if (this._config.readableStream !== null) {\n            readableStream = this._config.readableStream;\n        }\n        else {\n            if (typeof globalThis.ReadableStream !== 'undefined') {\n                readableStream = globalThis.ReadableStream;\n            }\n        }\n        if (!this._emulation) {\n            if ((0, utils_1.startsWith)(this._endpoint, 'http')) {\n                throw new Error('Provide explicit transport endpoints configuration in case of using HTTP (i.e. using array of TransportEndpoint instead of a single string), or use ws(s):// scheme in an endpoint if you aimed using WebSocket transport');\n            }\n            else {\n                this._debug('client will use websocket');\n                this._transport = new transport_websocket_1.WebsocketTransport(this._endpoint, {\n                    websocket: websocket\n                });\n                if (!this._transport.supported()) {\n                    throw new Error('WebSocket not available');\n                }\n            }\n        }\n        else {\n            if (this._currentTransportIndex >= this._transports.length) {\n                this._triedAllTransports = true;\n                this._currentTransportIndex = 0;\n            }\n            let count = 0;\n            while (true) {\n                if (count >= this._transports.length) {\n                    throw new Error('no supported transport found');\n                }\n                const transportConfig = this._transports[this._currentTransportIndex];\n                const transportName = transportConfig.transport;\n                const transportEndpoint = transportConfig.endpoint;\n                if (transportName === 'websocket') {\n                    this._debug('trying websocket transport');\n                    this._transport = new transport_websocket_1.WebsocketTransport(transportEndpoint, {\n                        websocket: websocket\n                    });\n                    if (!this._transport.supported()) {\n                        this._debug('websocket transport not available');\n                        this._currentTransportIndex++;\n                        count++;\n                        continue;\n                    }\n                }\n                else if (transportName === 'webtransport') {\n                    this._debug('trying webtransport transport');\n                    this._transport = new transport_webtransport_1.WebtransportTransport(transportEndpoint, {\n                        webtransport: globalThis.WebTransport,\n                        decoder: this._decoder,\n                        encoder: this._encoder\n                    });\n                    if (!this._transport.supported()) {\n                        this._debug('webtransport transport not available');\n                        this._currentTransportIndex++;\n                        count++;\n                        continue;\n                    }\n                }\n                else if (transportName === 'http_stream') {\n                    this._debug('trying http_stream transport');\n                    this._transport = new transport_http_stream_1.HttpStreamTransport(transportEndpoint, {\n                        fetch: fetchFunc,\n                        readableStream: readableStream,\n                        emulationEndpoint: this._config.emulationEndpoint,\n                        decoder: this._decoder,\n                        encoder: this._encoder\n                    });\n                    if (!this._transport.supported()) {\n                        this._debug('http_stream transport not available');\n                        this._currentTransportIndex++;\n                        count++;\n                        continue;\n                    }\n                }\n                else if (transportName === 'sse') {\n                    this._debug('trying sse transport');\n                    this._transport = new transport_sse_1.SseTransport(transportEndpoint, {\n                        eventsource: eventsource,\n                        fetch: fetchFunc,\n                        emulationEndpoint: this._config.emulationEndpoint,\n                    });\n                    if (!this._transport.supported()) {\n                        this._debug('sse transport not available');\n                        this._currentTransportIndex++;\n                        count++;\n                        continue;\n                    }\n                }\n                else if (transportName === 'sockjs') {\n                    this._debug('trying sockjs');\n                    this._transport = new transport_sockjs_1.SockjsTransport(transportEndpoint, {\n                        sockjs: sockjs,\n                        sockjsOptions: this._config.sockjsOptions\n                    });\n                    if (!this._transport.supported()) {\n                        this._debug('sockjs transport not available');\n                        this._currentTransportIndex++;\n                        count++;\n                        continue;\n                    }\n                }\n                else {\n                    throw new Error('unknown transport ' + transportName);\n                }\n                break;\n            }\n        }\n        const self = this;\n        let transportName;\n        let wasOpen = false;\n        let optimistic = true;\n        if (this._transport.name() === 'sse') {\n            // Avoid using optimistic subscriptions with SSE/EventSource as we are sending\n            // initial data in URL params. URL is recommended to be 2048 chars max – so adding\n            // subscription data may be risky.\n            optimistic = false;\n        }\n        const initialCommands = [];\n        if (this._transport.emulation()) {\n            const connectCommand = self._sendConnect(true);\n            initialCommands.push(connectCommand);\n            if (optimistic) {\n                const subscribeCommands = self._sendSubscribeCommands(true, true);\n                for (const i in subscribeCommands) {\n                    initialCommands.push(subscribeCommands[i]);\n                }\n            }\n        }\n        const initialData = this._encoder.encodeCommands(initialCommands);\n        this._transport.initialize(this._config.protocol, {\n            onOpen: function () {\n                wasOpen = true;\n                transportName = self._transport.subName();\n                self._debug(transportName, 'transport open');\n                self._transportWasOpen = true;\n                self._transportClosed = false;\n                if (self._transport.emulation()) {\n                    return;\n                }\n                self.startBatching();\n                self._sendConnect(false);\n                if (optimistic) {\n                    self._sendSubscribeCommands(true, false);\n                }\n                self.stopBatching();\n            },\n            onError: function (e) {\n                self._debug('transport level error', e);\n            },\n            onClose: function (closeEvent) {\n                self._debug(self._transport.name(), 'transport closed');\n                self._transportClosed = true;\n                let reason = 'connection closed';\n                let needReconnect = true;\n                let code = 0;\n                if (closeEvent && 'code' in closeEvent && closeEvent.code) {\n                    code = closeEvent.code;\n                }\n                if (closeEvent && closeEvent.reason) {\n                    try {\n                        const advice = JSON.parse(closeEvent.reason);\n                        reason = advice.reason;\n                        needReconnect = advice.reconnect;\n                    }\n                    catch (e) {\n                        reason = closeEvent.reason;\n                        if ((code >= 3500 && code < 4000) || (code >= 4500 && code < 5000)) {\n                            needReconnect = false;\n                        }\n                    }\n                }\n                if (code < 3000) {\n                    if (code === 1009) {\n                        code = codes_1.disconnectedCodes.messageSizeLimit;\n                        reason = 'message size limit exceeded';\n                        needReconnect = false;\n                    }\n                    else {\n                        code = codes_1.connectingCodes.transportClosed;\n                        reason = 'transport closed';\n                    }\n                    if (self._emulation && !self._transportWasOpen) {\n                        self._currentTransportIndex++;\n                        if (self._currentTransportIndex >= self._transports.length) {\n                            self._triedAllTransports = true;\n                            self._currentTransportIndex = 0;\n                        }\n                    }\n                }\n                else {\n                    // Codes >= 3000 are sent from a server application level.\n                    self._transportWasOpen = true;\n                }\n                let isInitialHandshake = false;\n                if (self._emulation && !self._transportWasOpen && !self._triedAllTransports) {\n                    isInitialHandshake = true;\n                }\n                if (self._isConnecting() && !wasOpen) {\n                    self.emit('error', {\n                        type: 'transport',\n                        error: {\n                            code: codes_1.errorCodes.transportClosed,\n                            message: 'transport closed'\n                        },\n                        transport: self._transport.name()\n                    });\n                }\n                self._disconnect(code, reason, needReconnect);\n                if (self._isConnecting()) {\n                    let delay = self._getReconnectDelay();\n                    if (isInitialHandshake) {\n                        delay = 0;\n                    }\n                    self._debug('reconnect after ' + delay + ' milliseconds');\n                    self._reconnecting = false;\n                    self._reconnectTimeout = setTimeout(() => {\n                        self._startReconnecting();\n                    }, delay);\n                }\n            },\n            onMessage: function (data) {\n                self._dataReceived(data);\n            }\n        }, initialData);\n    }\n    _sendConnect(skipSending) {\n        const connectCommand = this._constructConnectCommand();\n        const self = this;\n        this._call(connectCommand, skipSending).then(resolveCtx => {\n            // @ts-ignore = improve later.\n            const result = resolveCtx.reply.connect;\n            self._connectResponse(result);\n            // @ts-ignore - improve later.\n            if (resolveCtx.next) {\n                // @ts-ignore - improve later.\n                resolveCtx.next();\n            }\n        }, rejectCtx => {\n            self._connectError(rejectCtx.error);\n            if (rejectCtx.next) {\n                rejectCtx.next();\n            }\n        });\n        return connectCommand;\n    }\n    _startReconnecting() {\n        if (!this._isConnecting() || this._reconnecting) {\n            return;\n        }\n        this._reconnecting = true;\n        const needTokenRefresh = this._refreshRequired || (!this._token && this._config.getToken !== null);\n        if (!needTokenRefresh) {\n            this._initializeTransport();\n            return;\n        }\n        const self = this;\n        this._getToken().then(function (token) {\n            if (!self._isConnecting()) {\n                return;\n            }\n            if (!token) {\n                self._failUnauthorized();\n                return;\n            }\n            self._token = token;\n            self._debug('connection token refreshed');\n            self._initializeTransport();\n        }).catch(function (e) {\n            if (!self._isConnecting()) {\n                return;\n            }\n            self.emit('error', {\n                'type': 'connectToken',\n                'error': {\n                    code: codes_1.errorCodes.clientConnectToken,\n                    message: e !== undefined ? e.toString() : ''\n                }\n            });\n            const delay = self._getReconnectDelay();\n            self._debug('error on connection token refresh, reconnect after ' + delay + ' milliseconds', e);\n            self._reconnecting = false;\n            self._reconnectTimeout = setTimeout(() => {\n                self._startReconnecting();\n            }, delay);\n        });\n    }\n    _connectError(err) {\n        if (this.state !== types_1.State.Connecting) {\n            return;\n        }\n        if (err.code === 109) { // token expired.\n            // next connect attempt will try to refresh token.\n            this._refreshRequired = true;\n        }\n        if (err.code < 100 || err.temporary === true || err.code === 109) {\n            this.emit('error', {\n                'type': 'connect',\n                'error': err\n            });\n            // Not yet connected, closing transport is enough.\n            if (this._transport && !this._transportClosed) {\n                this._transportClosed = true;\n                this._transport.close();\n            }\n        }\n        else {\n            this._disconnect(err.code, err.message, false);\n        }\n    }\n    _constructConnectCommand() {\n        const req = {};\n        if (this._token) {\n            req.token = this._token;\n        }\n        if (this._config.data) {\n            req.data = this._config.data;\n        }\n        if (this._config.name) {\n            req.name = this._config.name;\n        }\n        if (this._config.version) {\n            req.version = this._config.version;\n        }\n        const subs = {};\n        let hasSubs = false;\n        for (const channel in this._serverSubs) {\n            if (this._serverSubs.hasOwnProperty(channel) && this._serverSubs[channel].recoverable) {\n                hasSubs = true;\n                const sub = {\n                    'recover': true\n                };\n                if (this._serverSubs[channel].offset) {\n                    sub['offset'] = this._serverSubs[channel].offset;\n                }\n                if (this._serverSubs[channel].epoch) {\n                    sub['epoch'] = this._serverSubs[channel].epoch;\n                }\n                subs[channel] = sub;\n            }\n        }\n        if (hasSubs) {\n            req.subs = subs;\n        }\n        return {\n            connect: req\n        };\n    }\n    _getHistoryRequest(channel, options) {\n        const req = {\n            channel: channel\n        };\n        if (options !== undefined) {\n            if (options.since) {\n                req.since = {\n                    offset: options.since.offset\n                };\n                if (options.since.epoch) {\n                    req.since.epoch = options.since.epoch;\n                }\n            }\n            if (options.limit !== undefined) {\n                req.limit = options.limit;\n            }\n            if (options.reverse === true) {\n                req.reverse = true;\n            }\n        }\n        return req;\n    }\n    _methodCall() {\n        if (this._isConnected()) {\n            return Promise.resolve();\n        }\n        return new Promise((res, rej) => {\n            const timeout = setTimeout(function () {\n                rej({ code: codes_1.errorCodes.timeout, message: 'timeout' });\n            }, this._config.timeout);\n            this._promises[this._nextPromiseId()] = {\n                timeout: timeout,\n                resolve: res,\n                reject: rej\n            };\n        });\n    }\n    _callPromise(cmd, resultCB) {\n        return new Promise((resolve, reject) => {\n            this._call(cmd, false).then(resolveCtx => {\n                // @ts-ignore - improve later.\n                resolve(resultCB(resolveCtx.reply));\n                // @ts-ignore - improve later.\n                if (resolveCtx.next) {\n                    // @ts-ignore - improve later.\n                    resolveCtx.next();\n                }\n            }, rejectCtx => {\n                reject(rejectCtx.error);\n                if (rejectCtx.next) {\n                    rejectCtx.next();\n                }\n            });\n        });\n    }\n    _dataReceived(data) {\n        if (this._serverPing > 0) {\n            this._waitServerPing();\n        }\n        const replies = this._decoder.decodeReplies(data);\n        // We have to guarantee order of events in replies processing - i.e. start processing\n        // next reply only when we finished processing of current one. Without syncing things in\n        // this way we could get wrong publication events order as reply promises resolve\n        // on next loop tick so for loop continues before we finished emitting all reply events.\n        this._dispatchPromise = this._dispatchPromise.then(() => {\n            let finishDispatch;\n            this._dispatchPromise = new Promise(resolve => {\n                finishDispatch = resolve;\n            });\n            this._dispatchSynchronized(replies, finishDispatch);\n        });\n    }\n    _dispatchSynchronized(replies, finishDispatch) {\n        let p = Promise.resolve();\n        for (const i in replies) {\n            if (replies.hasOwnProperty(i)) {\n                p = p.then(() => {\n                    return this._dispatchReply(replies[i]);\n                });\n            }\n        }\n        p = p.then(() => {\n            finishDispatch();\n        });\n    }\n    _dispatchReply(reply) {\n        let next;\n        const p = new Promise(resolve => {\n            next = resolve;\n        });\n        if (reply === undefined || reply === null) {\n            this._debug('dispatch: got undefined or null reply');\n            next();\n            return p;\n        }\n        const id = reply.id;\n        if (id && id > 0) {\n            this._handleReply(reply, next);\n        }\n        else {\n            if (!reply.push) {\n                this._handleServerPing(next);\n            }\n            else {\n                this._handlePush(reply.push, next);\n            }\n        }\n        return p;\n    }\n    _call(cmd, skipSending) {\n        return new Promise((resolve, reject) => {\n            cmd.id = this._nextCommandId();\n            this._registerCall(cmd.id, resolve, reject);\n            if (!skipSending) {\n                this._addCommand(cmd);\n            }\n        });\n    }\n    _startConnecting() {\n        this._debug('start connecting');\n        if (this._setState(types_1.State.Connecting)) {\n            this.emit('connecting', { code: codes_1.connectingCodes.connectCalled, reason: 'connect called' });\n        }\n        this._client = null;\n        this._startReconnecting();\n    }\n    _disconnect(code, reason, reconnect) {\n        if (this._isDisconnected()) {\n            return;\n        }\n        const previousState = this.state;\n        const ctx = {\n            code: code,\n            reason: reason\n        };\n        let needEvent = false;\n        if (reconnect) {\n            needEvent = this._setState(types_1.State.Connecting);\n        }\n        else {\n            needEvent = this._setState(types_1.State.Disconnected);\n            this._rejectPromises({ code: codes_1.errorCodes.clientDisconnected, message: 'disconnected' });\n        }\n        this._clearOutgoingRequests();\n        if (previousState === types_1.State.Connecting) {\n            this._clearReconnectTimeout();\n        }\n        if (previousState === types_1.State.Connected) {\n            this._clearConnectedState();\n        }\n        if (needEvent) {\n            if (this._isConnecting()) {\n                this.emit('connecting', ctx);\n            }\n            else {\n                this.emit('disconnected', ctx);\n            }\n        }\n        if (this._transport && !this._transportClosed) {\n            this._transportClosed = true;\n            this._transport.close();\n        }\n    }\n    _failUnauthorized() {\n        this._disconnect(codes_1.disconnectedCodes.unauthorized, 'unauthorized', false);\n    }\n    _getToken() {\n        this._debug('get connection token');\n        if (!this._config.getToken) {\n            throw new Error('provide a function to get connection token');\n        }\n        return this._config.getToken({});\n    }\n    _refresh() {\n        const clientId = this._client;\n        const self = this;\n        this._getToken().then(function (token) {\n            if (clientId !== self._client) {\n                return;\n            }\n            if (!token) {\n                self._failUnauthorized();\n                return;\n            }\n            self._token = token;\n            self._debug('connection token refreshed');\n            if (!self._isConnected()) {\n                return;\n            }\n            const cmd = {\n                refresh: { token: self._token }\n            };\n            self._call(cmd, false).then(resolveCtx => {\n                // @ts-ignore - improve later.\n                const result = resolveCtx.reply.refresh;\n                self._refreshResponse(result);\n                // @ts-ignore - improve later.\n                if (resolveCtx.next) {\n                    // @ts-ignore - improve later.\n                    resolveCtx.next();\n                }\n            }, rejectCtx => {\n                self._refreshError(rejectCtx.error);\n                if (rejectCtx.next) {\n                    rejectCtx.next();\n                }\n            });\n        }).catch(function (e) {\n            self.emit('error', {\n                type: 'refreshToken',\n                error: {\n                    code: codes_1.errorCodes.clientRefreshToken,\n                    message: e !== undefined ? e.toString() : ''\n                }\n            });\n            self._refreshTimeout = setTimeout(() => self._refresh(), self._getRefreshRetryDelay());\n        });\n    }\n    _refreshError(err) {\n        if (err.code < 100 || err.temporary === true) {\n            this.emit('error', {\n                type: 'refresh',\n                error: err\n            });\n            this._refreshTimeout = setTimeout(() => this._refresh(), this._getRefreshRetryDelay());\n        }\n        else {\n            this._disconnect(err.code, err.message, false);\n        }\n    }\n    _getRefreshRetryDelay() {\n        return (0, utils_1.backoff)(0, 5000, 10000);\n    }\n    _refreshResponse(result) {\n        if (this._refreshTimeout) {\n            clearTimeout(this._refreshTimeout);\n            this._refreshTimeout = null;\n        }\n        if (result.expires) {\n            this._client = result.client;\n            this._refreshTimeout = setTimeout(() => this._refresh(), (0, utils_1.ttlMilliseconds)(result.ttl));\n        }\n    }\n    _removeSubscription(sub) {\n        if (sub === null) {\n            return;\n        }\n        delete this._subs[sub.channel];\n    }\n    _unsubscribe(sub) {\n        if (!this._isConnected()) {\n            return;\n        }\n        const req = {\n            channel: sub.channel\n        };\n        const cmd = { unsubscribe: req };\n        const self = this;\n        this._call(cmd, false).then(resolveCtx => {\n            // @ts-ignore - improve later.\n            if (resolveCtx.next) {\n                // @ts-ignore - improve later.\n                resolveCtx.next();\n            }\n        }, rejectCtx => {\n            if (rejectCtx.next) {\n                rejectCtx.next();\n            }\n            self._disconnect(codes_1.connectingCodes.unsubscribeError, 'unsubscribe error', true);\n        });\n    }\n    _getSub(channel) {\n        const sub = this._subs[channel];\n        if (!sub) {\n            return null;\n        }\n        return sub;\n    }\n    _isServerSub(channel) {\n        return this._serverSubs[channel] !== undefined;\n    }\n    _sendSubscribeCommands(optimistic, skipSending) {\n        const commands = [];\n        for (const channel in this._subs) {\n            if (!this._subs.hasOwnProperty(channel)) {\n                continue;\n            }\n            const sub = this._subs[channel];\n            // @ts-ignore – we are hiding some symbols from public API autocompletion.\n            if (sub._inflight === true) {\n                continue;\n            }\n            if (sub.state === types_1.SubscriptionState.Subscribing) {\n                // @ts-ignore – we are hiding some symbols from public API autocompletion.\n                const cmd = sub._subscribe(optimistic, skipSending);\n                if (cmd) {\n                    commands.push(cmd);\n                }\n            }\n        }\n        return commands;\n    }\n    _connectResponse(result) {\n        this._transportWasOpen = true;\n        this._reconnectAttempts = 0;\n        this._refreshRequired = false;\n        if (this._isConnected()) {\n            return;\n        }\n        this._client = result.client;\n        this._setState(types_1.State.Connected);\n        this._setNetworkEvents();\n        if (this._refreshTimeout) {\n            clearTimeout(this._refreshTimeout);\n        }\n        if (result.expires) {\n            this._refreshTimeout = setTimeout(() => this._refresh(), (0, utils_1.ttlMilliseconds)(result.ttl));\n        }\n        this._session = result.session;\n        this._node = result.node;\n        this.startBatching();\n        this._sendSubscribeCommands(false, false);\n        this.stopBatching();\n        const ctx = {\n            client: result.client,\n            transport: this._transport.subName()\n        };\n        if (result.data) {\n            ctx.data = result.data;\n        }\n        this.emit('connected', ctx);\n        this._resolvePromises();\n        this._processServerSubs(result.subs || {});\n        if (result.ping && result.ping > 0) {\n            this._serverPing = result.ping * 1000;\n            this._sendPong = result.pong === true;\n            this._waitServerPing();\n        }\n        else {\n            this._serverPing = 0;\n        }\n    }\n    _processServerSubs(subs) {\n        for (const channel in subs) {\n            if (!subs.hasOwnProperty(channel)) {\n                continue;\n            }\n            const sub = subs[channel];\n            this._serverSubs[channel] = {\n                'offset': sub.offset,\n                'epoch': sub.epoch,\n                'recoverable': sub.recoverable || false\n            };\n            const subCtx = this._getSubscribeContext(channel, sub);\n            this.emit('subscribed', subCtx);\n        }\n        for (const channel in subs) {\n            if (!subs.hasOwnProperty(channel)) {\n                continue;\n            }\n            const sub = subs[channel];\n            if (sub.recovered) {\n                const pubs = sub.publications;\n                if (pubs && pubs.length > 0) {\n                    for (const i in pubs) {\n                        if (pubs.hasOwnProperty(i)) {\n                            this._handlePublication(channel, pubs[i]);\n                        }\n                    }\n                }\n            }\n        }\n        for (const channel in this._serverSubs) {\n            if (!this._serverSubs.hasOwnProperty(channel)) {\n                continue;\n            }\n            if (!subs[channel]) {\n                this.emit('unsubscribed', { channel: channel });\n                delete this._serverSubs[channel];\n            }\n        }\n    }\n    _clearRefreshTimeout() {\n        if (this._refreshTimeout !== null) {\n            clearTimeout(this._refreshTimeout);\n            this._refreshTimeout = null;\n        }\n    }\n    _clearReconnectTimeout() {\n        if (this._reconnectTimeout !== null) {\n            clearTimeout(this._reconnectTimeout);\n            this._reconnectTimeout = null;\n        }\n    }\n    _clearServerPingTimeout() {\n        if (this._serverPingTimeout !== null) {\n            clearTimeout(this._serverPingTimeout);\n            this._serverPingTimeout = null;\n        }\n    }\n    _waitServerPing() {\n        if (this._config.maxServerPingDelay === 0) {\n            return;\n        }\n        if (!this._isConnected()) {\n            return;\n        }\n        this._clearServerPingTimeout();\n        this._serverPingTimeout = setTimeout(() => {\n            if (!this._isConnected()) {\n                return;\n            }\n            this._disconnect(codes_1.connectingCodes.noPing, 'no ping', true);\n        }, this._serverPing + this._config.maxServerPingDelay);\n    }\n    _getSubscribeContext(channel, result) {\n        const ctx = {\n            channel: channel,\n            positioned: false,\n            recoverable: false,\n            wasRecovering: false,\n            recovered: false\n        };\n        if (result.recovered) {\n            ctx.recovered = true;\n        }\n        if (result.positioned) {\n            ctx.positioned = true;\n        }\n        if (result.recoverable) {\n            ctx.recoverable = true;\n        }\n        if (result.was_recovering) {\n            ctx.wasRecovering = true;\n        }\n        let epoch = '';\n        if ('epoch' in result) {\n            epoch = result.epoch;\n        }\n        let offset = 0;\n        if ('offset' in result) {\n            offset = result.offset;\n        }\n        if (ctx.positioned || ctx.recoverable) {\n            ctx.streamPosition = {\n                'offset': offset,\n                'epoch': epoch\n            };\n        }\n        if (result.data) {\n            ctx.data = result.data;\n        }\n        return ctx;\n    }\n    _handleReply(reply, next) {\n        const id = reply.id;\n        if (!(id in this._callbacks)) {\n            next();\n            return;\n        }\n        const callbacks = this._callbacks[id];\n        clearTimeout(this._callbacks[id].timeout);\n        delete this._callbacks[id];\n        if (!(0, utils_1.errorExists)(reply)) {\n            const callback = callbacks.callback;\n            if (!callback) {\n                return;\n            }\n            callback({ reply, next });\n        }\n        else {\n            const errback = callbacks.errback;\n            if (!errback) {\n                next();\n                return;\n            }\n            const error = reply.error;\n            errback({ error, next });\n        }\n    }\n    _handleJoin(channel, join) {\n        const sub = this._getSub(channel);\n        if (!sub) {\n            if (this._isServerSub(channel)) {\n                const ctx = { channel: channel, info: this._getJoinLeaveContext(join.info) };\n                this.emit('join', ctx);\n            }\n            return;\n        }\n        // @ts-ignore – we are hiding some symbols from public API autocompletion.\n        sub._handleJoin(join);\n    }\n    _handleLeave(channel, leave) {\n        const sub = this._getSub(channel);\n        if (!sub) {\n            if (this._isServerSub(channel)) {\n                const ctx = { channel: channel, info: this._getJoinLeaveContext(leave.info) };\n                this.emit('leave', ctx);\n            }\n            return;\n        }\n        // @ts-ignore – we are hiding some symbols from public API autocompletion.\n        sub._handleLeave(leave);\n    }\n    _handleUnsubscribe(channel, unsubscribe) {\n        const sub = this._getSub(channel);\n        if (!sub) {\n            if (this._isServerSub(channel)) {\n                delete this._serverSubs[channel];\n                this.emit('unsubscribed', { channel: channel });\n            }\n            return;\n        }\n        if (unsubscribe.code < 2500) {\n            // @ts-ignore – we are hiding some symbols from public API autocompletion.\n            sub._setUnsubscribed(unsubscribe.code, unsubscribe.reason, false);\n        }\n        else {\n            // @ts-ignore – we are hiding some symbols from public API autocompletion.\n            sub._setSubscribing(unsubscribe.code, unsubscribe.reason);\n        }\n    }\n    _handleSubscribe(channel, sub) {\n        this._serverSubs[channel] = {\n            'offset': sub.offset,\n            'epoch': sub.epoch,\n            'recoverable': sub.recoverable || false\n        };\n        this.emit('subscribed', this._getSubscribeContext(channel, sub));\n    }\n    _handleDisconnect(disconnect) {\n        const code = disconnect.code;\n        let reconnect = true;\n        if ((code >= 3500 && code < 4000) || (code >= 4500 && code < 5000)) {\n            reconnect = false;\n        }\n        this._disconnect(code, disconnect.reason, reconnect);\n    }\n    _getPublicationContext(channel, pub) {\n        const ctx = {\n            channel: channel,\n            data: pub.data\n        };\n        if (pub.offset) {\n            ctx.offset = pub.offset;\n        }\n        if (pub.info) {\n            ctx.info = this._getJoinLeaveContext(pub.info);\n        }\n        if (pub.tags) {\n            ctx.tags = pub.tags;\n        }\n        return ctx;\n    }\n    _getJoinLeaveContext(clientInfo) {\n        const info = {\n            client: clientInfo.client,\n            user: clientInfo.user\n        };\n        if (clientInfo.conn_info) {\n            info.connInfo = clientInfo.conn_info;\n        }\n        if (clientInfo.chan_info) {\n            info.chanInfo = clientInfo.chan_info;\n        }\n        return info;\n    }\n    _handlePublication(channel, pub) {\n        const sub = this._getSub(channel);\n        if (!sub) {\n            if (this._isServerSub(channel)) {\n                const ctx = this._getPublicationContext(channel, pub);\n                this.emit('publication', ctx);\n                if (pub.offset !== undefined) {\n                    this._serverSubs[channel].offset = pub.offset;\n                }\n            }\n            return;\n        }\n        // @ts-ignore – we are hiding some symbols from public API autocompletion.\n        sub._handlePublication(pub);\n    }\n    _handleMessage(message) {\n        this.emit('message', { data: message.data });\n    }\n    _handleServerPing(next) {\n        if (this._sendPong) {\n            const cmd = {};\n            this._transportSendCommands([cmd]);\n        }\n        next();\n    }\n    _handlePush(data, next) {\n        const channel = data.channel;\n        if (data.pub) {\n            this._handlePublication(channel, data.pub);\n        }\n        else if (data.message) {\n            this._handleMessage(data.message);\n        }\n        else if (data.join) {\n            this._handleJoin(channel, data.join);\n        }\n        else if (data.leave) {\n            this._handleLeave(channel, data.leave);\n        }\n        else if (data.unsubscribe) {\n            this._handleUnsubscribe(channel, data.unsubscribe);\n        }\n        else if (data.subscribe) {\n            this._handleSubscribe(channel, data.subscribe);\n        }\n        else if (data.disconnect) {\n            this._handleDisconnect(data.disconnect);\n        }\n        next();\n    }\n    _flush() {\n        const commands = this._commands.slice(0);\n        this._commands = [];\n        this._transportSendCommands(commands);\n    }\n    _createErrorObject(code, message, temporary) {\n        const errObject = {\n            code: code,\n            message: message\n        };\n        if (temporary) {\n            errObject.temporary = true;\n        }\n        return errObject;\n    }\n    _registerCall(id, callback, errback) {\n        this._callbacks[id] = {\n            callback: callback,\n            errback: errback,\n            timeout: null\n        };\n        this._callbacks[id].timeout = setTimeout(() => {\n            delete this._callbacks[id];\n            if ((0, utils_1.isFunction)(errback)) {\n                errback({ error: this._createErrorObject(codes_1.errorCodes.timeout, 'timeout') });\n            }\n        }, this._config.timeout);\n    }\n    _addCommand(command) {\n        if (this._batching) {\n            this._commands.push(command);\n        }\n        else {\n            this._transportSendCommands([command]);\n        }\n    }\n    _nextPromiseId() {\n        return ++this._promiseId;\n    }\n    _resolvePromises() {\n        for (const id in this._promises) {\n            if (this._promises[id].timeout) {\n                clearTimeout(this._promises[id].timeout);\n            }\n            this._promises[id].resolve();\n            delete this._promises[id];\n        }\n    }\n    _rejectPromises(err) {\n        for (const id in this._promises) {\n            if (this._promises[id].timeout) {\n                clearTimeout(this._promises[id].timeout);\n            }\n            this._promises[id].reject(err);\n            delete this._promises[id];\n        }\n    }\n}\nexports.Centrifuge = Centrifuge;\nCentrifuge.SubscriptionState = types_1.SubscriptionState;\nCentrifuge.State = types_1.State;\n//# sourceMappingURL=centrifuge.js.map","\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.unsubscribedCodes = exports.subscribingCodes = exports.disconnectedCodes = exports.connectingCodes = exports.errorCodes = void 0;\nexports.errorCodes = {\n    timeout: 1,\n    transportClosed: 2,\n    clientDisconnected: 3,\n    clientClosed: 4,\n    clientConnectToken: 5,\n    clientRefreshToken: 6,\n    subscriptionUnsubscribed: 7,\n    subscriptionSubscribeToken: 8,\n    subscriptionRefreshToken: 9,\n    transportWriteError: 10,\n    connectionClosed: 11\n};\nexports.connectingCodes = {\n    connectCalled: 0,\n    transportClosed: 1,\n    noPing: 2,\n    subscribeTimeout: 3,\n    unsubscribeError: 4\n};\nexports.disconnectedCodes = {\n    disconnectCalled: 0,\n    unauthorized: 1,\n    badProtocol: 2,\n    messageSizeLimit: 3\n};\nexports.subscribingCodes = {\n    subscribeCalled: 0,\n    transportClosed: 1\n};\nexports.unsubscribedCodes = {\n    unsubscribeCalled: 0,\n    unauthorized: 1,\n    clientClosed: 2\n};\n//# sourceMappingURL=codes.js.map","\"use strict\";\nvar __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {\n    if (k2 === undefined) k2 = k;\n    var desc = Object.getOwnPropertyDescriptor(m, k);\n    if (!desc || (\"get\" in desc ? !m.__esModule : desc.writable || desc.configurable)) {\n      desc = { enumerable: true, get: function() { return m[k]; } };\n    }\n    Object.defineProperty(o, k2, desc);\n}) : (function(o, m, k, k2) {\n    if (k2 === undefined) k2 = k;\n    o[k2] = m[k];\n}));\nvar __exportStar = (this && this.__exportStar) || function(m, exports) {\n    for (var p in m) if (p !== \"default\" && !Object.prototype.hasOwnProperty.call(exports, p)) __createBinding(exports, m, p);\n};\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.Subscription = exports.Centrifuge = void 0;\nconst centrifuge_1 = require(\"./centrifuge\");\nObject.defineProperty(exports, \"Centrifuge\", { enumerable: true, get: function () { return centrifuge_1.Centrifuge; } });\nconst subscription_1 = require(\"./subscription\");\nObject.defineProperty(exports, \"Subscription\", { enumerable: true, get: function () { return subscription_1.Subscription; } });\n__exportStar(require(\"./types\"), exports);\n//# sourceMappingURL=index.js.map","\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.JsonDecoder = exports.JsonEncoder = void 0;\n/** @internal */\nclass JsonEncoder {\n    encodeCommands(commands) {\n        return commands.map(c => JSON.stringify(c)).join('\\n');\n    }\n}\nexports.JsonEncoder = JsonEncoder;\n/** @internal */\nclass JsonDecoder {\n    decodeReplies(data) {\n        return data.trim().split('\\n').map(r => JSON.parse(r));\n    }\n}\nexports.JsonDecoder = JsonDecoder;\n//# sourceMappingURL=json.js.map","\"use strict\";\nvar __importDefault = (this && this.__importDefault) || function (mod) {\n    return (mod && mod.__esModule) ? mod : { \"default\": mod };\n};\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.Subscription = void 0;\nconst events_1 = __importDefault(require(\"events\"));\nconst codes_1 = require(\"./codes\");\nconst types_1 = require(\"./types\");\nconst utils_1 = require(\"./utils\");\n/** Subscription to a channel */\nclass Subscription extends events_1.default {\n    /** Subscription constructor should not be used directly, create subscriptions using Client method. */\n    constructor(centrifuge, channel, options) {\n        super();\n        this._resubscribeTimeout = null;\n        this._refreshTimeout = null;\n        this.channel = channel;\n        this.state = types_1.SubscriptionState.Unsubscribed;\n        this._centrifuge = centrifuge;\n        this._token = null;\n        this._getToken = null;\n        this._data = null;\n        this._recover = false;\n        this._offset = null;\n        this._epoch = null;\n        this._recoverable = false;\n        this._positioned = false;\n        this._joinLeave = false;\n        this._minResubscribeDelay = 500;\n        this._maxResubscribeDelay = 20000;\n        this._resubscribeTimeout = null;\n        this._resubscribeAttempts = 0;\n        this._promises = {};\n        this._promiseId = 0;\n        this._inflight = false;\n        this._refreshTimeout = null;\n        this._setOptions(options);\n        // @ts-ignore – we are hiding some symbols from public API autocompletion.\n        if (this._centrifuge._debugEnabled) {\n            this.on('state', (ctx) => {\n                // @ts-ignore – we are hiding some symbols from public API autocompletion.\n                this._centrifuge._debug('subscription state', channel, ctx.oldState, '->', ctx.newState);\n            });\n            this.on('error', (ctx) => {\n                // @ts-ignore – we are hiding some symbols from public API autocompletion.\n                this._centrifuge._debug('subscription error', channel, ctx);\n            });\n        }\n        else {\n            // Avoid unhandled exception in EventEmitter for non-set error handler.\n            this.on('error', function () { Function.prototype(); });\n        }\n    }\n    /** ready returns a Promise which resolves upon subscription goes to Subscribed\n     * state and rejects in case of subscription goes to Unsubscribed state.\n     * Optional timeout can be passed.*/\n    ready(timeout) {\n        if (this.state === types_1.SubscriptionState.Unsubscribed) {\n            return Promise.reject({ code: codes_1.errorCodes.subscriptionUnsubscribed, message: this.state });\n        }\n        if (this.state === types_1.SubscriptionState.Subscribed) {\n            return Promise.resolve();\n        }\n        return new Promise((res, rej) => {\n            const ctx = {\n                resolve: res,\n                reject: rej\n            };\n            if (timeout) {\n                ctx.timeout = setTimeout(function () {\n                    rej({ code: codes_1.errorCodes.timeout, message: 'timeout' });\n                }, timeout);\n            }\n            this._promises[this._nextPromiseId()] = ctx;\n        });\n    }\n    /** subscribe to a channel.*/\n    subscribe() {\n        if (this._isSubscribed()) {\n            return;\n        }\n        this._resubscribeAttempts = 0;\n        this._setSubscribing(codes_1.subscribingCodes.subscribeCalled, 'subscribe called');\n    }\n    /** unsubscribe from a channel, keeping position state.*/\n    unsubscribe() {\n        this._setUnsubscribed(codes_1.unsubscribedCodes.unsubscribeCalled, 'unsubscribe called', true);\n    }\n    /** publish data to a channel.*/\n    publish(data) {\n        const self = this;\n        return this._methodCall().then(function () {\n            return self._centrifuge.publish(self.channel, data);\n        });\n    }\n    /** get online presence for a channel.*/\n    presence() {\n        const self = this;\n        return this._methodCall().then(function () {\n            return self._centrifuge.presence(self.channel);\n        });\n    }\n    /** presence stats for a channel (num clients and unique users).*/\n    presenceStats() {\n        const self = this;\n        return this._methodCall().then(function () {\n            return self._centrifuge.presenceStats(self.channel);\n        });\n    }\n    /** history for a channel. By default it does not return publications (only current\n     *  StreamPosition data) – provide an explicit limit > 0 to load publications.*/\n    history(opts) {\n        const self = this;\n        return this._methodCall().then(function () {\n            return self._centrifuge.history(self.channel, opts);\n        });\n    }\n    _methodCall() {\n        if (this._isSubscribed()) {\n            return Promise.resolve();\n        }\n        if (this._isUnsubscribed()) {\n            return Promise.reject({ code: codes_1.errorCodes.subscriptionUnsubscribed, message: this.state });\n        }\n        return new Promise((res, rej) => {\n            const timeout = setTimeout(function () {\n                rej({ code: codes_1.errorCodes.timeout, message: 'timeout' });\n                // @ts-ignore – we are hiding some symbols from public API autocompletion.\n            }, this._centrifuge._config.timeout);\n            this._promises[this._nextPromiseId()] = {\n                timeout: timeout,\n                resolve: res,\n                reject: rej\n            };\n        });\n    }\n    _nextPromiseId() {\n        return ++this._promiseId;\n    }\n    _needRecover() {\n        return this._recover === true;\n    }\n    _isUnsubscribed() {\n        return this.state === types_1.SubscriptionState.Unsubscribed;\n    }\n    _isSubscribing() {\n        return this.state === types_1.SubscriptionState.Subscribing;\n    }\n    _isSubscribed() {\n        return this.state === types_1.SubscriptionState.Subscribed;\n    }\n    _setState(newState) {\n        if (this.state !== newState) {\n            const oldState = this.state;\n            this.state = newState;\n            this.emit('state', { newState, oldState, channel: this.channel });\n            return true;\n        }\n        return false;\n    }\n    _usesToken() {\n        return this._token !== null || this._getToken !== null;\n    }\n    _clearSubscribingState() {\n        this._resubscribeAttempts = 0;\n        this._clearResubscribeTimeout();\n    }\n    _clearSubscribedState() {\n        this._clearRefreshTimeout();\n    }\n    _setSubscribed(result) {\n        if (!this._isSubscribing()) {\n            return;\n        }\n        this._clearSubscribingState();\n        if (result.recoverable) {\n            this._recover = true;\n            this._offset = result.offset || 0;\n            this._epoch = result.epoch || '';\n        }\n        this._setState(types_1.SubscriptionState.Subscribed);\n        // @ts-ignore – we are hiding some methods from public API autocompletion.\n        const ctx = this._centrifuge._getSubscribeContext(this.channel, result);\n        this.emit('subscribed', ctx);\n        this._resolvePromises();\n        const pubs = result.publications;\n        if (pubs && pubs.length > 0) {\n            for (const i in pubs) {\n                if (!pubs.hasOwnProperty(i)) {\n                    continue;\n                }\n                this._handlePublication(pubs[i]);\n            }\n        }\n        if (result.expires === true) {\n            this._refreshTimeout = setTimeout(() => this._refresh(), (0, utils_1.ttlMilliseconds)(result.ttl));\n        }\n    }\n    _setSubscribing(code, reason) {\n        if (this._isSubscribing()) {\n            return;\n        }\n        if (this._isSubscribed()) {\n            this._clearSubscribedState();\n        }\n        if (this._setState(types_1.SubscriptionState.Subscribing)) {\n            this.emit('subscribing', { channel: this.channel, code: code, reason: reason });\n        }\n        this._subscribe(false, false);\n    }\n    _subscribe(optimistic, skipSending) {\n        // @ts-ignore – we are hiding some symbols from public API autocompletion.\n        this._centrifuge._debug('subscribing on', this.channel);\n        if (this._centrifuge.state !== types_1.State.Connected && !optimistic) {\n            // @ts-ignore – we are hiding some symbols from public API autocompletion.\n            this._centrifuge._debug('delay subscribe on', this.channel, 'till connected');\n            // subscribe will be called later automatically.\n            return null;\n        }\n        if (this._usesToken()) {\n            // token channel, need to get token before sending subscribe.\n            if (this._token) {\n                return this._sendSubscribe(this._token, skipSending);\n            }\n            else {\n                if (optimistic) {\n                    return null;\n                }\n                const self = this;\n                this._getSubscriptionToken().then(function (token) {\n                    if (!self._isSubscribing()) {\n                        return;\n                    }\n                    if (!token) {\n                        self._failUnauthorized();\n                        return;\n                    }\n                    self._token = token;\n                    self._sendSubscribe(token, false);\n                }).catch(function (e) {\n                    if (!self._isSubscribing()) {\n                        return;\n                    }\n                    self.emit('error', {\n                        type: 'subscribeToken',\n                        channel: self.channel,\n                        error: {\n                            code: codes_1.errorCodes.subscriptionSubscribeToken,\n                            message: e !== undefined ? e.toString() : ''\n                        }\n                    });\n                    self._scheduleResubscribe();\n                });\n                return null;\n            }\n        }\n        else {\n            return this._sendSubscribe('', skipSending);\n        }\n    }\n    _sendSubscribe(token, skipSending) {\n        const channel = this.channel;\n        const req = {\n            channel: channel\n        };\n        if (token) {\n            req.token = token;\n        }\n        if (this._data) {\n            req.data = this._data;\n        }\n        if (this._positioned) {\n            req.positioned = true;\n        }\n        if (this._recoverable) {\n            req.recoverable = true;\n        }\n        if (this._joinLeave) {\n            req.join_leave = true;\n        }\n        if (this._needRecover()) {\n            req.recover = true;\n            const offset = this._getOffset();\n            if (offset) {\n                req.offset = offset;\n            }\n            const epoch = this._getEpoch();\n            if (epoch) {\n                req.epoch = epoch;\n            }\n        }\n        const cmd = { subscribe: req };\n        this._inflight = true;\n        // @ts-ignore – we are hiding some symbols from public API autocompletion.\n        this._centrifuge._call(cmd, skipSending).then(resolveCtx => {\n            this._inflight = false;\n            // @ts-ignore - improve later.\n            const result = resolveCtx.reply.subscribe;\n            this._handleSubscribeResponse(result);\n            // @ts-ignore - improve later.\n            if (resolveCtx.next) {\n                // @ts-ignore - improve later.\n                resolveCtx.next();\n            }\n        }, rejectCtx => {\n            this._inflight = false;\n            this._handleSubscribeError(rejectCtx.error);\n            if (rejectCtx.next) {\n                rejectCtx.next();\n            }\n        });\n        return cmd;\n    }\n    _handleSubscribeError(error) {\n        if (!this._isSubscribing()) {\n            return;\n        }\n        if (error.code === codes_1.errorCodes.timeout) {\n            // @ts-ignore – we are hiding some symbols from public API autocompletion.\n            this._centrifuge._disconnect(codes_1.connectingCodes.subscribeTimeout, 'subscribe timeout', true);\n            return;\n        }\n        this._subscribeError(error);\n    }\n    _handleSubscribeResponse(result) {\n        if (!this._isSubscribing()) {\n            return;\n        }\n        this._setSubscribed(result);\n    }\n    _setUnsubscribed(code, reason, sendUnsubscribe) {\n        if (this._isUnsubscribed()) {\n            return;\n        }\n        if (this._isSubscribed()) {\n            if (sendUnsubscribe) {\n                // @ts-ignore – we are hiding some methods from public API autocompletion.\n                this._centrifuge._unsubscribe(this);\n            }\n            this._clearSubscribedState();\n        }\n        if (this._isSubscribing()) {\n            this._clearSubscribingState();\n        }\n        if (this._setState(types_1.SubscriptionState.Unsubscribed)) {\n            this.emit('unsubscribed', { channel: this.channel, code: code, reason: reason });\n        }\n        this._rejectPromises({ code: codes_1.errorCodes.subscriptionUnsubscribed, message: this.state });\n    }\n    _handlePublication(pub) {\n        // @ts-ignore – we are hiding some methods from public API autocompletion.\n        const ctx = this._centrifuge._getPublicationContext(this.channel, pub);\n        this.emit('publication', ctx);\n        if (pub.offset) {\n            this._offset = pub.offset;\n        }\n    }\n    _handleJoin(join) {\n        // @ts-ignore – we are hiding some methods from public API autocompletion.\n        const info = this._centrifuge._getJoinLeaveContext(join.info);\n        this.emit('join', { channel: this.channel, info: info });\n    }\n    _handleLeave(leave) {\n        // @ts-ignore – we are hiding some methods from public API autocompletion.\n        const info = this._centrifuge._getJoinLeaveContext(leave.info);\n        this.emit('leave', { channel: this.channel, info: info });\n    }\n    _resolvePromises() {\n        for (const id in this._promises) {\n            if (this._promises[id].timeout) {\n                clearTimeout(this._promises[id].timeout);\n            }\n            this._promises[id].resolve();\n            delete this._promises[id];\n        }\n    }\n    _rejectPromises(err) {\n        for (const id in this._promises) {\n            if (this._promises[id].timeout) {\n                clearTimeout(this._promises[id].timeout);\n            }\n            this._promises[id].reject(err);\n            delete this._promises[id];\n        }\n    }\n    _scheduleResubscribe() {\n        const self = this;\n        const delay = this._getResubscribeDelay();\n        this._resubscribeTimeout = setTimeout(function () {\n            if (self._isSubscribing()) {\n                self._subscribe(false, false);\n            }\n        }, delay);\n    }\n    _subscribeError(err) {\n        if (!this._isSubscribing()) {\n            return;\n        }\n        if (err.code < 100 || err.code === 109 || err.temporary === true) {\n            if (err.code === 109) { // Token expired error.\n                this._token = null;\n            }\n            const errContext = {\n                channel: this.channel,\n                type: 'subscribe',\n                error: err\n            };\n            if (this._centrifuge.state === types_1.State.Connected) {\n                this.emit('error', errContext);\n            }\n            this._scheduleResubscribe();\n        }\n        else {\n            this._setUnsubscribed(err.code, err.message, false);\n        }\n    }\n    _getResubscribeDelay() {\n        const delay = (0, utils_1.backoff)(this._resubscribeAttempts, this._minResubscribeDelay, this._maxResubscribeDelay);\n        this._resubscribeAttempts++;\n        return delay;\n    }\n    _setOptions(options) {\n        if (!options) {\n            return;\n        }\n        if (options.since) {\n            this._offset = options.since.offset;\n            this._epoch = options.since.epoch;\n            this._recover = true;\n        }\n        if (options.data) {\n            this._data = options.data;\n        }\n        if (options.minResubscribeDelay !== undefined) {\n            this._minResubscribeDelay = options.minResubscribeDelay;\n        }\n        if (options.maxResubscribeDelay !== undefined) {\n            this._maxResubscribeDelay = options.maxResubscribeDelay;\n        }\n        if (options.token) {\n            this._token = options.token;\n        }\n        if (options.getToken) {\n            this._getToken = options.getToken;\n        }\n        if (options.positioned === true) {\n            this._positioned = true;\n        }\n        if (options.recoverable === true) {\n            this._recoverable = true;\n        }\n        if (options.joinLeave === true) {\n            this._joinLeave = true;\n        }\n    }\n    _getOffset() {\n        const offset = this._offset;\n        if (offset !== null) {\n            return offset;\n        }\n        return 0;\n    }\n    _getEpoch() {\n        const epoch = this._epoch;\n        if (epoch !== null) {\n            return epoch;\n        }\n        return '';\n    }\n    _clearRefreshTimeout() {\n        if (this._refreshTimeout !== null) {\n            clearTimeout(this._refreshTimeout);\n            this._refreshTimeout = null;\n        }\n    }\n    _clearResubscribeTimeout() {\n        if (this._resubscribeTimeout !== null) {\n            clearTimeout(this._resubscribeTimeout);\n            this._resubscribeTimeout = null;\n        }\n    }\n    _getSubscriptionToken() {\n        // @ts-ignore – we are hiding some methods from public API autocompletion.\n        this._centrifuge._debug('get subscription token for channel', this.channel);\n        const ctx = {\n            channel: this.channel\n        };\n        const getToken = this._getToken;\n        if (getToken === null) {\n            throw new Error('provide a function to get channel subscription token');\n        }\n        return getToken(ctx);\n    }\n    _refresh() {\n        this._clearRefreshTimeout();\n        const self = this;\n        this._getSubscriptionToken().then(function (token) {\n            if (!self._isSubscribed()) {\n                return;\n            }\n            if (!token) {\n                self._failUnauthorized();\n                return;\n            }\n            self._token = token;\n            const req = {\n                channel: self.channel,\n                token: token\n            };\n            const msg = {\n                'sub_refresh': req\n            };\n            // @ts-ignore – we are hiding some symbols from public API autocompletion.\n            self._centrifuge._call(msg).then(resolveCtx => {\n                // @ts-ignore - improve later.\n                const result = resolveCtx.reply.sub_refresh;\n                self._refreshResponse(result);\n                // @ts-ignore - improve later.\n                if (resolveCtx.next) {\n                    // @ts-ignore - improve later.\n                    resolveCtx.next();\n                }\n            }, rejectCtx => {\n                self._refreshError(rejectCtx.error);\n                if (rejectCtx.next) {\n                    rejectCtx.next();\n                }\n            });\n        }).catch(function (e) {\n            self.emit('error', {\n                type: 'refreshToken',\n                channel: self.channel,\n                error: {\n                    code: codes_1.errorCodes.subscriptionRefreshToken,\n                    message: e !== undefined ? e.toString() : ''\n                }\n            });\n            self._refreshTimeout = setTimeout(() => self._refresh(), self._getRefreshRetryDelay());\n        });\n    }\n    _refreshResponse(result) {\n        if (!this._isSubscribed()) {\n            return;\n        }\n        // @ts-ignore – we are hiding some methods from public API autocompletion.\n        this._centrifuge._debug('subscription token refreshed, channel', this.channel);\n        this._clearRefreshTimeout();\n        if (result.expires === true) {\n            this._refreshTimeout = setTimeout(() => this._refresh(), (0, utils_1.ttlMilliseconds)(result.ttl));\n        }\n    }\n    _refreshError(err) {\n        if (!this._isSubscribed()) {\n            return;\n        }\n        if (err.code < 100 || err.temporary === true) {\n            this.emit('error', {\n                type: 'refresh',\n                channel: this.channel,\n                error: err\n            });\n            this._refreshTimeout = setTimeout(() => this._refresh(), this._getRefreshRetryDelay());\n        }\n        else {\n            this._setUnsubscribed(err.code, err.message, true);\n        }\n    }\n    _getRefreshRetryDelay() {\n        return (0, utils_1.backoff)(0, 10000, 20000);\n    }\n    _failUnauthorized() {\n        this._setUnsubscribed(codes_1.unsubscribedCodes.unauthorized, 'unauthorized', true);\n    }\n}\nexports.Subscription = Subscription;\n//# sourceMappingURL=subscription.js.map","\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.HttpStreamTransport = void 0;\n/** @internal */\nclass HttpStreamTransport {\n    constructor(endpoint, options) {\n        this.endpoint = endpoint;\n        this.options = options;\n        this._abortController = null;\n        this._utf8decoder = new TextDecoder();\n        this._protocol = 'json';\n    }\n    name() {\n        return 'http_stream';\n    }\n    subName() {\n        return 'http_stream';\n    }\n    emulation() {\n        return true;\n    }\n    _handleErrors(response) {\n        if (!response.ok)\n            throw new Error(response.status);\n        return response;\n    }\n    _fetchEventTarget(self, endpoint, options) {\n        const eventTarget = new EventTarget();\n        // fetch with connection timeout maybe? https://github.com/github/fetch/issues/175\n        const fetchFunc = self.options.fetch;\n        fetchFunc(endpoint, options)\n            .then(self._handleErrors)\n            .then(response => {\n            eventTarget.dispatchEvent(new Event('open'));\n            let jsonStreamBuf = '';\n            let jsonStreamPos = 0;\n            let protoStreamBuf = new Uint8Array();\n            const reader = response.body.getReader();\n            return new self.options.readableStream({\n                start(controller) {\n                    function pump() {\n                        return reader.read().then(({ done, value }) => {\n                            // When no more data needs to be consumed, close the stream\n                            if (done) {\n                                eventTarget.dispatchEvent(new Event('close'));\n                                controller.close();\n                                return;\n                            }\n                            try {\n                                if (self._protocol === 'json') {\n                                    jsonStreamBuf += self._utf8decoder.decode(value);\n                                    while (jsonStreamPos < jsonStreamBuf.length) {\n                                        if (jsonStreamBuf[jsonStreamPos] === '\\n') {\n                                            const line = jsonStreamBuf.substring(0, jsonStreamPos);\n                                            eventTarget.dispatchEvent(new MessageEvent('message', { data: line }));\n                                            jsonStreamBuf = jsonStreamBuf.substring(jsonStreamPos + 1);\n                                            jsonStreamPos = 0;\n                                        }\n                                        else {\n                                            ++jsonStreamPos;\n                                        }\n                                    }\n                                }\n                                else {\n                                    const mergedArray = new Uint8Array(protoStreamBuf.length + value.length);\n                                    mergedArray.set(protoStreamBuf);\n                                    mergedArray.set(value, protoStreamBuf.length);\n                                    protoStreamBuf = mergedArray;\n                                    while (true) {\n                                        const result = self.options.decoder.decodeReply(protoStreamBuf);\n                                        if (result.ok) {\n                                            const data = protoStreamBuf.slice(0, result.pos);\n                                            eventTarget.dispatchEvent(new MessageEvent('message', { data: data }));\n                                            protoStreamBuf = protoStreamBuf.slice(result.pos);\n                                            continue;\n                                        }\n                                        break;\n                                    }\n                                }\n                            }\n                            catch (error) {\n                                // @ts-ignore - improve later.\n                                eventTarget.dispatchEvent(new Event('error', { detail: error }));\n                                eventTarget.dispatchEvent(new Event('close'));\n                                controller.close();\n                                return;\n                            }\n                            pump();\n                        }).catch(function (e) {\n                            // @ts-ignore - improve later.\n                            eventTarget.dispatchEvent(new Event('error', { detail: e }));\n                            eventTarget.dispatchEvent(new Event('close'));\n                            controller.close();\n                            return;\n                        });\n                    }\n                    return pump();\n                }\n            });\n        })\n            .catch(error => {\n            // @ts-ignore - improve later.\n            eventTarget.dispatchEvent(new Event('error', { detail: error }));\n            eventTarget.dispatchEvent(new Event('close'));\n        });\n        return eventTarget;\n    }\n    supported() {\n        return this.options.fetch !== null &&\n            this.options.readableStream !== null &&\n            typeof TextDecoder !== 'undefined' &&\n            typeof AbortController !== 'undefined' &&\n            typeof EventTarget !== 'undefined' &&\n            typeof Event !== 'undefined' &&\n            typeof MessageEvent !== 'undefined' &&\n            typeof Error !== 'undefined';\n    }\n    initialize(protocol, callbacks, initialData) {\n        this._protocol = protocol;\n        this._abortController = new AbortController();\n        let headers;\n        let body;\n        if (protocol === 'json') {\n            headers = {\n                'Accept': 'application/json',\n                'Content-Type': 'application/json'\n            };\n            body = initialData;\n        }\n        else {\n            headers = {\n                'Accept': 'application/octet-stream',\n                'Content-Type': 'application/octet-stream'\n            };\n            body = initialData;\n        }\n        const fetchOptions = {\n            method: 'POST',\n            headers: headers,\n            body: body,\n            mode: 'cors',\n            credentials: 'same-origin',\n            cache: 'no-cache',\n            signal: this._abortController.signal\n        };\n        const eventTarget = this._fetchEventTarget(this, this.endpoint, fetchOptions);\n        eventTarget.addEventListener('open', () => {\n            callbacks.onOpen();\n        });\n        eventTarget.addEventListener('error', (e) => {\n            this._abortController.abort();\n            callbacks.onError(e);\n        });\n        eventTarget.addEventListener('close', () => {\n            this._abortController.abort();\n            callbacks.onClose({\n                code: 4,\n                reason: 'connection closed'\n            });\n        });\n        eventTarget.addEventListener('message', (e) => {\n            callbacks.onMessage(e.data);\n        });\n    }\n    close() {\n        this._abortController.abort();\n    }\n    send(data, session, node) {\n        let headers;\n        let body;\n        const req = {\n            session: session,\n            node: node,\n            data: data\n        };\n        if (this._protocol === 'json') {\n            headers = {\n                'Content-Type': 'application/json'\n            };\n            body = JSON.stringify(req);\n        }\n        else {\n            headers = {\n                'Content-Type': 'application/octet-stream'\n            };\n            body = this.options.encoder.encodeEmulationRequest(req);\n        }\n        const fetchFunc = this.options.fetch;\n        const fetchOptions = {\n            method: 'POST',\n            headers: headers,\n            body: body,\n            mode: 'cors',\n            credentials: 'same-origin',\n            cache: 'no-cache'\n        };\n        fetchFunc(this.options.emulationEndpoint, fetchOptions);\n    }\n}\nexports.HttpStreamTransport = HttpStreamTransport;\n//# sourceMappingURL=transport_http_stream.js.map","\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.SockjsTransport = void 0;\n/** @internal */\nclass SockjsTransport {\n    constructor(endpoint, options) {\n        this.endpoint = endpoint;\n        this.options = options;\n        this._transport = null;\n    }\n    name() {\n        return 'sockjs';\n    }\n    subName() {\n        return 'sockjs-' + this._transport.transport;\n    }\n    emulation() {\n        return false;\n    }\n    supported() {\n        return this.options.sockjs !== null;\n    }\n    initialize(_protocol, callbacks) {\n        this._transport = new this.options.sockjs(this.endpoint, null, this.options.sockjsOptions);\n        this._transport.onopen = () => {\n            callbacks.onOpen();\n        };\n        this._transport.onerror = e => {\n            callbacks.onError(e);\n        };\n        this._transport.onclose = closeEvent => {\n            callbacks.onClose(closeEvent);\n        };\n        this._transport.onmessage = event => {\n            callbacks.onMessage(event.data);\n        };\n    }\n    close() {\n        this._transport.close();\n    }\n    send(data) {\n        this._transport.send(data);\n    }\n}\nexports.SockjsTransport = SockjsTransport;\n//# sourceMappingURL=transport_sockjs.js.map","\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.SseTransport = void 0;\n/** @internal */\nclass SseTransport {\n    constructor(endpoint, options) {\n        this.endpoint = endpoint;\n        this.options = options;\n        this._protocol = 'json';\n        this._transport = null;\n        this._onClose = null;\n    }\n    name() {\n        return 'sse';\n    }\n    subName() {\n        return 'sse';\n    }\n    emulation() {\n        return true;\n    }\n    supported() {\n        return this.options.eventsource !== null && this.options.fetch !== null;\n    }\n    initialize(_protocol, callbacks, initialData) {\n        let url;\n        if (globalThis && globalThis.document && globalThis.document.baseURI) {\n            // Handle case when endpoint is relative, like //example.com/connection/sse\n            url = new URL(this.endpoint, globalThis.document.baseURI);\n        }\n        else {\n            url = new URL(this.endpoint);\n        }\n        url.searchParams.append('cf_connect', initialData);\n        const eventsourceOptions = {};\n        const eventSource = new this.options.eventsource(url.toString(), eventsourceOptions);\n        this._transport = eventSource;\n        const self = this;\n        eventSource.onopen = function () {\n            callbacks.onOpen();\n        };\n        eventSource.onerror = function (e) {\n            eventSource.close();\n            callbacks.onError(e);\n            callbacks.onClose({\n                code: 4,\n                reason: 'connection closed'\n            });\n        };\n        eventSource.onmessage = function (e) {\n            callbacks.onMessage(e.data);\n        };\n        self._onClose = function () {\n            callbacks.onClose({\n                code: 4,\n                reason: 'connection closed'\n            });\n        };\n    }\n    close() {\n        this._transport.close();\n        if (this._onClose !== null) {\n            this._onClose();\n        }\n    }\n    send(data, session, node) {\n        const req = {\n            session: session,\n            node: node,\n            data: data\n        };\n        const headers = {\n            'Content-Type': 'application/json'\n        };\n        const body = JSON.stringify(req);\n        const fetchFunc = this.options.fetch;\n        const fetchOptions = {\n            method: 'POST',\n            headers: headers,\n            body: body,\n            mode: 'cors',\n            credentials: 'same-origin',\n            cache: 'no-cache'\n        };\n        fetchFunc(this.options.emulationEndpoint, fetchOptions);\n    }\n}\nexports.SseTransport = SseTransport;\n//# sourceMappingURL=transport_sse.js.map","\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.WebsocketTransport = void 0;\n/** @internal */\nclass WebsocketTransport {\n    constructor(endpoint, options) {\n        this.endpoint = endpoint;\n        this.options = options;\n        this._transport = null;\n    }\n    name() {\n        return 'websocket';\n    }\n    subName() {\n        return 'websocket';\n    }\n    emulation() {\n        return false;\n    }\n    supported() {\n        return this.options.websocket !== undefined && this.options.websocket !== null;\n    }\n    initialize(protocol, callbacks) {\n        let subProtocol = '';\n        if (protocol === 'protobuf') {\n            subProtocol = 'centrifuge-protobuf';\n        }\n        if (subProtocol !== '') {\n            this._transport = new this.options.websocket(this.endpoint, subProtocol);\n        }\n        else {\n            this._transport = new this.options.websocket(this.endpoint);\n        }\n        if (protocol === 'protobuf') {\n            this._transport.binaryType = 'arraybuffer';\n        }\n        this._transport.onopen = () => {\n            callbacks.onOpen();\n        };\n        this._transport.onerror = e => {\n            callbacks.onError(e);\n        };\n        this._transport.onclose = closeEvent => {\n            callbacks.onClose(closeEvent);\n        };\n        this._transport.onmessage = event => {\n            callbacks.onMessage(event.data);\n        };\n    }\n    close() {\n        this._transport.close();\n    }\n    send(data) {\n        this._transport.send(data);\n    }\n}\nexports.WebsocketTransport = WebsocketTransport;\n//# sourceMappingURL=transport_websocket.js.map","\"use strict\";\nvar __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {\n    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }\n    return new (P || (P = Promise))(function (resolve, reject) {\n        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }\n        function rejected(value) { try { step(generator[\"throw\"](value)); } catch (e) { reject(e); } }\n        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }\n        step((generator = generator.apply(thisArg, _arguments || [])).next());\n    });\n};\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.WebtransportTransport = void 0;\n/** @internal */\nclass WebtransportTransport {\n    constructor(endpoint, options) {\n        this.endpoint = endpoint;\n        this.options = options;\n        this._transport = null;\n        this._stream = null;\n        this._writer = null;\n        this._utf8decoder = new TextDecoder();\n        this._protocol = 'json';\n    }\n    name() {\n        return 'webtransport';\n    }\n    subName() {\n        return 'webtransport';\n    }\n    emulation() {\n        return false;\n    }\n    supported() {\n        return this.options.webtransport !== undefined && this.options.webtransport !== null;\n    }\n    initialize(protocol, callbacks) {\n        return __awaiter(this, void 0, void 0, function* () {\n            let url;\n            if (globalThis && globalThis.document && globalThis.document.baseURI) {\n                // Handle case when endpoint is relative, like //example.com/connection/webtransport\n                url = new URL(this.endpoint, globalThis.document.baseURI);\n            }\n            else {\n                url = new URL(this.endpoint);\n            }\n            if (protocol === 'protobuf') {\n                url.searchParams.append('cf_protocol', 'protobuf');\n            }\n            this._protocol = protocol;\n            const eventTarget = new EventTarget();\n            this._transport = new this.options.webtransport(url.toString());\n            this._transport.closed.then(() => {\n                callbacks.onClose({\n                    code: 4,\n                    reason: 'connection closed'\n                });\n            }).catch(() => {\n                callbacks.onClose({\n                    code: 4,\n                    reason: 'connection closed'\n                });\n            });\n            try {\n                yield this._transport.ready;\n            }\n            catch (_a) {\n                this.close();\n                return;\n            }\n            let stream;\n            try {\n                stream = yield this._transport.createBidirectionalStream();\n            }\n            catch (_b) {\n                this.close();\n                return;\n            }\n            this._stream = stream;\n            this._writer = this._stream.writable.getWriter();\n            eventTarget.addEventListener('close', () => {\n                callbacks.onClose({\n                    code: 4,\n                    reason: 'connection closed'\n                });\n            });\n            eventTarget.addEventListener('message', (e) => {\n                callbacks.onMessage(e.data);\n            });\n            this._startReading(eventTarget);\n            callbacks.onOpen();\n        });\n    }\n    _startReading(eventTarget) {\n        return __awaiter(this, void 0, void 0, function* () {\n            const reader = this._stream.readable.getReader();\n            let jsonStreamBuf = '';\n            let jsonStreamPos = 0;\n            let protoStreamBuf = new Uint8Array();\n            try {\n                while (true) {\n                    const { done, value } = yield reader.read();\n                    if (value.length > 0) {\n                        if (this._protocol === 'json') {\n                            jsonStreamBuf += this._utf8decoder.decode(value);\n                            while (jsonStreamPos < jsonStreamBuf.length) {\n                                if (jsonStreamBuf[jsonStreamPos] === '\\n') {\n                                    const line = jsonStreamBuf.substring(0, jsonStreamPos);\n                                    eventTarget.dispatchEvent(new MessageEvent('message', { data: line }));\n                                    jsonStreamBuf = jsonStreamBuf.substring(jsonStreamPos + 1);\n                                    jsonStreamPos = 0;\n                                }\n                                else {\n                                    ++jsonStreamPos;\n                                }\n                            }\n                        }\n                        else {\n                            const mergedArray = new Uint8Array(protoStreamBuf.length + value.length);\n                            mergedArray.set(protoStreamBuf);\n                            mergedArray.set(value, protoStreamBuf.length);\n                            protoStreamBuf = mergedArray;\n                            while (true) {\n                                const result = this.options.decoder.decodeReply(protoStreamBuf);\n                                if (result.ok) {\n                                    const data = protoStreamBuf.slice(0, result.pos);\n                                    eventTarget.dispatchEvent(new MessageEvent('message', { data: data }));\n                                    protoStreamBuf = protoStreamBuf.slice(result.pos);\n                                    continue;\n                                }\n                                break;\n                            }\n                        }\n                    }\n                    if (done) {\n                        break;\n                    }\n                }\n            }\n            catch (_a) {\n                eventTarget.dispatchEvent(new Event('close'));\n            }\n        });\n    }\n    close() {\n        return __awaiter(this, void 0, void 0, function* () {\n            try {\n                if (this._writer) {\n                    yield this._writer.close();\n                }\n                this._transport.close();\n            }\n            catch (e) {\n                // already closed.\n            }\n        });\n    }\n    send(data) {\n        return __awaiter(this, void 0, void 0, function* () {\n            let binary;\n            if (this._protocol === 'json') {\n                // Need extra \\n since WT is non-frame protocol. \n                binary = new TextEncoder().encode(data + '\\n');\n            }\n            else {\n                binary = data;\n            }\n            try {\n                yield this._writer.write(binary);\n            }\n            catch (e) {\n                this.close();\n            }\n        });\n    }\n}\nexports.WebtransportTransport = WebtransportTransport;\n//# sourceMappingURL=transport_webtransport.js.map","\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.SubscriptionState = exports.State = void 0;\n/** State of client. */\nvar State;\n(function (State) {\n    State[\"Disconnected\"] = \"disconnected\";\n    State[\"Connecting\"] = \"connecting\";\n    State[\"Connected\"] = \"connected\";\n})(State = exports.State || (exports.State = {}));\n/** State of Subscription */\nvar SubscriptionState;\n(function (SubscriptionState) {\n    SubscriptionState[\"Unsubscribed\"] = \"unsubscribed\";\n    SubscriptionState[\"Subscribing\"] = \"subscribing\";\n    SubscriptionState[\"Subscribed\"] = \"subscribed\";\n})(SubscriptionState = exports.SubscriptionState || (exports.SubscriptionState = {}));\n//# sourceMappingURL=types.js.map","\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.ttlMilliseconds = exports.errorExists = exports.backoff = exports.log = exports.isFunction = exports.startsWith = void 0;\n/** @internal */\nfunction startsWith(value, prefix) {\n    return value.lastIndexOf(prefix, 0) === 0;\n}\nexports.startsWith = startsWith;\n/** @internal */\nfunction isFunction(value) {\n    if (value === undefined || value === null) {\n        return false;\n    }\n    return typeof value === 'function';\n}\nexports.isFunction = isFunction;\n/** @internal */\nfunction log(level, args) {\n    if (globalThis.console) {\n        const logger = globalThis.console[level];\n        if (isFunction(logger)) {\n            logger.apply(globalThis.console, args);\n        }\n    }\n}\nexports.log = log;\nfunction randomInt(min, max) {\n    return Math.floor(Math.random() * (max - min + 1) + min);\n}\n/** @internal */\nfunction backoff(step, min, max) {\n    // Full jitter technique, see:\n    // https://aws.amazon.com/blogs/architecture/exponential-backoff-and-jitter/\n    if (step > 31) {\n        step = 31;\n    }\n    const interval = randomInt(0, Math.min(max, min * Math.pow(2, step)));\n    return Math.min(max, min + interval);\n}\nexports.backoff = backoff;\n/** @internal */\nfunction errorExists(data) {\n    return 'error' in data && data.error !== null;\n}\nexports.errorExists = errorExists;\n/** @internal */\nfunction ttlMilliseconds(ttl) {\n    // https://stackoverflow.com/questions/12633405/what-is-the-maximum-delay-for-setinterval\n    return Math.min(ttl * 1000, 2147483647);\n}\nexports.ttlMilliseconds = ttlMilliseconds;\n//# sourceMappingURL=utils.js.map","// Copyright Joyent, Inc. and other Node contributors.\n//\n// Permission is hereby granted, free of charge, to any person obtaining a\n// copy of this software and associated documentation files (the\n// \"Software\"), to deal in the Software without restriction, including\n// without limitation the rights to use, copy, modify, merge, publish,\n// distribute, sublicense, and/or sell copies of the Software, and to permit\n// persons to whom the Software is furnished to do so, subject to the\n// following conditions:\n//\n// The above copyright notice and this permission notice shall be included\n// in all copies or substantial portions of the Software.\n//\n// THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS\n// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF\n// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN\n// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,\n// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR\n// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE\n// USE OR OTHER DEALINGS IN THE SOFTWARE.\n\n'use strict';\n\nvar R = typeof Reflect === 'object' ? Reflect : null\nvar ReflectApply = R && typeof R.apply === 'function'\n  ? R.apply\n  : function ReflectApply(target, receiver, args) {\n    return Function.prototype.apply.call(target, receiver, args);\n  }\n\nvar ReflectOwnKeys\nif (R && typeof R.ownKeys === 'function') {\n  ReflectOwnKeys = R.ownKeys\n} else if (Object.getOwnPropertySymbols) {\n  ReflectOwnKeys = function ReflectOwnKeys(target) {\n    return Object.getOwnPropertyNames(target)\n      .concat(Object.getOwnPropertySymbols(target));\n  };\n} else {\n  ReflectOwnKeys = function ReflectOwnKeys(target) {\n    return Object.getOwnPropertyNames(target);\n  };\n}\n\nfunction ProcessEmitWarning(warning) {\n  if (console && console.warn) console.warn(warning);\n}\n\nvar NumberIsNaN = Number.isNaN || function NumberIsNaN(value) {\n  return value !== value;\n}\n\nfunction EventEmitter() {\n  EventEmitter.init.call(this);\n}\nmodule.exports = EventEmitter;\nmodule.exports.once = once;\n\n// Backwards-compat with node 0.10.x\nEventEmitter.EventEmitter = EventEmitter;\n\nEventEmitter.prototype._events = undefined;\nEventEmitter.prototype._eventsCount = 0;\nEventEmitter.prototype._maxListeners = undefined;\n\n// By default EventEmitters will print a warning if more than 10 listeners are\n// added to it. This is a useful default which helps finding memory leaks.\nvar defaultMaxListeners = 10;\n\nfunction checkListener(listener) {\n  if (typeof listener !== 'function') {\n    throw new TypeError('The \"listener\" argument must be of type Function. Received type ' + typeof listener);\n  }\n}\n\nObject.defineProperty(EventEmitter, 'defaultMaxListeners', {\n  enumerable: true,\n  get: function() {\n    return defaultMaxListeners;\n  },\n  set: function(arg) {\n    if (typeof arg !== 'number' || arg < 0 || NumberIsNaN(arg)) {\n      throw new RangeError('The value of \"defaultMaxListeners\" is out of range. It must be a non-negative number. Received ' + arg + '.');\n    }\n    defaultMaxListeners = arg;\n  }\n});\n\nEventEmitter.init = function() {\n\n  if (this._events === undefined ||\n      this._events === Object.getPrototypeOf(this)._events) {\n    this._events = Object.create(null);\n    this._eventsCount = 0;\n  }\n\n  this._maxListeners = this._maxListeners || undefined;\n};\n\n// Obviously not all Emitters should be limited to 10. This function allows\n// that to be increased. Set to zero for unlimited.\nEventEmitter.prototype.setMaxListeners = function setMaxListeners(n) {\n  if (typeof n !== 'number' || n < 0 || NumberIsNaN(n)) {\n    throw new RangeError('The value of \"n\" is out of range. It must be a non-negative number. Received ' + n + '.');\n  }\n  this._maxListeners = n;\n  return this;\n};\n\nfunction _getMaxListeners(that) {\n  if (that._maxListeners === undefined)\n    return EventEmitter.defaultMaxListeners;\n  return that._maxListeners;\n}\n\nEventEmitter.prototype.getMaxListeners = function getMaxListeners() {\n  return _getMaxListeners(this);\n};\n\nEventEmitter.prototype.emit = function emit(type) {\n  var args = [];\n  for (var i = 1; i < arguments.length; i++) args.push(arguments[i]);\n  var doError = (type === 'error');\n\n  var events = this._events;\n  if (events !== undefined)\n    doError = (doError && events.error === undefined);\n  else if (!doError)\n    return false;\n\n  // If there is no 'error' event listener then throw.\n  if (doError) {\n    var er;\n    if (args.length > 0)\n      er = args[0];\n    if (er instanceof Error) {\n      // Note: The comments on the `throw` lines are intentional, they show\n      // up in Node's output if this results in an unhandled exception.\n      throw er; // Unhandled 'error' event\n    }\n    // At least give some kind of context to the user\n    var err = new Error('Unhandled error.' + (er ? ' (' + er.message + ')' : ''));\n    err.context = er;\n    throw err; // Unhandled 'error' event\n  }\n\n  var handler = events[type];\n\n  if (handler === undefined)\n    return false;\n\n  if (typeof handler === 'function') {\n    ReflectApply(handler, this, args);\n  } else {\n    var len = handler.length;\n    var listeners = arrayClone(handler, len);\n    for (var i = 0; i < len; ++i)\n      ReflectApply(listeners[i], this, args);\n  }\n\n  return true;\n};\n\nfunction _addListener(target, type, listener, prepend) {\n  var m;\n  var events;\n  var existing;\n\n  checkListener(listener);\n\n  events = target._events;\n  if (events === undefined) {\n    events = target._events = Object.create(null);\n    target._eventsCount = 0;\n  } else {\n    // To avoid recursion in the case that type === \"newListener\"! Before\n    // adding it to the listeners, first emit \"newListener\".\n    if (events.newListener !== undefined) {\n      target.emit('newListener', type,\n                  listener.listener ? listener.listener : listener);\n\n      // Re-assign `events` because a newListener handler could have caused the\n      // this._events to be assigned to a new object\n      events = target._events;\n    }\n    existing = events[type];\n  }\n\n  if (existing === undefined) {\n    // Optimize the case of one listener. Don't need the extra array object.\n    existing = events[type] = listener;\n    ++target._eventsCount;\n  } else {\n    if (typeof existing === 'function') {\n      // Adding the second element, need to change to array.\n      existing = events[type] =\n        prepend ? [listener, existing] : [existing, listener];\n      // If we've already got an array, just append.\n    } else if (prepend) {\n      existing.unshift(listener);\n    } else {\n      existing.push(listener);\n    }\n\n    // Check for listener leak\n    m = _getMaxListeners(target);\n    if (m > 0 && existing.length > m && !existing.warned) {\n      existing.warned = true;\n      // No error code for this since it is a Warning\n      // eslint-disable-next-line no-restricted-syntax\n      var w = new Error('Possible EventEmitter memory leak detected. ' +\n                          existing.length + ' ' + String(type) + ' listeners ' +\n                          'added. Use emitter.setMaxListeners() to ' +\n                          'increase limit');\n      w.name = 'MaxListenersExceededWarning';\n      w.emitter = target;\n      w.type = type;\n      w.count = existing.length;\n      ProcessEmitWarning(w);\n    }\n  }\n\n  return target;\n}\n\nEventEmitter.prototype.addListener = function addListener(type, listener) {\n  return _addListener(this, type, listener, false);\n};\n\nEventEmitter.prototype.on = EventEmitter.prototype.addListener;\n\nEventEmitter.prototype.prependListener =\n    function prependListener(type, listener) {\n      return _addListener(this, type, listener, true);\n    };\n\nfunction onceWrapper() {\n  if (!this.fired) {\n    this.target.removeListener(this.type, this.wrapFn);\n    this.fired = true;\n    if (arguments.length === 0)\n      return this.listener.call(this.target);\n    return this.listener.apply(this.target, arguments);\n  }\n}\n\nfunction _onceWrap(target, type, listener) {\n  var state = { fired: false, wrapFn: undefined, target: target, type: type, listener: listener };\n  var wrapped = onceWrapper.bind(state);\n  wrapped.listener = listener;\n  state.wrapFn = wrapped;\n  return wrapped;\n}\n\nEventEmitter.prototype.once = function once(type, listener) {\n  checkListener(listener);\n  this.on(type, _onceWrap(this, type, listener));\n  return this;\n};\n\nEventEmitter.prototype.prependOnceListener =\n    function prependOnceListener(type, listener) {\n      checkListener(listener);\n      this.prependListener(type, _onceWrap(this, type, listener));\n      return this;\n    };\n\n// Emits a 'removeListener' event if and only if the listener was removed.\nEventEmitter.prototype.removeListener =\n    function removeListener(type, listener) {\n      var list, events, position, i, originalListener;\n\n      checkListener(listener);\n\n      events = this._events;\n      if (events === undefined)\n        return this;\n\n      list = events[type];\n      if (list === undefined)\n        return this;\n\n      if (list === listener || list.listener === listener) {\n        if (--this._eventsCount === 0)\n          this._events = Object.create(null);\n        else {\n          delete events[type];\n          if (events.removeListener)\n            this.emit('removeListener', type, list.listener || listener);\n        }\n      } else if (typeof list !== 'function') {\n        position = -1;\n\n        for (i = list.length - 1; i >= 0; i--) {\n          if (list[i] === listener || list[i].listener === listener) {\n            originalListener = list[i].listener;\n            position = i;\n            break;\n          }\n        }\n\n        if (position < 0)\n          return this;\n\n        if (position === 0)\n          list.shift();\n        else {\n          spliceOne(list, position);\n        }\n\n        if (list.length === 1)\n          events[type] = list[0];\n\n        if (events.removeListener !== undefined)\n          this.emit('removeListener', type, originalListener || listener);\n      }\n\n      return this;\n    };\n\nEventEmitter.prototype.off = EventEmitter.prototype.removeListener;\n\nEventEmitter.prototype.removeAllListeners =\n    function removeAllListeners(type) {\n      var listeners, events, i;\n\n      events = this._events;\n      if (events === undefined)\n        return this;\n\n      // not listening for removeListener, no need to emit\n      if (events.removeListener === undefined) {\n        if (arguments.length === 0) {\n          this._events = Object.create(null);\n          this._eventsCount = 0;\n        } else if (events[type] !== undefined) {\n          if (--this._eventsCount === 0)\n            this._events = Object.create(null);\n          else\n            delete events[type];\n        }\n        return this;\n      }\n\n      // emit removeListener for all listeners on all events\n      if (arguments.length === 0) {\n        var keys = Object.keys(events);\n        var key;\n        for (i = 0; i < keys.length; ++i) {\n          key = keys[i];\n          if (key === 'removeListener') continue;\n          this.removeAllListeners(key);\n        }\n        this.removeAllListeners('removeListener');\n        this._events = Object.create(null);\n        this._eventsCount = 0;\n        return this;\n      }\n\n      listeners = events[type];\n\n      if (typeof listeners === 'function') {\n        this.removeListener(type, listeners);\n      } else if (listeners !== undefined) {\n        // LIFO order\n        for (i = listeners.length - 1; i >= 0; i--) {\n          this.removeListener(type, listeners[i]);\n        }\n      }\n\n      return this;\n    };\n\nfunction _listeners(target, type, unwrap) {\n  var events = target._events;\n\n  if (events === undefined)\n    return [];\n\n  var evlistener = events[type];\n  if (evlistener === undefined)\n    return [];\n\n  if (typeof evlistener === 'function')\n    return unwrap ? [evlistener.listener || evlistener] : [evlistener];\n\n  return unwrap ?\n    unwrapListeners(evlistener) : arrayClone(evlistener, evlistener.length);\n}\n\nEventEmitter.prototype.listeners = function listeners(type) {\n  return _listeners(this, type, true);\n};\n\nEventEmitter.prototype.rawListeners = function rawListeners(type) {\n  return _listeners(this, type, false);\n};\n\nEventEmitter.listenerCount = function(emitter, type) {\n  if (typeof emitter.listenerCount === 'function') {\n    return emitter.listenerCount(type);\n  } else {\n    return listenerCount.call(emitter, type);\n  }\n};\n\nEventEmitter.prototype.listenerCount = listenerCount;\nfunction listenerCount(type) {\n  var events = this._events;\n\n  if (events !== undefined) {\n    var evlistener = events[type];\n\n    if (typeof evlistener === 'function') {\n      return 1;\n    } else if (evlistener !== undefined) {\n      return evlistener.length;\n    }\n  }\n\n  return 0;\n}\n\nEventEmitter.prototype.eventNames = function eventNames() {\n  return this._eventsCount > 0 ? ReflectOwnKeys(this._events) : [];\n};\n\nfunction arrayClone(arr, n) {\n  var copy = new Array(n);\n  for (var i = 0; i < n; ++i)\n    copy[i] = arr[i];\n  return copy;\n}\n\nfunction spliceOne(list, index) {\n  for (; index + 1 < list.length; index++)\n    list[index] = list[index + 1];\n  list.pop();\n}\n\nfunction unwrapListeners(arr) {\n  var ret = new Array(arr.length);\n  for (var i = 0; i < ret.length; ++i) {\n    ret[i] = arr[i].listener || arr[i];\n  }\n  return ret;\n}\n\nfunction once(emitter, name) {\n  return new Promise(function (resolve, reject) {\n    function errorListener(err) {\n      emitter.removeListener(name, resolver);\n      reject(err);\n    }\n\n    function resolver() {\n      if (typeof emitter.removeListener === 'function') {\n        emitter.removeListener('error', errorListener);\n      }\n      resolve([].slice.call(arguments));\n    };\n\n    eventTargetAgnosticAddListener(emitter, name, resolver, { once: true });\n    if (name !== 'error') {\n      addErrorHandlerIfEventEmitter(emitter, errorListener, { once: true });\n    }\n  });\n}\n\nfunction addErrorHandlerIfEventEmitter(emitter, handler, flags) {\n  if (typeof emitter.on === 'function') {\n    eventTargetAgnosticAddListener(emitter, 'error', handler, flags);\n  }\n}\n\nfunction eventTargetAgnosticAddListener(emitter, name, listener, flags) {\n  if (typeof emitter.on === 'function') {\n    if (flags.once) {\n      emitter.once(name, listener);\n    } else {\n      emitter.on(name, listener);\n    }\n  } else if (typeof emitter.addEventListener === 'function') {\n    // EventTarget does not have `error` event semantics like Node\n    // EventEmitters, we do not listen for `error` events here.\n    emitter.addEventListener(name, function wrapListener(arg) {\n      // IE does not have builtin `{ once: true }` support so we\n      // have to do it manually.\n      if (flags.once) {\n        emitter.removeEventListener(name, wrapListener);\n      }\n      listener(arg);\n    });\n  } else {\n    throw new TypeError('The \"emitter\" argument must be of type EventEmitter. Received type ' + typeof emitter);\n  }\n}\n","/**\n * @license\n * Copyright 2019 Google LLC\n * SPDX-License-Identifier: Apache-2.0\n */\nconst proxyMarker = Symbol(\"Comlink.proxy\");\nconst createEndpoint = Symbol(\"Comlink.endpoint\");\nconst releaseProxy = Symbol(\"Comlink.releaseProxy\");\nconst finalizer = Symbol(\"Comlink.finalizer\");\nconst throwMarker = Symbol(\"Comlink.thrown\");\nconst isObject = (val) => (typeof val === \"object\" && val !== null) || typeof val === \"function\";\n/**\n * Internal transfer handle to handle objects marked to proxy.\n */\nconst proxyTransferHandler = {\n    canHandle: (val) => isObject(val) && val[proxyMarker],\n    serialize(obj) {\n        const { port1, port2 } = new MessageChannel();\n        expose(obj, port1);\n        return [port2, [port2]];\n    },\n    deserialize(port) {\n        port.start();\n        return wrap(port);\n    },\n};\n/**\n * Internal transfer handler to handle thrown exceptions.\n */\nconst throwTransferHandler = {\n    canHandle: (value) => isObject(value) && throwMarker in value,\n    serialize({ value }) {\n        let serialized;\n        if (value instanceof Error) {\n            serialized = {\n                isError: true,\n                value: {\n                    message: value.message,\n                    name: value.name,\n                    stack: value.stack,\n                },\n            };\n        }\n        else {\n            serialized = { isError: false, value };\n        }\n        return [serialized, []];\n    },\n    deserialize(serialized) {\n        if (serialized.isError) {\n            throw Object.assign(new Error(serialized.value.message), serialized.value);\n        }\n        throw serialized.value;\n    },\n};\n/**\n * Allows customizing the serialization of certain values.\n */\nconst transferHandlers = new Map([\n    [\"proxy\", proxyTransferHandler],\n    [\"throw\", throwTransferHandler],\n]);\nfunction isAllowedOrigin(allowedOrigins, origin) {\n    for (const allowedOrigin of allowedOrigins) {\n        if (origin === allowedOrigin || allowedOrigin === \"*\") {\n            return true;\n        }\n        if (allowedOrigin instanceof RegExp && allowedOrigin.test(origin)) {\n            return true;\n        }\n    }\n    return false;\n}\nfunction expose(obj, ep = globalThis, allowedOrigins = [\"*\"]) {\n    ep.addEventListener(\"message\", function callback(ev) {\n        if (!ev || !ev.data) {\n            return;\n        }\n        if (!isAllowedOrigin(allowedOrigins, ev.origin)) {\n            console.warn(`Invalid origin '${ev.origin}' for comlink proxy`);\n            return;\n        }\n        const { id, type, path } = Object.assign({ path: [] }, ev.data);\n        const argumentList = (ev.data.argumentList || []).map(fromWireValue);\n        let returnValue;\n        try {\n            const parent = path.slice(0, -1).reduce((obj, prop) => obj[prop], obj);\n            const rawValue = path.reduce((obj, prop) => obj[prop], obj);\n            switch (type) {\n                case \"GET\" /* MessageType.GET */:\n                    {\n                        returnValue = rawValue;\n                    }\n                    break;\n                case \"SET\" /* MessageType.SET */:\n                    {\n                        parent[path.slice(-1)[0]] = fromWireValue(ev.data.value);\n                        returnValue = true;\n                    }\n                    break;\n                case \"APPLY\" /* MessageType.APPLY */:\n                    {\n                        returnValue = rawValue.apply(parent, argumentList);\n                    }\n                    break;\n                case \"CONSTRUCT\" /* MessageType.CONSTRUCT */:\n                    {\n                        const value = new rawValue(...argumentList);\n                        returnValue = proxy(value);\n                    }\n                    break;\n                case \"ENDPOINT\" /* MessageType.ENDPOINT */:\n                    {\n                        const { port1, port2 } = new MessageChannel();\n                        expose(obj, port2);\n                        returnValue = transfer(port1, [port1]);\n                    }\n                    break;\n                case \"RELEASE\" /* MessageType.RELEASE */:\n                    {\n                        returnValue = undefined;\n                    }\n                    break;\n                default:\n                    return;\n            }\n        }\n        catch (value) {\n            returnValue = { value, [throwMarker]: 0 };\n        }\n        Promise.resolve(returnValue)\n            .catch((value) => {\n            return { value, [throwMarker]: 0 };\n        })\n            .then((returnValue) => {\n            const [wireValue, transferables] = toWireValue(returnValue);\n            ep.postMessage(Object.assign(Object.assign({}, wireValue), { id }), transferables);\n            if (type === \"RELEASE\" /* MessageType.RELEASE */) {\n                // detach and deactive after sending release response above.\n                ep.removeEventListener(\"message\", callback);\n                closeEndPoint(ep);\n                if (finalizer in obj && typeof obj[finalizer] === \"function\") {\n                    obj[finalizer]();\n                }\n            }\n        })\n            .catch((error) => {\n            // Send Serialization Error To Caller\n            const [wireValue, transferables] = toWireValue({\n                value: new TypeError(\"Unserializable return value\"),\n                [throwMarker]: 0,\n            });\n            ep.postMessage(Object.assign(Object.assign({}, wireValue), { id }), transferables);\n        });\n    });\n    if (ep.start) {\n        ep.start();\n    }\n}\nfunction isMessagePort(endpoint) {\n    return endpoint.constructor.name === \"MessagePort\";\n}\nfunction closeEndPoint(endpoint) {\n    if (isMessagePort(endpoint))\n        endpoint.close();\n}\nfunction wrap(ep, target) {\n    return createProxy(ep, [], target);\n}\nfunction throwIfProxyReleased(isReleased) {\n    if (isReleased) {\n        throw new Error(\"Proxy has been released and is not useable\");\n    }\n}\nfunction releaseEndpoint(ep) {\n    return requestResponseMessage(ep, {\n        type: \"RELEASE\" /* MessageType.RELEASE */,\n    }).then(() => {\n        closeEndPoint(ep);\n    });\n}\nconst proxyCounter = new WeakMap();\nconst proxyFinalizers = \"FinalizationRegistry\" in globalThis &&\n    new FinalizationRegistry((ep) => {\n        const newCount = (proxyCounter.get(ep) || 0) - 1;\n        proxyCounter.set(ep, newCount);\n        if (newCount === 0) {\n            releaseEndpoint(ep);\n        }\n    });\nfunction registerProxy(proxy, ep) {\n    const newCount = (proxyCounter.get(ep) || 0) + 1;\n    proxyCounter.set(ep, newCount);\n    if (proxyFinalizers) {\n        proxyFinalizers.register(proxy, ep, proxy);\n    }\n}\nfunction unregisterProxy(proxy) {\n    if (proxyFinalizers) {\n        proxyFinalizers.unregister(proxy);\n    }\n}\nfunction createProxy(ep, path = [], target = function () { }) {\n    let isProxyReleased = false;\n    const proxy = new Proxy(target, {\n        get(_target, prop) {\n            throwIfProxyReleased(isProxyReleased);\n            if (prop === releaseProxy) {\n                return () => {\n                    unregisterProxy(proxy);\n                    releaseEndpoint(ep);\n                    isProxyReleased = true;\n                };\n            }\n            if (prop === \"then\") {\n                if (path.length === 0) {\n                    return { then: () => proxy };\n                }\n                const r = requestResponseMessage(ep, {\n                    type: \"GET\" /* MessageType.GET */,\n                    path: path.map((p) => p.toString()),\n                }).then(fromWireValue);\n                return r.then.bind(r);\n            }\n            return createProxy(ep, [...path, prop]);\n        },\n        set(_target, prop, rawValue) {\n            throwIfProxyReleased(isProxyReleased);\n            // FIXME: ES6 Proxy Handler `set` methods are supposed to return a\n            // boolean. To show good will, we return true asynchronously ¯\\_(ツ)_/¯\n            const [value, transferables] = toWireValue(rawValue);\n            return requestResponseMessage(ep, {\n                type: \"SET\" /* MessageType.SET */,\n                path: [...path, prop].map((p) => p.toString()),\n                value,\n            }, transferables).then(fromWireValue);\n        },\n        apply(_target, _thisArg, rawArgumentList) {\n            throwIfProxyReleased(isProxyReleased);\n            const last = path[path.length - 1];\n            if (last === createEndpoint) {\n                return requestResponseMessage(ep, {\n                    type: \"ENDPOINT\" /* MessageType.ENDPOINT */,\n                }).then(fromWireValue);\n            }\n            // We just pretend that `bind()` didn’t happen.\n            if (last === \"bind\") {\n                return createProxy(ep, path.slice(0, -1));\n            }\n            const [argumentList, transferables] = processArguments(rawArgumentList);\n            return requestResponseMessage(ep, {\n                type: \"APPLY\" /* MessageType.APPLY */,\n                path: path.map((p) => p.toString()),\n                argumentList,\n            }, transferables).then(fromWireValue);\n        },\n        construct(_target, rawArgumentList) {\n            throwIfProxyReleased(isProxyReleased);\n            const [argumentList, transferables] = processArguments(rawArgumentList);\n            return requestResponseMessage(ep, {\n                type: \"CONSTRUCT\" /* MessageType.CONSTRUCT */,\n                path: path.map((p) => p.toString()),\n                argumentList,\n            }, transferables).then(fromWireValue);\n        },\n    });\n    registerProxy(proxy, ep);\n    return proxy;\n}\nfunction myFlat(arr) {\n    return Array.prototype.concat.apply([], arr);\n}\nfunction processArguments(argumentList) {\n    const processed = argumentList.map(toWireValue);\n    return [processed.map((v) => v[0]), myFlat(processed.map((v) => v[1]))];\n}\nconst transferCache = new WeakMap();\nfunction transfer(obj, transfers) {\n    transferCache.set(obj, transfers);\n    return obj;\n}\nfunction proxy(obj) {\n    return Object.assign(obj, { [proxyMarker]: true });\n}\nfunction windowEndpoint(w, context = globalThis, targetOrigin = \"*\") {\n    return {\n        postMessage: (msg, transferables) => w.postMessage(msg, targetOrigin, transferables),\n        addEventListener: context.addEventListener.bind(context),\n        removeEventListener: context.removeEventListener.bind(context),\n    };\n}\nfunction toWireValue(value) {\n    for (const [name, handler] of transferHandlers) {\n        if (handler.canHandle(value)) {\n            const [serializedValue, transferables] = handler.serialize(value);\n            return [\n                {\n                    type: \"HANDLER\" /* WireValueType.HANDLER */,\n                    name,\n                    value: serializedValue,\n                },\n                transferables,\n            ];\n        }\n    }\n    return [\n        {\n            type: \"RAW\" /* WireValueType.RAW */,\n            value,\n        },\n        transferCache.get(value) || [],\n    ];\n}\nfunction fromWireValue(value) {\n    switch (value.type) {\n        case \"HANDLER\" /* WireValueType.HANDLER */:\n            return transferHandlers.get(value.name).deserialize(value.value);\n        case \"RAW\" /* WireValueType.RAW */:\n            return value.value;\n    }\n}\nfunction requestResponseMessage(ep, msg, transfers) {\n    return new Promise((resolve) => {\n        const id = generateUUID();\n        ep.addEventListener(\"message\", function l(ev) {\n            if (!ev.data || !ev.data.id || ev.data.id !== id) {\n                return;\n            }\n            ep.removeEventListener(\"message\", l);\n            resolve(ev.data);\n        });\n        if (ep.start) {\n            ep.start();\n        }\n        ep.postMessage(Object.assign({ id }, msg), transfers);\n    });\n}\nfunction generateUUID() {\n    return new Array(4)\n        .fill(0)\n        .map(() => Math.floor(Math.random() * Number.MAX_SAFE_INTEGER).toString(16))\n        .join(\"-\");\n}\n\nexport { createEndpoint, expose, finalizer, proxy, proxyMarker, releaseProxy, transfer, transferHandlers, windowEndpoint, wrap };\n//# sourceMappingURL=comlink.mjs.map\n"],"names":["bufferIfNot","canEmitObservable","source","Observable","subscriber","buffer","canEmit","emitBuffer","canEmitSub","val","sourceSub","value","error","InternalStreamMessageType","reduceNewValuesSameSchemaMessages","packets","acc","values","i","j","filterMessages","type","p","LiveDataStream","deps","ReplaySubject","err","toDataQueryError","evt","liveChannelStatusEvent","msg","bufferOptions","options","subKey","shouldSendLastPacketOnly","fieldsNamesFilter","fieldFilterPredicate","name","matchingFieldIndexes","getFullFrameResponseData","messages","getNewValuesSameSchemaResponseData","lastMessage","filteredValues","v","shouldSendFullFrame","transformedInternalStream","map","errors","lastError","n","newValueSameSchemaMessages","sub","StreamingDataFrame","CentrifugeLiveChannel","id","addr","Subject","ctx","message","copy","initialMessage","getErrorChannel","defaultStreamingFrameOptions","dataStreamShutdownDelayInMs","CentrifugeService","context","address","streamCounter","channelId","existingStream","channel","subscriptionKey","share","startWith","liveUrl","token","BehaviorSubject","resolve","connectListener","subscription","subscriberTransferHandler","obj","port1","port2","__importDefault","mod","exports","subscription_1","codes_1","transport_sockjs_1","transport_websocket_1","transport_http_stream_1","transport_sse_1","transport_webtransport_1","json_1","utils_1","types_1","events_1","defaults","Centrifuge","endpoint","timeout","res","rej","data","cmd","self","method","reply","result","publications","args","format","_format","transportConfig","transportName","newState","oldState","eventTarget","delay","callbacks","errback","commands","command","e","websocket","sockjs","eventsource","fetchFunc","readableStream","count","transportEndpoint","wasOpen","optimistic","initialCommands","connectCommand","subscribeCommands","initialData","closeEvent","reason","needReconnect","code","advice","isInitialHandshake","skipSending","resolveCtx","rejectCtx","req","subs","hasSubs","resultCB","reject","replies","finishDispatch","next","reconnect","previousState","needEvent","clientId","subCtx","pubs","epoch","offset","callback","join","leave","unsubscribe","disconnect","pub","clientInfo","info","temporary","errObject","__createBinding","o","m","k","k2","desc","__exportStar","centrifuge_1","JsonEncoder","c","JsonDecoder","r","Subscription","centrifuge","opts","sendUnsubscribe","errContext","getToken","HttpStreamTransport","response","jsonStreamBuf","jsonStreamPos","protoStreamBuf","reader","controller","pump","done","line","mergedArray","protocol","headers","body","fetchOptions","session","node","SockjsTransport","_protocol","event","SseTransport","url","eventsourceOptions","eventSource","WebsocketTransport","subProtocol","__awaiter","thisArg","_arguments","P","generator","adopt","fulfilled","step","rejected","WebtransportTransport","stream","binary","State","SubscriptionState","startsWith","prefix","isFunction","log","level","logger","randomInt","min","max","backoff","interval","errorExists","ttlMilliseconds","ttl","R","ReflectApply","target","receiver","ReflectOwnKeys","ProcessEmitWarning","warning","NumberIsNaN","EventEmitter","module","once","defaultMaxListeners","checkListener","listener","arg","_getMaxListeners","that","doError","events","er","handler","len","listeners","arrayClone","_addListener","prepend","existing","w","onceWrapper","_onceWrap","state","wrapped","list","position","originalListener","spliceOne","keys","key","_listeners","unwrap","evlistener","unwrapListeners","emitter","listenerCount","arr","index","ret","errorListener","resolver","eventTargetAgnosticAddListener","addErrorHandlerIfEventEmitter","flags","wrapListener","proxyMarker","createEndpoint","releaseProxy","finalizer","throwMarker","isObject","proxyTransferHandler","expose","port","wrap","throwTransferHandler","serialized","transferHandlers","isAllowedOrigin","allowedOrigins","origin","allowedOrigin","ep","ev","path","argumentList","fromWireValue","returnValue","parent","prop","rawValue","proxy","transfer","wireValue","transferables","toWireValue","closeEndPoint","isMessagePort","createProxy","throwIfProxyReleased","isReleased","releaseEndpoint","requestResponseMessage","proxyCounter","proxyFinalizers","newCount","registerProxy","unregisterProxy","isProxyReleased","_target","_thisArg","rawArgumentList","last","processArguments","myFlat","processed","transferCache","transfers","windowEndpoint","targetOrigin","serializedValue","generateUUID","l"],"sourceRoot":""}