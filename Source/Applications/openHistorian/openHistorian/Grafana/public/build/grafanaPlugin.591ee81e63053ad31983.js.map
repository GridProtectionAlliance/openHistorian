{"version":3,"sources":["webpack:///./public/app/plugins/datasource/grafana/types.ts","webpack:///./public/app/plugins/datasource/grafana/datasource.ts","webpack:///./public/app/plugins/datasource/grafana/components/QueryEditor.tsx","webpack:///./public/app/plugins/datasource/grafana/annotation_ctrl.ts","webpack:///./public/app/plugins/datasource/grafana/module.ts"],"names":["GrafanaQueryType","GrafanaAnnotationType","defaultQuery","refId","queryType","RandomWalk","counter","GrafanaDatasource","instanceSettings","request","queries","targets","target","hide","LiveMeasurements","channel","measurements","push","getLiveMeasurementsObserver","scope","LiveChannelScope","Grafana","namespace","path","requestId","getRandomWalk","length","of","options","Promise","resolve","templateSrv","getTemplateSrv","annotation","params","from","range","valueOf","to","limit","tags","matchAny","type","Dashboard","dashboard","id","dashboardId","Array","isArray","t","renderedValues","replace","value","join","split","tt","getBackendSrv","get","name","DataSourceApi","intervalMs","maxDataPoints","fetch","url","method","pipe","map","rsp","toDataQueryResponse","catchError","err","QueryEditor","queryTypes","label","description","onQueryTypeChange","sel","props","onChange","query","onRunQuery","onChannelChange","onMeasurementNameChanged","this","channels","currentChannel","find","c","names","info","undefined","foundName","getLiveMeasurements","getDistinctNames","console","log","className","grow","labelWidth","allowCustomValue","backspaceRemovesValue","placeholder","isClearable","noOptionsMessage","formatCreateLabel","input","v","isSearchable","title","featureState","FeatureState","alpha","defaults","renderMeasurementsQuery","PureComponent","annotationTypes","text","Tags","GrafanaAnnotationsQueryCtrl","types","templateUrl","plugin","DataSourcePlugin","setQueryEditor","setAnnotationQueryCtrl"],"mappings":"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","file":"grafanaPlugin.591ee81e63053ad31983.js","sourcesContent":["import { AnnotationQuery, DataQuery } from '@grafana/data';\nimport { MeasurementsQuery } from '@grafana/runtime';\n\n//----------------------------------------------\n// Query\n//----------------------------------------------\n\nexport enum GrafanaQueryType {\n  RandomWalk = 'randomWalk',\n  LiveMeasurements = 'measurements',\n}\n\nexport interface GrafanaQuery extends DataQuery {\n  queryType: GrafanaQueryType; // RandomWalk by default\n  channel?: string;\n  measurements?: MeasurementsQuery;\n}\n\nexport const defaultQuery: GrafanaQuery = {\n  refId: 'A',\n  queryType: GrafanaQueryType.RandomWalk,\n};\n\n//----------------------------------------------\n// Annotations\n//----------------------------------------------\n\nexport enum GrafanaAnnotationType {\n  Dashboard = 'dashboard',\n  Tags = 'tags',\n}\n\nexport interface GrafanaAnnotationQuery extends AnnotationQuery<GrafanaQuery> {\n  type: GrafanaAnnotationType; // tags\n  limit: number; // 100\n  tags?: string[];\n  matchAny?: boolean; // By default Grafana only shows annotations that match all tags in the query. Enabling this returns annotations that match any of the tags in the query.\n}\n","import _ from 'lodash';\nimport {\n  AnnotationEvent,\n  AnnotationQueryRequest,\n  DataQueryRequest,\n  DataQueryResponse,\n  DataSourceApi,\n  DataSourceInstanceSettings,\n  LiveChannelScope,\n} from '@grafana/data';\n\nimport { GrafanaQuery, GrafanaAnnotationQuery, GrafanaAnnotationType, GrafanaQueryType } from './types';\nimport { getBackendSrv, getTemplateSrv, toDataQueryResponse, getLiveMeasurementsObserver } from '@grafana/runtime';\nimport { Observable, of } from 'rxjs';\nimport { map, catchError } from 'rxjs/operators';\n\nlet counter = 100;\n\nexport class GrafanaDatasource extends DataSourceApi<GrafanaQuery> {\n  constructor(instanceSettings: DataSourceInstanceSettings) {\n    super(instanceSettings);\n  }\n\n  query(request: DataQueryRequest<GrafanaQuery>): Observable<DataQueryResponse> {\n    const queries: Array<Observable<DataQueryResponse>> = [];\n    for (const target of request.targets) {\n      if (target.hide) {\n        continue;\n      }\n      if (target.queryType === GrafanaQueryType.LiveMeasurements) {\n        const { channel, measurements } = target;\n        if (channel) {\n          queries.push(\n            getLiveMeasurementsObserver(\n              {\n                scope: LiveChannelScope.Grafana,\n                namespace: 'measurements',\n                path: channel,\n              },\n              `${request.requestId}.${counter++}`,\n              measurements\n            )\n          );\n        }\n      } else {\n        queries.push(getRandomWalk(request));\n      }\n    }\n    // With a single query just return the results\n    if (queries.length === 1) {\n      return queries[0];\n    }\n    if (queries.length > 1) {\n      // HELP!!!\n      return queries[0];\n    }\n    return of(); // nothing\n  }\n\n  metricFindQuery(options: any) {\n    return Promise.resolve([]);\n  }\n\n  annotationQuery(options: AnnotationQueryRequest<GrafanaQuery>): Promise<AnnotationEvent[]> {\n    const templateSrv = getTemplateSrv();\n    const annotation = (options.annotation as unknown) as GrafanaAnnotationQuery;\n    const params: any = {\n      from: options.range.from.valueOf(),\n      to: options.range.to.valueOf(),\n      limit: annotation.limit,\n      tags: annotation.tags,\n      matchAny: annotation.matchAny,\n    };\n\n    if (annotation.type === GrafanaAnnotationType.Dashboard) {\n      // if no dashboard id yet return\n      if (!options.dashboard.id) {\n        return Promise.resolve([]);\n      }\n      // filter by dashboard id\n      params.dashboardId = options.dashboard.id;\n      // remove tags filter if any\n      delete params.tags;\n    } else {\n      // require at least one tag\n      if (!Array.isArray(annotation.tags) || annotation.tags.length === 0) {\n        return Promise.resolve([]);\n      }\n      const delimiter = '__delimiter__';\n      const tags = [];\n      for (const t of params.tags) {\n        const renderedValues = templateSrv.replace(t, {}, (value: any) => {\n          if (typeof value === 'string') {\n            return value;\n          }\n\n          return value.join(delimiter);\n        });\n        for (const tt of renderedValues.split(delimiter)) {\n          tags.push(tt);\n        }\n      }\n      params.tags = tags;\n    }\n\n    return getBackendSrv().get(\n      '/api/annotations',\n      params,\n      `grafana-data-source-annotations-${annotation.name}-${options.dashboard?.id}`\n    );\n  }\n\n  testDatasource() {\n    return Promise.resolve();\n  }\n}\n\n// Note that the query does not actually matter\nfunction getRandomWalk(request: DataQueryRequest): Observable<DataQueryResponse> {\n  const { intervalMs, maxDataPoints, range, requestId } = request;\n\n  // Yes, this implementation ignores multiple targets!  But that matches existing behavior\n  const params: Record<string, any> = {\n    intervalMs,\n    maxDataPoints,\n    from: range.from.valueOf(),\n    to: range.to.valueOf(),\n  };\n\n  return getBackendSrv()\n    .fetch({\n      url: '/api/tsdb/testdata/random-walk',\n      method: 'GET',\n      params,\n      requestId,\n    })\n    .pipe(\n      map((rsp: any) => {\n        return toDataQueryResponse(rsp);\n      }),\n      catchError(err => {\n        return of(toDataQueryResponse(err));\n      })\n    );\n}\n","import defaults from 'lodash/defaults';\n\nimport React, { PureComponent } from 'react';\nimport { InlineField, Select, FeatureInfoBox } from '@grafana/ui';\nimport { QueryEditorProps, SelectableValue, LiveChannelScope, FeatureState } from '@grafana/data';\nimport { getLiveMeasurements, LiveMeasurements } from '@grafana/runtime';\nimport { GrafanaDatasource } from '../datasource';\nimport { defaultQuery, GrafanaQuery, GrafanaQueryType } from '../types';\n\ntype Props = QueryEditorProps<GrafanaDatasource, GrafanaQuery>;\n\nconst labelWidth = 12;\n\nexport class QueryEditor extends PureComponent<Props> {\n  queryTypes: Array<SelectableValue<GrafanaQueryType>> = [\n    {\n      label: 'Random Walk',\n      value: GrafanaQueryType.RandomWalk,\n      description: 'Random signal within the selected time rage',\n    },\n    {\n      label: 'Live Measurements',\n      value: GrafanaQueryType.LiveMeasurements,\n      description: 'Stream real-time measurements from Grafana',\n    },\n  ];\n\n  onQueryTypeChange = (sel: SelectableValue<GrafanaQueryType>) => {\n    const { onChange, query, onRunQuery } = this.props;\n    onChange({ ...query, queryType: sel.value! });\n    onRunQuery();\n  };\n\n  onChannelChange = (sel: SelectableValue<string>) => {\n    const { onChange, query, onRunQuery } = this.props;\n    onChange({ ...query, channel: sel?.value });\n    onRunQuery();\n  };\n\n  onMeasurementNameChanged = (sel: SelectableValue<string>) => {\n    const { onChange, query, onRunQuery } = this.props;\n    onChange({\n      ...query,\n      measurements: {\n        ...query.measurements,\n        name: sel?.value,\n      },\n    });\n    onRunQuery();\n  };\n\n  renderMeasurementsQuery() {\n    let { channel, measurements } = this.props.query;\n    const channels: Array<SelectableValue<string>> = [];\n    let currentChannel = channels.find(c => c.value === channel);\n    if (channel && !currentChannel) {\n      currentChannel = {\n        value: channel,\n        label: channel,\n        description: `Connected to ${channel}`,\n      };\n      channels.push(currentChannel);\n    }\n\n    if (!measurements) {\n      measurements = {};\n    }\n    const names: Array<SelectableValue<string>> = [\n      { value: '', label: 'All measurements', description: 'Show every measurement streamed to this channel' },\n    ];\n\n    let info: LiveMeasurements | undefined = undefined;\n    if (channel) {\n      info = getLiveMeasurements({\n        scope: LiveChannelScope.Grafana,\n        namespace: 'measurements',\n        path: channel,\n      });\n\n      let foundName = false;\n      if (info) {\n        for (const name of info.getDistinctNames()) {\n          names.push({\n            value: name,\n            label: name,\n          });\n          if (name === measurements.name) {\n            foundName = true;\n          }\n        }\n      } else {\n        console.log('NO INFO for', channel);\n      }\n\n      if (measurements.name && !foundName) {\n        names.push({\n          label: measurements.name,\n          value: measurements.name,\n          description: `Frames with name ${measurements.name}`,\n        });\n      }\n    }\n\n    return (\n      <>\n        <div className=\"gf-form\">\n          <InlineField label=\"Channel\" grow={true} labelWidth={labelWidth}>\n            <Select\n              options={channels}\n              value={currentChannel || ''}\n              onChange={this.onChannelChange}\n              allowCustomValue={true}\n              backspaceRemovesValue={true}\n              placeholder=\"Select measurements channel\"\n              isClearable={true}\n              noOptionsMessage=\"Enter channel name\"\n              formatCreateLabel={(input: string) => `Connect to: ${input}`}\n            />\n          </InlineField>\n        </div>\n        {channel && (\n          <div className=\"gf-form\">\n            <InlineField label=\"Measurement\" grow={true} labelWidth={labelWidth}>\n              <Select\n                options={names}\n                value={names.find(v => v.value === measurements?.name) || names[0]}\n                onChange={this.onMeasurementNameChanged}\n                allowCustomValue={true}\n                backspaceRemovesValue={true}\n                placeholder=\"Filter by name\"\n                isClearable={true}\n                noOptionsMessage=\"Filter by name\"\n                formatCreateLabel={(input: string) => `Show: ${input}`}\n                isSearchable={true}\n              />\n            </InlineField>\n          </div>\n        )}\n\n        <FeatureInfoBox title=\"Grafana Live - Measurements\" featureState={FeatureState.alpha}>\n          <p>\n            This supports real-time event streams in Grafana core. This feature is under heavy development. Expect the\n            interfaces and structures to change as this becomes more production ready.\n          </p>\n        </FeatureInfoBox>\n      </>\n    );\n  }\n\n  render() {\n    const query = defaults(this.props.query, defaultQuery);\n    return (\n      <>\n        <div className=\"gf-form\">\n          <InlineField label=\"Query type\" grow={true} labelWidth={labelWidth}>\n            <Select\n              options={this.queryTypes}\n              value={this.queryTypes.find(v => v.value === query.queryType) || this.queryTypes[0]}\n              onChange={this.onQueryTypeChange}\n            />\n          </InlineField>\n        </div>\n        {query.queryType === GrafanaQueryType.LiveMeasurements && this.renderMeasurementsQuery()}\n      </>\n    );\n  }\n}\n","import { SelectableValue } from '@grafana/data';\nimport { GrafanaAnnotationType } from './types';\n\nexport const annotationTypes: Array<SelectableValue<GrafanaAnnotationType>> = [\n  { text: 'Dashboard', value: GrafanaAnnotationType.Dashboard },\n  { text: 'Tags', value: GrafanaAnnotationType.Tags },\n];\n\nexport class GrafanaAnnotationsQueryCtrl {\n  annotation: any;\n\n  types = annotationTypes;\n\n  constructor() {\n    this.annotation.type = this.annotation.type || GrafanaAnnotationType.Tags;\n    this.annotation.limit = this.annotation.limit || 100;\n  }\n\n  static templateUrl = 'partials/annotations.editor.html';\n}\n","import { DataSourcePlugin } from '@grafana/data';\nimport { GrafanaDatasource } from './datasource';\nimport { QueryEditor } from './components/QueryEditor';\nimport { GrafanaQuery } from './types';\nimport { GrafanaAnnotationsQueryCtrl } from './annotation_ctrl';\n\nexport const plugin = new DataSourcePlugin<GrafanaDatasource, GrafanaQuery>(GrafanaDatasource)\n  .setQueryEditor(QueryEditor)\n  .setAnnotationQueryCtrl(GrafanaAnnotationsQueryCtrl);\n"],"sourceRoot":""}