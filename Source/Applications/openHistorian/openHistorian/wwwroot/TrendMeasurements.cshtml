@*******************************************************************************************************
//  TrendMeasurements.cshtml - Gbtc
//
//  Copyright © 2016, Grid Protection Alliance.  All Rights Reserved.
//
//  Licensed to the Grid Protection Alliance (GPA) under one or more contributor license agreements. See
//  the NOTICE file distributed with this work for additional information regarding copyright ownership.
//  The GPA licenses this file to you under the MIT License (MIT), the "License"; you may not use this
//  file except in compliance with the License. You may obtain a copy of the License at:
//
//      http://opensource.org/licenses/MIT
//
//  Unless agreed to in writing, the subject software distributed under the License is distributed on an
//  "AS-IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. Refer to the
//  License for the specific language governing permissions and limitations.
//
//  Code Modification History:
//  ----------------------------------------------------------------------------------------------------
//  07/30/2016 - Ritchie Carroll
//       Generated original version of source code.
//
//*****************************************************************************************************@
@* ReSharper disable RedundantUnits *@
@* ReSharper disable CoercedEqualsUsing *@
@* ReSharper disable UnknownCssClass *@
@* ReSharper disable Html.PathError *@
@* ReSharper disable InlineOutVariableDeclaration *@
@* ReSharper disable ArrangeAccessorOwnerBody *@
@* ReSharper disable SymbolFromNotCopiedLocallyReferenceUsedWarning *@
@using System.Net.Http
@using System.Text
@using GSF
@using GSF.Web
@using GSF.Web.Model
@using GSF.Web.Security
@using GSF.Web.Shared
@using Microsoft.Ajax.Utilities
@using openHistorian
@using openHistorian.Model
@inherits ExtendedTemplateBase<AppModel>
@section StyleSheets {
    <link href="@Resources.Root/Shared/Content/jquery-ui.css" rel="stylesheet">
    <link href="@Resources.Root/Shared/Content/primeui-theme.css" rel="stylesheet">
    <link href="@Resources.Root/Shared/Content/font-awesome.css" rel="stylesheet">
    <link href="@Resources.Root/Shared/Content/primeui.css" rel="stylesheet">
    <link href="Content/bootstrap-datetimepicker.css" rel="stylesheet">
    <style>
        html, body {
            height: 100%;
        }

        .tabs-nohdr {
            padding: 0;
            background: none;
            border-width: 0;
        }

        .tabs-nohdr .ui-tabs-nav {
            padding: 0;
            background: transparent;
            border: none;
        }

        .tabs-nohdr .ui-tabs-panel {
            border: none;
            padding: 0;
            margin: 0;
        }

        /* Collapsable button style */
        .btn-collapsable.btn {
            color: #606060;
            font-family: "Glyphicons Halflings";
            font-size: 8pt;
            padding: 0 2px 2px 2px;
            height: 18px;
        }

        /* Collapsable button icon when content is shown - arrow down */
        .btn-collapsable.btn:after {
            content: "\e114";
        }

        /* Collapsable button icon when content is hidden - arrow right */
        .btn-collapsable.btn.collapsed:after {
            content: "\e080";
        }

        #collapseSelectedPoints.btn-collapsable.btn {
            margin-top: 3px;
            margin-left: -353px;
            -webkit-transition: all .75s ease-out;
            -moz-transition: all .75s ease-out;
            transition: all .75s ease-out;
        }

        #collapseSelectedPoints.btn-collapsable.btn.collapsed {
            margin-top: 3px;
            margin-left: -345px;
        }

        #collapseTrendSetup.btn-collapsable.btn {
            margin-top: 7px;
            margin-right: 6px;
            -webkit-transition: all .75s ease-out;
            -moz-transition: all .75s ease-out;
            transition: all .75s ease-out;
        }

            #collapseTrendSetup.btn-collapsable.btn.collapsed {
                margin-top: -24px;
            }

        span.fixed-font {
            font-size: small;
            font-family: Menlo, Monaco, Consolas, 'Courier New', monospace;
        }

        span.input-group-addon i.disabled {
            color: #ccc;
            cursor: not-allowed;
        }

        hr.series-color {
            background-color: transparent;
            height: 5px;
            border: none;
            margin: 3px;
        }

        .axisLabels {
            -webkit-transform-origin: 50% 51%
        }

        .busy-state * {
            cursor: progress
        }

        #scrollablePointsArea {
            overflow: -moz-scrollbars-vertical;
            overflow-y: scroll;
        }

        #selectAllProgress {
            position: absolute;
            margin-top: 6px;
            margin-left: 115px;
            font-size: smaller;
        }

        #selectAllProgressBar {
            padding-left: 10px;
            padding-bottom: 5px;
            padding-top: 2px;
        }

        #selectAllProgressCancel {
            font-size: small;
            padding-top: 1px;
            padding-bottom: 1px;
            margin-top: -20px;
            margin-left: 1px
        }

        #selectAllMessage {
            position: absolute;
            margin-top: 8px;
            margin-left: 15px;
            font-size: smaller;
        }

        #selectAllMessage a {
            color: #337ab7;
            text-decoration: none;
        }

        #selectAllMessage a:active, a:hover, a:focus {
            color: #23527c;
            text-decoration: underline;
            cursor: pointer;
        }

        #tabs ul li {
            outline: none;
        }

        #tabs ul li a {
            outline: none;
        }

        button.set-midnight-time {
            font-size: 13px;
            height: 25px;
            padding-top: 3px;
            margin-top: 2px;
        }

        .noselect {
            -webkit-touch-callout: none; /* iOS Safari */
            -webkit-user-select: none; /* Safari */
            -khtml-user-select: none; /* Konqueror HTML */
            -moz-user-select: none; /* Firefox */
            -ms-user-select: none; /* Internet Explorer / Edge */
            user-select: none; /* Non-prefixed version, currently Chrome / Opera */
        }
    </style>
}
@{
    const string UpdateCOMTRADECounters = "/@openHistorian/UpdateCOMTRADECounters.exe";

    if (ViewBag.PageControlScripts == null) {
        ViewBag.PageControlScripts = new StringBuilder();
    }

    DataContext dataContext = ViewBag.DataContext;
    StringBuilder pageControlScripts = ViewBag.PageControlScripts;
    HttpRequestMessage request = ViewBag.Request;
    Dictionary<string, string> parameters = request.QueryParameters();

    Uri requestUri = ViewBag.Request.RequestUri;
    string updateCompleteCallback = requestUri.Scheme + "://" + requestUri.Authority + "/api/Feedback/SendUpdateCOMTRADECountersCompleteNotification?operationHandle=";

    string showMenu;
    parameters.TryGetValue("ShowMenu", out showMenu);

    if (string.IsNullOrEmpty(showMenu)) {
        showMenu = "true";
    }

    Layout = "Layout.cshtml";
    ViewBag.Title = "Trend/Export Measurements";
    ViewBag.AddNewEditTitle = "Measurement Detail";
    ViewBag.ShowSearchFilter = true;
    ViewBag.HideUnauthorizedControls = true;
    ViewBag.CanEdit = false;
    ViewBag.CanAddNew = false;
    ViewBag.CanDelete = false;
    ViewBag.ShowMenu = showMenu.ParseBoolean();

    ViewBag.HeaderColumns = new[]
    {   //    { "Field", "Label", "Classes" }
        new[] { null, "<input type='checkbox' id='selectAllCheckbox' title='Select All'/>", "text-center valign-middle non-sortable" },
        new[] { "ID", "ID", "text-center" },
        new[] { "SignalType", "Type", "text-center" },
        new[] { "PointTag", "Tag&nbsp;Name", "text-left" },
        new[] { null, "Current&nbsp;Value", "text-left valign-middle non-sortable" },
        new[] { "SignalReference", "Signal&nbsp;Reference", "text-left" },
        new[] { "Description", "Description", "text-left" }
    };

    ViewBag.BodyRows = BodyRows().ToString();
    ViewBag.AddNewEditDialog = AddNewEditDialog(dataContext).ToString();
    ViewBag.PageRecordsForEachBinding = "afterRender: postRecordRendering";

    // Prepend view model extension scripts to occur before model initialization
    pageControlScripts.Insert(0, ExtendedViewModel(dataContext).ToString().TrimStart());

    // Setup AJAX based anti-forgery implementation
    string verificationHeader = AuthenticationOptions.DefaultRequestVerificationToken;
    string useAjaxVerfication = AuthenticationOptions.DefaultAjaxRequestVerificationToken;
    ReadonlyAuthenticationOptions options = ViewBag.AuthenticationOptions;

    if (options != null) {
        if (!string.IsNullOrWhiteSpace(options.RequestVerificationToken)) {
            verificationHeader = options.RequestVerificationToken;
        }

        if (!string.IsNullOrWhiteSpace(options.AjaxRequestVerificationToken)) {
            useAjaxVerfication = options.AjaxRequestVerificationToken;
        }
    }

    string verificationValue = Html.RequestVerificationHeaderToken();

    string constants = string.Format(@"
        const verificationHeader = ""{0}"";
        const verificationValue = ""{1}"";
        const useAjaxVerfication = ""{2}"";",
        /* 0 */ verificationHeader.JavaScriptEncode(),
        /* 1 */ verificationValue.JavaScriptEncode(),
        /* 2 */ useAjaxVerfication.JavaScriptEncode()
    );
}
@helper BodyRows()
{
    <td width="5%" class="text-center valign-middle"><input type="checkbox" /></td>
    <td width="5%" class="text-center valign-middle"><span data-bind="text: PointID"></span></td>
    <td width="5%" class="text-center valign-middle"><span data-bind="text: SignalType"></span></td>
    <td width="15%" class="text-left valign-middle"><div data-bind="attr: { title: PointTag }"><button type="button" class="btn btn-link btn-sm" data-bind="text: PointTag.truncate(25), click: $parent.viewPageRecord"></button></div></td>
    <td width="5%" class="text-left valign-middle"><span data-bind="attr: { id: 'currentValue' + PointID }"></span></td>
    <td width="15%" class="text-left valign-middle table-cell-hard-wrap"><div data-bind="text: $($element.parentElement).truncateToWidth(SignalReference, 1), attr: { title: SignalReference }"></div></td>
    <td width="45%" class="text-left table-cell-wrap"><div data-bind="text: $($element.parentElement).truncateToWidth(Description, 1.5), attr: { title: Description }"></div></td>
    <td width="5%" class="text-center valign-middle" nowrap>
        <button type="button" class="btn btn-xs" title="View Measurement Detail..." data-bind="click: $parent.viewPageRecord, enable: $parent.dataHubIsConnected"><span class="glyphicon glyphicon-list"></span></button>
    </td>
}
@helper AddNewEditDialog(DataContext dataContext)
{
    <div class="col-md-6">
        @Raw(dataContext.AddInputField<ActiveMeasurement>("ID", customDataBinding: "disable: true"))
        @Raw(dataContext.AddInputField<ActiveMeasurement>("SignalID", customDataBinding: "disable: true"))
        @Raw(dataContext.AddInputField<ActiveMeasurement>("Device"))
        @Raw(dataContext.AddInputField<ActiveMeasurement>("PointTag", initialFocus: true))
        @Raw(dataContext.AddInputField<ActiveMeasurement>("AlternateTag"))
        @Raw(dataContext.AddInputField<ActiveMeasurement>("SignalReference"))
        @Raw(dataContext.AddInputField<ActiveMeasurement>("SignalType"))
        @Raw(dataContext.AddInputField<ActiveMeasurement>("FramesPerSecond"))
    </div>
    <div class="col-md-6">
        @Raw(dataContext.AddTextAreaField<ActiveMeasurement>("Description", 4))
        @Raw(dataContext.AddInputField<ActiveMeasurement>("Protocol"))
        @Raw(dataContext.AddInputField<ActiveMeasurement>("Adder"))
        @Raw(dataContext.AddInputField<ActiveMeasurement>("Multiplier"))
        @Raw(dataContext.AddInputField<ActiveMeasurement>("Company"))
        @Raw(dataContext.AddInputField<ActiveMeasurement>("Longitude"))
        @Raw(dataContext.AddInputField<ActiveMeasurement>("Latitude"))
        <div class="form-inline pull-right">
            @Raw(dataContext.AddCheckBoxField<ActiveMeasurement>("Internal"))&nbsp;
            @Raw(dataContext.AddCheckBoxField<ActiveMeasurement>("Subscribed"))
        </div>
    </div>
}
@helper HistorianInstanceSelect()
{
    @* Make sure to use single quotes in this function: *@
    <form class='form-inline pull-right clearfix' role='form'>
        <small>
            Instance:&nbsp;<select class='form-control' id='instanceName' data-bind='value: instanceName; valueAllowUnset: false' style='border: 0; width: 80px'></select>&nbsp;&nbsp;&nbsp;&nbsp;
        </small>
    </form>
}
@helper ExtendedViewModel(DataContext dataContext)
{
    <script src="@Resources.Root/Shared/Scripts/moment.js"></script>
    <script src="Scripts/bootstrap-datetimepicker.js"></script>
    <script src="Scripts/dateFormat.js"></script>

    <script>
        const MomentDateTimeFormat = dateFormat.convert(DateTimeFormat, dateFormat.dotnet, dateFormat.moment);

        const SubsecondDigits = function() {
            const dotIndex = DateTimeFormat.indexOf(".");

            if (dotIndex < 0 || dotIndex === DateTimeFormat.length - 1)
                return 0;

            return DateTimeFormat.substr(dotIndex + 1).trim().length;
        }();

        var plot;

        // Data query resolutions enumeration
        var Resolution = {
            Full: 0,
            TenPerSecond: 1,
            EverySecond: 2,
            Every10Seconds: 3,
            Every30Seconds: 4,
            EveryMinute: 5,
            Every10Minutes: 6,
            Every30Minutes: 7,
            EveryHour: 8,
            EveryDay: 9,
            EveryMonth: 10
        }

        function estimatePlotResolution(startMoment, endMoment) {
            const span = endMoment.diff(startMoment, "seconds");

            if (span > 0) {
                if (span <= 60)
                    return Resolution.Full;
                if (span <= 300)
                    return Resolution.TenPerSecond;
                if (span <= 1800)
                    return Resolution.EverySecond;
                if (span <= 10800)
                    return Resolution.Every10Seconds;
                if (span <= 28800)
                    return Resolution.Every30Seconds;
                if (span <= 86400)
                    return Resolution.EveryMinute;
                if (span <= 604800)
                    return Resolution.Every10Minutes;
                if (span <= 1814400)
                    return Resolution.Every30Minutes;
                else
                    return Resolution.EveryHour;
            }

            return Resolution.Full;
        }

        function getResolutionDescription(resolution) {
            switch (resolution) {
                case Resolution.Full:
                    return "Full";
                case Resolution.TenPerSecond:
                    return "Ten per Second";
                case Resolution.EverySecond:
                    return "Every Second";
                case Resolution.Every10Seconds:
                    return "Every 10 Seconds";
                case Resolution.Every30Seconds:
                    return "Every 30 Seconds";
                case Resolution.EveryMinute:
                    return "Every Minute";
                case Resolution.Every10Minutes:
                    return "Every 10 Minutes";
                case Resolution.Every30Minutes:
                    return "Every 30 Minutes";
                case Resolution.EveryHour:
                    return "Every Hour";
                case Resolution.EveryDay:
                    return "Every Day";
                case Resolution.EveryMonth:
                    return "Every Month";
            }

            return "Undefined Resolution: " + notNull(resolution);
        }

        function populateDataResolutionSelect() {
            const dataResolutionSelect = $("#trendResolution");

            for (let key in Resolution) {
                if (Resolution.hasOwnProperty(key)) {
                    const value = Resolution[key];
                    dataResolutionSelect.append($("<option>", { value: value, text: getResolutionDescription(value)}));
                }
            }
        }

        function adjustSubsecondDigits(timeValue) {
            if (SubsecondDigits === 0)
                return timeValue;

            const dotIndex = timeValue.indexOf(".");

            if (dotIndex < 0)
                return timeValue + "." + Array(SubsecondDigits + 2).join("0");

            return timeValue + Array(SubsecondDigits - timeValue.substr(dotIndex + 1).trim().length + 1).join("0");
        }

        function postRecordRendering(elements, sequenceRecord) {
            const checkbox = $(elements).find("input[type=checkbox]");

            if (!checkbox)
                return;

            checkbox.click(function() {
                const record = viewModel.pageRecords()[checkbox.parents("tr")[0].rowIndex - 1];

                if (checkbox[0].checked)
                    viewModel.addNewSelectedPointByRecord(record);
                else
                    viewModel.deleteSelectedPointByRecord(record);

                $("#selectAllMessage").invisible();
            });

            // Allow up/down arrow keys to change focus between each row's checkbox
            checkbox.keydown(function(event) {
                if (event.which === 38) {
                    // Arrow up
                    const previousIndex = $(event.target).parents("tr")[0].rowIndex - 1;

                    if (previousIndex >= 0) {
                        const previous = $("#recordsTable").find("input[type=checkbox]:eq(" + previousIndex + ")");

                        if (!$.isEmptyObject(previous))
                            previous.focus();
                    }

                } else if (event.which === 40) {
                    // Arrow down
                    const nextIndex = $(event.target).parents("tr")[0].rowIndex + 1;

                    if (nextIndex <= viewModel.currentPageSize()) {
                        const next = $("#recordsTable").find("input[type=checkbox]:eq(" + nextIndex + ")");

                        if (!$.isEmptyObject(next))
                            next.focus();
                    }
                }
            });
        }

        function ExtendedViewModel() {
            const self = this;

            PagedViewModel.call(self);

            self.selectedPoints = ko.observableArray().extend({ deferred: true });

            self.addNewSelectedPoint = function(id, tag, signalType, description) {
                if (!self.selectedPoints().any(function(point) { return point.id === id })) {
                    self.selectedPoints.push({ id: id, tag: tag, signalType: signalType, description: description });

                    setTimeout(function () {
                        const container = $("#scrollablePointsArea");

                        if (container) {
                            const row = $("#selectedPoints").parent().find("tr:last");

                            if (row) {
                                container.scrollTop(row.position().top + row.height());
                            }
                        }
                    }, 100);
                }
            }

            self.deleteSelectedPoint = function(point) {
                self.selectedPoints.remove(point);
                $(self).trigger("selectedPointRemoved", point);
            }

            self.refreshSelectedPoints = function() {
                self.selectedPoints.valueHasMutated();
            }

            self.clearSelectedPoints = function() {
                const placeholder = $("#placeholder");

                self.selectedPoints([]);
                placeholder.empty();

                $("#selectAllMessage").invisible();
                $("#selectAllCheckbox")[0].checked = false;

                if (typeof selectPageRecords === "function")
                    selectPageRecords(false);
            }

            self.addNewSelectedPointByRecord = function(record) {
                self.addNewSelectedPoint(record.PointID, record.PointTag, record.SignalType, record.Description);
            }

            self.deleteSelectedPointByRecord = function(record) {
                self.selectedPoints().any(function(point) {
                    if (point.id === record.PointID)
                        self.deleteSelectedPoint(point);
                });
            }

            self.getSelectedPointIDs = function() {
                var selectedPointIDs = [];

                self.selectedPoints().forEach(function(point) {
                    selectedPointIDs.push(point.id);
                });

                return selectedPointIDs;
            }

            self.getSeries = function(selectedPoint) {
                if (!plot)
                    return null;

                const series = plot.getData();

                if (!series)
                    return null;

                for (let i = 0; i < series.length; i++) {
                    const label = notNull(series[i].label);
                    const leftBracketIndex = label.indexOf("[");
                    const rightBracketIndex = label.indexOf("]");

                    if (leftBracketIndex > -1 && rightBracketIndex > -1) {
                        if (selectedPoint.id === parseInt(label.substring(leftBracketIndex + 1, rightBracketIndex)))
                            return { index: i, value: series[i] };
                    }
                }

                return null;
            }

            self.getSeriesColor = function(selectedPoint) {
                const series = self.getSeries(selectedPoint);

                if (!series)
                    return "transparent";

                return series.value.color;
            }

            self._startTime = ko.observable(adjustSubsecondDigits(moment.utc().subtract(5, "minutes").format(MomentDateTimeFormat)));
            self._endTime = ko.observable(adjustSubsecondDigits(moment.utc().format(MomentDateTimeFormat)));

            self.startTime = ko.pureComputed({
                read: function() {
                    return self._startTime();
                },
                write: function(value) {
                    self._startTime(value);

                    if (self.timeRange.isValid()) {
                        const startMoment = self.startMoment();
                        const endMoment = self.endMoment();

                        if (self.autoEstimateResolution())
                            self.trendResolution(estimatePlotResolution(startMoment, endMoment));

                        if (self.dataHubIsConnected())
                            dataHub.getElapsedTimeString(startMoment.toDate(), endMoment.toDate()).done(function(elapsedTime) {
                                self.elapsedTime(elapsedTime);
                            });
                    } else {
                        self.elapsedTime("Invalid time range selected.");
                    }
                },
                owner: self
            });

            self.endTime = ko.pureComputed({
                read: function() {
                    return self._endTime();
                },
                write: function(value) {
                    self._endTime(value);

                    if (self.useInterval() && !self.fromNow()) {
                        self.applyIntervalRange();
                    }

                    if (self.timeRange.isValid()) {
                        const startMoment = self.startMoment();
                        const endMoment = self.endMoment();

                        if (self.autoEstimateResolution())
                            self.trendResolution(estimatePlotResolution(startMoment, endMoment));

                        if (self.dataHubIsConnected())
                            dataHub.getElapsedTimeString(startMoment.toDate(), endMoment.toDate()).done(function(elapsedTime) {
                                self.elapsedTime(elapsedTime);
                            });
                    } else {
                        self.elapsedTime("Invalid time range selected.");
                    }
                },
                owner: self
            });

            self.startMoment = ko.pureComputed({
                read: function() {
                    return moment.utc(self.startTime(), MomentDateTimeFormat);
                },
                owner: self
            });

            self.endMoment = ko.pureComputed({
                read: function() {
                    return moment.utc(self.endTime(), MomentDateTimeFormat);
                },
                owner: self
            });

            self.preciseTimeDiff = function() {
                var difference = self.endMoment().diff(self.startMoment());

                if (difference === 0) {
                    const endTime = self.endTime().toString();
                    const startTime = self.startTime().toString();
                    const endTimePointIndex = endTime.indexOf(".") + 1;
                    const startTimePointIndex = startTime.indexOf(".") + 1;

                    if (endTimePointIndex > 0 && startTimePointIndex > 0 && endTimePointIndex < endTime.length && startTimePointIndex < startTime.length) {
                        const fractionalTimeDiff = parseInt(endTime.substr(endTimePointIndex)) - parseInt(startTime.substr(startTimePointIndex));

                        if (isNumber(fractionalTimeDiff) && fractionalTimeDiff !== 0)
                            difference = 10000000 / fractionalTimeDiff;
                    }
                }

                return difference;
            }

            self.timeRange = ko.validatedObservable([{
                startTime: self.startTime.extend({
                    required: {
                        message: "<br />Start time is required"
                    },
                    validation: {
                        validator: function() {
                            return self.preciseTimeDiff() > 0;
                        },
                        message: "<br />Start time must be less than end time"
                    }
                })
            }, {
                endTime: self.endTime.extend({
                    required: {
                        message: "<br />End time is required"
                    },
                    validation: {
                        validator: function() {
                            return self.preciseTimeDiff() > 0;
                        },
                        message: "<br />End time must be greater than start time"
                    }
                })
            }]);

            var trendSeriesLimitValue = Cookies.get("trendSeriesLimit");

            if (trendSeriesLimitValue === undefined)
                trendSeriesLimitValue = "500";

            var timestampSnap = Cookies.get("timestampSnap");
            var alignTimestamps = Cookies.get("alignTimestamps");
            var missingAsNaN = Cookies.get("missingAsNaN");
            var fillMissingTimestamps = Cookies.get("fillMissingTimestamps");
            var tolerance = Cookies.get("tolerance");
            var fileFormat = Cookies.get("fileFormat");

            if (timestampSnap === undefined)
                timestampSnap = 0;
            else
                timestampSnap = parseInt(timestampSnap);

            if (alignTimestamps === undefined)
                alignTimestamps = true;
            else
                alignTimestamps = getBool(alignTimestamps);

            if (missingAsNaN === undefined)
                missingAsNaN = true;
            else
                missingAsNaN = getBool(missingAsNaN);

            if (fillMissingTimestamps === undefined)
                fillMissingTimestamps = false;
            else
                fillMissingTimestamps = getBool(fillMissingTimestamps);

            if (tolerance === undefined)
                tolerance = true;
            else
                tolerance = getBool(tolerance);

            if (fileFormat === undefined)
                fileFormat = -1;
            else
                fileFormat = parseInt(fileFormat);

            self.tolerance = ko.observable(tolerance);

            var autoEstimateResolutionValue = Cookies.get("autoEstimateResolution");

            if (autoEstimateResolutionValue === undefined)
                autoEstimateResolutionValue = true;
            else
                autoEstimateResolutionValue = (autoEstimateResolutionValue === "true");

            var autoTrendValue = Cookies.get("autoTrend");

            if (autoTrendValue === undefined)
                autoTrendValue = true;
            else
                autoTrendValue = (autoTrendValue === "true");

            self._instanceName = ko.observable("");
            self._alignTimestamps = ko.observable(alignTimestamps);
            self._trendSeriesLimit = ko.observable(parseInt(trendSeriesLimitValue));
            self._autoEstimateResolution = ko.observable(autoEstimateResolutionValue);
            self._autoTrend = ko.observable(autoTrendValue);
            self._useInterval = ko.observable(false);
            self._fromNow = ko.observable(true);
            self._interval = ko.observable(5);
            self._intervalUnits = ko.observable(1);

            self.trendResolution = ko.observable(Resolution.EverySecond);
            self.elapsedTime = ko.observable("");
            self.fileFormat = ko.observable(fileFormat);
            self.frameRate = ko.observable(30);
            self.frameBase = ko.observable(0);
            self.timestampSnap = ko.observable(timestampSnap);

            self.missingAsNaN = ko.observable(missingAsNaN);
            self.fillMissingTimestamps = ko.observable(fillMissingTimestamps);
            self.selectAllProgress = ko.observable("0%");

            self.fillMissingTimestamps.subscribe(function (val) {
                Cookies.set("fillMissingTimestamps", val.toString(), { expires: 365 });
            });

            self.missingAsNaN.subscribe(function(val) {
                Cookies.set("missingAsNaN", val.toString(), { expires: 365 });
            });

            self.timestampSnap.subscribe(function(val) {
                Cookies.set("timestampSnap", val.toString(), { expires: 365 });
            });

            self.tolerance.subscribe(function(val) {
                Cookies.set("tolerance", val.toString(), { expires: 365 });

                if (val) {
                    showInfoMessage("WARNING: Exporting data with the \"Round to Frame Rate Timestamps\" option will result in an export with generated timestamps.", 10000);
                }
            });

            self.fileFormat.subscribe(function(val) {
                Cookies.set("fileFormat", val.toString(), { expires: 365 });
            });

            self.instanceName = ko.pureComputed({
                read: function() {
                    return self._instanceName();
                },
                write: function(value) {
                    if (value === self._instanceName())
                        return;

                    if (value) {
                        self._instanceName(value);
                        Cookies.set("instanceName", value.toString(), { expires: 365 });
                    } else {
                        self._instanceName("");
                    }

                    self.clearSelectedPoints();

                    if (self.dataHubIsConnected()) {
                        dataHub.getSelectedInstanceName().done(function(selectedInstanceName) {
                            const currentInstanceName = self._instanceName();

                            if (selectedInstanceName !== currentInstanceName) {
                                dataHub.setSelectedInstanceName(currentInstanceName).done(function() {
                                    self.initialize();
                                });
                            }
                        });
                    }
                },
                owner: self
            });

            self.trendSeriesLimit = ko.pureComputed({
                read: function() {
                    return self._trendSeriesLimit();
                },
                write: function(value) {
                    self._trendSeriesLimit(value);
                    Cookies.set("trendSeriesLimit", value.toString(), { expires: 365 });
                },
                owner: self
            });

            self.autoEstimateResolution = ko.pureComputed({
                read: function() {
                    return self._autoEstimateResolution();
                },
                write: function(value) {
                    self._autoEstimateResolution(value);
                    Cookies.set("autoEstimateResolution", value.toString(), { expires: 365 });
                },
                owner: self
            });

            self.autoTrend = ko.pureComputed({
                read: function() {
                    return self._autoTrend();
                },
                write: function(value) {
                    self._autoTrend(value);
                    Cookies.set("autoTrend", value.toString(), { expires: 365 });
                },
                owner: self
            });

            self.applyIntervalRange = function() {
                var intervalUnits = null;

                switch (parseInt(self.intervalUnits())) {
                    case 0:
                        intervalUnits = "seconds";
                        break;
                    case 1:
                        intervalUnits = "minutes";
                        break;
                    case 2:
                        intervalUnits = "hours";
                        break;
                    case 3:
                        intervalUnits = "days";
                        break;
                }

                if (!intervalUnits)
                    return;

                if (self.fromNow()) {
                    self.startTime(moment.utc().subtract(self.interval(), intervalUnits).format(MomentDateTimeFormat));
                    self.endTime(moment.utc().format(MomentDateTimeFormat));
                }
                else {
                    self.startTime(moment(self.endMoment()).subtract(self.interval(), intervalUnits).format(MomentDateTimeFormat));
                }
            }

            self.alignTimestamps = ko.pureComputed({
                read: function() {
                    return self._alignTimestamps();
                },
                write: function(value) {
                    self._alignTimestamps(value);
                    Cookies.set("alignTimestamps", value.toString(), { expires: 365 });
                    if (!value) {
                        self.fillMissingTimestamps(false);
                        self.tolerance(false);
                    }
                },
                owner: self
            });

            self.useInterval = ko.pureComputed({
                read: function() {
                    return self._useInterval();
                },
                write: function(value) {
                    self._useInterval(value);

                    if (value)
                        self.applyIntervalRange();
                },
                owner: self
            });

            self.fromNow = ko.pureComputed({
                read: function () {
                    return self._fromNow();
                },
                write: function (value) {
                    self._fromNow(value);

                    if (self.useInterval()) {
                        self.applyIntervalRange();
                    }
                },
                owner: self
            });

            self.fromNowOption = ko.pureComputed({
                read: function() {
                    return self.fromNow() ? "FromNow" : "FromEndTime";
                },
                write: function(value) {
                    self.fromNow(value === "FromNow");
                },
                owner: self
            });

            self.interval = ko.pureComputed({
                read: function() {
                    return self._interval();
                },
                write: function(value) {
                    self._interval(value);
                    self.applyIntervalRange();
                },
                owner: self
            });

            self.intervalUnits = ko.pureComputed({
                read: function() {
                    return self._intervalUnits();
                },
                write: function(value) {
                    self._intervalUnits(value);
                    self.applyIntervalRange();
                },
                owner: self
            });

            self.saveSelections = function(fileName) {
                const data = JSON.stringify(self.selectedPoints(), null, 4);
                const anchor = $("#saveSelectionsFileLink");

                if (typeof anchor[0].download != "undefined") {
                    anchor.attr("href", "data:text/json;charset=utf-8," + encodeURIComponent(data));
                    anchor.attr("download", fileName);
                    anchor[0].click();
                } else {
                    if (isIE)
                        window.navigator.msSaveBlob(new Blob([data]), fileName);
                    else
                        window.open("data:text/json;charset=utf-8," + encodeURIComponent(data), "_blank", "");
                }
            }

            self.loadSelections = function(fileBlob) {
                var reader = new FileReader();

                reader.onload = function() {
                    self.clearSelectedPoints();
                    self.selectedPoints(JSON.parse(reader.result));
                }

                reader.onloadend = function() {
                    if (reader.error && reader.error.message)
                        showErrorMessage("Failed to load point selections: " + reader.error.message, null, true);
                };

                reader.readAsText(fileBlob);
            }

            self.sortSelections = function() {
                self.selectedPoints.sort(function(a, b) {
                    return a.id - b.id;
                });
            }
        }

        function extendViewModel(event, data) {
            const newViewModel = new ExtendedViewModel();
            data.viewModel.cloneConfiguration(newViewModel);
            data.viewModel = newViewModel;

            // Populate data resolution drop-down before binding
            populateDataResolutionSelect();

            // Define instance name selector before binding
            $("#titleText").parent("h3").append("@Raw(HistorianInstanceSelect().ToString().RemoveDuplicateWhiteSpace().Replace("\r\n", ""))");

            ko.bindingHandlers.dateTimePicker = {
                init: function (element, valueAccessor, allBindingsAccessor) {
                    // Initialize datepicker with some basic options
                    const options = allBindingsAccessor().dateTimePickerOptions || { showClose: true, useCurrent: false, format: MomentDateTimeFormat };

                    $(element).datetimepicker(options);

                    // When user changes the date, update view model
                    ko.utils.registerEventHandler(element, "dp.change", function (event) {
                        const value = valueAccessor();

                        if (ko.isObservable(value) && event.date != null) {
                            if (event.date._isAMomentObject)
                                value(event.date.format(MomentDateTimeFormat));
                            else if (event.date instanceof Date)
                                value(event.date.formatDate(DateTimeFormat, true));
                        }
                    });

                    ko.utils.registerEventHandler(element, "dp.show", function (event) {
                        const picker = $(element).data("DateTimePicker");

                        if (picker)
                            picker.date(moment.utc(ko.utils.unwrapObservable(valueAccessor()), MomentDateTimeFormat));
                    });

                    ko.utils.domNodeDisposal.addDisposeCallback(element, function () {
                        const picker = $(element).data("DateTimePicker");

                        if (picker)
                            picker.destroy();
                    });
                }
            }

            ko.validation.init({
                registerExtenders: true,
                messagesOnModified: true,
                insertMessages: true,
                parseInputAttributes: true,
                allowHtmlMessages: true,
                messageTemplate: null,
                decorateElement: true,
                errorElementClass: "has-error",
                errorMessageClass: "help-block",
                grouping: { deep: true, observable: true, live: true }
            }, true);
        }

        $(window).on("beforeApplyBindings", extendViewModel);

        function refreshSeriesColors() {
            const selectedPointsTable = $("#selectedPoints")[0];

            viewModel.selectedPoints().forEach(function(point, index) {
                $(selectedPointsTable.rows[index].cells[1]).find("hr.series-color").css("background-color", viewModel.getSeriesColor(point));
            });
        }
    </script>
}
@section Scripts {
    <script src="@Resources.Root/Shared/Scripts/primeui.js"></script>
    <script src="@Resources.Root/Shared/Scripts/flot/jquery.flot.min.js"></script>
    <script src="@Resources.Root/Shared/Scripts/flot/jquery.flot.crosshair.min.js"></script>
    <script src="@Resources.Root/Shared/Scripts/flot/jquery.flot.navigate.min.js"></script>
    <script src="@Resources.Root/Shared/Scripts/flot/jquery.flot.resize.min.js"></script>
    <script src="@Resources.Root/Shared/Scripts/flot/jquery.flot.selection.min.js"></script>
    <script src="@Resources.Root/Shared/Scripts/flot/jquery.flot.time.min.js"></script>
    <script src="@Resources.Root/Shared/Scripts/flot/jquery.flot.axislabels.min.js"></script>
    <script>

        "use strict";

        @Raw(new Minifier().MinifyJavaScript(constants));

        @Raw(dataContext.RenderViewModelConfiguration<ActiveMeasurement, DataHub>(ViewBag, "PointTag"))
        const progressRefreshRate = 1000;
        var uriProtocolScheme = null;
        var exportOperationHandle = 0;
        var lastProgress = 0;
        var plotData = [];
        var trendQueue = [];
        var clickHandled = false;
        var panCenter = null;

        function getAxisIndex(signalType) {
            switch (signalType.toUpperCase().trim()) {
                case "FREQ":
                    return 1;
                case "VPHM":
                    return 2;
                case "IPHM":
                    return 3;
                case "VPHA":
                case "IPHA":
                    return 4;
            }

            return 2;
        }

        function buildPlot(data) {
            var elements = new Dictionary(); // Key = ID, Value = Array([Timestamp, Value])
            var elementData;
            plotData = [];

            $.each(data, function(i, trendValue) {
                // See if this is a newly encountered point
                if (elements.containsKey(trendValue.ID)) {
                    // Key already initialized, get element data for ID
                    elementData = elements.get(trendValue.ID);
                } else {
                    // Initialize new element data for ID
                    var point = null;
                    elementData = [];

                    // Find associated selected point
                    $.each(viewModel.selectedPoints(),
                        function(j, selectedPoint) {
                            if (selectedPoint.id === trendValue.ID) {
                                point = selectedPoint;
                                return false; // break
                            }

                            return true;
                        });

                    if (point) {
                        // Note that [n] in label is used to map label back to selected point for applying series color, so do not remove
                        plotData.push({ label: String.format("[{0}] {1} ({2})", point.id, point.tag, point.signalType), yaxis: getAxisIndex(point.signalType), data: elementData });
                        elements.set(trendValue.ID, elementData);
                    }
                }

                // Add measurement time and value to element data
                elementData.push([trendValue.Timestamp, trendValue.Value]);
            });

            const placeholder = $("#placeholder");
            const initialized = (plot !== undefined);

            plot = $.plot(placeholder, plotData,
                {
                    series: {
                        shadowSize: 1,
                        lines: {
                            show: true
                        },
                        points: {
                            show: $("#showPoints")[0].checked
                        }
                    },
                    grid: {
                        hoverable: true,
                        clickable: true
                    },
                    yaxes: [
                        {
                            show: viewModel.selectedPoints().any(function(point) { return point.signalType === "FREQ" }),
                            position: "left",
                            axisLabel: "Frequency",
                            panRange: false,
                            zoomRange: false
                        }, {
                            show: viewModel.selectedPoints().any(function(point) { return point.signalType === "VPHM" }),
                            position: "left",
                            axisLabel: "Voltage",
                            panRange: false,
                            zoomRange: false
                        }, {
                            show: viewModel.selectedPoints().any(function(point) { return point.signalType === "IPHM" }),
                            position: "right",
                            axisLabel: "Current",
                            panRange: false,
                            zoomRange: false
                        }, {
                            show: viewModel.selectedPoints().any(function(point) { return point.signalType === "VPHA" || point.signalType === "IPHA" }),
                            position: "right",
                            axisLabel: "Angle",
                            panRange: false,
                            zoomRange: false
                        }
                    ],
                    xaxis: {
                        mode: "time",
                        timeformat: "%H:%M:%S",
                        timezone: "UTC",
                        reserveSpace: true,
                        zoomRange: [1, 3.154e+11]
                    } ,
                    legend: {
                        show: true
                    },
                    zoom: {
                        interactive: true,
                        amount: 1.2,
                        mode: "x"
                    },
                    selection: {
                        mode: "x"
                    }
                });

            if (!initialized)
                initializePlot(placeholder);
        }

        function getValidTimeRange(startDate, endDate) {
            var startMoment = moment.utc(startDate);
            var endMoment = moment.utc(endDate);
            const diff = endMoment.diff(startMoment);

            if (startMoment <= 0 || endMoment <= 0) {
                if (startMoment <= 0 && endMoment > 0) {
                    startMoment = endMoment.subtract(5, "minutes");
                }
                else if (endMoment <= 0 && startMoment > 0) {
                    endMoment = startMoment.add(5, "minutes");
                }
                else {
                    startMoment = moment.utc().subtract(5, "minutes");
                    endMoment = moment.utc();
                }
            } else if (diff < 2) {
                startMoment = startMoment.subtract(0.25, "seconds");
                endMoment = endMoment.add(0.25, "seconds");
            }

            if (endMoment > moment.utc()) {
                startMoment.subtract(endMoment.diff(moment.utc()));
                endMoment = moment.utc();
            }

            return {
                startDate: startMoment.toDate(),
                endDate: endMoment.toDate()
            };
        }

        function getRangeDifference(range) {
            return moment.utc(range.endDate).diff(moment.utc(range.startDate));
        }

        function compareRange(startRange, endRange) {
            return getRangeDifference(startRange) - getRangeDifference(endRange);
        }

        function initializePlot(placeholder) {
            placeholder.on("plotselected", function(event, ranges) {
                if (!$("#showLegend")[0].checked)
                    $(".legend").hide();

                const range = getValidTimeRange(new Date(ranges.xaxis.from), new Date(ranges.xaxis.to));
                viewModel.startTime(range.startDate.formatDate());
                viewModel.endTime(range.endDate.formatDate());
                trendData();
            });

            placeholder.on("plotzoom", function(event, plot, args) {
                if (!$("#showLegend")[0].checked)
                    $(".legend").hide();

                const axes = plot.getAxes();
                var newRange = getValidTimeRange(new Date(axes.xaxis.min), new Date(axes.xaxis.max));
                const currentRange = getValidTimeRange(viewModel.startMoment(), viewModel.endMoment());
                const comparison = compareRange(newRange, currentRange);
                const queueZoomForTrending = args.zoomingOut ? comparison >= 0 : comparison < 0;

                if (!queueZoomForTrending) {
                    var startMoment = viewModel.startMoment();
                    var endMoment = viewModel.endMoment();
                    const amount = viewModel.preciseTimeDiff() / plot.getOptions().zoom.amount;

                    if (args.zoomingOut) {
                        startMoment = startMoment.subtract(amount / 2);
                        endMoment = endMoment.add(amount / 2);

                        if (moment.utc().diff(endMoment) < 0)
                            endMoment = moment.utc();
                    }
                    else {
                        startMoment = startMoment.add(amount);
                    }

                    newRange = getValidTimeRange(startMoment, endMoment);
                }

                viewModel.startTime(newRange.startDate.formatDate());
                viewModel.endTime(newRange.endDate.formatDate());

                if (viewModel.autoTrend())
                    trendData();
            });

            placeholder.bind("plothover", function (event, pos, item) {
                if (item) {
                    const toolTipText = String.format("{0} at {1} = {2}", item.series.label, (new Date(item.datapoint[0])).formatDate(), item.datapoint[1].toFixed(2));
                    $("#plotToolTip").html(toolTipText).css({ top: item.pageY + 5, left: item.pageX + 5 }).fadeIn(200);
                } else {
                    $("#plotToolTip").hide();
                }
            });

            placeholder.bind("plotclick", function (event, pos, item) {
                if (clickHandled || !item)
                    return;

                plot.highlight(item.series, item.datapoint);
            });

            placeholder.mouseleave(function() {
                $("#plotToolTip").hide();
            });

            placeholder.mousedown(function(e) {
                if (e.which !== 1) {
                    clickHandled = true;
                    return;
                }

                if (e.shiftKey) {
                    panCenter = { x: e.pageX, y: e.pageY };
                    plot.suspendSelection();

                    if (!$("#showLegend")[0].checked)
                        $(".legend").hide();

                    $(document).one("mouseup", function(e) {
                        if (e.which === 1 && panCenter != null) {
                            panCenter = null;
                            plot.resumeSelection();

                            if (!$("#showLegend")[0].checked)
                                $(".legend").hide();
                        }
                    });
                }

                clickHandled = false;
            });

            placeholder.mousemove(function(e) {
                if (panCenter != null) {
                    const xaxis = plot.getAxes().xaxis;
                    const panDistance = { left: panCenter.x - e.pageX, top: 0 };

                    plot.pan(panDistance);

                    if (!$("#showLegend")[0].checked)
                        $(".legend").hide();

                    panCenter.x -= panDistance.left;

                    const range = getValidTimeRange(new Date(xaxis.min), new Date(xaxis.max));
                    viewModel.startTime(range.startDate.formatDate());
                    viewModel.endTime(range.endDate.formatDate());

                    clickHandled = true;

                    if (viewModel.autoTrend())
                        trendData();
                }
            });
        }

        $(viewModel).on("selectedPointRemoved", function(event, point) {
            const series = viewModel.getSeries(point);

            if (series) {
                const plotData = plot.getData();
                plotData.splice(series.index, 1);
                plot.setData(plotData);
                plot.setupGrid();
                plot.draw();

                if (!$("#showLegend")[0].checked)
                    $(".legend").hide();
            }
        });

        function displayTimeRange() {
            if (!hubIsConnected || !viewModel.timeRange.isValid())
                return;

            dataHub.getElapsedTimeString(viewModel.startMoment().toDate(), viewModel.endMoment().toDate()).done(function(elapsedTime) {
                viewModel.elapsedTime(elapsedTime);
            });
        }

        function getHistorianData(instanceName, startTime, stopTime, measurementIDs, resolution, seriesLimit, forceLimit, timestampType) {
            const queryParameters = {
                instanceName: instanceName,
                startTime: startTime,
                stopTime: stopTime,
                measurementIDs: measurementIDs,
                resolution: resolution,
                seriesLimit: seriesLimit,
                forceLimit: forceLimit
            };

            if (timestampType !== undefined)
                queryParameters.timestampType = timestampType;

            return $.ajax({
                url: "/api/HistorianQuery/GetHistorianData",
                method: "POST",
                contentType: "application/json; charset=UTF-8",
                dataType: "json",
                data: JSON.stringify(queryParameters)
            });
        }

        function processNextTrend() {
            if (trendQueue.length > 1) {
                trendQueue.shift();
                setTimeout(processNextTrend, 100);
                return;
            }

            const trend = trendQueue.pop();

            if (!trend)
                return;

            const instanceName = trend.instanceName;
            const startDate = trend.startDate;
            const endDate = trend.endDate;
            const resolution = trend.resolution;

            if (isEmpty(instanceName))
                return;

            try {

                const selectedPointIDs = viewModel.getSelectedPointIDs();

                if (selectedPointIDs.length === 0)
                    return;

                $("html,body").addClass("busy-state");
                viewModel.useInterval(false);

                const queryStartTime = performance.now();

                getHistorianData(instanceName, startDate, endDate, selectedPointIDs, resolution, viewModel.trendSeriesLimit(), false)
                    .done(function (data) {
                        const graphStartTime = performance.now();

                        $("#queryTime").text((graphStartTime - queryStartTime).toFixed(3));

                        buildPlot(data);
                        plot.setData(plotData);
                        plot.setupGrid();
                        plot.draw();
                        refreshSeriesColors();

                        if (!$("#showLegend")[0].checked)
                            $(".legend").hide();

                        $("html,body").removeClass("busy-state");
                        $("#graphTime").text((performance.now() - graphStartTime).toFixed(3));
                        $("#pointCount").text(data.length);
                    })
                    .fail(function(error) {
                        showErrorMessage(error);
                        $("html,body").removeClass("busy-state");
                    });
            }
            catch (ex) {
                showErrorMessage(ex.message);
                $("html,body").removeClass("busy-state");
            }
        }

        function trendData() {
            if (!hubIsConnected)
                return;

            const startMoment = viewModel.startMoment();
            const endMoment = viewModel.endMoment();

            if (endMoment.diff(startMoment) <= 0)
                return;

            trendQueue.push({
                instanceName: viewModel.instanceName(),
                startDate: startMoment.toDate(),
                endDate: endMoment.toDate(),
                resolution: viewModel.trendResolution()
            });

            setTimeout(processNextTrend, 200);
        }

        // Define a function to update UI with data export progress
        function updateProgress(state) {
            const progressBar = $("#progressBar");
            const progress = state.Progress;
            const total = state.Completed ? state.Progress : state.Total;
            const progressValue = (progress / total * 100.0).toFixed(2);

            $("#progressLabel").text(String.format("{0} / {1}", Math.round(progress / 10000000).toLocaleString(), Math.round(total / 10000000).toLocaleString()));

            if (isNumber(progressValue)) {
                progressBar.text(progressValue.toString() + "%");
                progressBar.css("width", progressBar.text());

                if (progressValue < 100.0 && !progressBar.hasClass("active"))
                    progressBar.addClass("active");
                else if (progressValue >= 100.0 && progressBar.hasClass("active"))
                    progressBar.removeClass("active");
            }

            if (progress > 0) {
                $("#progressRate").text(String.format("Exporting {0} minutes of data per second...", (state.OperationRate / 6000000000).toLocaleString()));
                $("#remainingTime").text(state.RemainingTimeEstimate);
                $("#totalTime").text(state.TotalOperationTime);

                if (lastProgress === 0)
                    setTimeout(function() { $("#timeEstimate").show(); }, progressRefreshRate * 2);

                lastProgress = progress;
            }
        };

        function launchUpdaterApp() {
            if (!uriProtocolScheme)
                return;

            // When user clicks launch button, create emphasis on
            // download application message since this will often
            // be primary action when application does not launch
            const button = $("#launchButton");
            const message = $("#downloadAndRunMessage");

            button.css("margin-bottom", "0px");
            message.css("font-size", "110%");
            message.css("font-weight", "bolder");
            message.css("color", "black");
            message.css("background", "lightyellow");
            message.css("border-radius", "5px");
            message.css("padding", "5px");

            window.open(uriProtocolScheme, "_self");
        }

        function checkUpdaterComplete(state) {
            if (!uriProtocolScheme || getActiveTab() !== 2 || !viewModel.dataHubIsConnected()) {
                hideInfoMessage();
                uriProtocolScheme = null;
                return;
            }

            dataHub.checkIfUpdateCOMTRADECountersIsCompleted(state.OperationHandle).done(function (completed) {
                if (completed) {
                    showInfoMessage("COMTRADE CFF successfully updated with end sample count " + state.EndSampleCount + (viewModel.fileFormat() > 0 ? " and binary byte count " + state.BinaryByteCount : ""), 10000, true);
                    uriProtocolScheme = null;
                }
                else {
                    setTimeout(() => checkUpdaterComplete(state), 1000);
                }
            })
            .fail(function () {
                hideInfoMessage();
                uriProtocolScheme = null;
            });
        }

        // Define a function to check data export progress
        function checkProgress() {
            if (!viewModel.dataHubIsConnected())
                return;

            dataHub.getHistorianOperationState(exportOperationHandle).done(function (state) {
                if (state.Completed) {
                    let openCOMTRADEUpdater = "";

                    if (viewModel.fileFormat() >= 0) {
                        if (viewModel.fileFormat() == 0)
                            state.BinaryByteCount = 0;

                        const callback = "@updateCompleteCallback" + encodeURIComponent(exportOperationHandle);

                        uriProtocolScheme = "comtrade-update-counter://open?" +
                            "targetExportName=" + encodeURIComponent(state.TargetExportName) +
                            "&endSampleCount=" + encodeURIComponent(state.EndSampleCount) +
                            "&binaryByteCount=" + encodeURIComponent(state.BinaryByteCount) +
                            "&callback=" + encodeURIComponent(callback);

                        openCOMTRADEUpdater =
                            "<br/><br/><span style='background: yellow; color: black; font-weight: bold; padding: 5px; border-radius: 5px'>Need to update COMTRADE CFF with end sample count " + state.EndSampleCount +
                            (viewModel.fileFormat() > 0 ? " and binary byte count " + state.BinaryByteCount : "") + ", <span style='color: firebrick'>attempting to launch counter update app:</span></span><br/><br/>" +
                            "<div><p style='text-align: center'>Click <strong>Open UpdateCOMTRADECounters</strong> on browser dialog or click button below to launch app, if needed:</p></div>" +
                            "<div style='margin-bottom: -10px'><p style='text-align: center'><button id='launchButton' type='button' class='btn' style='margin-bottom: -10px; background: blue; color: ghostwhite' onclick='launchUpdaterApp()'><strong>Launch UpdateCOMTRADECounters</string></button><br/><br/>" +
                            "<span id='downloadAndRunMessage' style='font-size: 85%'>&nbsp;App not not launching?&nbsp;<a href='@UpdateCOMTRADECounters' style='font-style: italic'>Click Here to Download and Run</a>&nbsp;&nbsp;</span></p></div>";

                        copyToClipboard(uriProtocolScheme);
                        window.open(uriProtocolScheme, "_self");

                        // Monitor for application completion
                        setTimeout(() => checkUpdaterComplete(state), 1000);
                    }
                    else {
                        uriProtocolScheme = null;
                    }

                    showInfoMessage(String.format(
                        "Data export complete in {0} averaging {1} minutes of data per second" + openCOMTRADEUpdater,
                        state.TotalOperationTime,
                        (state.OperationRate / 6000000000).toLocaleString()
                    ), -1, true);

                    $("#exportingLabel").text("Complete");
                    $("#progressIcon").hide();
                    $("#cancelDataExport").disable();

                    updateProgress(state);
                    setTimeout(function () { $("#exportingDataDialog").modal("hide"); }, 1500);
                }
                else if (state.Failed) {
                    showErrorMessage("Data export failed: " + state.FailedReason, null, true);

                    $("#exportingLabel").text("Failed");
                    $("#progressIcon").hide();
                    $("#cancelDataExport").disable();

                    setTimeout(function () { $("#exportingDataDialog").modal("hide"); }, 1000);
                }
                else if (state.CancellationToken.IsCancelled) {
                    showInfoMessage("Data export cancelled", -1, true);

                    $("#exportingLabel").text("Cancelled");
                    $("#progressIcon").hide();
                    $("#cancelDataExport").disable();

                    setTimeout(function () { $("#exportingDataDialog").modal("hide"); }, 1000);
                }
                else {
                    updateProgress(state);
                    setTimeout(checkProgress, progressRefreshRate);
                }
            })
            .fail(function (error) {
                $("#exportingDataDialog").modal("hide");
                showErrorMessage("Failed while checking data export status: " + error);
            });
        };

        function exportData() {
            if (!hubIsConnected)
                return;

            uriProtocolScheme = null;
            showInfoMessage("Exporting data, please wait...", -1, true);
            disableUIButtons();

            const startTime = adjustSubsecondDigits(viewModel.startTime());
            const endTime = adjustSubsecondDigits(viewModel.endTime());

            dataHub.beginDataExport(startTime, endTime).done(function (operationHandle) {
                // Track export operation handle so data export can be monitored or cancelled
                exportOperationHandle = operationHandle;

                const selectedPointIDs = viewModel.getSelectedPointIDs();

                if (selectedPointIDs.length === 0)
                    return;

                let adjustedFrameRate = viewModel.frameRate();

                if (viewModel.frameBase() == 1)
                    adjustedFrameRate = adjustedFrameRate / 60.0;

                if (viewModel.frameBase() == 2)
                    adjustedFrameRate = adjustedFrameRate / (60.0 * 60.0);

                let tolerance = 0.5;

                if (viewModel.tolerance())
                    tolerance = 500 / adjustedFrameRate;

                $.ajax({
                    cache: false,
                    url: "ExportDataHandler.ashx",
                    method: "post",
                    data: selectedPointIDs.join(),
                    dataType: "text",
                    success: function (cacheID) {
                        const progressBar = $("#progressBar");

                        progressBar.text("0%");
                        progressBar.css("width", "0");
                        progressBar.removeClass("active");

                        $("#progressLabel").text("");
                        $("#exportingLabel").text("Exporting");
                        $("#progressRate").text("");
                        $("#remainingTime").text("");
                        $("#totalTime").text("");
                        $("#timeEstimate").hide();
                        $("#progressIcon").show();
                        $("#cancelDataExport").enable();
                        $("#exportingDataDialog").modal("show");

                        $("#exportDataLink").attr("href", "ExportDataHandler.ashx" +
                            "?CacheID=" + encodeURIComponent(cacheID) +
                            "&StartTime=" + encodeURIComponent(startTime) +
                            "&EndTime=" + encodeURIComponent(endTime) +
                            "&FrameRate=" + encodeURIComponent(adjustedFrameRate) +
                            "&AlignTimestamps=" + encodeURIComponent(viewModel.alignTimestamps()) +
                            "&MissingAsNaN=" + encodeURIComponent(viewModel.missingAsNaN()) +
                            "&FillMissingTimestamps=" + encodeURIComponent(viewModel.fillMissingTimestamps()) +
                            "&InstanceName=" + encodeURIComponent(viewModel.instanceName()) +
                            "&TimestampSnap=" + encodeURIComponent(viewModel.timestampSnap()) +
                            "&Tolerance=" + encodeURIComponent(tolerance) +
                            "&FileFormat=" + encodeURIComponent(viewModel.fileFormat()) +
                            "&ConnectionID=" + encodeURIComponent($.connection.hub.id) +
                            "&OperationHandle=" + encodeURIComponent(exportOperationHandle)
                        );

                        $("#exportDataLink")[0].click();

                        // Start checking operation progress
                        lastProgress = 0;
                        setTimeout(checkProgress, progressRefreshRate);
                    },
                    beforeSend: function (xhr) {
                        xhr.setRequestHeader(verificationHeader, verificationValue);
                        xhr.setRequestHeader(useAjaxVerfication, "true");
                    }
                });
            })
            .fail(function(error) {
                showErrorMessage(error);
                enableUIButtons();
            });
        }

        var baseCalculateRemainingBodyHeight;

        // Override remaining body height calculation to include new tab rows
        var calculateRemainingBodyHeight = (function() {
            baseCalculateRemainingBodyHeight = calculateRemainingBodyHeight;

            return function() {
                return baseCalculateRemainingBodyHeight() - $("#tabs ul").outerHeight(true);
            }
        })();

        function getActiveTab() {
            return $("#tabs").tabs("option", "active");
        }

        function resizeScreenObjects(refreshPageSize) {
            if (refreshPageSize === undefined)
                refreshPageSize = false;

            setTimeout(function() {
                const selectedPointsArea = $("#selectedPointsArea");

                if (getActiveTab() === 0)
                    selectedPointsArea.height($("#tabs").height() - 12);
                else
                    selectedPointsArea.height(baseCalculateRemainingBodyHeight());

                $("#scrollablePointsArea").height(selectedPointsArea.height() - $("#selectedPointsHeader").outerHeight(true) - 5);
            }, 300);

            const selectedPointsColumn = $("#selectedPointsColumn");
            const containerWidth = $("#bodyContainer").innerWidth();

            if (selectedPointsColumn.hasClass("in")) {
                let areaWidth = containerWidth * 0.2;

                if (areaWidth < 150)
                    areaWidth = 150;

                selectedPointsColumn.width(areaWidth);

                if (refreshPageSize) {
                    setTimeout(function() {
                        viewModel.calculatePageSize();
                        viewModel.refreshSelectedPoints();
                    }, 100);
                }
            }

            if (getActiveTab() === 1) {
                const placeholder = $("#placeholder");
                const height = calculateRemainingBodyHeight() - $("#trendTimeRangeSelection").outerHeight(true);
                const width = containerWidth - (selectedPointsColumn.hasClass("in") ? selectedPointsColumn.width() : 0);

                if (height !== placeholder.height() || width !== placeholder.width()) {
                    placeholder.height(height);
                    placeholder.width(width);
                }

                if (!$("#showLegend")[0].checked)
                    $(".legend").hide();
            }

            $("#plotToolTip").hide();
        }

        var queryInProgress = false;

        function queryCurrentValues() {
            if (queryInProgress || getActiveTab() !== 0)
                return;

            queryInProgress = true;

            setTimeout(function() {
                if (!hubIsConnected) {
                    queryInProgress = false;
                    queryCurrentValues();
                    return;
                }

                const instanceName = viewModel.instanceName();
                const pageRecords = viewModel.pageRecords();
                const startDate = moment.utc().subtract(1, "minute").toDate();
                const endDate = moment.utc().toDate();
                const pagePointIDs = [];

                if (isEmpty(instanceName)) {
                    queryInProgress = false;
                    queryCurrentValues();
                    return;
                }

                for (let i = 0; i < pageRecords.length; i++)
                    pagePointIDs.push(pageRecords[i].PointID);

                getHistorianData(instanceName, startDate, endDate, pagePointIDs, Resolution.EverySecond, 2, true)
                    .done(function (data) {
                        $.each(data, function(i, trendValue) {
                            const currentValue = $("#currentValue" + trendValue.ID);

                            if (isNumeric(trendValue.Value))
                                currentValue.text(trendValue.Value.toFixed(3));
                            else
                                currentValue.text(trendValue.Value);

                            currentValue.attr("title", new Date(trendValue.Timestamp).formatDate());
                        });

                        queryInProgress = false;
                        queryCurrentValues();
                    })
                    .fail(function () {
                        queryInProgress = false;
                        queryCurrentValues();
                    });
            }, 1000);
        }

        function showAdvancedTrendOptions() {
            $("#advancedTrendOptions").toggleClass("in");
            resizeScreenObjects();
        }

        function selectPageRecords(checked) {
            for (let i = 0; i < viewModel.pageRecords().length; i++) {
                const next = $("#recordsTable").find("input[type=checkbox]:eq(" + (i + 1) + ")");

                if (!$.isEmptyObject(next)) {
                    if (next[0].checked !== checked)
                        next.click();
                }
            }

            if (checked && viewModel.totalPages() > 1) {
                $("#selectAllProgress").invisible();
                cancelSelectAllRecords();
                $("#selectAllMessage").visible();
            }
        }

        var selectAllRecordsCanceled = false;

        function cancelSelectAllRecords() {
            selectAllRecordsCanceled = true;
        }

        function selectAllRecords() {
            $("#selectAllMessage").invisible();
            $("#tabs").tabs({ active: 0 });
            $("a[href='#tab1']").parent().focus();

            if (!hubIsConnected)
                return;

            const totalPages = viewModel.totalPages();
            const sortField = viewModel.sortField();
            const sortAscending = viewModel.sortAscending();
            const currentPageSize = viewModel.currentPageSize();
            const filterText = viewModel.filterText;

            selectAllRecordsCanceled = false;
            viewModel.selectAllProgress("0%");

            $("#selectAllProgressCancel").text("Cancel");
            $("#selectAllProgress").visible();

            var page = 1;
            var processedPages = 0;

            function selectPageRecords() {
                if (!hubIsConnected) {
                    $("#selectAllProgress").invisible();
                    return;
                }

                viewModel.queryRecords(sortField, sortAscending, page, currentPageSize, filterText).done(function(records) {
                    if (!selectAllRecordsCanceled) {
                        records.forEach(function(record) {
                            viewModel.addNewSelectedPointByRecord(record);
                            return !selectAllRecordsCanceled;
                        });
                    }

                    viewModel.selectAllProgress(String.format("{0}%", (++processedPages / totalPages * 100).truncate()));

                    if (page === totalPages) {
                        $("#selectAllProgressCancel").text("Done!");

                        setTimeout(function() {
                            $("#selectAllProgress").invisible();
                        }, 2000);
                    } else if (selectAllRecordsCanceled) {
                        $("#selectAllProgressCancel").text("Canceled!");

                        setTimeout(function() {
                            $("#selectAllProgress").invisible();
                        }, 2000);
                    } else {
                        page++;

                        if (page <= totalPages)
                            selectPageRecords();
                    }
                }).
                fail(function(error) {
                    showErrorMessage(error);

                    if (page === totalPages)
                        $("#selectAllProgress").invisible();
                });
            }

            // Start page level record selection
            selectPageRecords();
        }

        function disableUIButtons() {
            $("#exportData").disable();
            $("#tabs").disable();
        }

        function enableUIButtons() {
            $("#exportData").enable();
            $("#tabs").enable();
        }

        $(function () {
            $("#tabs").tabs({
                active: 0,
                activate: function(event, ui) {
                    const searchHeader = $("#searchFilter").parents(".form-group");
                    const recordCount = $("#titleText");

                    switch (ui.newPanel.attr("id")) {
                        case "tab1":
                            searchHeader.show();
                            recordCount.show();
                            viewModel.calculatePageSize();
                            $("#plotToolTip").hide();
                            queryCurrentValues();
                            break;
                        case "tab2":
                            searchHeader.hide();
                            recordCount.hide();
                            $("#selectAllMessage").invisible();
                            displayTimeRange();
                            break;
                        case "tab3":
                            searchHeader.hide();
                            recordCount.hide();
                            $("#selectAllMessage").invisible();
                            $("#plotToolTip").hide();
                            displayTimeRange();
                            break;
                    }

                    resizeScreenObjects();
                }
            });

            $("#selectedPointsColumn").on("shown.bs.collapse", function() {
                resizeScreenObjects(true);
            });

            $("#selectedPointsColumn").on("hidden.bs.collapse", function() {
                resizeScreenObjects(true);
            });

            $("#trendTimeRangeSelection").on("shown.bs.collapse", function() {
                resizeScreenObjects(true);
            });

            $("#trendTimeRangeSelection").on("hidden.bs.collapse", function() {
                resizeScreenObjects(true);
            });

            $(viewModel).on("pageSizeCalculated", function() {
                resizeScreenObjects(false);
            });

            $(viewModel).on("pageRecordsQueried", function() {
                $("#selectAllMessage").invisible();
            });

            $("#cancelDataExport").click(function () {
                if (!hubIsConnected)
                    return;

                $("#cancelDataExport").disable();

                dataHub.cancelHistorianOperation(exportOperationHandle).done(function (success) {
                    if (success)
                        showInfoMessage("Request to cancel data export initiated...");
                    else
                        showInfoMessage("Request to cancel data export did not succeed: operation has already completed or handle " + exportOperationHandle + " is invalid");
                })
                .fail(function (error) {
                    showErrorMessage("Failed to cancel data export: " + error, null, true);
                    $("#cancelDataExport").enable();
                });
            });

            $("#exportingDataDialog").on("shown.bs.modal", function () {
                disableUIButtons();
            });

            $("#exportingDataDialog").on("hidden.bs.modal", function () {
                enableUIButtons();
            });

            $(window).resize(resizeScreenObjects);

            resizeScreenObjects();

            const selectAllCheckbox = $("#selectAllCheckbox");

            selectAllCheckbox.click(function() {
                selectPageRecords(selectAllCheckbox[0].checked);
            });

            selectAllCheckbox.keydown(function(event) {
                if (event.which === 40) {
                    // Arrow down
                    if (viewModel.currentPageSize() > 0) {
                        const next = $("#recordsTable").find("input[type=checkbox]:eq(1)");

                        if (!$.isEmptyObject(next))
                            next.focus();
                    }
                }
            });

            $(viewModel).on("pageRecordsQueried", function() {
                selectAllCheckbox[0].checked = false;
                queryCurrentValues();
            });

            ko.watch(viewModel.currentPage, function(parents, child, item) {
                $("#selectAllMessage").invisible();
            });

            $("<div id='plotToolTip'></div>").css({
                position: "absolute",
                display: "none",
                border: "1px solid #fdd",
                padding: "2px",
                "background-color": "#fee",
                opacity: 0.80
            }).appendTo("body");

            $("#selectedPointsColumn").mouseenter(function() {
                $("#plotToolTip").hide();
            });

            const showLegend = $("#showLegend");
            var lastShowLegendState = Cookies.get("trendShowLegend");

            if (lastShowLegendState === undefined)
                lastShowLegendState = "true";

            showLegend.prop("checked", lastShowLegendState === "true");

            showLegend.click(function() {
                $(".legend").toggle();
                Cookies.set("trendShowLegend", this.checked.toString(), { expires: 365 });
            });

            $("#trendData").click(function() {
                trendData();
            });

            $("#showPoints").click(function() {
                trendData();
            });

            $("#exportData").click(function() {
                exportData();
            });

            $("#estimateResolution").click(function () {
                viewModel.trendResolution(estimatePlotResolution(viewModel.startMoment(), viewModel.endMoment()));
                trendData();
            });

            // Setup save selections file name dialog functionality
            $("#saveSelectionsFile").click(function() {
                $("#saveSelectionsFileNameDialog").hide();

                var fileName = notNull($("#inputSelectionsFileName").val());

                if (fileName.length === 0)
                    fileName = "SelectedPoints.json";

                if (!fileName.endsWith(".json"))
                    fileName += ".json";

                viewModel.saveSelections(fileName);
            });

            // Make enter key auto-click save
            $("#inputSelectionsFileName").keyup(function(event) {
                if (event.keyCode === 13)
                    $("#saveSelectionsFile").click();
            });

            // Auto-select all text on focus
            $("#inputSelectionsFileName").focus(function() {
                $(this).select();
            });

            // Prevent default form submission when user presses enter
            $("#saveSelectionsFileNameDialog").submit(function() {
                return false;
            });

            // Auto-hide pop-up form when user clicks outside form area
            $("#saveSelectionsFileNameDialog").focusout(function() {
                if (!$("#saveSelectionsFileNameDialog").is(":hover") && !$("#showSaveSelectionsFileNameDialog").is(":hover"))
                    $("#saveSelectionsFileNameDialog").hide();
            });
        });


        $(window).on("hubConnected", function() {
            setTimeout(keepAlive, 1000);

            // Load available historian instance names, if not already loaded
            if ($("#instanceName").children("option").length > 0)
                return;

            const instanceNameSelect = $("#instanceName");

            dataHub.getInstanceNames().done(function(names) {
                for (let i = 0; i < names.length; i++) {
                    const value = names[i];
                    instanceNameSelect.append($("<option>", { value: value, text: value }));
                }

                // Select last value
                var lastInstanceName = Cookies.get("instanceName");

                if (lastInstanceName === undefined)
                    lastInstanceName = instanceNameSelect.eq(0).val();

                if (!isEmpty(lastInstanceName))
                    instanceNameSelect.val(lastInstanceName);

                setTimeout(function() {
                    viewModel.instanceName(lastInstanceName);
                }, 200);
            });
        });

        $(window).on("hubDisconnected", function() {
            if (exportOperationHandle > 0) {
                exportOperationHandle = 0;
                $("#exportingDataDialog").modal("hide");
                showInfoMessage("Data connection lost, data export canceled...", -1, true);
            }
        });

        function keepAlive() {
            if (!hubIsConnected)
                return;

            serviceHub.getServerTime().done(function(serverTime) {
                $("#serverTime").html(serverTime.formatDate());
                setTimeout(keepAlive, 1000);
            });
        }

        function showSaveSelectionsFileNameDialog() {
            $("#saveSelectionsFileNameDialog").toggle();

            if ($("#saveSelectionsFileNameDialog").is(":visible"))
                $("#inputSelectionsFileName").focus();
        }

        function showLoadSelectionsFileNameDialog() {
            $("#loadSelectionsFileName").trigger("click");
        }

        function loadSelectionsFile(event) {
            viewModel.loadSelections(event.target.files[0]);
            $("#loadSelectionsFileName").val("");
        }

        function cleanupTagName(tagName) {
            var cleanedTagName = notNull(tagName).trim();
            const prefixIndex = cleanedTagName.lastIndexOf("!");

            if (prefixIndex > -1 && prefixIndex < cleanedTagName.length - 1)
                cleanedTagName = cleanedTagName.substr(prefixIndex + 1);

            return cleanedTagName.truncate(25);
        }

        function setTimeToMidnight() {
            viewModel.startTime(moment(viewModel.startMoment()).hours(0).minutes(0).seconds(0).milliseconds(0).format(MomentDateTimeFormat));
            viewModel.endTime(moment(viewModel.endMoment()).hours(0).minutes(0).seconds(0).milliseconds(0).format(MomentDateTimeFormat));
        }

        function copyToClipboard(text) {
            const textarea = document.createElement("textarea");

            textarea.textContent = text;
            textarea.style.position = "fixed";
            document.body.appendChild(textarea);
            textarea.select();

            try {
                return document.execCommand("copy");
            }
            catch (ex) {
                console.warn("Copy to clipboard failed.", ex);
                return false;
            }
            finally {
                document.body.removeChild(textarea);
            }
        }
    </script>
}
<table>
    <tr>
        <td id="selectedPointsColumn" style="width: 20%; vertical-align: top; padding-right: 3px" class="collapse in">
            <div id="selectedPointsArea" class="well" style="padding: 5px">
                <div id="selectedPointsHeader" class="clearfix">
                    Selected Points&nbsp;<span data-bind="text: selectedPoints().length"></span><br />
                    <button type="button" class="btn btn-sm" onclick="showSaveSelectionsFileNameDialog()" id="showSaveSelectionsFileNameDialog" data-bind="enable: selectedPoints().length > 0">Save</button>
                    <div class="well well-sm floating-form" id="saveSelectionsFileNameDialog" style="z-index: 1000">
                        <form class="form-inline" role="form">
                            <div class="form-group form-group-sm">
                                <button type="button" class="close" onclick="$('#saveSelectionsFileNameDialog').hide()" style="margin-top: -13px; margin-left: 8px">&times;</button>
                                <div class="input-group">
                                    <input type="text" class="form-control" id="inputSelectionsFileName" placeholder="File name..." />
                                    <span class="input-group-btn">
                                        <button type="button" class="btn btn-default btn-sm" id="saveSelectionsFile" style="margin-right: -3px; font-weight: bold">Save</button>
                                    </span>
                                </div>
                            </div>
                        </form>
                    </div>
                    <a href="#" id="saveSelectionsFileLink" target="_blank" style="display: none"></a>
                    <button type="button" class="btn btn-sm" onclick="showLoadSelectionsFileNameDialog()">Load</button>
                    <input id="loadSelectionsFileName" type="file" accept="text/json" style="position: fixed; top: -100em" onchange="loadSelectionsFile(event)">
                    <button type="button" class="btn btn-sm" data-bind="click: sortSelections">Sort</button>
                    <button type="button" class="btn btn-sm pull-right" data-bind="click: clearSelectedPoints.bind($data)">Clear All</button>
                </div>
                <div id="scrollablePointsArea" style="overflow-x: hidden">
                    <table class="table table-striped table-bordered table-hover table-condensed" style="table-layout: fixed">
                        <tbody id="selectedPoints" data-bind="foreach: selectedPoints">
                            <tr>
                                <td style="width: 20%; overflow: hidden" class="text-center valign-middle" data-bind="text: id, attr: { title: id }"></td>
                                <td style="width: 60%" class="table-cell-hard-wrap">
                                    <span class="fixed-font" data-bind="text: cleanupTagName(tag), attr: { title: String.format('{0}: {1} - {2}', signalType, tag, description) }"></span>
                                    <hr class="series-color" data-bind="style: { 'background-color': $parent.getSeriesColor($data) }" />
                                </td>
                                <td style="width: 20%" class="text-center valign-middle"><button type="button" class="btn btn-xs" title="Unselect Point" data-bind="click: $parent.deleteSelectedPoint"><span class="glyphicon glyphicon-remove"></span></button></td>
                            </tr>
                        </tbody>
                    </table>
                </div>
            </div>
        </td>
        <td id="tabsColumns" style="width: 80%; vertical-align: top">
            <div id="tabs" class="tabs-nohdr">
                <ul>
                    <button type="button" class="btn btn-xs btn-collapsable" id="collapseSelectedPoints" data-toggle="collapse" data-target="#selectedPointsColumn"></button>
                    <li>
                        <a href="#tab1">Select Points</a>
                    </li>
                    <li><a href="#tab2">Trend Data</a></li>
                    <li>
                        <a href="#tab3">Export Data</a>
                        <span id="selectAllMessage" style="visibility: hidden">Selected <span data-bind="text: pageRecords().length"></span> points on the current page, <a class="active" onclick="selectAllRecords()">click here</a> to select all <span data-bind="text: recordCount"></span> points on all pages.</span>
                        <div class="input-group" id="selectAllProgress" style="visibility: hidden">
                            <span style="display: table-cell; font-size: small">Selecting&nbsp;Points:&nbsp;</span>
                            <div class="progress" style="width: 180px; height: 22px">
                                <div class="progress-bar-info" id="selectAllProgressBar" role="progressbar" data-bind="style: { 'width': selectAllProgress }"><span data-bind="text: selectAllProgress">0%</span> Complete...</div>
                            </div>
                            <span class="input-group-btn">
                                <button class="btn btn-secondary" id="selectAllProgressCancel" type="button" onclick="cancelSelectAllRecords()">Cancel</button>
                            </span>
                        </div>
                    </li>
                </ul>
                <div id="tab1" class="ui-tabs-active">
                    @Html.RenderResource("GSF.Web.Model.Views.PagedViewModel.cshtml")
                </div>
                <div id="tab2" style="display: none">
                    <button type="button" class="btn btn-xs btn-collapsable pull-right" id="collapseTrendSetup" data-toggle="collapse" data-target="#trendTimeRangeSelection"></button>
                    <div class="well collapse in clearfix" style="padding: 10px 20px 10px 20px" id="trendTimeRangeSelection">
                        @Raw(string.Format(Include("SelectTimeRange.cshtml").ToString(), "plot").Trim())
                        <form class="form-inline clearfix" role="form">
                            <label for="trendResolution">Data Resolution:</label>
                            <div class="input-group">
                                <select class="form-control" id="trendResolution" data-bind="value: trendResolution" style="width: 165px"></select>
                                <span class="input-group-btn">
                                    <button class="btn btn-default" style="font-size: 14px" id="estimateResolution" type="button">Estimate</button>
                                </span>
                            </div>
                            <div class="checkbox">
                                <label for="autoEstimateResolution"><input type="checkbox" id="autoEstimateResolution" data-bind="checked: autoEstimateResolution"> <strong>Auto&nbsp;Estimate</strong></label>
                            </div>
                            <div class="checkbox pull-right">
                                <label for="showAdvanced" style="margin-top: 4px"><input type="checkbox" id="showAdvanced" onclick="showAdvancedTrendOptions()"> Advanced&nbsp;Options</label>
                            </div>
                        </form>
                        <form class="form-inline collapse" id="advancedTrendOptions" role="form">
                            <hr class="quarter-break" />
                            <div class="form-group form-group-sm">
                                <label for="trendSeriesLimit">Series Limit<sup>*</sup>:</label>
                                <div class="input-group">
                                    <input type="number" class="form-control" id="trendSeriesLimit" style="width: 65px" data-bind="textInput: trendSeriesLimit">
                                    <span class="input-group-addon">values per selected point</span>
                                </div>
                            </div>
                            <hr class="quarter-break" />
                            <div style="max-width: 600px">
                                <table>
                                    <tr>
                                        <td style="vertical-align: top"><sup>*</sup></td>
                                        <td>
                                            <em class="small">
                                                Series limit can be set to zero to trend all data values, however, for large data windows
                                                this could have severe performance implications.
                                            </em>
                                        </td>
                                    </tr>
                                </table>
                            </div>
                        </form>
                        <hr class="thick-spacer">
                        <form class="form-inline" role="form" onsubmit="return false">
                            <button class="btn btn-primary pull-right" id="trendData" hub-dependent>Trend</button>
                            <div class="checkbox pull-right" style="margin-top: 5px">
                                <label for="showPoints"><input type="checkbox" id="showPoints" hub-dependent> <strong>Show&nbsp;Points</strong></label>
                                &nbsp;&nbsp;
                            </div>
                            <div class="checkbox pull-right" style="margin-top: 5px">
                                <label for="showLegend"><input type="checkbox" id="showLegend"> <strong>Show&nbsp;Legend</strong></label>
                                &nbsp;&nbsp;
                            </div>
                            <div class="checkbox pull-right" style="margin-top: 5px">
                                <label for="autoTrend"><input type="checkbox" id="autoTrend" data-bind="checked: autoTrend"> <strong>Auto&nbsp;Trend</strong></label>
                                &nbsp;&nbsp;
                            </div>
                        </form>
                    </div>
                    <span class="noselect pull-left" style="font-size: x-small; color: lightgray; margin-top: -17px; padding-left: 10px">
                        <span>Hold shift and click to pan</span>
                    </span>
                    <div id="placeholder" class="noselect" style="width: 100%;"></div>
                    <span class="noselect" style="font-size: x-small; color: lightgray; margin-top: 10px; padding-left: 10px">
                        <span>Server time: <span id="serverTime">@DateTime.UtcNow.ToString(Model.Global.DateTimeFormat)</span></span>
                    </span>
                    <span class="noselect pull-right" style="font-size: x-small; color: lightgray; margin-top: 2px">
                        <span>Round-trip query time: <span id="queryTime"></span>ms</span>&nbsp;&nbsp;
                        <span>Graph generation time: <span id="graphTime"></span>ms</span>&nbsp;&nbsp;
                        <span>Total processed points: <span id="pointCount"></span></span>&nbsp;&nbsp;
                    </span>
                </div>
                <div id="tab3" style="display: none">
                    <div class="well clearfix" style="padding: 10px 20px 10px 20px" id="exportTimeRangeSelection">
                        @Raw(string.Format(Include("SelectTimeRange.cshtml").ToString(), "export").Trim())
                        <form class="form-inline" role="form">
                            <div class="form-group form-group-sm">
                                <label for="exportFileFormat">File Format:</label>
                                <select class="form-control" id="exportFileFormat" data-bind="value: fileFormat">
                                    <option value="-1" selected>Comma Separated Values (CSV)</option>
                                    <option value="0">COMTRADE ASCII (CFF)</option>
                                    <option value="1">COMTRADE Binary UInt16 (CFF)</option>
                                    <option value="2">COMTRADE Binary UInt32 (CFF)</option>
                                    <option value="3">COMTRADE Binary Float32 (CFF)</option>
                                </select>
                                &nbsp;&nbsp;
                            </div>
                            <div class="form-group form-group-sm">
                                <label for="exportFrameRate" data-bind="css: { 'disabled': !alignTimestamps()}">Frame Rate:</label>
                                <div class="input-group">
                                    <input type="number" class="form-control" id="exportFrameRate" style="width: 65px" data-bind="integer, textInput: frameRate, enable: alignTimestamps()">
                                </div>
                                <select class="form-control" id="exportFrameRateQualifier" style="margin-left: -3px" data-bind="value: frameBase, enable: alignTimestamps()">
                                    <option value="0" selected>frames per second</option>
                                    <option value="1">frames per minute</option>
                                    <option value="2">frames per hour</option>
                                </select>
                            </div>
                            <hr class="quarter-break" />
                            <div class="form-group form-group-sm">
                                <label for="exportTSSnap" data-bind="css: { 'disabled': !alignTimestamps()}">First Timestamp Based On:</label>
                                <select class="form-control" id="exportTSSnap" data-bind="value: timestampSnap, enable: alignTimestamps()">
                                    <option value="0" selected>frame rate starting at top of second</option>
                                    <option value="1">first available measurement</option>
                                    <option value="2">exact start time</option>
                                </select>
                            </div>
                        </form>
                        <hr class="quarter-break" />
                        <form class="form-inline" role="form">
                            <div class="checkbox">
                                <label for="exportAlignTimestamps"><input type="checkbox" id="exportAlignTimestamps" data-bind="checked: alignTimestamps"> <strong>Align&nbsp;Timestamps</strong></label>
                            </div>
                            &nbsp;&nbsp;
                            <div class="checkbox">
                                <label for="exportMissingAsNaN"><input type="checkbox" id="exportMissingAsNaN" data-bind="checked: missingAsNaN"> <strong>Export&nbsp;Missing Values&nbsp;as&nbsp;NaN</strong></label>
                            </div>
                            &nbsp;&nbsp;
                            <div class="checkbox">
                                <label for="exportFillMissingTimestamps" data-bind="css: { 'disabled': !alignTimestamps()}"><input type="checkbox" id="exportFillMissingTimestamps" data-bind="checked: fillMissingTimestamps, enable: alignTimestamps"> <strong>Fill-in&nbsp;Missing Timestamps</strong><sup>*</sup></label>
                            </div>
                            &nbsp;&nbsp;
                            <div class="checkbox">
                                <label for="exportTolerance" data-bind="css: { 'disabled': !alignTimestamps()}"><input type="checkbox" id="exportTolerance" data-bind="checked: tolerance"> <strong>Round&nbsp;to&nbsp;Frame&nbsp;Rate&nbsp;Timestamps</strong><sup>**</sup></label>
                            </div>
                            &nbsp;&nbsp;
                        </form>
                        <hr class="quarter-break" />
                        <div style="max-width: 600px">
                            <table>
                                <tr>
                                    <td style="vertical-align: top"><sup>*</sup></td>
                                    <td>
                                        <em class="small">
                                            Export timestamps with monotonically increasing time based on frame rate with no missing rows, i.e.,
                                            when no data is archived for a timestamp, write a blank row and don’t skip times.
                                        </em>
                                        <hr class="quarter-break" />
                                    </td>
                                </tr>
                                <tr>
                                    <td style="vertical-align: top"><sup>**</sup></td>
                                    <td>
                                        <em class="small">
                                            Exporting with timestamps rounded to closest frame rate will export <b>generated</b> timestamps with data matched into closest alignment.
                                            Note that this will result in an export where timestamp values do not match original data, but are sorted into closest timestamps. This is
                                            similar to how "concentration" features operate when using synchrophasor data.
                                        </em>
                                    </td>
                                </tr>
                            </table>
                        </div>
                        <hr class="thick-spacer">
                        <button class="btn btn-primary pull-right" id="exportData">Export</button>
                        <a id="exportDataLink" download="" hidden=""></a>
                    </div>
                </div>
            </div>
        </td>
    </tr>
</table>
@* Exporting Data Dialog *@
<div id="exportingDataDialog" class="modal" role="dialog">
    <div class="modal-dialog modal-lg">
        <div class="modal-content">
            <div class="modal-header">
                <h4 class="modal-title">Exporting Data...</h4>
            </div>
            <div class="modal-body">
                <div style="margin: 10px">
                    <div class="pull-right" style="font-weight: bold">
                        <span id="exportingLabel">Exporting</span>&nbsp;<span id="progressLabel"></span>&nbsp;&nbsp;<span id="progressIcon" class="glyphicon glyphicon-refresh glyphicon-spin"></span>
                    </div>
                    <br />
                    <div class="progress" style="margin-top: 5px; margin-bottom: -5px">
                        <div id="progressBar" class="progress-bar progress-bar-striped active" role="progressbar" style="width: 0">0%</div>
                    </div>
                    <br />
                    <div>
                        <span id="progressRate" class="pull-left"></span>
                        <span id="timeEstimate" class="pull-right">Estimated remaining time: <span id="remainingTime"></span></span>
                    </div>
                </div>
            </div>
            <div class="modal-footer">
                <span class="pull-left">Total elapsed time: <span id="totalTime"></span></span>
                <button id="cancelDataExport" type="button" class="btn btn-default pull-right">Cancel</button>
            </div>
        </div>
    </div>
</div>