@*******************************************************************************************************
//  AddSynchrophasorDevice.cshtml - Gbtc
//
//  Copyright © 2019, Grid Protection Alliance.  All Rights Reserved.
//
//  Licensed to the Grid Protection Alliance (GPA) under one or more contributor license agreements. See
//  the NOTICE file distributed with this work for additional information regarding copyright ownership.
//  The GPA licenses this file to you under the MIT License (MIT), the "License"; you may not use this
//  file except in compliance with the License. You may obtain a copy of the License at:
//
//      http://opensource.org/licenses/MIT
//
//  Unless agreed to in writing, the subject software distributed under the License is distributed on an
//  "AS-IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. Refer to the
//  License for the specific language governing permissions and limitations.
//
//  Code Modification History:
//  ----------------------------------------------------------------------------------------------------
//  02/18/2019 - J. Ritchie Carroll
//       Generated original version of source code.
//
//*****************************************************************************************************@
@using System.Net.Http
@using System.Threading
@using GSF.ComponentModel.DataAnnotations
@using GSF.Identity
@using GSF.Security
@using GSF.Web
@using GSF.Web.Model
@using GSF.Web.Shared
@using openHistorian
@using openHistorian.Model
@inherits ExtendedTemplateBase<AppModel>
@{
    Layout = "Layout.cshtml";
    ViewBag.HidePageTitle = true;
    ViewBag.Title = "New Device Commissioning Wizard";

    HttpRequestMessage request = ViewBag.Request;
    Dictionary<string, string> parameters = request.QueryParameters();
    string parameter;
    int deviceID;

    if (!parameters.TryGetValue("DeviceID", out parameter) || !int.TryParse(parameter, out deviceID)) {
        deviceID = 0;
    }

    bool userIsEditor = UserIsEditor();
}
@section StyleSheets {
    <style>
        html, body {
            height: 100%;
        }

        span.table-cell-text {
            display: table-cell;
            vertical-align: middle;
        }

        .input-label {
            text-align: right;
            vertical-align: top;
            padding: 6px;
            width: 160px;
        }

        .input-area {
            width: 80%;
            display: inline-table;
            vertical-align: middle;
        }

        tr.top-border {
            border-top-width: 2px;
            border-top-style: solid;
        }

        @@media screen {
            .page-logo {
                margin-bottom: 2px;
                margin-top: -38px;
            }
        }

        @@media screen and (min-width: 638px) {
            .page-logo {
                margin-bottom: 2px;
                margin-top: -12px;
            }
        }

        @@media screen and (min-width: 868px) {
            .page-logo {
                margin-bottom: 2px;
                margin-top: -12px;
            }
        }

        @@media screen and (min-width: 992px) {
            .page-logo {
                margin-bottom: -25px;
                margin-top: -4px;
            }
        }
    </style>
}
@functions {
    public string GetCurrentUserID()
    {
        if ((object)Thread.CurrentPrincipal.Identity == null)
            return UserInfo.CurrentUserID;

        return Thread.CurrentPrincipal.Identity.Name;
    }

    // This function simply limits access to UI elements that the user does not have access to, server-side
    // functions will further validate user rights even if UI restriction was somehow bypassed
    public bool UserIsEditor()
    {
        SecurityPrincipal securityPrincipal = ViewBag.SecurityPrincipal as SecurityPrincipal;

        if ((object)securityPrincipal == null)
            return false;

        return securityPrincipal.IsInRole("Administrator") || securityPrincipal.IsInRole("Editor");
    }
}
@section Scripts {
    <script src="@Resources.Root/Shared/Scripts/knockout.js"></script>
    <script src="@Resources.Root/Shared/Scripts/knockout.mapping.js"></script>
    <script src="@Resources.Root/Shared/Scripts/knockout.validation.js"></script>
    <script src="@Resources.Root/Shared/Scripts/knockout.reactor.js"></script>
    <script src="@Resources.Root/Shared/Scripts/gsf.web.knockout.js"></script>
    <script>
        "use script";

        var firstConnect = true;
        var deviceID = @deviceID;
        var nodeID = "@Program.Host.Model.Global.NodeID";
        var viewModel = null;
        var deviceSignalTypes = [];
        var phasorSignalTypes = [];

        function showLoadingLabel() {
            $("#loadingDataLabel").css("visibility", "visible");
            viewModel.working(true);
        }

        function hideLoadingLabel() {
            viewModel.working(false);
            setTimeout(function () { $("#loadingDataLabel").css("visibility", "hidden"); }, 500);
        }

        function guessPhase(phase, phasorLabel) {
            if (!isEmpty(phase) && phase !== "+")
                return phase;

            if (phasorLabel.indexOf("_VA") > -1 || phasorLabel.indexOf("_IA") > -1 || phasorLabel.indexOf(" A ") > -1 || phasorLabel.indexOf(" APV") > -1 || phasorLabel.indexOf(" API") > -1 || phasorLabel.indexOf("VA ") > -1 || phasorLabel.indexOf("IA ") > -1 || phasorLabel.indexOf("VAPM") > -1 || phasorLabel.indexOf("IAPM") > -1 || phasorLabel.indexOf(".AV") > -1 || phasorLabel.indexOf(".AI") > -1)
                return "A";

            if (phasorLabel.indexOf("_VB") > -1 || phasorLabel.indexOf("_IB") > -1 || phasorLabel.indexOf(" B ") > -1 || phasorLabel.indexOf(" BPV") > -1 || phasorLabel.indexOf(" BPI") > -1 || phasorLabel.indexOf("VB ") > -1 || phasorLabel.indexOf("IB ") > -1 || phasorLabel.indexOf("VBPM") > -1 || phasorLabel.indexOf("IBPM") > -1 || phasorLabel.indexOf(".BV") > -1 || phasorLabel.indexOf(".BI") > -1)
                return "B";

            if (phasorLabel.indexOf("_VC") > -1 || phasorLabel.indexOf("_IC") > -1 || phasorLabel.indexOf(" C ") > -1 || phasorLabel.indexOf(" CPV") > -1 || phasorLabel.indexOf(" CPI") > -1 || phasorLabel.indexOf("VC ") > -1 || phasorLabel.indexOf("IC ") > -1 || phasorLabel.indexOf("VCPM") > -1 || phasorLabel.indexOf("ICPM") > -1 || phasorLabel.indexOf(".CV") > -1 || phasorLabel.indexOf(".CI") > -1)
                return "C";

            if (phasorLabel.indexOf("_VN") > -1 || phasorLabel.indexOf("_IN") > -1 || phasorLabel.indexOf(" NEUT ") > -1 || phasorLabel.indexOf(" NPV") > -1 || phasorLabel.indexOf(" NPI") > -1 || phasorLabel.indexOf("VN ") > -1 || phasorLabel.indexOf("IN ") > -1 || phasorLabel.indexOf("VNPM") > -1 || phasorLabel.indexOf("INPM") > -1 || phasorLabel.indexOf(".NV") > -1 || phasorLabel.indexOf(".NI") > -1)
                return "N";

            if (phasorLabel.indexOf("_V0") > -1 || phasorLabel.indexOf("_I0") > -1 || phasorLabel.indexOf(" ZERO ") > -1 || phasorLabel.indexOf(" ZPV") > -1 || phasorLabel.indexOf(" ZPI") > -1 || phasorLabel.indexOf("VZ ") > -1 || phasorLabel.indexOf("IZ ") > -1 || phasorLabel.indexOf("VZPM") > -1 || phasorLabel.indexOf("IZPM") > -1 || phasorLabel.indexOf(".ZV") > -1 || phasorLabel.indexOf(".ZI") > -1 || phasorLabel.indexOf("_ZS") > -1)
                return "0";

            if (phasorLabel.indexOf("_V2") > -1 || phasorLabel.indexOf("_I2") > -1 || phasorLabel.indexOf(" NEG ") > -1 || phasorLabel.indexOf(" -SV") > -1 || phasorLabel.indexOf(" -SI") > -1 || phasorLabel.indexOf("V2 ") > -1 || phasorLabel.indexOf("I2 ") > -1 || phasorLabel.indexOf("V2PM") > -1 || phasorLabel.indexOf("I2PM") > -1 || phasorLabel.indexOf(".-V") > -1 || phasorLabel.indexOf(".-I") > -1 || phasorLabel.indexOf("_NS") > -1)
                return "-";

            if (phasorLabel.indexOf("_V1") > -1 || phasorLabel.indexOf("_I1") > -1 || phasorLabel.indexOf(" POS ") > -1 || phasorLabel.indexOf(" +SV") > -1 || phasorLabel.indexOf(" +SI") > -1 || phasorLabel.indexOf(" SI") > -1 || phasorLabel.indexOf("V1 ") > -1 || phasorLabel.indexOf("I1 ") > -1 || phasorLabel.indexOf("V1PM") > -1 || phasorLabel.indexOf("I1PM") > -1 || phasorLabel.indexOf(".+V") > -1 || phasorLabel.indexOf(".+I") > -1 || phasorLabel.indexOf("_PS") > -1)
                return "+";

            return isEmpty(phase) ? "?" : phase;
        }

        function guessNominalVoltage(nominalVoltage, phasorLabel, deviceLabel) {
            if (!isEmpty(nominalVoltage) && nominalVoltage > 0)
                return nominalVoltage;

            const commonVoltageLevels = ["69", "115", "230", "500", "765"];

            // Check phasor label before device
            for (let i = 0; i < commonVoltageLevels.length; i++) {
                const voltageLevel = commonVoltageLevels[i];

                if (phasorLabel.indexOf(voltageLevel) > -1)
                    return parseInt(voltageLevel);
            }

            for (let i = 0; i < commonVoltageLevels.length; i++) {
                const voltageLevel = commonVoltageLevels[i];

                if (deviceLabel.indexOf(voltageLevel) > -1)
                    return parseInt(voltageLevel);
            }

            return 500;
        }

        function guessAssociatedVoltage(current) {
            const voltages = current.DeviceVoltages();
            const phasorLabel = current.Label().toUpperCase();
            let phase = current.Phase();

            if (phase === "+")
                phase = "1";
            else if (phase === "-")
                phase = "2";

            let search = "V" + phase;
            let replace = "I" + phase;

            for (let i = 0; i < voltages.length; i++) {
                if (phasorLabel === voltages[i].Label().toUpperCase().replace(search, replace))
                    return voltages[i].ID;
            }

            search = "POT";
            replace = "CURR";

            for (let i = 0; i < voltages.length; i++) {
                if (phasorLabel === voltages[i].Label().toUpperCase().replace(search, replace))
                    return voltages[i].ID;
            }

            let aCount = 0, aID = -1;
            let bCount = 0, bID = -1;
            let cCount = 0, cID = -1;
            let posCount = 0, posID = -1;
            let negCount = 0, negID = -1;
            let zCount = 0, zID = -1;
            let nCount = 0, nID = -1;
            let otherCount = 0;

            for (let i = 0; i < voltages.length; i++) {
                const voltageID = voltages[i].ID;

                switch (voltages[i].Phase().toUpperCase()) {
                    case "A":
                        aCount++;
                        aID = voltageID;
                        break;
                    case "B":
                        bCount++;
                        bID = voltageID;
                        break;
                    case "C":
                        cCount++;
                        cID = voltageID;
                        break;
                    case "+":
                        posCount++;
                        posID = voltageID;
                        break;
                    case "-":
                        negCount++;
                        negID = voltageID;
                        break;
                    case "0":
                        zCount++;
                        zID = voltageID;
                        break;
                    case "N":
                        nCount++;
                        nID = voltageID;
                        break;
                    default:
                        otherCount++;
                        break;
                }
            }

            if (otherCount === 0) {
                switch (phase) {
                    case "A":
                        if (aCount === 1)
                            return aID;
                        break;
                    case "B":
                        if (bCount === 1)
                            return bID;
                        break;
                    case "C":
                        if (cCount === 1)
                            return cID;
                        break;
                    case "1":
                        if (posCount === 1)
                            return posID;
                        break;
                    case "2":
                        if (negCount === 1)
                            return negID;
                        break;
                    case "0":
                        if (zCount === 1)
                            return zID;
                        break;
                    case "N":
                        if (nCount === 1)
                            return nID;
                        break;
                }
            }

            return -1;
        }

        function delayedPromise(timeout) {
            const $d = $.Deferred();
            setTimeout(function () { $d.resolve(); }, timeout || 0);
            return  $d.promise();
        }

        function DeviceViewModel() {
            const self = this;

            // Observable fields
            self.voltages = ko.observableArray();
            self.currents = ko.observableArray();
            self.configFrame = ko.observable({ConnectionString: "", Cells: []});
            self.configFrameDetails = ko.observable("Calculating...");
            self.addAnalogs = ko.observable(false);
            self.addDigitals = ko.observable(false);
            self.readOnly = ko.observable(false);
            self.errors = ko.validation.group(self);
            self.working = ko.observable(false);

            // Internal fields
            self._addTagsAsVirtualPoints = ko.observable(undefined);
            self._deviceAcronym = ko.observable("DEVICENAME");
            self._instanceName = ko.observable("");
            self._templateType = ko.observable("");
            self._historianID = ko.observable(-1);
            self._dataHubIsConnected = ko.observable(false);
            self._isDirty = ko.observable(false);

            // Properties
            self.addTagsAsVirtualPoints = ko.pureComputed({
                read: function () {
                    if (self._addTagsAsVirtualPoints() === undefined)
                        self._addTagsAsVirtualPoints(Cookies.get("addTagsAsVirtualPoints") === "true");

                    return self._addTagsAsVirtualPoints();
                },
                write: function (value) {
                    if (value === self._addTagsAsVirtualPoints())
                        return;

                    self._addTagsAsVirtualPoints(value);
                    Cookies.set("addTagsAsVirtualPoints", value.toString(), { expires: 365 });
                },
                owner: self
            });

            self.editMode = ko.pureComputed({
                read: function () {
                    return deviceID > 0;
                }
            });

            self.deviceAcronym = ko.pureComputed({
                read: self._deviceAcronym,
                write: function (value) {
                    if (value === self._deviceAcronym())
                        return;

                    if (value) {
                        value = value.trim();
                        self._deviceAcronym(value);
                    }
                    else {
                        self.deviceAcronym(value);
                    }
                },
                owner: self
            });

            self.instanceName = ko.pureComputed({
                read: self._instanceName,
                write: function (value) {
                    if (value === self._instanceName())
                        return;

                    if (value) {
                        self._instanceName(value);
                        Cookies.set("instanceName", value.toString(), { expires: 365 });
                    } else {
                        self._instanceName("");
                    }

                    if (self.dataHubIsConnected()) {
                        if (isEmpty(self._instanceName())) {
                            self._historianID(-1);
                        }
                        else {
                            dataHub.queryHistorian(self.instanceName()).done(function (historian) {
                                if (historian)
                                    self._historianID(historian.ID);
                                else
                                    self._historianID(-1);
                            });
                        }
                    }
                },
                owner: self
            });

            self.templateType = ko.pureComputed({
                read: self._templateType,
                write: function (value) {
                    if (value === self._templateType())
                        return;

                    if (value) {
                        self._templateType(value);
                        Cookies.set("templateType", value.toString(), { expires: 365 });
                    } else {
                        self._templateType("");
                    }
                },
                owner: self
            });

            self.historianID = ko.pureComputed({
                read: function () {
                    const historianID = self._historianID();

                    if (historianID === -1)
                        return null;

                    return historianID;
                },
                owner: self
            });

            self.dataHubIsConnected = ko.pureComputed({
                read: self._dataHubIsConnected,
                write: function (value) {
                    if (value === undefined)
                        value = false;

                    self._dataHubIsConnected(value);

                    if (value)
                        self.refreshValidationErrors();
                },
                owner: self
            });

            self.isDirty = ko.pureComputed({
                read: self._isDirty,
                write: function (value) {
                    if (value === undefined)
                        value = true;

                    self._isDirty(value);
                },
                owner: self
            });

            // Methods

            self.updateConfigFrameDetails = function () {
                var voltageCount = 0;
                var currentCount = 0;
                var analogCount = 0;
                var digitalCount = 0;

                const cells = self.configFrame().Cells;
                const cellCount = cells.length;

                for (let i = 0; i < cellCount; i++) {
                    const cell = cells[i];

                    for (let j = 0; j < cell.PhasorDefinitions.length; j++) {
                        const phasorDefinition = cell.PhasorDefinitions[j];

                        if (phasorDefinition.PhasorType.toLowerCase() === "voltage")
                            voltageCount++;
                        else
                            currentCount++;
                    }

                    analogCount += cell.AnalogDefinitions.length;
                    digitalCount += cell.DigitalDefinitions.length;
                }

                self.configFrameDetails(String.format("Device Count {0} &ndash; {1} Voltage Phasors, {2} Current Phasors, {3} Analogs, {4} Digitals",
                    cellCount,
                    voltageCount,
                    currentCount,
                    analogCount,
                    digitalCount));

                self.addAnalogs(analogCount > 0);
                self.addDigitals(digitalCount > 0);
            };

            self.loadConfigFrame = function (configFrame) {
                self.configFrame(configFrame);
                self.voltageCount = 0;

                if (configFrame.ProtocolID > 0) {
                    dataHub.getProtocolCategory(configFrame.ProtocolID).done(function (category) {
                        self.readOnly(category.toLowerCase() === "gateway");
                    });
                }

                // Sort devices
                self.configFrame().Cells.sort(function (left, right) {
                    const leftLabel = String(left.IDLabel).trim().toUpperCase();
                    const rightLabel = String(right.IDLabel).trim().toUpperCase();

                    if (leftLabel < rightLabel)
                        return -1;

                    if (leftLabel > rightLabel)
                        return 1;

                    return 0;
                });

                let deviceAcronym = configFrame.IDLabel;

                if (isEmpty(deviceAcronym) && !isEmpty(configFrame.StationName))
                    deviceAcronym = getCleanAcronym(configFrame.StationName.toUpperCase().replaceAll(" ", "_"));
                else
                    deviceAcronym = "DEVICENAME";

                self.deviceAcronym(deviceAcronym);

                const deviceCount = self.configFrame().Cells.length;

                // Sort device phasor definitions by voltage, current then label
                for (let i = 0; i < deviceCount; i++) {
                    const cell = self.configFrame().Cells[i];

                    cell.PhasorDefinitions.sort(function (left, right) {
                        const leftIsVoltage = left.PhasorType.toLowerCase() === "voltage";
                        const rightIsVoltage = right.PhasorType.toLowerCase() === "voltage";

                        if (leftIsVoltage && !rightIsVoltage)
                            return -1;

                        if (!leftIsVoltage && rightIsVoltage)
                            return 1;

                        const leftLabel = String(left.Label).trim().toUpperCase();
                        const rightLabel = String(right.Label).trim().toUpperCase();

                        if (leftLabel < rightLabel)
                            return -1;

                        if (leftLabel > rightLabel)
                            return 1;

                        return 0;                        
                    });
                }

                for (let i = 0; i < deviceCount; i++) {
                    const cell = self.configFrame().Cells[i];

                    let cellAcronym = cell.IDLabel;

                    if (isEmpty(cellAcronym))
                        cellAcronym = getCleanAcronym(cell.StationName.toUpperCase().replaceAll(" ", "_"));

                    if (deviceCount === 1) {
                        self.deviceAcronym(cellAcronym);
                        cell.IDLabel = self.deviceAcronym;
                    } else {
                        cell.IDLabel = ko.observable(cellAcronym);
                    }

                    cell.IDLabel.extend({
                        required: true,
                        pattern: {
                            message: "@Raw(AcronymValidationAttribute.DefaultErrorMessage)",
                            params: "@Raw(AcronymValidationAttribute.ValidationPattern.JavaScriptEncode())"
                        },
                        deviceUniqueInDatabase: cell.ID
                    });

                    cell.Acronym = cellAcronym;

                    cell.OriginalAcronym = ko.pureComputed({
                        read: function () {
                            // ReSharper disable ClosureOnModifiedVariable
                            return self.editMode() ? cell.Acronym : cell.IDLabel();
                            // ReSharper enable ClosureOnModifiedVariable
                        },
                        owner: cell
                    });

                    let firstVoltage = true;
                    let firstCurrent = true;

                    for (let j = 0; j < cell.PhasorDefinitions.length; j++) {
                        const phasorDefinition = cell.PhasorDefinitions[j];

                        phasorDefinition.Label = String(phasorDefinition.Label).toUpperCase();

                        if (phasorDefinition.PhasorType.toLowerCase() === "voltage") {
                            self.voltages.push(self.createObservableVoltage(cell, phasorDefinition, firstVoltage));
                            firstVoltage = false;
                        } else {
                            self.currents.push(self.createObservableCurrent(cell, phasorDefinition, firstCurrent));
                            firstCurrent = false;
                        }
                    }
                }

                // Make sure table is refreshed
                if (ko.options.deferUpdates)
                    ko.tasks.runEarly();

                self.errors = ko.validation.group([
                    self.deviceAcronym,
                    self.voltages,
                    self.currents
                ]);

                self.refreshValidationErrors();

                $("[id=voltageRow]").css("visibility", "visible");
                $("[id=currentRow]").css("visibility", "visible");

                self.updateConfigFrameDetails();
                self.isDirty(false);

                if (deviceCount === 1) {
                    $("#voltagesSection").addClass("col-md-6");
                    $("#currentsSection").addClass("col-md-6");
                } else {
                    $("#voltagesSection").removeClass("col-md-6");
                    $("#currentsSection").removeClass("col-md-6");
                }
                
                hideLoadingLabel();
            };

            self.loadExisting = function () {
                if (!self.dataHubIsConnected())
                    return;

                self.voltages.removeAll();
                self.currents.removeAll();

                $("#responsiveTableDiv").show();
                $("[id=voltageRow]").css("visibility", "hidden");
                $("[id=currentRow]").css("visibility", "hidden");
                $("#bulkSelectionButtons").hide();
                showLoadingLabel();

                self.configFrameDetails("Analyzing...");

                dataHub.extractConfigurationFrame(deviceID).done(self.loadConfigFrame).fail(function (error) {
                    showErrorMessage(String.format("Failed to extract config file from existing device: {0}", error));

                    self.configFrameDetails("Unavailable");
                    $("[id=voltageRow]").css("visibility", "visible");
                    $("[id=currentRow]").css("visibility", "visible");
                    hideLoadingLabel();
                });
            };

            self.analyzeConfig = function (sourceData) {
                if (!self.dataHubIsConnected())
                    return;

                self.voltages.removeAll();
                self.currents.removeAll();

                $("#responsiveTableDiv").show();
                $("[id=voltageRow]").css("visibility", "hidden");
                $("[id=currentRow]").css("visibility", "hidden");
                $("#bulkSelectionButtons").hide();
                showLoadingLabel();

                self.configFrameDetails("Analyzing...");

                // If device is currently active, disconnect it before requesting a configuration
                // frame in case device doesn't support multiple connections
                if (deviceID > 0)
                    serviceHub.sendCommand("disconnect " + deviceID);

                dataHub.loadConfigurationFrame(sourceData).done(self.loadConfigFrame).then(function () {
                    // Reconnect device
                    if (deviceID > 0)
                        serviceHub.sendCommand("connect " + deviceID);
                })
                .fail(function (error) {
                    showErrorMessage(String.format("Failed to analyze config file: {0}", error));

                    self.configFrameDetails("Unavailable");
                        $("[id=voltageRow]").css("visibility", "visible");
                    $("[id=currentRow]").css("visibility", "visible");
                    hideLoadingLabel();
                });
            };

            self.refreshValidationErrors = function () {
                // Make sure any initial validation error messages are visible
                self.errors.showAllMessages();
            };

            self.createObservableVoltage = function (cell, phasorDefinition, firstVoltage) {
                const voltage = {};
                const phasorLabel = phasorDefinition.Label;
                const nominalVoltage = guessNominalVoltage(phasorDefinition.NominalVoltage, phasorLabel, cell.IDLabel());
                const phase = guessPhase(phasorDefinition.Phase, phasorLabel);

                voltage.ID = phasorDefinition.ID;
                voltage.Device = cell;
                voltage.Label = ko.observable(phasorLabel);
                voltage.Phase = ko.observable(phase);
                voltage.NominalVoltage = ko.observable(nominalVoltage);
                voltage.FirstVoltage = firstVoltage;
                voltage.Enabled = ko.observable(true);

                voltage.Label.extend({ required: true });
                voltage.Phase.extend({
                    required: true,
                    pattern: {
                        message: "Must be one of: A, B, C, 0, +, - or N",
                        params: "^[A-C0+\\-N]$"
                    }
                });
                voltage.NominalVoltage.extend({ required: true });

                phasorDefinition.Voltage = voltage;
                phasorDefinition.Label = voltage.Label;
                phasorDefinition.Phase = voltage.Phase;
                phasorDefinition.Enabled = voltage.Enabled;

                return voltage;
            };

            self.createObservableCurrent = function (cell, phasorDefinition, firstCurrent) {
                const current = {};
                const phasorLabel = phasorDefinition.Label;

                current.ID = phasorDefinition.ID;
                current.Device = cell;
                current.Label = ko.observable(phasorLabel);
                current.FirstCurrent = firstCurrent;
                current.Enabled = ko.observable(true);

                current._associatedVoltage = ko.observable(-1);
                current._phase = ko.observable("");

                current.AssociatedVoltage = ko.pureComputed({
                    read: function () {
                        if (current._associatedVoltage() === undefined) // Unselected KO option
                            current._associatedVoltage(-1);

                        return current._associatedVoltage();
                    },
                    write: function (value) {
                        if (value === null) // Undefined DB value
                            value = -1;

                        current._associatedVoltage(value);
                    },
                    owner: current
                });

                current.Phase = ko.pureComputed({
                    read: current._phase,
                    write: function (value) {
                        current._phase(value);

                        // Validate any pre-defined association
                        const associatedVoltage = current.AssociatedVoltage();

                        if (associatedVoltage > 0) {
                            const voltages = current.DeviceVoltages();
                            let found = false;

                            for (let j = 0; j < voltages.length; j++) {
                                const voltage = voltages[j];

                                if (voltage.ID === associatedVoltage && voltage.Phase() === current.Phase() && voltage.Enabled()) {
                                    found = true;
                                    break;
                                }
                            }

                            if (!found)
                                current.AssociatedVoltage(-1);
                        }

                        // Guess associated voltage
                        if (current.AssociatedVoltage() === -1)
                            current.AssociatedVoltage(guessAssociatedVoltage(current));
                    },
                    owner: current
                });

                current.DeviceVoltages = ko.pureComputed({
                    read: function () {
                        const allVoltages = self.voltages();
                        const deviceVoltages = [];

                        // Match by phase first
                        for (let i = 0; i < allVoltages.length; i++) {
                            const voltage = allVoltages[i];

                            if (voltage.Device === current.Device && voltage.Phase() === current.Phase() && voltage.Enabled())
                                deviceVoltages.push(voltage);
                        }

                        if (deviceVoltages.length === 0) {
                            // If no phases match, select all for device second
                            for (let i = 0; i < allVoltages.length; i++) {
                                const voltage = allVoltages[i];

                                if (voltage.Device === current.Device && voltage.Enabled())
                                    deviceVoltages.push(voltage);
                            }
                        }

                        return deviceVoltages;
                    },
                    owner: current
                });

                current.Label.extend({ required: true });
                current.Phase.extend({
                    required: true,
                    pattern: {
                        message: "Must be one of: A, B, C, 0, +, - or N",
                        params: "^[A-C0+\\-N]$"
                    }
                });

                // Assign any existing associated voltage
                current.AssociatedVoltage(phasorDefinition.DestinationPhasorID);

                // Guess phase, which will subsequently guess any unassociated voltage
                current.Phase(guessPhase(phasorDefinition.Phase, phasorLabel));

                phasorDefinition.Current = current;
                phasorDefinition.Label = current.Label;
                phasorDefinition.Phase = current.Phase;
                phasorDefinition.Enabled = current.Enabled;

                return current;
            };

            // Validations
            self.deviceAcronym.extend({
                required: true,
                pattern: {
                    message: "@Raw(AcronymValidationAttribute.DefaultErrorMessage)",
                    params: "@Raw(AcronymValidationAttribute.ValidationPattern.JavaScriptEncode())"
                },
                deviceUniqueInDatabase: deviceID
            });

            self.validationErrors = ko.pureComputed(function () {
                return self.errors().length;
            }).extend({
                notify: "always"
            });
        }

        function getCleanAcronym(acronym) {
            // Remove any invalid characters from acronym - @@ is escaped single at symbol:
            return acronym.replace(/[^A-Z0-9\-!_\.@@#\$]/gi, "");
        }

        function getDeviceSignalType(acronym) {
            acronym = acronym.toUpperCase();

            for (let i = 0; i < deviceSignalTypes.length; i++) {
                const deviceSignalType = deviceSignalTypes[i];

                if (deviceSignalType.Acronym.toUpperCase() === acronym)
                    return deviceSignalType;
            }

            return null;
        }

        function getPhasorSignalType(acronym) {
            acronym = acronym.toUpperCase();

            for (let i = 0; i < phasorSignalTypes.length; i++) {
                const phasorSignalType = phasorSignalTypes[i];

                if (phasorSignalType.Acronym.toUpperCase() === acronym)
                    return phasorSignalType;
            }

            return null;
        }

        function lookupAssociatedVoltage(cell, voltageID) {
            for (let i = 0; i < cell.PhasorDefinitions.length; i++) {
                const phasorDefinition = cell.PhasorDefinitions[i];

                if (phasorDefinition.PhasorType.toLowerCase() === "voltage" && phasorDefinition.Voltage.ID === voltageID)
                    return phasorDefinition;
            }

            return null;
        }

        function savePhasorMeasurement(cell, signalType, phasorDefinition, index) {
            const orgSignalReference = String.format("{0}-{1}{2}", cell.OriginalAcronym(), signalType.Suffix, index);
            const signalReference = String.format("{0}-{1}{2}", cell.IDLabel(), signalType.Suffix, index);

            // Query existing measurement record for specified signal reference - function will create a new blank measurement record if one does not exist
            return dataHub.queryMeasurement(orgSignalReference).then(function (measurement) {
                // Determine defined nominal voltage kV level of phasor
                let baseKV = 0;

                if (phasorDefinition.Voltage) {
                    baseKV = phasorDefinition.Voltage.NominalVoltage();
                }
                else if (phasorDefinition.Current) {
                    const voltage = lookupAssociatedVoltage(cell, phasorDefinition.Current.AssociatedVoltage());

                    if (voltage)
                        baseKV = voltage.Voltage.NominalVoltage();
                }

                // Create point tag using system defined naming convention
                return dataHub.createPhasorPointTag(cell.IDLabel(), signalType.Acronym, phasorDefinition.Label(), phasorDefinition.Phase(), index, baseKV).then(function (pointTag) {
                    measurement.DeviceID = cell.ID;
                    measurement.HistorianID = viewModel.historianID();
                    measurement.PointTag = pointTag;
                    measurement.Description = String.format("{0} {1} {2} {3}", cell.IDLabel(), phasorDefinition.Label(), phasorDefinition.Phase(), signalType.Name);
                    measurement.PhasorSourceIndex = index;
                    measurement.SignalReference = signalReference;
                    measurement.SignalTypeID = signalType.ID;
                    measurement.Internal = true;
                    measurement.Enabled = true;

                    return dataHub.addNewOrUpdateMeasurement(measurement).fail(function (error) {
                        showErrorMessage("Save failed for new measurement " + signalReference + ": " + error);
                    });
                })
                .fail(function (error) {
                    showErrorMessage("Failed to create point tag for measurement " + signalReference + ": " + error);
                });
            })
            .fail(function (error) {
                showErrorMessage("Failed to lookup measurement " + signalReference + ": " + error);
            });
        }

        function saveDevicePhasors(cell) {
            // Get phasor signal types
            const iphmSignalType = getPhasorSignalType("IPHM");
            const iphaSignalType = getPhasorSignalType("IPHA");
            const vphmSignalType = getPhasorSignalType("VPHM");
            const vphaSignalType = getPhasorSignalType("VPHA");

            if (iphmSignalType == null || iphaSignalType == null || vphmSignalType == null || vphaSignalType == null) {
                showErrorMessage("Failed to find one or more phasor signal type records.");
                return $.Deferred().resolve().promise();
            }

            return dataHub.queryPhasorsForDevice(cell.ID).then(function (phasors) {
                let dropAndAdd = phasors.length !== cell.PhasorDefinitions.length;

                if (!dropAndAdd) {
                    // Also do add operation if these are new records, e.g., from new config
                    for (let i = 0; i < cell.PhasorDefinitions.length; i++) {
                        const phasorID = cell.PhasorDefinitions[i].ID;

                        if (phasorID === null || phasorID === 0) {
                            dropAndAdd = true;
                            break;
                        }
                    }
                }

                if (!dropAndAdd) {
                    // Also do add operation if phasor source index records are not sequential
                    for (let i = 0; i < phasors.length; i++) {
                        if (phasors[i].SourceIndex !== i + 1) {
                            dropAndAdd = true;
                            break;
                        }
                    }
                }

                // Separate voltage and current phasor definitions
                const voltages = [];
                const currents = [];

                for (let i = 0; i < cell.PhasorDefinitions.length; i++) {
                    const phasorDefinition = cell.PhasorDefinitions[i];

                    if (phasorDefinition.PhasorType.toLowerCase() === "voltage")
                        voltages.push(phasorDefinition);
                    else
                        currents.push(phasorDefinition);
                }

                if (dropAndAdd) {
                    // Handle drop and (re)add phasors operation
                    const promise = cell.PhasorDefinitions.length > 0 ? dataHub.deletePhasorsForDevice(cell.ID) : $.Deferred().resolve().promise();

                    return promise.then(function () {
                        const promises = [];
                        const voltageIDMap = [];

                        for (let i = 0; i < voltages.length; i++) {
                            const voltage = voltages[i];

                            promises.push(dataHub.newPhasor().then(function (phasor) {
                                phasor.DeviceID = cell.ID;
                                phasor.Label = voltage.Label();
                                phasor.Type = "V";
                                phasor.Phase = voltage.Phase();
                                phasor.BaseKV = voltage.Voltage.NominalVoltage();
                                phasor.DestinationPhasorID = null;
                                phasor.SourceIndex = voltage.SourceIndex;

                                return dataHub.addNewPhasor(phasor).then(function () {
                                    if (!voltage.Enabled())
                                        return $.Deferred().resolve().promise();

                                    return savePhasorMeasurement(cell, vphmSignalType, voltage, phasor.SourceIndex).then(function () {
                                        return savePhasorMeasurement(cell, vphaSignalType, voltage, phasor.SourceIndex);
                                    })
                                    .then(function () {
                                        const vphmSignalReference = String.format("{0}-{1}{2}", cell.IDLabel(), vphmSignalType.Suffix, phasor.SourceIndex);

                                        return dataHub.queryMeasurement(vphmSignalReference).done(function (measurement) {
                                            voltage.vphmMeasurement = measurement;
                                        });
                                    })
                                    .then(function () {
                                        const vphaSignalReference = String.format("{0}-{1}{2}", cell.IDLabel(), vphaSignalType.Suffix, phasor.SourceIndex);

                                        return dataHub.queryMeasurement(vphaSignalReference).done(function (measurement) {
                                            voltage.vphaMeasurement = measurement;
                                        });
                                    })
                                    .then(function () {
                                        return dataHub.queryPhasorForDevice(cell.ID, phasor.SourceIndex).then(function (newPhasor) {
                                            voltageIDMap[voltage.ID] = newPhasor.ID;
                                        })
                                        .fail(function (error) {
                                            showErrorMessage("Failed to query voltage phasor: " + error);
                                        });
                                    });
                                })
                                .fail(function (error) {
                                    showErrorMessage("Failed to save new voltage phasor: " + error);
                                });
                            })
                            .fail(function (error) {
                                showErrorMessage("Failed to create new voltage phasor: " + error);
                            }));                        
                        }

                        for (let i = 0; i < currents.length; i++) {
                            const current = currents[i];

                            promises.push(dataHub.newPhasor().then(function (phasor) {
                                const associatedVoltage = current.Current.AssociatedVoltage();
                                const voltage = lookupAssociatedVoltage(cell, associatedVoltage);
                                let baseKV = 0;

                                if (voltage)
                                    baseKV = voltage.Voltage.NominalVoltage();

                                phasor.DeviceID = cell.ID;
                                phasor.Label = current.Label();
                                phasor.Type = "I";
                                phasor.Phase = current.Phase();
                                phasor.BaseKV = baseKV;
                                phasor.DestinationPhasorID = voltageIDMap[associatedVoltage];
                                phasor.SourceIndex = current.SourceIndex;

                                if (phasor.DestinationPhasorID === undefined)
                                    phasor.DestinationPhasorID = null;

                                return dataHub.addNewPhasor(phasor).then(function () {
                                    if (!current.Enabled())
                                        return $.Deferred().resolve().promise();

                                    return savePhasorMeasurement(cell, iphmSignalType, current, phasor.SourceIndex).then(function () {
                                        return savePhasorMeasurement(cell, iphaSignalType, current, phasor.SourceIndex);
                                    })
                                    .then(function () {
                                        const iphmSignalReference = String.format("{0}-{1}{2}", cell.IDLabel(), iphmSignalType.Suffix, phasor.SourceIndex);

                                        return dataHub.queryMeasurement(iphmSignalReference).done(function (measurement) {
                                            current.iphmMeasurement = measurement;
                                        });
                                    })
                                    .then(function () {
                                        const iphaSignalReference = String.format("{0}-{1}{2}", cell.IDLabel(), iphaSignalType.Suffix, phasor.SourceIndex);

                                        return dataHub.queryMeasurement(iphaSignalReference).done(function (measurement) {
                                            current.iphaMeasurement = measurement;
                                        });
                                    });
                                })
                                .fail(function (error) {
                                    showErrorMessage("Failed to save new current phasor: " + error);
                                });
                            })
                            .fail(function (error) {
                                showErrorMessage("Failed to create current new phasor: " + error);
                            }));
                        }

                        return $(promises).whenAll();
                    })
                    .fail(function (error) {
                        showErrorMessage("Failed to delete old phasors: " + error);
                    });
                }
                else {
                    // Handle update phasors operation
                    const promises = [];
                    const voltageIDMap = [];

                    for (let i = 0; i < voltages.length; i++) {
                        const voltage = voltages[i];

                        promises.push(dataHub.queryPhasorForDevice(cell.ID, voltage.SourceIndex).then(function (phasor) {
                            phasor.DeviceID = cell.ID;
                            phasor.Label = voltage.Label();
                            phasor.Type = "V";
                            phasor.Phase = voltage.Phase();
                            phasor.DestinationPhasorID = null;
                            phasor.SourceIndex = voltage.SourceIndex;
                            
                            voltageIDMap[voltage.ID] = phasor.ID;
                            
                            return dataHub.updatePhasor(phasor).then(function () {
                                if (!voltage.Enabled())
                                    return $.Deferred().resolve().promise();
                                
                                return savePhasorMeasurement(cell, vphmSignalType, voltage, phasor.SourceIndex).then(function () {
                                    return savePhasorMeasurement(cell, vphaSignalType, voltage, phasor.SourceIndex);
                                })
                                .then(function () {
                                    const vphmSignalReference = String.format("{0}-{1}{2}", cell.IDLabel(), vphmSignalType.Suffix, phasor.SourceIndex);

                                    return dataHub.queryMeasurement(vphmSignalReference).done(function (measurement) {
                                        voltage.vphmMeasurement = measurement;
                                    });
                                })
                                .then(function () {
                                    const vphaSignalReference = String.format("{0}-{1}{2}", cell.IDLabel(), vphaSignalType.Suffix, phasor.SourceIndex);

                                    return dataHub.queryMeasurement(vphaSignalReference).done(function (measurement) {
                                        voltage.vphaMeasurement = measurement;
                                    });
                                });
                            })
                            .fail(function (error) {
                                showErrorMessage("Failed to save voltage phasor: " + error);
                            });
                        })
                        .fail(function (error) {
                            showErrorMessage("Failed to query voltage phasor: " + error);
                        }));
                    }

                    for (let i = 0; i < currents.length; i++) {
                        const current = currents[i];

                        promises.push(dataHub.queryPhasorForDevice(cell.ID, current.SourceIndex).then(function (phasor) {
                            phasor.DeviceID = cell.ID;
                            phasor.Label = current.Label();
                            phasor.Type = "I";
                            phasor.Phase = current.Phase();
                            phasor.DestinationPhasorID = voltageIDMap[current.Current.AssociatedVoltage()];
                            phasor.SourceIndex = current.SourceIndex;

                            if (phasor.DestinationPhasorID === undefined)
                                phasor.DestinationPhasorID = null;

                            return dataHub.updatePhasor(phasor).then(function () {
                                if (!current.Enabled())
                                    return $.Deferred().resolve().promise();
                                
                                return savePhasorMeasurement(cell, iphmSignalType, current, phasor.SourceIndex).then(function () {
                                    return savePhasorMeasurement(cell, iphaSignalType, current, phasor.SourceIndex);
                                })
                                .then(function () {
                                    const iphmSignalReference = String.format("{0}-{1}{2}", cell.IDLabel(), iphmSignalType.Suffix, phasor.SourceIndex);

                                    return dataHub.queryMeasurement(iphmSignalReference).done(function (measurement) {
                                        current.iphmMeasurement = measurement;
                                    });
                                })
                                .then(function () {
                                    const iphaSignalReference = String.format("{0}-{1}{2}", cell.IDLabel(), iphaSignalType.Suffix, phasor.SourceIndex);

                                    return dataHub.queryMeasurement(iphaSignalReference).done(function (measurement) {
                                        current.iphaMeasurement = measurement;
                                    });
                                });
                            })
                            .fail(function (error) {
                                showErrorMessage("Failed to save current phasor: " + error);
                            });
                        })
                        .fail(function (error) {
                            showErrorMessage("Failed to query current phasor: " + error);
                        }));
                    }

                    return $(promises).whenAll();
                }
            })
            .fail(function (error) {
                showErrorMessage("Failed to query phasor count: " + error);
            });
        }

        function saveFixedMeasurement(cell, signalType, label) {
            const orgSignalReference = String.format("{0}-{1}", cell.OriginalAcronym(), signalType.Suffix);
            const signalReference = String.format("{0}-{1}", cell.IDLabel(), signalType.Suffix);

            // Query existing measurement record for specified signal reference - function will create a new blank measurement record if one does not exist
            return dataHub.queryMeasurement(orgSignalReference).then(function (measurement) {
                return dataHub.createPointTag(cell.IDLabel(), signalType.Acronym).then(function (pointTag) {
                    measurement.DeviceID = cell.ID;
                    measurement.HistorianID = viewModel.historianID();
                    measurement.PointTag = pointTag;
                    measurement.Description = String.format("{0} {1}", cell.IDLabel(), signalType.Name, isEmpty(label) ? "" : " - " + label);
                    measurement.SignalReference = signalReference;
                    measurement.SignalTypeID = signalType.ID;
                    measurement.Internal = true;
                    measurement.Enabled = true;

                    return dataHub.addNewOrUpdateMeasurement(measurement).fail(function (error) {
                        showErrorMessage("Save failed for new measurement " + signalReference + ": " + error);
                    });
                })
                .fail(function (error) {
                    showErrorMessage("Failed to create point tag for measurement " + signalReference + ": " + error);
                });
            })
            .fail(function (error) {
                showErrorMessage("Failed to lookup measurement " + signalReference + ": " + error);
            });
        }

        function saveDeviceMeasurements(cell) {
            const freqSignalType = getDeviceSignalType("FREQ");
            const dfdtSignalType = getDeviceSignalType("DFDT");
            const flagSignalType = getDeviceSignalType("FLAG");

            if (freqSignalType == null || dfdtSignalType == null || flagSignalType == null) {
                showErrorMessage("Failed to find one or more signal type records.");
                return $.Deferred().resolve().promise();
            }

            // Add frequency
            return saveFixedMeasurement(cell, freqSignalType, cell.FrequencyDefinition.Label).then(function () {
                // Add dF/dt
                return saveFixedMeasurement(cell, dfdtSignalType);
            })
            .then(function () {
                // Add status flags
                return saveFixedMeasurement(cell, flagSignalType);
            })
            .then(function () {
                // Add analogs
                if (viewModel.addAnalogs()) {
                    const analogSignalType = getDeviceSignalType("ALOG");

                    if (analogSignalType != null) {
                        const promises = [];

                        for (let i = 0; i < cell.AnalogDefinitions.length; i++) {
                            const index = i + 1;
                            const analogDefinition = cell.AnalogDefinitions[i];
                            const orgSignalReference = String.format("{0}-{1}{2}", cell.OriginalAcronym(), analogSignalType.Suffix, index);
                            const signalReference = String.format("{0}-{1}{2}", cell.IDLabel(), analogSignalType.Suffix, index);

                            // Query existing measurement record for specified signal reference - function will create a new blank measurement record if one does not exist
                            promises.push(dataHub.queryMeasurement(orgSignalReference).then(function (measurement) {
                                return dataHub.createIndexedPointTag(cell.IDLabel(), analogSignalType.Acronym, index).then(function (pointTag) {
                                    measurement.DeviceID = cell.ID;
                                    measurement.HistorianID = viewModel.historianID();
                                    measurement.PointTag = pointTag;
                                    measurement.AlternateTag = analogDefinition.Label;
                                    measurement.Description = String.format("{0} Analog Value {1}:{2}: {3}", cell.IDLabel(), index, analogDefinition.AnalogType, analogDefinition.Label);
                                    measurement.SignalReference = signalReference;
                                    measurement.SignalTypeID = analogSignalType.ID;
                                    measurement.Internal = true;
                                    measurement.Enabled = true;

                                    return dataHub.addNewOrUpdateMeasurement(measurement).fail(function (error) {
                                        showErrorMessage("Save failed for new measurement " + signalReference + ": " + error);
                                    });
                                })
                                .fail(function (error) {
                                    showErrorMessage("Failed to create point tag for measurement " + signalReference + ": " + error);
                                });
                            })
                            .fail(function (error) {
                                showErrorMessage("Failed to lookup measurement " + signalReference + ": " + error);
                            }));
                        }

                        return $(promises).whenAll();
                    }
                    else {
                        showErrorMessage("Failed to find analog signal type record.");
                        return $.Deferred().resolve().promise();
                    }
                }
                else {
                    return $.Deferred().resolve().promise();
                }
            })
            .then(function () {
                // Add digitals
                if (viewModel.addDigitals()) {
                    const digitalSignalType = getDeviceSignalType("DIGI");

                    if (digitalSignalType != null) {
                        const promises = [];

                        for (let i = 0; i < cell.DigitalDefinitions.length; i++) {
                            const index = i + 1;
                            const digitialDefinition = cell.DigitalDefinitions[i];
                            const orgSignalReference = String.format("{0}-{1}{2}", cell.OriginalAcronym(), digitalSignalType.Suffix, index);
                            const signalReference = String.format("{0}-{1}{2}", cell.IDLabel(), digitalSignalType.Suffix, index);

                            // Query existing measurement record for specified signal reference - function will create a new blank measurement record if one does not exist
                            promises.push(dataHub.queryMeasurement(orgSignalReference).then(function (measurement) {
                                return dataHub.createIndexedPointTag(cell.IDLabel(), digitalSignalType.Acronym, index).then(function (pointTag) {
                                    measurement.DeviceID = cell.ID;
                                    measurement.HistorianID = viewModel.historianID();
                                    measurement.PointTag = pointTag;
                                    measurement.AlternateTag = digitialDefinition.Label;
                                    measurement.Description = String.format("{0} Digital Value {1}: {2}", cell.IDLabel(), index, digitialDefinition.Label);
                                    measurement.SignalReference = signalReference;
                                    measurement.SignalTypeID = digitalSignalType.ID;
                                    measurement.Internal = true;
                                    measurement.Enabled = true;

                                    return dataHub.addNewOrUpdateMeasurement(measurement).fail(function (error) {
                                        showErrorMessage("Save failed for new measurement " + signalReference + ": " + error);
                                    });
                                })
                                .fail(function (error) {
                                    showErrorMessage("Failed to create point tag for measurement " + signalReference + ": " + error);
                                });
                            })
                            .fail(function (error) {
                                showErrorMessage("Failed to lookup measurement " + signalReference + ": " + error);
                            }));
                        }

                        return $(promises).whenAll();
                    }
                    else {
                        showErrorMessage("Failed to find digital signal type record.");
                        return $.Deferred().resolve().promise();
                    }
                }
                else {
                    return $.Deferred().resolve().promise();
                }
            })
            .then(function () {
                return saveDevicePhasors(cell);
            });
        }

        function savePowerCalcuations(cell, tagTemplate) {
            const promises = [];
            const phase = tagTemplate.Inputs[0].toUpperCase()[0];

            for (let i = 0; i < cell.PhasorDefinitions.length; i++) {
                const phasorDefinition = cell.PhasorDefinitions[i];

                // Power calculations can be applied to currents with an associated voltage
                if (phasorDefinition.PhasorType.toLowerCase() === "current" && phasorDefinition.Phase().toUpperCase() === phase && phasorDefinition.Current.AssociatedVoltage() > 0) {
                    const current = phasorDefinition;
                    const voltage = lookupAssociatedVoltage(cell, phasorDefinition.Current.AssociatedVoltage());

                    if (voltage) {
                        if (voltage.hasOwnProperty("vphaMeasurement") && voltage.hasOwnProperty("vphmMeasurement") && current.hasOwnProperty("iphaMeasurement") && current.hasOwnProperty("iphmMeasurement")) {
                            const circuitDescription = String.format("{0}-{1}-{2}", cell.IDLabel(), tagTemplate.TagName, current.Label());
                            const vphaID = voltage.vphaMeasurement.SignalID;
                            const vphmID = voltage.vphmMeasurement.SignalID;
                            const iphaID = current.iphaMeasurement.SignalID;
                            const iphmID = current.iphmMeasurement.SignalID;

                            // Query for existing power calculation, this will create a new record if not found
                            promises.push(dataHub.queryPowerCalculationForDescriptionOrInputs(circuitDescription, vphaID, vphmID, iphaID, iphmID).then(function (powerCalculation) {
                                powerCalculation.VoltageAngleSignalID = vphaID;
                                powerCalculation.VoltageMagSignalID = vphmID;
                                powerCalculation.CurrentAngleSignalID = iphaID;
                                powerCalculation.CurrentMagSignalID = iphmID;
                                powerCalculation.Enabled = true;

                                // For direct phase power calculations, do not apply voltage adjustment strategy
                                if (phase === "A" || phase === "B" || phase === "C")
                                    powerCalculation.CircuitDescription = circuitDescription + "; AdjustmentStrategy = None";
                                else
                                    powerCalculation.CircuitDescription = circuitDescription;

                                if (powerCalculation.ID === 0) {
                                    return dataHub.addNewPowerCalculation(powerCalculation).fail(function (error) {
                                        showErrorMessage("Failed to add new power calculation record: " + error);
                                    });
                                }
                                else {
                                    return dataHub.updatePowerCalculation(powerCalculation).fail(function (error) {
                                        showErrorMessage("Failed to update power calculation record: " + error);
                                    });
                                }
                            })
                            .fail(function (error) {
                                showErrorMessage("Failed to query power calculation record: " + error);
                            }));
                        }                        
                    }
                }
            }

            return $(promises).whenAll();
        }

        function lineCurrentExists(lines, current) {
            for (let i = 0; i < lines.length; i++) {
                const line = lines[i];

                if (line.A.current === current || line.B.current === current || line.C.current === current)
                    return true;
            }

            return false;
        }

        // Find lines that have phasors for each phase, i.e., A, B and C
        function findMatchingLines(cell) {
            const lines = [];

            // Scan all phasor definitions
            for (let i = 0; i < cell.PhasorDefinitions.length; i++) {
                const phasorDefinition = cell.PhasorDefinitions[i];
                const phase = phasorDefinition.Phase().toUpperCase();

                if ((phase !== "A" && phase !== "B" && phase !== "C") || phasorDefinition.PhasorType.toLowerCase() !== "current")
                    continue;

                const current = phasorDefinition;                   
                const voltage = lookupAssociatedVoltage(cell, phasorDefinition.Current.AssociatedVoltage());

                // No matching voltage means no power calculation, so can skip this as a match potential
                if (!voltage)
                    continue;
                    
                // See if this line current has already been matched
                if (lineCurrentExists(lines, current))
                    continue;

                // Strategy for finding matching line phases is to remove any A, B or C phase designations from label
                const match = current.Label().trim().toUpperCase().replace(/[ABC]/gi, "");

                if (isEmpty(match))
                    continue;

                const line = [];

                line[phase] = {
                    current: current,
                    voltage: voltage
                };

                // Look for matching line currents - this creates a quadratic search time, but total phasors are expected to be small
                for (let j = 0; j < cell.PhasorDefinitions.length; j++) {
                    if (j === i)
                        continue;
                        
                    const nextPhasorDefinition = cell.PhasorDefinitions[j];
                    const nextPhase = nextPhasorDefinition.Phase().toUpperCase();

                    if ((nextPhase !== "A" && nextPhase !== "B" && nextPhase !== "C") || nextPhasorDefinition.PhasorType.toLowerCase() !== "current" || nextPhase === phase || line.hasOwnProperty(nextPhase))
                        continue;

                    const nextCurrent = nextPhasorDefinition;                   
                    const nextVoltage = lookupAssociatedVoltage(cell, nextPhasorDefinition.Current.AssociatedVoltage());

                    // No matching voltage means no power calculation, so can skip this as a match potential
                    if (!nextVoltage)
                        continue;

                    // See if this next current is for matching line based on label minus phase designations
                    if (match === nextCurrent.Label().trim().toUpperCase().replace(/[ABC]/gi, "")) {
                        line[nextPhase] = {
                            current: nextCurrent,
                            voltage: nextVoltage
                        };

                        if (line.hasOwnProperty("A") && line.hasOwnProperty("B") && line.hasOwnProperty("C")) {
                            lines.push(line);
                            break;
                        }
                    }
                }
            }

            return lines;
        }

        function queryPowerOutput(type, linePhase, attempt) {
            if (attempt === undefined)
                attempt = 1;

            if (attempt > 4) {
                showErrorMessage("Failed to find power output measurement after waiting 4 seconds - skipping 3-phase power calculations.");
                return $.Deferred().resolve(null).promise();
            }

            if (!linePhase.voltage.hasOwnProperty("vphaMeasurement") || !linePhase.voltage.hasOwnProperty("vphmMeasurement") || !linePhase.current.hasOwnProperty("iphaMeasurement") || !linePhase.current.hasOwnProperty("iphmMeasurement"))
                return $.Deferred().resolve(null).promise();

            const vphaID = linePhase.voltage.vphaMeasurement.SignalID;
            const vphmID = linePhase.voltage.vphmMeasurement.SignalID;
            const iphaID = linePhase.current.iphaMeasurement.SignalID;
            const iphmID = linePhase.current.iphmMeasurement.SignalID;

            return dataHub.queryPowerCalculationForInputs(vphaID, vphmID, iphaID, iphmID).then(function (powerCalculation) {
                if (powerCalculation.ID > 0) {
                    switch (type) {
                        case "MW":
                            if (powerCalculation.ActivePowerOutputSignalID == null || powerCalculation.ActivePowerOutputSignalID === 0)
                                return delayedPromise(1000).then(function () { return queryPowerOutput(type, linePhase, ++attempt); });

                            return $.Deferred().resolve(powerCalculation.ActivePowerOutputSignalID).promise();
                        case "MVAR":
                            if (powerCalculation.ReactivePowerOutputSignalID == null || powerCalculation.ReactivePowerOutputSignalID === 0)
                                return delayedPromise(1000).then(function () { return queryPowerOutput(type, linePhase, ++attempt); });

                            return $.Deferred().resolve(powerCalculation.ReactivePowerOutputSignalID).promise();
                        case "MVA":
                            if (powerCalculation.ApparentPowerOutputSignalID == null || powerCalculation.ApparentPowerOutputSignalID === 0)
                                return delayedPromise(1000).then(function () { return queryPowerOutput(type, linePhase, ++attempt); });

                            return $.Deferred().resolve(powerCalculation.ApparentPowerOutputSignalID).promise();
                    }
                }
                
                return $.Deferred().resolve(null).promise();
            })
            .fail(function (error) {
                showErrorMessage("Failed to query power calculation record: " + error);
            });
        }

        var matchingLines = [];

        function saveSumPhase(cell, tagTemplate, calcSignalType) {
            const deviceLabel = cell.IDLabel();
            var lines;

            if (matchingLines.hasOwnProperty(deviceLabel)) {
                lines = matchingLines[deviceLabel];
            }
            else {
                lines = findMatchingLines(cell);
                matchingLines[deviceLabel] = lines;
            }

            const type = tagTemplate.Inputs[0].trim().toUpperCase(); // MW, MVAR, MVA
            const linePromises = [];

            for (let i = 0; i < lines.length; i++) {
                const line = lines[i];
                const queryPromises = [];
                
                let phaseASignalID = null;
                let phaseBSignalID = null;
                let phaseCSignalID = null;

                // These queries will keep looping while power calculations are initializing until power output measurements exist or timeout after 4 seconds:
                queryPromises.push(queryPowerOutput(type, line.A, 1).then(function (signalID) {
                    phaseASignalID = signalID;
                }));
                
                queryPromises.push(queryPowerOutput(type, line.B, 1).then(function (signalID) {
                    phaseBSignalID = signalID;
                }));
                
                queryPromises.push(queryPowerOutput(type, line.C, 1).then(function (signalID) {
                    phaseCSignalID = signalID;
                }));

                linePromises.push($(queryPromises).whenAll().then(function () {
                    // Signal IDs should not be null at this point
                    if (!phaseASignalID && !phaseBSignalID && !phaseCSignalID)
                        return $.Deferred().resolve().promise();

                    const lineName = line.A.current.Label();
                    const orgSignalReference = String.format("{0}-{1}-{2}-{3}", cell.OriginalAcronym(), tagTemplate.TagName, lineName, calcSignalType.Suffix);
                    const signalReference = String.format("{0}-{1}-{2}-{3}", cell.IDLabel(), tagTemplate.TagName, lineName, calcSignalType.Suffix);

                    // Query existing measurement record for specified signal reference - function will create a new blank measurement record if one does not exist
                    return dataHub.queryMeasurement(orgSignalReference).then(function (measurement) {
                        measurement.DeviceID = cell.ID;
                        measurement.HistorianID = viewModel.historianID();
                        measurement.PointTag = getCleanAcronym(String.format("{0}-{1}:CALC-{2}", cell.IDLabel(), lineName, tagTemplate.TagName));
                        measurement.Description = String.format("{0} {1} Calculated Value: {2}", cell.IDLabel(), lineName, tagTemplate.Description);
                        measurement.SignalReference = signalReference;
                        measurement.SignalTypeID = calcSignalType.ID;
                        measurement.Internal = true;
                        measurement.Enabled = true;

                        return dataHub.addNewOrUpdateMeasurement(measurement).then(function () {
                            return dataHub.queryMeasurement(signalReference).then(function (measurement) {
                                const connectionString = new Dictionary();
                                const variableList = new Dictionary();
                                const equation = "APW+BPW+CPW";

                                variableList.set("APW", phaseASignalID);
                                variableList.set("BPW", phaseBSignalID);
                                variableList.set("CPW", phaseCSignalID);

                                connectionString.set("variableList", variableList.joinKeyValuePairs());
                                connectionString.set("expressionText", equation);
                                connectionString.set("framesPerSecond", viewModel.configFrame().FrameRate);
                                connectionString.set("lagTime", "@Program.Host.Model.Global.DefaultCalculationLagTime");
                                connectionString.set("leadTime", "@Program.Host.Model.Global.DefaultCalculationLeadTime");
                                connectionString.set("outputMeasurements", measurement.SignalID);
                                connectionString.set("useLatestValues", "false");

                                return dataHub.newCustomActionAdapter().then(function (adapter) {
                                    adapter.NodeID = nodeID;
                                    adapter.AdapterName = measurement.PointTag;
                                    adapter.AssemblyName = "DynamicCalculator.dll";
                                    adapter.TypeName = "DynamicCalculator.DynamicCalculator";
                                    adapter.ConnectionString = connectionString.joinKeyValuePairs();
                                    adapter.LoadOrder = 100;
                                    adapter.Enabled = true;

                                    return dataHub.addNewOrUpdateCustomActionAdapter(adapter).then(function () {
                                        return serviceHub.sendCommand("initialize " + adapter.AdapterName);
                                    })
                                    .fail(function (error) {
                                        showErrorMessage("Save failed for new custom action measurement: " + error);
                                    });
                                })
                                .fail(function (error) {
                                    showErrorMessage("Failed to create new custom action adapter record: " + error);
                                });
                            })
                            .fail(function (error) {
                                showErrorMessage("Failed to lookup measurement " + signalReference + ": " + error);
                            });
                        })
                        .fail(function (error) {
                            showErrorMessage("Save failed for new measurement " + signalReference + ": " + error);
                        });
                    })
                    .fail(function (error) {
                        showErrorMessage("Failed to lookup or create measurement " + signalReference + ": " + error);
                    });
                }));
            }

            return $(linePromises).whenAll();
        }

        var dynamicCalculation = {
            initialized: false,
            deviceVariables: new Dictionary(),
            FAVG: "",
            FNOM: 60
        };

        function initializeDynamicCalculation() {
            if (dynamicCalculation.initialized)
                return $.Deferred().resolve().promise();

            // Input variables - expanded per device:
            //   VNOM: Nominal Voltage = viewModel.configFrame().PhasorDefintions[voltage].Voltage.NominalVoltage()
            //    VAM: Voltage A-Phase Magnitude also VBM, VCM, VNM for B, C & N phases and VPOSM, VNEGM, VZM for +, -, 0 sequence
            //    VAA: Voltage A-Phase Angle     also VBA, VCA, VNA            ↑            VPOSA, VNEGA, VZA
            //    IAM: Current A-Phase Magnitude also IBM, ICM, INM         Neutral         IPOSM, INEGM, IZM
            //    IAA: Current A-Phase Angle     also IBA, ICA, INA                         IPOSA, INEGA, IZA
            //   FREQ: Frequency
            //   FNOM: Model.Global.NominalFrequency
            //   FAVG: Frequency Average = system singleton where signal reference is "SYSTEM!FREQ-AVG-FQ"
            //  FLAGS: Status Flags

            const promises = [];
            const configFrame = viewModel.configFrame();
            const cells = configFrame.Cells;
            const cellCount = cells.length;

            for (let i = 0; i < cellCount; i++) {
                const cell = cells[i];
                const label = cell.IDLabel();
                const vars = {
                      VAM: [],   VBM: [],   VCM: [],   VNM: [],   VPOSM: [],   VNEGM: [],   VZM: [],
                      VAA: [],   VBA: [],   VCA: [],   VNA: [],   VPOSA: [],   VNEGA: [],   VZA: [],
                    VANOM: [], VBNOM: [], VCNOM: [], VNNOM: [], VPOSNOM: [], VNEGNOM: [], VZNOM: [],
                      IAM: [],   IBM: [],   ICM: [],   INM: [],   IPOSM: [],   INEGM: [],   IZM: [],
                      IAA: [],   IBA: [],   ICA: [],   INA: [],   IPOSA: [],   INEGA: [],   IZA: [],
                     FREQ: "", FLAGS: ""
                };

                for (let j = 0; j < cell.PhasorDefinitions.length; j++) {
                    const phasorDefinition = cell.PhasorDefinitions[j];
                    const phase = phasorDefinition.Phase().toUpperCase();

                    if (phasorDefinition.PhasorType.toLowerCase() === "voltage") {
                        const nominalVoltage = phasorDefinition.Voltage.NominalVoltage() * 1000; // Convert to kV
                        const nominalVoltage3 = nominalVoltage / 1.7320508075688772;

                        if (!phasorDefinition.hasOwnProperty("vphmMeasurement") || !phasorDefinition.hasOwnProperty("vphaMeasurement"))
                            continue;

                        switch (phase) {
                            case "A":
                                vars.VAM.push(phasorDefinition.vphmMeasurement.SignalID);
                                vars.VAA.push(phasorDefinition.vphaMeasurement.SignalID);
                                vars.VANOM.push(nominalVoltage3);
                                break;
                            case "B":
                                vars.VBM.push(phasorDefinition.vphmMeasurement.SignalID);
                                vars.VBA.push(phasorDefinition.vphaMeasurement.SignalID);
                                vars.VBNOM.push(nominalVoltage3);
                                break;
                            case "C":
                                vars.VCM.push(phasorDefinition.vphmMeasurement.SignalID);
                                vars.VCA.push(phasorDefinition.vphaMeasurement.SignalID);
                                vars.VCNOM.push(nominalVoltage3);
                                break;
                            case "N": // Neutral
                                vars.VNM.push(phasorDefinition.vphmMeasurement.SignalID);
                                vars.VNA.push(phasorDefinition.vphaMeasurement.SignalID);
                                vars.VNNOM.push(nominalVoltage);
                                break;
                            case "+": // Positive Sequence
                                vars.VPOSM.push(phasorDefinition.vphmMeasurement.SignalID);
                                vars.VPOSA.push(phasorDefinition.vphaMeasurement.SignalID);
                                vars.VPOSNOM.push(nominalVoltage);
                                break;
                            case "-": // Negative Sequence
                                vars.VNEGM.push(phasorDefinition.vphmMeasurement.SignalID);
                                vars.VNEGA.push(phasorDefinition.vphaMeasurement.SignalID);
                                vars.VNEGNOM.push(nominalVoltage);
                                break;
                            case "0": // Zero Sequence
                                vars.VZM.push(phasorDefinition.vphmMeasurement.SignalID);
                                vars.VZA.push(phasorDefinition.vphaMeasurement.SignalID);
                                vars.VZNOM.push(nominalVoltage);
                                break;
                            default:
                                continue;
                        }
                    } else {
                        if (!phasorDefinition.hasOwnProperty("iphmMeasurement") || !phasorDefinition.hasOwnProperty("iphaMeasurement"))
                            continue;

                        switch (phase) {
                            case "A":
                                vars.IAM.push(phasorDefinition.iphmMeasurement.SignalID);
                                vars.IAA.push(phasorDefinition.iphaMeasurement.SignalID);
                                break;
                            case "B":
                                vars.IBM.push(phasorDefinition.iphmMeasurement.SignalID);
                                vars.IBA.push(phasorDefinition.iphaMeasurement.SignalID);
                                break;
                            case "C":
                                vars.ICM.push(phasorDefinition.iphmMeasurement.SignalID);
                                vars.ICA.push(phasorDefinition.iphaMeasurement.SignalID);
                                break;
                            case "N": // Neutral
                                vars.INM.push(phasorDefinition.iphmMeasurement.SignalID);
                                vars.INA.push(phasorDefinition.iphaMeasurement.SignalID);
                                break;
                            case "+": // Positive Sequence
                                vars.IPOSM.push(phasorDefinition.iphmMeasurement.SignalID);
                                vars.IPOSA.push(phasorDefinition.iphaMeasurement.SignalID);
                                break;
                            case "-": // Negative Sequence
                                vars.INEGM.push(phasorDefinition.iphmMeasurement.SignalID);
                                vars.INEGA.push(phasorDefinition.iphaMeasurement.SignalID);
                                break;
                            case "0": // Zero Sequence
                                vars.IZM.push(phasorDefinition.iphmMeasurement.SignalID);
                                vars.IZA.push(phasorDefinition.iphaMeasurement.SignalID);
                                break;
                            default:
                                continue;
                        }
                    }
                }

                promises.push(dataHub.queryMeasurement(label + "-FQ").then(function (measurement) {
                    vars.FREQ = measurement.SignalID;
                    return dataHub.queryMeasurement(label + "-SF");
                })
                .then(function (measurement) {
                    vars.FLAGS = measurement.SignalID;
                    dynamicCalculation.deviceVariables.set(label, vars);
                })
                .fail(function (error) {
                    showErrorMessage("Failed to find device '" + label + "' frequency or flags: " + error);
                }));
            }

            return $(promises).whenAll().then(function () {
                return dataHub.queryMeasurement("SYSTEM!FREQ-AVG-FQ");
            })
            .then(function (measurement) {
                if (measurement && measurement.SignalID)
                    dynamicCalculation.FAVG = measurement.SignalID;

                dynamicCalculation.FNOM = @Program.Host.Model.Global.NominalFrequency;
                dynamicCalculation.initialized = true;
            })
            .fail(function (error) {
                showErrorMessage("Failed to find average system frequency with SignalReference = 'SYSTEM!FREQ-AVG-FQ': " + error);
            });
        }

        function lookupAssociatedPhasorDefinition(cell, signalID) {
            for (let i = 0; i < cell.PhasorDefinitions.length; i++) {
                const phasorDefinition = cell.PhasorDefinitions[i];

                if (phasorDefinition.PhasorType.toLowerCase() === "voltage") {
                    if (phasorDefinition.hasOwnProperty("vphmMeasurement") && phasorDefinition.hasOwnProperty("vphaMeasurement"))
                        if (phasorDefinition.vphmMeasurement.SignalID === signalID || phasorDefinition.vphaMeasurement.SignalID === signalID)
                            return phasorDefinition;
                }
                else if (phasorDefinition.hasOwnProperty("iphmMeasurement") && phasorDefinition.hasOwnProperty("iphaMeasurement")) {
                    if (phasorDefinition.iphmMeasurement.SignalID === signalID || phasorDefinition.iphaMeasurement.SignalID === signalID)
                        return phasorDefinition;
                }
            }

            return null;
        }

        function saveDynamicCalculation(cell, tagTemplate, calcSignalType) {
            return initializeDynamicCalculation().then(function () {
                const vars = dynamicCalculation.deviceVariables.get(cell.IDLabel());
                var inputSet = {};

                for (let i = 0; i < tagTemplate.Inputs.length; i++) {
                    const inputName = tagTemplate.Inputs[i].toUpperCase();
                    let varName = inputName;

                    if (inputName === "FAVG") {
                        inputSet.FAVG = dynamicCalculation.FAVG;
                        continue;
                    }

                    if (inputName === "FNOM") {
                        inputSet.FNOM = dynamicCalculation.FNOM;
                        continue;
                    }

                    // Map VNOM since it's entered as per-phasor nominal voltage
                    if (inputName === "VNOM") {
                        for (let j = 0; j < tagTemplate.Inputs.length; j++) {
                            if (i === j)
                                continue;

                            switch (tagTemplate.Inputs[j].toUpperCase()) {
                                case "VAM":
                                case "VAA":
                                    varName = "VANOM";
                                    break;
                                case "VBM":
                                case "VBA":
                                    varName = "VBNOM";
                                    break;
                                case "VCM":
                                case "VCA":
                                    varName = "VCNOM";
                                    break;
                                case "VNM":
                                case "VNA":
                                    varName = "VNNOM";
                                    break;
                                case "VPOSM":
                                case "VPOSA":
                                    varName = "VPOSNOM";
                                    break;
                                case "VNEGM":
                                case "VNEGA":
                                    varName = "VNEGNOM";
                                    break;
                                case "VZM":
                                case "VZA":
                                    varName = "VZNOM";
                                    break;
                            }

                            if (varName !== inputName)
                                break;
                        }

                        if (varName === "VNOM")
                            varName = "VANOM";
                    }

                    inputSet[inputName] = vars[varName];
                }

                var maxInputLength = 0;
                var inputsAvailable = true;
                var singletonCalculation = false;

                // TODO: Handle case where there may be an odd number of positive sequence values to phase values - may need to match by line??

                // Get max channel count
                for (let property in inputSet) {
                    if (inputSet.hasOwnProperty(property)) {
                        // Ignore non-array elements
                        if (!Array.isArray(inputSet[property]))
                            continue;

                        const channelCount = inputSet[property].length;

                        if (channelCount > maxInputLength)
                            maxInputLength = channelCount;
                    }
                }

                // Validate inputs
                if (maxInputLength > 0) {
                    for (let property in inputSet) {
                        if (inputSet.hasOwnProperty(property)) {
                            // Ignore non-array elements
                            if (!Array.isArray(inputSet[property]))
                                continue;

                            // All array-based inputs, e.g., phasors, must have consistent lengths
                            if (maxInputLength !== inputSet[property].length) {
                                inputsAvailable = false;
                                break;
                            }
                        }
                    }
                } else {
                    // Check for singleton calculation inputs
                    inputsAvailable = inputSet.hasOwnProperty("FREQ") || inputSet.hasOwnProperty("FAVG") || inputSet.hasOwnProperty("FNOM") || inputSet.hasOwnProperty("FLAGS");

                    if (inputsAvailable) {
                        maxInputLength = 1;
                        singletonCalculation = true;
                    }
                }

                const promises = [];

                if (inputsAvailable) {
                    for (let i = 0; i < maxInputLength; i++) {
                        const index = i;
                        const orgSignalReference = String.format("{0}-{1}-{2}{3}", cell.OriginalAcronym(), tagTemplate.TagName, calcSignalType.Suffix, singletonCalculation ? "" : String(index));
                        const signalReference = String.format("{0}-{1}-{2}{3}", cell.IDLabel(), tagTemplate.TagName, calcSignalType.Suffix, singletonCalculation ? "" : String(index));

                        // Query existing measurement record for specified signal reference - function will create a new blank measurement record if one does not exist
                        promises.push(dataHub.queryMeasurement(orgSignalReference).then(function (measurement) {
                            measurement.DeviceID = cell.ID;
                            measurement.HistorianID = viewModel.historianID();
                            measurement.PointTag = String.format("{0}-<0>:CALC-{1}", cell.IDLabel(), tagTemplate.TagName);
                            measurement.Description = String.format("{0} <0> Calculated Value {1}: {2}", cell.IDLabel(), index, tagTemplate.Description);
                            measurement.SignalReference = signalReference;
                            measurement.SignalTypeID = calcSignalType.ID;
                            measurement.Internal = true;
                            measurement.Enabled = true;

                            return dataHub.addNewOrUpdateMeasurement(measurement).then(function () {
                                return dataHub.queryMeasurement(signalReference).then(function (measurement) {
                                    var phasorDefinition = null;
                                    const connectionString = new Dictionary();
                                    const variableList = new Dictionary();
                                    var equation = tagTemplate.Equation;

                                    for (let property in inputSet) {
                                        if (inputSet.hasOwnProperty(property)) {
                                            if (Array.isArray(inputSet[property])) {
                                                if (property === "VNOM") {
                                                    // Replace VNOM constant
                                                    equation = equation.replaceAll("VNOM", String(inputSet.VNOM[index]), true);
                                                }
                                                else {
                                                    // Assign variable to signal ID
                                                    const signalID = inputSet[property][index] + "";
                                                    variableList.set(property, signalID);

                                                    if (phasorDefinition == null) {
                                                        const matchedPhasorDefinition = lookupAssociatedPhasorDefinition(cell, signalID);

                                                        if (matchedPhasorDefinition != null)
                                                            phasorDefinition = matchedPhasorDefinition;
                                                    }
                                                }
                                            }
                                            else {
                                                if (property === "FNOM") {
                                                    // Replace FNOM constant
                                                    equation = equation.replaceAll("FNOM", String(inputSet.FNOM), true);
                                                } else {
                                                    // Assign variable to signal ID
                                                    const signalID = inputSet[property] + "";
                                                    variableList.set(property, signalID);
                                                }
                                            }
                                        }
                                    }

                                    // Inject phasor definition label into output measurement point tag and description
                                    if (phasorDefinition != null) {
                                        const label = phasorDefinition.Label().replaceAll(" ", "_").toUpperCase();
                                        measurement.PointTag = getCleanAcronym(String.format(measurement.PointTag.replace("<0>", "{0}"), label));
                                        measurement.Description = String.format(measurement.Description.replace("<0>", "{0}"), phasorDefinition.Label());
                                        dataHub.updateMeasurement(measurement);
                                    }
                                    else {
                                        measurement.PointTag = getCleanAcronym(measurement.PointTag.replace("-<0>", ""));
                                        measurement.Description = measurement.Description.replace(" <0>", "");
                                        dataHub.updateMeasurement(measurement);
                                    }
                                    
                                    connectionString.set("variableList", variableList.joinKeyValuePairs());
                                    connectionString.set("expressionText", equation);
                                    connectionString.set("framesPerSecond", viewModel.configFrame().FrameRate);
                                    connectionString.set("lagTime", "@Program.Host.Model.Global.DefaultCalculationLagTime");
                                    connectionString.set("leadTime", "@Program.Host.Model.Global.DefaultCalculationLeadTime");
                                    connectionString.set("outputMeasurements", measurement.SignalID);
                                    connectionString.set("useLatestValues", "false");

                                    return dataHub.newCustomActionAdapter().then(function (adapter) {
                                        adapter.NodeID = nodeID;
                                        adapter.AdapterName = measurement.PointTag;
                                        adapter.AssemblyName = "DynamicCalculator.dll";
                                        adapter.TypeName = "DynamicCalculator.DynamicCalculator";
                                        adapter.ConnectionString = connectionString.joinKeyValuePairs();
                                        adapter.LoadOrder = 100;
                                        adapter.Enabled = true;

                                        return dataHub.addNewOrUpdateCustomActionAdapter(adapter).then(function () {
                                            return serviceHub.sendCommand("initialize " + adapter.AdapterName);
                                        })
                                        .fail(function (error) {
                                            showErrorMessage("Save failed for new custom action measurement: " + error);
                                        });
                                    })
                                    .fail(function (error) {
                                        showErrorMessage("Failed to create new custom action adapter record: " + error);
                                    });
                                })
                                .fail(function (error) {
                                    showErrorMessage("Failed to lookup measurement " + signalReference + ": " + error);
                                });
                            })
                            .fail(function (error) {
                                showErrorMessage("Save failed for new measurement " + signalReference + ": " + error);
                            });
                        })
                        .fail(function (error) {
                            showErrorMessage("Failed to lookup or create measurement " + signalReference + ": " + error);
                        }));
                    }
                }

                return $(promises).whenAll();
            });
        }

        function saveTemplateCalculations(cell) {
            const templateType = viewModel.templateType();

            if (templateType.toUpperCase() === "NONE")
                return $.Deferred().resolve().promise();

            const calcSignalType = getDeviceSignalType("CALC");
            
            if (calcSignalType == null && !errorDisplayed) {
                showErrorMessage("Cannot save tag template calculations: no signal type record found for 'CALC'");
                return $.Deferred().resolve().promise();
            }

            return dataHub.loadTemplate(templateType).then(function (tagTemplates) {
                return dataHub.validateCalculatorConfigurations(viewModel.historianID()).then(function () {
                    return serviceHub.sendCommand("initialize PHASOR!AVERAGEFREQ").then(function () {
                        const promises = [];

                        let calculatePowerCount = 0;
                        let sumPhaseCount = 0;

                        for (let i = 0; i < tagTemplates.length; i++) {
                            const tagTemplate = tagTemplates[i];

                            switch (tagTemplate.Type.toUpperCase()) {
                                case "CALCULATEPOWER":
                                    calculatePowerCount++;
                                    break;
                                case "SUMPHASE":
                                    sumPhaseCount++;
                                    break;
                            }

                            if (calculatePowerCount > 0 && sumPhaseCount > 0)
                                break;
                        }

                        if (sumPhaseCount > 0 && calculatePowerCount === 0)
                            showErrorMessage("3-phase power calculations will be skipped because selected template \"" + templateType + "\" defines no power calculations...");

                        const sumPhaseTagTemplates = [];

                        for (let i = 0; i < tagTemplates.length; i++) {
                            const tagTemplate = tagTemplates[i];

                            switch (tagTemplate.Type.toUpperCase()) {
                                case "CALCULATEPOWER":
                                    promises.push(savePowerCalcuations(cell, tagTemplate).then(function () {
                                        return serviceHub.sendCommand("initialize PHASOR!POWERCALC");
                                    }));
                                    break;
                                case "SUMPHASE":
                                    // Hold on to sum phase tag templates for later execution
                                    if (calculatePowerCount > 0)
                                        sumPhaseTagTemplates.push(tagTemplate);
                                    break;
                                case "DYNAMICCALCULATOR":
                                    promises.push(saveDynamicCalculation(cell, tagTemplate, calcSignalType));
                                    break;
                            }
                        }

                        return $(promises).whenAll().then(function () {
                            const sumPhasePromises = [];

                            // Sum phase templates are saved after power calculations have completed as they are dependent calculations
                            for (let i = 0; i < sumPhaseTagTemplates.length; i++) {
                                sumPhasePromises.push(saveSumPhase(cell, sumPhaseTagTemplates[i], calcSignalType));
                            }

                            return $(sumPhasePromises).whenAll();
                        });
                    })
                    .fail(function (error) {
                        showErrorMessage("Failed to validate calculator configurations: " + error);
                    });
                });
            })
            .fail(function (error) {
                showErrorMessage("Failed to load " + templateType + " tag template: " + error);
            });
        }

        function saveDeviceRecords(id) {
            const configFrame = viewModel.configFrame();
            const cells = configFrame.Cells;
            const cellCount = cells.length;

            if (cellCount === 0) {
                showErrorMessage("Cannot save device records: no devices were defined in loaded configuration.");
                return $.Deferred().resolve().promise();
            }

            if (configFrame.IsConcentrator || cellCount > 1) {
                let deviceSaveChain = $.Deferred().resolve();

                for (let i = 0; i < cellCount; i++) {
                    const index = i;
                    const cell = cells[index];

                    // Chain multiple devices saves behind one another...
                    deviceSaveChain = deviceSaveChain.then(function () {
                        showInfoMessage(String.format("Saving \"{0}\" device {1} / {2} please wait...", cell.IDLabel(), index + 1, cellCount), -1);

                        // Query existing child device record - function will create a new blank device record if one does not exist
                        return dataHub.queryDeviceByID(cell.ID).then(function (device) {
                            // Check if this is a direct update to child device
                            if (cellCount === 1 && device.ID === id) {
                                cell.ID = id;

                                return dataHub.updateDevice(device).then(function () {
                                    // Save measurements and calculations associated with a directly edited child device
                                    return saveDeviceMeasurements(cell).then(function () {
                                        return saveTemplateCalculations(cell);
                                    });
                                });
                            }
                            else {
                                // Set device properties
                                device.ParentID = cell.ParentID == null ? id : cell.ParentID;
                                device.HistorianID = viewModel.historianID();
                                device.ProtocolID = configFrame.ProtocolID;
                                device.FrameRate = configFrame.FrameRate;
                                device.AccessID = cell.IDCode;
                                device.Acronym = cell.IDLabel();

                                if (isEmpty(device.Name))
                                    device.Name = device.Acronym;

                                device.Enabled = true;

                                // Check if this is a new device or an edit to an existing one
                                if (device.ID === 0) {
                                    // Add new device record
                                    return dataHub.addNewDevice(device).then(function () {
                                        // Get newly added device with auto-incremented ID
                                        return dataHub.queryDevice(device.Acronym).then(function (newDevice) {
                                            // Save associated device records...
                                            cell.ID = newDevice.ID;

                                            return saveDeviceMeasurements(cell).then(function () {
                                                return saveTemplateCalculations(cell);
                                            });
                                        })
                                        .fail(function (error) {
                                            showErrorMessage("Failed while querying new device " + device.Acronym + " - no measurements saved: " + error);
                                        });
                                    })
                                    .fail(function (error) {
                                        showErrorMessage("Save failed for new device " + device.Acronym + ": " + error);
                                    });
                                }
                                else {
                                    // Update existing device record
                                    return dataHub.updateDevice(device).then(function () {
                                        // Save associated device records...
                                        cell.ID = device.ID;

                                        return saveDeviceMeasurements(cell).then(function () {
                                            return saveTemplateCalculations(cell);
                                        });
                                    })
                                    .fail(function (error) {
                                        showErrorMessage("Update failed for existing device " + device.Acronym + " - no measurements updated: " + error);
                                    });
                                }
                            }
                        })
                        .fail(function (error) {
                            showErrorMessage("Save failed for new device " + device.Acronym + " - could not create new or lookup existing device: " + error);
                        });
                    });
                }

                return deviceSaveChain.promise();
            }
            else {
                const cell = cells[0];
                cell.ID = id;

                // Save measurements and calculations  associated with a directly connected device
                return saveDeviceMeasurements(cell).then(function () {
                    return saveTemplateCalculations(cell);
                });
            }
        }

        function saveDeviceConnection() {
            if (!viewModel.editMode() && isEmpty(viewModel.configFrame().ConnectionString)) {
                showErrorMessage("Cannot save device connection without a connection string");
                return $.Deferred().resolve().promise();
            }

            if (!hubIsConnected) {
                showErrorMessage("Cannot save device connection, cannot connect to server.");
                return $.Deferred().resolve().promise();
            }

            showInfoMessage("Saving device connection, please wait...", -1);
            disableUIButtons();

            // Query existing device record - function will create a new blank device record if one does not exist
            return dataHub.queryDeviceByID(deviceID).then(function (device) {
                // Set device properties
                const configFrame = viewModel.configFrame();
                var connectionString = configFrame.ConnectionString + "";
                const connectionStringMap = new Dictionary(connectionString.parseKeyValuePairs());
                var autoStartDataParsingSequence = true;
                var skipDisableRealTimeData = false;

                // Handle connection string parameters that are fields in the device table
                if (connectionStringMap.containsKey("autoStartDataParsingSequence")) {
                    autoStartDataParsingSequence = connectionStringMap.get("autoStartDataParsingSequence");
                    connectionStringMap.remove("autoStartDataParsingSequence");
                    connectionString = connectionStringMap.joinKeyValuePairs();
                }

                if (connectionStringMap.containsKey("skipDisableRealTimeData")) {
                    skipDisableRealTimeData = connectionStringMap.get("skipDisableRealTimeData");
                    connectionStringMap.remove("skipDisableRealTimeData");
                    connectionString = connectionStringMap.joinKeyValuePairs();
                }

                device.Acronym = viewModel.deviceAcronym();
                device.HistorianID = viewModel.historianID();
                device.ProtocolID = configFrame.ProtocolID;
                device.FrameRate = configFrame.FrameRate;
                device.AccessID = configFrame.IDCode;
                
                if (isEmpty(device.Name))
                    device.Name = device.Acronym;
                
                if (!isEmpty(connectionString))
                    device.ConnectionString = connectionString;

                device.AutoStartDataParsingSequence = autoStartDataParsingSequence;
                device.SkipDisableRealTimeData = skipDisableRealTimeData;
                //device.Longitude = viewModel.longitude();
                //device.Latitude = viewModel.latitude();
                device.Enabled = true;

                // Check if this is a new device or an edit to an existing one
                if (device.ID === 0) {
                    // Add new device record
                    return dataHub.addNewDevice(device).then(function () {
                        // Get newly added device with auto-incremented ID
                        return dataHub.queryDevice(device.Acronym).then(function (newDevice) {
                            // Save associated device records...
                            deviceID = newDevice.ID;

                            return saveDeviceRecords(deviceID).then(function () {
                                enableUIButtons("Save complete.");

                                serviceHub.sendCommand("initialize " + deviceID).done(function () {
                                    window.location = "GraphMeasurements.cshtml";
                                });
                            });
                        })
                        .fail(function (error) {
                            showErrorMessage("Failed while querying new device " + device.Acronym + " - no measurements saved: " + error);
                            enableUIButtons();
                        });
                    })
                    .fail(function (error) {
                        showErrorMessage("Save failed for new device " + device.Acronym + ": " + error);
                        enableUIButtons();
                    });
                }
                else {
                    // Update existing device record
                    return dataHub.updateDevice(device).then(function () {
                        // Save associated device records...
                        return saveDeviceRecords(device.ID).then(function () {
                            enableUIButtons("Save complete.");

                            const connectionID = device.ParentID ? device.ParentID : device.ID;

                            serviceHub.sendCommand("initialize " + connectionID).done(function () {
                                window.location = "GraphMeasurements.cshtml";
                            });
                        });
                    })
                    .fail(function (error) {
                        showErrorMessage("Update failed for existing device " + device.Acronym + " - no measurements updated: " + error);
                        enableUIButtons();
                    });
                }
            })
            .fail(function (error) {
                showErrorMessage("Save failed for new device " + device.Acronym + " - could not create new or lookup existing device: " + error);
                enableUIButtons();
            });
        }

        // Load existing device data
        function loadDeviceConnection(id) {
            if (!hubIsConnected)
                return;

            dataHub.queryDeviceByID(id).done(function (device) {
                $("#editDeviceName").html("Editing&nbsp;" + device.Acronym);
            })
            .fail(function (error) {
                showErrorMessage(String.format("Failed to load existing device \"{0}\": {1}", id, error));
            });
        }

        function resizePageElements() {
            if (deviceID === 0)
                $("#inputDeviceAcronym").width($("#inputConfigFile").width());

            $("#contentWell").height(calculateRemainingBodyHeight() - $("#headerArea").outerHeight(true));
        }

        function disableUIButtons() {
            $("#inputConfigFile").disable();
            $("#saveData").disable();
            showLoadingLabel();
        }

        function enableUIButtons(message) {
            $("#inputConfigFile").enable();
            $("#saveData").enable();
            hideLoadingLabel();

            if (message === undefined)
                hideInfoMessage();
            else
                showInfoMessage(message);
        }

        // Page initialization function
        $(function () {
            $("#bodyContainer").addClass("fill-height");

            // Define local rule that will check that device acronym is unique in the database
            ko.validation.rules["deviceUniqueInDatabase"] = {
                async: true,
                validator: function (newVal, options, callback) {
                    if (viewModel.dataHubIsConnected()) {
                        // Lookup Device record by Acronym - this will return an empty record if not found
                        dataHub.queryDevice(newVal).done(function (device) {
                            // Valid if device doesn't exist or is itself
                            callback(device.ID === 0 || device.ID === options);
                        })
                        .fail(function (error) {
                            showErrorMessage(error);

                            // Do not display validation failure message for connection issues
                            callback(true);
                        });
                    }
                    else {
                        callback(true);
                    }
                },
                message: "This device acronym already exists in the database. Acronyms must be unique."
            };

            ko.bindingHandlers.selectOnError = {
                init: function (element, valueAccessor) {
                    $(element).on("input", function(event) {
                        setTimeout(function () {
                            if (!valueAccessor().isValid())
                                element.select();
                        }, 1);
                    });
                }
            }

            // Enable knockout validation
            ko.validation.init({
                registerExtenders: true,
                messagesOnModified: true,
                insertMessages: true,
                parseInputAttributes: true,
                allowHtmlMessages: true,
                messageTemplate: null,
                decorateElement: true,
                errorElementClass: "has-error",
                errorMessageClass: "help-block",
                grouping: { deep: true, observable: true, live: true }
            }, true);

            // Enable deferred updates for better performance
            ko.options.deferUpdates = true;

            // Create the primary view model
            viewModel = new DeviceViewModel();

            // Initialize primary view model
            ko.applyBindings(viewModel);

            // Monitor for view model changes
            ko.watch(viewModel.devices, { depth: -1 }, function (parents, child, item) {
                viewModel.isDirty(true);
            });

            // Let view model know about hub connectivity changes
            $(window).on("hubConnected", function () {
                viewModel.dataHubIsConnected(true);

                if (!firstConnect)
                    return;

                firstConnect = false;

                if (deviceID > 0)
                    loadDeviceConnection(deviceID);

                const instanceNameSelect = $("#instanceName");

                // Load available historian instance names, if not already loaded
                if (instanceNameSelect.children("option").length === 0) {
                    dataHub.getInstanceNames().done(function (names) {
                        instanceNameSelect.append($("<option>", { value: null, text: 'Do Not Archive' }));

                        for (let i = 0; i < names.length; i++) {
                            const value = names[i];
                            instanceNameSelect.append($("<option>", { value: value, text: value }));
                        }

                        // Select last value
                        var lastInstanceName = Cookies.get("instanceName");

                        if (lastInstanceName === undefined)
                            lastInstanceName = instanceNameSelect.eq(0).val();

                        if (!isEmpty(lastInstanceName))
                            instanceNameSelect.val(lastInstanceName);

                        setTimeout(function () {
                            viewModel.instanceName(lastInstanceName);
                        }, 200);
                    });
                }

                const templateTypeSelect = $("#templateType");

                // Load available calculation templates, if not already loaded
                if (templateTypeSelect.children("option").length === 0) {
                    dataHub.getTemplateTypes().done(function (names) {
                        for (let i = 0; i < names.length; i++) {
                            const value = names[i];
                            templateTypeSelect.append($("<option>", { value: value, text: value }));
                        }

                        // Select last value
                        var lastTemplateType = Cookies.get("templateType");

                        if (lastTemplateType === undefined)
                            lastTemplateType = templateTypeSelect.eq(0).val();

                        if (!isEmpty(lastTemplateType))
                            instanceNameSelect.val(lastTemplateType);

                        setTimeout(function () {
                            viewModel.templateType(lastTemplateType);
                        }, 200);
                    });
                }

                dataHub.loadSignalTypes("PMU").then(function (result) {
                    deviceSignalTypes = result;

                    return dataHub.loadSignalTypes("Phasor").then(function (result) {
                        phasorSignalTypes = result;

                        if (deviceID > 0)
                            viewModel.loadExisting();
                    });
                });
            });

            $(window).on("hubDisconnected", function () {
                viewModel.dataHubIsConnected(false);
            });

            $(window).on("messageVisibiltyChanged", function () {
                resizePageElements();
            });

            $(window).resize(function () {
                resizePageElements();
            });

            // Define button handlers
            $("#saveData").click(function() {
                saveDeviceConnection();
            });

            $("#inputConfigFile").change(function(event){
                const uploadedFile = event.target.files[0];

                if (uploadedFile) {
                    const readFile = new FileReader();

                    readFile.onload = function(event) {
                        viewModel.analyzeConfig(event.target.result);
                    };

                    readFile.readAsText(uploadedFile);
                }

                $("#inputConfigFile").tooltip("hide");
            });

            resizePageElements();

            if (deviceID === 0)
                hideLoadingLabel();
        });
    </script>
}
<div id="headerArea">
    <h3 style="margin-top: -10px;">
        @ViewBag.Title <span class="label label-info" id="editDeviceName"></span> <!--img class="page-logo pull-right" src="Images/AddDevice.png" /-->
        <span style="padding-right: 10px" class="form-inline pull-right clearfix">
            <small>
                Instance:&nbsp;<select class="form-control" id="instanceName" data-bind="value: instanceName; valueAllowUnset: true" style="border: 0; width: 140px"></select>
            </small>
        </span>
    </h3>
    <form>
        <table style="width: 95%">
            <tr data-bind="visible: !editMode()">
                <td class="input-label">
                    <label for="inputConfigFile">Connection File:</label>
                </td>
                <td>
                    <div class="input-group input-area">
                        <input id="inputConfigFile" type="file" placeholder="Connection file name..." title="Select&nbsp;PMUConnection&nbsp;file..." accept=".PmuConnection,.xml,text/xml" data-toggle="tooltip" data-placement="right" class="form-control" style="width: 100%">
                    </div>
                </td>
            </tr>
            <tr>
                <td class="input-label">
                    <label for="inputDeviceAcronym"><span data-bind="text: configFrame().Cells.length == 1 ? 'Device' : 'Connection'">Connection</span> Acronym:</label>
                </td>
                <td>
                    <div class="input-group" data-bind="css: { 'has-error': !fieldIsValid(deviceAcronym, true), 'has-feedback': !fieldIsValid(deviceAcronym, true) }">
                        <input id="inputDeviceAcronym" type="text" class="form-control" style="width: 250px" data-bind="acronym: deviceAcronym, textInput: deviceAcronym, disable: readOnly" required>
                        <span class="glyphicon glyphicon-remove form-control-feedback" data-bind="visible: !fieldIsValid(deviceAcronym, true)"></span>
                    </div>
                </td>
            </tr>
            <tr>
                <td class="input-label">
                    <label for="templateType">Tag Template:</label>
                </td>
                <td>
                    <div class="input-group">
                        <select class="form-control" id="templateType" data-bind="value: templateType; valueAllowUnset: false" style="border: 0; width: 250px"></select>
                        <div class="checkbox" style="display:inline; margin-left: 15px">
                            <label class="disabled" style="margin-top: 6px"><input type="checkbox" data-bind="checked: addTagsAsVirtualPoints" disabled> Generate virtual tags (otherwise tags will be archived)</label>
                        </div>
                    </div>
                </td>
            </tr>
        </table>
        <span class="pull-right clearfix" id="loadingDataLabel" style="display: inline; margin-top: -27px">
            Loading&nbsp;&nbsp;<span class="glyphicon glyphicon-refresh glyphicon-spin"></span>
        </span>
    </form>
</div>
<div id="contentWell" class="well well-dynamic-content">
    <div id="responsiveTableDiv" class="table-responsive" style="display: none; border: none">
        <span id="configFrameDetails">Config Frame: <span data-bind="html: configFrameDetails"></span></span>
        <div id="saveDataButton" class="pull-right" style="text-align: right">
            @if (userIsEditor)
            {
                <text>
                    <div class="input-group pull-right" style="margin-top: -4px">
                        <form class="form-inline" style="padding-bottom: 4px">
                            <div class="checkbox">
                                <label><input type="checkbox" data-bind="checked: addAnalogs"> Add Analogs</label>
                            </div>
                            <div class="checkbox" style="padding-left: 5px;">
                                <label><input type="checkbox" data-bind="checked: addDigitals"> Add Digitals</label>
                            </div>
                        </form>
                        <button type="button" class="btn btn-sm btn-primary pull-right" id="saveData" data-bind="disable: working() || validationErrors() > 0 || !dataHubIsConnected() || (!editMode() && isEmpty(configFrame().ConnectionString))">
                            <span class="glyphicon glyphicon-plus"></span>&nbsp;&nbsp;Save&nbsp;Device
                        </button>
                    </div>
                </text>
            }
            else
            {
                <span class="label label-danger label-md">User "@GetCurrentUserID()" does not have rights to add or modify device data.</span>
            }
        </div>
        <span><br />Connection String: <span data-bind="text: configFrame().ConnectionString"></span></span>
        <em data-bind="visible: validationErrors() > 0">
            <br />
            <span data-bind="text: validationErrors()"></span> validation error<span data-bind="visible: validationErrors() > 1">s</span>...
        </em>
        <hr class="quarter-break" />
        <div id="configInfo"></div>
        
        <!-- Voltages Section -->
        <div id="voltagesSection" class="col-md-6">
            <h3>Voltages</h3>
            <table class="table table-condensed table-striped table-hover">
                <thead>
                    <tr>
                        <!-- ko if: configFrame().Cells.length > 1 -->
                        <th class="text-left">Device&nbsp;Acronym</th>
                        <!-- /ko -->
                        <th class="text-left">Phasor&nbsp;Label</th>
                        <th class="text-center">Phase</th>
                        <th class="text-left">Nominal&nbsp;Voltage</th>
                    </tr>
                </thead>
                <tbody data-bind="foreach: { data: voltages }">
                    <tr id="voltageRow" style="visibility: hidden" data-bind="css: { 'top-border': FirstVoltage }">
                        <!-- ko if: !FirstVoltage && $parent.configFrame().Cells.length > 1 -->
                        <td width="190px" class="text-left valign-middle">
                            <div class="input-group"></div>
                        </td>
                        <!-- /ko -->
                        <!-- ko if: FirstVoltage && $parent.configFrame().Cells.length > 1 -->
                        <td width="190px" class="text-left valign-middle">
                            <div class="input-group" data-bind="css: { 'has-error': !fieldIsValid(Device.IDLabel, true), 'has-feedback': !fieldIsValid(Device.IDLabel, true) }">
                                <input type="text" class="form-control" style="width: 180px" data-bind="acronym: Device, textInput: Device.IDLabel, disable: $parent.readOnly() || !$data.Enabled()" required>
                                <span class="glyphicon glyphicon-remove form-control-feedback" data-bind="visible: !fieldIsValid(Device.IDLabel, true)"></span>
                            </div>
                        </td>
                        <!-- /ko -->
                        <td width="210px" class="text-left valign-middle">
                            <div class="checkbox" style="margin-top: 0; margin-bottom: 0">
                                <input type="checkbox" style="margin-top: 10px" data-bind="checked: Enabled">
                            </div>
                            <div class="input-group" data-bind="css: { 'has-error': !fieldIsValid(Label, true), 'has-feedback': !fieldIsValid(Label, true) }">
                                <input type="text" class="form-control" style="width: 200px" data-bind="acronym: Label, textInput: Label, disable: $parent.readOnly() || !$data.Enabled()" required>
                                <span class="glyphicon glyphicon-remove form-control-feedback" style="z-index: 5" data-bind="visible: !fieldIsValid(Label, true)"></span>
                            </div>
                        </td>
                        <td width="55px" class="text-center valign-middle">
                            <div class="input-group" data-bind="css: { 'has-error': !fieldIsValid(Phase, true), 'has-feedback': !fieldIsValid(Phase, true) }">
                                <input type="text" class="form-control" maxlength="1" style="width: 37px; margin-left: 3px" onclick="this.select()" data-bind="upperCase: Phase, textInput: Phase, style: { width: Phase.isValid() ? '37px' : '70px' }, selectOnError: Phase, enable: Enabled" placeholder="Ø" required>
                                <span class="glyphicon glyphicon-remove form-control-feedback" style="z-index: 5" data-bind="visible: !fieldIsValid(Phase, true)"></span>
                            </div>
                        </td>
                        <td class="text-left valign-middle">
                            <div class="input-group" data-bind="css: { 'has-error': !fieldIsValid(NominalVoltage, true), 'has-feedback': !fieldIsValid(NominalVoltage, true) }">
                                <input type="text" class="form-control" style="width: 70px; margin-left: 10px" data-bind="integer: NominalVoltage, textInput: NominalVoltage, enable: Enabled" required>&nbsp;<span class="table-cell-text">kV</span>
                                <span class="glyphicon glyphicon-remove form-control-feedback" style="z-index: 5" data-bind="visible: !fieldIsValid(NominalVoltage, true)"></span>
                            </div>
                        </td>
                    </tr>
                </tbody>
            </table>
        </div>
        
        <!-- Currents Section -->
        <div id="currentsSection" class="col-md-6">
            <h3>Currents</h3>
            <table class="table table-condensed table-striped table-hover">
                <thead>
                    <tr>
                        <!-- ko if: configFrame().Cells.length > 1 -->
                        <th class="text-left">Device&nbsp;Acronym</th>
                        <!-- /ko -->
                        <th class="text-left">Phasor&nbsp;Label</th>
                        <th class="text-center">Phase</th>
                        <th class="text-left">Associated&nbsp;Voltage</th>
                    </tr>
                </thead>
                <tbody data-bind="foreach: { data: currents }">
                    <tr id="currentRow" style="visibility: hidden" data-bind="css: { 'top-border': FirstCurrent }">
                        <!-- ko if: !FirstCurrent && $parent.configFrame().Cells.length > 1 -->
                        <td width="190px" class="text-left valign-middle">
                            <div class="input-group"></div>
                        </td>
                        <!-- /ko -->
                        <!-- ko if: FirstCurrent && $parent.configFrame().Cells.length > 1 -->
                        <td width="190px" class="text-left valign-middle">
                            <div class="input-group" data-bind="css: { 'has-error': !fieldIsValid(Device.IDLabel, true), 'has-feedback': !fieldIsValid(Device.IDLabel, true) }">
                                <input type="text" class="form-control" style="width: 180px" data-bind="acronym: Device, textInput: Device.IDLabel, disable: $parent.readOnly() || !$data.Enabled()" required>
                                <span class="glyphicon glyphicon-remove form-control-feedback" data-bind="visible: !fieldIsValid(Device.IDLabel, true)"></span>
                            </div>
                        </td>
                        <!-- /ko -->
                        <td width="210px" class="text-left valign-middle">
                            <div class="checkbox" style="margin-top: 0; margin-bottom: 0">
                                <input type="checkbox" style="margin-top: 10px" data-bind="checked: Enabled">
                            </div>
                            <div class="input-group" data-bind="css: { 'has-error': !fieldIsValid(Label, true), 'has-feedback': !fieldIsValid(Label, true) }">
                                <input type="text" class="form-control" style="width: 200px" data-bind="acronym: Label, textInput: Label, disable: $parent.readOnly() || !$data.Enabled()" required>
                                <span class="glyphicon glyphicon-remove form-control-feedback" style="z-index: 5" data-bind="visible: !fieldIsValid(Label, true)"></span>
                            </div>
                        </td>
                        <td width="55px" class="text-center valign-middle">
                            <div class="input-group" data-bind="css: { 'has-error': !fieldIsValid(Phase, true), 'has-feedback': !fieldIsValid(Phase, true) }">
                                <input type="text" class="form-control" maxlength="1" style="width: 37px; margin-left: 3px" onclick="this.select()" data-bind="upperCase: Phase, textInput: Phase, style: { width: Phase.isValid() ? '37px' : '70px' }, selectOnError: Phase, enable: Enabled" placeholder="Ø" required>
                                <span class="glyphicon glyphicon-remove form-control-feedback" style="z-index: 5" data-bind="visible: !fieldIsValid(Phase, true)"></span>
                            </div>
                        </td>
                        <td class="text-left valign-middle">
                            <select class="form-control" style="width: 90%" data-bind="options: DeviceVoltages, optionsCaption: '', value: AssociatedVoltage, optionsText: 'Label', optionsValue: 'ID', valueAllowUnset: true, enable: Enabled"></select>
                        </td>
                    </tr>
                </tbody>
            </table>
        </div>
    </div>
</div>