@*******************************************************************************************************
//  AddSynchrophasorDevice.cshtml - Gbtc
//
//  Copyright © 2019, Grid Protection Alliance.  All Rights Reserved.
//
//  Licensed to the Grid Protection Alliance (GPA) under one or more contributor license agreements. See
//  the NOTICE file distributed with this work for additional information regarding copyright ownership.
//  The GPA licenses this file to you under the MIT License (MIT), the "License"; you may not use this
//  file except in compliance with the License. You may obtain a copy of the License at:
//
//      http://opensource.org/licenses/MIT
//
//  Unless agreed to in writing, the subject software distributed under the License is distributed on an
//  "AS-IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. Refer to the
//  License for the specific language governing permissions and limitations.
//
//  Code Modification History:
//  ----------------------------------------------------------------------------------------------------
//  02/18/2019 - J. Ritchie Carroll
//       Generated original version of source code.
//
//******************************************************************************************************
//  To use in ASP.NET project, include a AddSynchrophasorDevice.cshtml view with the following:
//
//  @using GSF.Web
//  @section StyleSheets{@Html.Raw(ViewBag.StyleSheetsSection?.ToString())}
//  @Html.RenderResource("PhasorWebUI.Views.AddSynchrophasorDevice.cshtml")
//  @section Scripts{@Html.Raw(ViewBag.ScriptsSection?.ToString())}
//
//******************************************************************************************************
//  To use in self-hosted web project, include a AddSynchrophasorDevice.cshtml view with the following:
//
//  @using GSF.Web.Model
//  @using <MyAppNameSpace>.Model
//  @inherits ExtendedTemplateBase<AppModel>
//  @section StyleSheets{@Html.Raw(ViewBag.StyleSheetsSection.ToString())}
//  @{Layout = "Layout.cshtml";}
//  @Html.RenderResource("PhasorWebUI.AddSynchrophasorDevice.cshtml")
//  @section Scripts{@Html.Raw(ViewBag.ScriptsSection.ToString())}
//*****************************************************************************************************@
@* ReSharper disable UnknownCssClass *@
@* ReSharper disable Html.PathError *@
@* ReSharper disable InlineOutVariableDeclaration *@
@* ReSharper disable ArrangeAccessorOwnerBody *@
@using System
@using System.Collections.Generic
@using System.ComponentModel
@using System.Net.Http
@using System.Text.RegularExpressions
@using System.Threading
@using GSF.ComponentModel
@using GSF.ComponentModel.DataAnnotations
@using GSF.Identity
@using GSF.Security
@using GSF.Web
@using GSF.Web.Model
@using GSF.Web.Shared
@inherits ExtendedTemplateBase<openHistorian.Model.AppModel>
@{
    ViewBag.HidePageTitle = true;
    ViewBag.Title = "New Device Commissioning Wizard";

    Layout = "Layout.cshtml";

    HttpRequestMessage request = ViewBag.Request;
    Dictionary<string, string> parameters = request.QueryParameters();
    string parameter;
    int deviceID;

    if (!parameters.TryGetValue("DeviceID", out parameter) || !int.TryParse(parameter, out deviceID)) {
        deviceID = 0;
    }

    bool userIsEditor = UserIsEditor();
}
@section StyleSheets {
    <link href="@Resources.Root/Shared/Content/jquery-ui.css" rel="stylesheet">
    <link href="@Resources.Root/Shared/Content/select2.css" rel="stylesheet">
    <link href="@Resources.Root/Shared/Content/select2-bootstrap.css" rel="stylesheet">
    <style>
        html, body {
            height: 100%;
        }
        
        .tabs-nohdr {
            padding: 0;
            background: none;
            border-width: 0;
        }
         
        .tabs-nohdr .ui-tabs-nav {
            padding: 0;
            background: transparent;
            border: none;
        }

        .tabs-nohdr .ui-tabs-panel {
            border: none;
            padding: 0;
            margin: 0;
        }

        #tabs {
            border: none;
            padding: 0;
        }

        #tabs ul {
            border: none;
            background: none;
        }

        #tabs ul li {
            outline: none;
        }

        #tabs ul li:nth-child(1) {
            margin-left: -3px;
        }

        #tabs ul li a {
            outline: none;
            padding: 2px 8px;
        }

        .ui-tabs-nav li.ui-tabs-active,
        .ui-tabs-nav li:hover {
            background: #337ab7;
        }

        #tab1 {
            padding: 10px 0px;
        }

        #tab2 {
            padding: 5px 0px;
        }

        .input-group-btn button {
            font-size: 14px;
        }

        span.table-cell-text {
            display: table-cell;
            vertical-align: middle;
        }

        span.org-label {
            font-size: 9px;
            display: block;
            text-align: right;
            margin-top: -5px;
            margin-right: 2px;
            margin-bottom: -1px;
            color: darkgray;
        }

        span.tag-name-label {
            font-size: 10.5px;
            display: block;
            text-align: left;
            margin-top: -1px;
            margin-left: 2px;
            margin-bottom: -5px;
            color: darkslategray;
        }

        span.tag-name {
            font-size: 10px;
            position: absolute;
            margin-top: -9px;
            margin-left: 52px;
            white-space: nowrap;
            color: darkslategray;
            -webkit-text-stroke-width: thin;
        }

        span.sub-text {
            font-size: x-small;
            vertical-align: baseline;
        }

        div.save-button {
            margin-top: -33px;
            margin-right: 2px;
            z-index: 10;
        }

        button.save-button {
            width: 140px;
        }

        div.no-access {
            margin-top: -33px;
            z-index: 10;
            width: 40%;
            white-space: inherit;
            position: relative;
        }

        div.panel-heading-condensed {
            height: 30px;
            padding-top: 5px;
        }

        div.include-phasor {
            margin-top: 0;
            margin-bottom: 0;
        }

        input[type='checkbox'].include-phasor {
            margin-top: 10px;
            cursor: pointer;
        }

        div.delete-phasor {
            position: absolute;
            margin-top: 32px;
            margin-left: -20px;
            cursor: pointer;
        }

        span.delete-phasor {
            font-size: smaller;
        }

        tr.separator-top {
            visibility: hidden;
            border-bottom-width: 4px;
            border-bottom-style: solid;
            background-color: inherit;
        }

        tr.separator-bottom {
            visibility: hidden;
            background-color: inherit;
        }

        .input-label {
            text-align: right;
            vertical-align: top;
            padding: 6px;
            width: 160px;
        }

        .input-area {
            width: 80%;
            display: inline-table;
            vertical-align: middle;
        }

        label.col-input {
            padding-right: 0;
            margin-right: -10px;
            margin-left: 10px;
            white-space: nowrap;
        }

        tr.top-border {
            border-top-width: 2px;
            border-top-style: solid;
        }

        div.error-margin {
            padding-bottom: 10px;
        }

        .form-group {
            padding-top: 5px;
        }

        .top-padding {
            padding-top: 5px;
        }

        .top-margin {
            margin-top: 5px;
        }

        .bottom-margin {
            margin-bottom: 5px;
        }

        .connection-status {
            background-color: black;
            padding: 10px;
            margin: 0;
            overflow: auto;
        }

        .glyphicon-interpret-type {
            color: darkgrey;
            vertical-align: middle;
            font-size: 15pt;
            margin-right: -5px;
            margin-left: -5px;
        }

        .glyphicon-interpret-result {
            color: darkgrey;
            vertical-align: middle;
            font-size: 17pt;
        }

        .glyphicon-delete-sequence {
            vertical-align: text-top;
            color: red;
            font-size: larger;
        }

        .glyphicon-action-button {
            color: #606060;
            vertical-align: text-top;
        }

        /* Collapsable button style */
        .btn-collapsable.btn {
            color: #606060;
            font-family: "Glyphicons Halflings";
            font-size: 8pt;
            position: relative;
            top: 0;
            right: -10px;
            padding: 0 2px 2px 2px;
            height: 18px;
            float: right !important;
        }

        /* Collapsable button icon when content is shown - arrow down */
        .btn-collapsable.btn:after {
            content: "\e114";
        }

        /* Collapsable button icon when content is hidden - arrow right */
        .btn-collapsable.btn.collapsed:after {
            content: "\e080";
        }

        #templateType:focus {
            border-color: #66afe9;
        }

        @@media screen {
            .page-logo {
                margin-bottom: 2px;
                margin-top: -38px;
            }

            .offset-width {
                width: 10px
            }
        }

        @@media screen and (min-width: 638px) {
            .page-logo {
                margin-bottom: 2px;
                margin-top: -12px;
            }

            .offset-width {
                width: 10px
            }
        }

        @@media screen and (min-width: 868px) {
            .page-logo {
                margin-bottom: 2px;
                margin-top: -12px;
            }

            .offset-width {
                width: 10px
            }
        }

        @@media screen and (min-width: 992px) {
            .page-logo {
                margin-bottom: -25px;
                margin-top: -4px;
            }

            .offset-width {
                width: 150px
            }
        }
    </style>
}
@functions {
    private static Dictionary<string, object> s_appModelGlobal;
    private static Guid s_nodeID;
    private static string s_companyAcronym;
    private static double s_defaultCalculationLagTime;
    private static double s_defaultCalculationLeadTime;
    private static int s_nominalFrequency;
    private static string s_systemName;

    // Quasi-Static Properties
    private Dictionary<string, object> AppModelGlobal
    {
        get
        {
            if (s_appModelGlobal != null)
                return s_appModelGlobal;

            s_appModelGlobal = new Dictionary<string, object>();
            ExpressionEvaluator.ValueType global = ValueExpressionParser.DefaultTypeRegistry["Global"] as ExpressionEvaluator.ValueType;

            if (global == null)
                return s_appModelGlobal;

            foreach (PropertyDescriptor propertyDescriptor in TypeDescriptor.GetProperties(global.Value))
            {
                s_appModelGlobal.Add(propertyDescriptor.Name, propertyDescriptor.GetValue(global.Value));
            }

            return s_appModelGlobal;
        }
    }

    private Guid NodeID
    {
        get
        {
            return s_nodeID != default(Guid) ? s_nodeID : s_nodeID = (Guid)AppModelGlobal["NodeID"];
        }
    }

    private string CompanyAcronym
    {
        get
        {
            return !string.IsNullOrWhiteSpace(s_companyAcronym) ? s_companyAcronym : s_companyAcronym = (string)AppModelGlobal["CompanyAcronym"];
        }
    }

    private double DefaultCalculationLagTime
    {
        get
        {
            return s_defaultCalculationLagTime != default(double) ? s_defaultCalculationLagTime : s_defaultCalculationLagTime = (double)AppModelGlobal["DefaultCalculationLagTime"];
        }
    }

    private double DefaultCalculationLeadTime
    {
        get
        {
            return s_defaultCalculationLeadTime != default(double) ? s_defaultCalculationLeadTime : s_defaultCalculationLeadTime = (double)AppModelGlobal["DefaultCalculationLeadTime"];
        }
    }

    private int NominalFrequency
    {
        get
        {
            return s_nominalFrequency != default(int) ? s_nominalFrequency : s_nominalFrequency = (int)AppModelGlobal["NominalFrequency"];
        }
    }

    private string SystemName
    {
        get
        {
            if (s_systemName == default(string))
            {
                object value;

                if (AppModelGlobal.TryGetValue("SystemName", out value))
                {
                    s_systemName = (string)value;

                    if (s_systemName != null)
                        s_systemName = Regex.Replace(s_systemName.Trim().ToUpperInvariant(), @"[^A-Z0-9\-!_\.@#\$]+", "_", RegexOptions.Compiled);

                    if (!string.IsNullOrWhiteSpace(s_systemName))
                        s_systemName = s_systemName + "!";
                }

                if (s_systemName == null)
                    s_systemName = "";
            }

            return s_systemName;
        }
    }

    private string GetCurrentUserID()
    {
        if (Thread.CurrentPrincipal.Identity == null)
            return UserInfo.CurrentUserID;

        return Thread.CurrentPrincipal.Identity.Name;
    }

    // This function simply limits access to UI elements that the user does not have access to, server-side
    // functions will further validate user rights even if UI restriction was somehow bypassed
    private bool UserIsEditor()
    {
        SecurityPrincipal securityPrincipal = ViewBag.SecurityPrincipal as SecurityPrincipal;

        if (securityPrincipal == null)
            return false;

        return securityPrincipal.IsInRole("Administrator") || securityPrincipal.IsInRole("Editor");
    }
}
@section Scripts {
    <script src="@Resources.Root/Shared/Scripts/knockout.js"></script>
    <script src="@Resources.Root/Shared/Scripts/knockout.mapping.js"></script>
    <script src="@Resources.Root/Shared/Scripts/knockout.validation.js"></script>
    <script src="@Resources.Root/Shared/Scripts/knockout.reactor.js"></script>
    <script src="@Resources.Root/Shared/Scripts/gsf.web.knockout.js"></script>
    <script src="@Resources.Root/Shared/Scripts/select2.js"></script>
    <script src="@Resources.Root/Shared/Scripts/knockout-select2.js"></script>
    <script>
        "use strict";

        var phasorHub, phasorHubClient;
        var firstConnect = true;
        var deviceID = @deviceID;
        var nodeID = "@NodeID";
        var viewModel = null;
        var deviceSignalTypes = [];
        var phasorSignalTypes = [];
        var freqDeviceName = "@(SystemName)SYSTEM!FREQ";

        function showLoadingLabel() {
            $("#loadingDataLabel").css("visibility", "visible");
            viewModel.working(true);
        }

        function hideLoadingLabel() {
            viewModel.working(false);
            setTimeout(function () { $("#loadingDataLabel").css("visibility", "hidden"); }, 500);
        }

        @{ /* Make sure any updates to phase guessing is synchronized with "InputWizardDevices.cs" in the "GSF.PhasorProtocol.UI.WPF" assembly */ }
        function phaseMatchExact(phaseLabel, phaseMatches) {
            for (let i = 0; i < phaseMatches.length; i++) {
                if (phaseLabel === phaseMatches[i])
                    return true;
            }

            return false;
        }

        function phaseEndsWith(phaseLabel, phaseMatches, ignoreCase) {
            if (ignoreCase)
                phaseLabel = phaseLabel.toUpperCase();

            for (let i = 0; i < phaseMatches.length; i++) {
                let phaseMatch = phaseMatches[i];

                if (ignoreCase)
                    phaseMatch = phaseMatch.toUpperCase();

                if (phaseLabel.endsWith(phaseMatch))
                    return true;
            }

            return false;
        }

        function phaseStartsWith(phaseLabel, phaseMatches, ignoreCase) {
            if (ignoreCase)
                phaseLabel = phaseLabel.toUpperCase();

            for (let i = 0; i < phaseMatches.length; i++) {
                let phaseMatch = phaseMatches[i];

                if (ignoreCase)
                    phaseMatch = phaseMatch.toUpperCase();

                if (phaseLabel.startsWith(phaseMatch))
                    return true;
            }

            return false;
        }

        function phaseContains(phaseLabel, phaseMatches, ignoreCase) {
            if (ignoreCase)
                phaseLabel = phaseLabel.toUpperCase();

            for (let i = 0; i < phaseMatches.length; i++) {
                let phaseMatch = phaseMatches[i];

                if (ignoreCase)
                    phaseMatch = phaseMatch.toUpperCase();

                if (phaseLabel.indexOf(phaseMatch) > -1)
                    return true;
            }

            return false;
        }

        function phaseMatchHighConfidence(phaseLabel, containsMatches, endsWithMatches) {
            if (phaseEndsWith(phaseLabel, containsMatches, true))
                return true;

            if (phaseStartsWith(phaseLabel, containsMatches, true))
                return true;

            const matches = containsMatches.concat(endsWithMatches);

            for (let i = 0; i < matches.length; i++) {
                const match = matches[i];
                const variations = [ " " + match, "_" + match, "-" + match, "." + match ];

                if (phaseEndsWith(phaseLabel, variations, false))
                    return true;
            }

            for (let i = 0; i < containsMatches.length; i++) {
                const match = containsMatches[i];
                const variations = [ " " + match + " ", "_" + match + "_", "-" + match + "-", "-" + match + "_", "_" + match + "-", "." + match + "." ];

                if (phaseContains(phaseLabel, variations, false))
                    return true;
            }

            return false;
        }

        function phaseMatchLowConfidence(phaseLabel, phaseMatches) {
            for (let i = 0; i < phaseMatches.length; i++) {
                const match = phaseMatches[i];
                const variations = [ " " + match, match + " ", "_" + match, match + "_", "_" + match + "_", "-" + match, match + "-", "-" + match + "-", "-" + match + "_", "_" + match + "-", "." + match, match + ".", "." + match + "." ];

                if (phaseContains(phaseLabel, variations, true))
                    return true;
            }

            return false;
        }

        function guessPhase(phasorDefinition, phasorLabel) {
            const phase = phasorDefinition.Phase;

            // If user has already manually updated phase, do not "re-guess"
            const updatedOn = new Date(phasorDefinition.UpdatedOn);
            const createdOn = new Date(phasorDefinition.CreatedOn);

            if (updatedOn > createdOn)
                return phase;

            if (!isEmpty(phase) && phase !== "+" && !phase.endsWith("?"))
                return phase;

            // Handle high confidence phase matches when no phase is defined or when phase is "+" - since positive sequence is often default value, it's treated with suspicion
            if (isEmpty(phase) || phase === "+") {
                if (phaseMatchExact(phasorLabel, [ "V1PM", "I1PM" ]) || phaseMatchHighConfidence(phasorLabel, [ "V1", "VP", "I1", "IP", "VSEQ1", "ISEQ1" ], [ "POS", "V1PM", "I1PM", "PS", "PSV", "PSI" ]) || phaseEndsWith(phasorLabel, [ "+SV", "+SI", "+V", "+I" ], true))
                    return "+";

                if (phaseMatchExact(phasorLabel, [ "V0PM", "I0PM", "VZPM", "IZPM" ]) || phaseMatchHighConfidence(phasorLabel, [ "V0", "I0", "VSEQ0", "ISEQ0" ], [ "ZERO", "ZPV", "ZPI", "VSPM", "V0PM", "I0PM", "VZPM", "IZPM", "ZS", "ZSV", "ZSI" ]) || phaseEndsWith(phasorLabel, [ "0SV", "0SI" ], true))
                    return "0";

                if (phaseMatchExact(phasorLabel, [ "VAPM", "IAPM" ]) || phaseMatchHighConfidence(phasorLabel, [ "VA", "IA" ], [ "APV", "API", "VAPM", "IAPM", "AV", "AI" ]))
                    return "A";

                if (phaseMatchExact(phasorLabel, [ "VBPM", "IBPM" ]) || phaseMatchHighConfidence(phasorLabel, [ "VB", "IB" ], [ "BPV", "BPI", "VBPM", "IBPM", "BV", "BI" ]))
                    return "B";

                if (phaseMatchExact(phasorLabel, [ "VCPM", "ICPM" ]) || phaseMatchHighConfidence(phasorLabel, [ "VC", "IC" ], [ "CPV", "CPI", "VCPM", "ICPM", "CV", "CI" ]))
                    return "C";

                if (phaseMatchExact(phasorLabel, [ "VNPM", "INPM" ]) || phaseMatchHighConfidence(phasorLabel, [ "VN", "IN" ], [ "NEUT", "NPV", "NPI", "VNPM", "INPM", "NV", "NI" ]))
                    return "N";

                if (phaseMatchExact(phasorLabel, [ "V2PM", "I2PM" ]) || phaseMatchHighConfidence(phasorLabel, [ "V2", "I2", "VSEQ2", "ISEQ2" ], [ "NEG", "-SV", "-SI", "V2PM", "I2PM", "NS", "NSV", "NSI" ]))
                    return "-";
            }

            // Handle lower confidence phase matches only when phase is not defined
            if (isEmpty(phase)) {
                // Since positive sequence is the default and always treated with accuracy suspicion, verify it's value first
                if (phaseMatchLowConfidence(phasorLabel, [ "V1", "VP", "I1", "IP", "POS", "V1PM", "I1PM", "PS", "PSV", "PSI", "+SV", "+SI", "+V", "+I" ]))
                    return "+?";

                if (phaseMatchLowConfidence(phasorLabel, [ "V0", "I0", "ZERO", "ZPV", "ZPI", "VSPM", "VZPM", "IZPM", "ZS", "ZSV", "ZSI", "0SV", "0SI" ]))
                    return "0?";

                if (phaseMatchLowConfidence(phasorLabel, [ "VA", "IA", "APV", "API", "VAPM", "IAPM", "AV", "AI" ]))
                    return "A?";

                if (phaseMatchLowConfidence(phasorLabel, [ "VB", "IB", "BPV", "BPI", "VBPM", "IBPM", "BV", "BI" ]))
                    return "B?";

                if (phaseMatchLowConfidence(phasorLabel, [ "VC", "IC", "CPV", "CPI", "VCPM", "ICPM", "CV", "CI" ]))
                    return "C?";

                if (phaseMatchLowConfidence(phasorLabel, [ "VN", "IN", "NEUT", "NPV", "NPI", "VNPM", "INPM", "NV", "NI" ]))
                    return "N?";

                if (phaseMatchLowConfidence(phasorLabel, [ "V2", "I2", "NEG", "-SV", "-SI", "V2PM", "I2PM", "NS", "NSV", "NSI" ]))
                    return "-?";

                // Test for contains after checks with separators
                if (phaseContains(phasorLabel, ["V1", "I1", "POS", "V1PM", "I1PM", "PS", "PSV", "PSI", "+SV", "+SI", "+V", "+I"], true))
                    return "+?";

                if (phaseContains(phasorLabel, ["V0", "I0", "ZERO", "ZPV", "ZPI", "VSPM", "VZPM", "IZPM", "ZS", "ZSV", "ZSI", "0SV", "0SI"], true))
                    return "0?";

                if (phaseContains(phasorLabel, ["VA", "IA", "APV", "API", "VAPM", "IAPM", "AV", "AI"], true))
                    return "A?";

                if (phaseContains(phasorLabel, ["VB", "IB", "BPV", "BPI", "VBPM", "IBPM", "BV", "BI"], true))
                    return "B?";

                if (phaseContains(phasorLabel, [ "VC", "IC", "CPV", "CPI", "VCPM", "ICPM", "CV", "CI" ], true))
                    return "C?";

                if (phaseContains(phasorLabel, ["VN", "IN", "NEUT", "NPV", "NPI", "VNPM", "INPM", "NV", "NI"], true))
                    return "N?";

                if (phaseContains(phasorLabel, ["V2", "I2", "NEG", "-SV", "-SI", "V2PM", "I2PM", "NS", "NSV", "NSI"], true))
                    return "-?";

                // -V and -I may match too often, so check these last
                if (phaseMatchLowConfidence(phasorLabel, ["-V", "-I"]) || phaseContains(phasorLabel, ["-V", "-I"], true))
                    return "-?";

                return "+?";
            }

            return phase;
        }

        function guessNominalVoltage(nominalVoltage, phasorLabel, deviceLabel) {
            if (!isEmpty(nominalVoltage) && nominalVoltage !== 0)
                return nominalVoltage;

            const commonVoltageLevels = [ "44", "69", "115", "138", "161", "169", "230", "345", "500", "765", "1100" ];

            // Check phasor label before device
            for (let i = 0; i < commonVoltageLevels.length; i++) {
                const voltageLevel = commonVoltageLevels[i];

                if (phasorLabel.indexOf(voltageLevel) > -1)
                    return parseInt(voltageLevel);
            }

            for (let i = 0; i < commonVoltageLevels.length; i++) {
                const voltageLevel = commonVoltageLevels[i];

                if (deviceLabel.indexOf(voltageLevel) > -1)
                    return parseInt(voltageLevel);
            }

            return 500;
        }

        function guessAssociatedVoltage(current) {
            const voltages = current.DeviceVoltages();
            const phasorLabel = current.Label().toUpperCase();
            let phase = current.Phase();

            if (phase === "+")
                phase = "1";
            else if (phase === "-")
                phase = "2";

            let search = "V" + phase;
            let replace = "I" + phase;

            for (let i = 0; i < voltages.length; i++) {
                if (phasorLabel === voltages[i].Label().toUpperCase().replace(search, replace))
                    return voltages[i].ID;
            }

            search = "POT";
            replace = "CURR";

            for (let i = 0; i < voltages.length; i++) {
                if (phasorLabel === voltages[i].Label().toUpperCase().replace(search, replace))
                    return voltages[i].ID;
            }

            let aCount = 0, aID = -1;
            let bCount = 0, bID = -1;
            let cCount = 0, cID = -1;
            let posCount = 0, posID = -1;
            let negCount = 0, negID = -1;
            let zCount = 0, zID = -1;
            let nCount = 0, nID = -1;
            let otherCount = 0;

            for (let i = 0; i < voltages.length; i++) {
                const voltageID = voltages[i].ID;

                switch (voltages[i].Phase().toUpperCase()) {
                    case "A":
                        aCount++;
                        aID = voltageID;
                        break;
                    case "B":
                        bCount++;
                        bID = voltageID;
                        break;
                    case "C":
                        cCount++;
                        cID = voltageID;
                        break;
                    case "+":
                        posCount++;
                        posID = voltageID;
                        break;
                    case "-":
                        negCount++;
                        negID = voltageID;
                        break;
                    case "0":
                        zCount++;
                        zID = voltageID;
                        break;
                    case "N":
                        nCount++;
                        nID = voltageID;
                        break;
                    default:
                        otherCount++;
                        break;
                }
            }

            if (otherCount === 0) {
                switch (phase) {
                    case "A":
                        if (aCount === 1)
                            return aID;
                        break;
                    case "B":
                        if (bCount === 1)
                            return bID;
                        break;
                    case "C":
                        if (cCount === 1)
                            return cID;
                        break;
                    case "1":
                        if (posCount === 1)
                            return posID;
                        break;
                    case "2":
                        if (negCount === 1)
                            return negID;
                        break;
                    case "0":
                        if (zCount === 1)
                            return zID;
                        break;
                    case "N":
                        if (nCount === 1)
                            return nID;
                        break;
                }
            }

            return -1;
        }

        function updateTagName(evaluator, owner) {
            const result = ko.observable();

            ko.computed(function () {
                evaluator.call(owner).done(function (tagName) {
                    if (!isEmpty(tagName)) {
                        if (tagName.length > 4)
                            result(tagName.substring(0, tagName.length - 4) + " (:MAG/:ANG)");
                        else
                            result(tagName);
                    }
                    else {
                        result(tagName);
                    }
                });
            });

            return result;
        }

        function associatedVoltageLabel(voltage) {
            if (isEmpty(voltage.Label()) || voltage.Label() === voltage.OriginalLabel)
                return voltage.Label();

            return voltage.Label() + "~" + voltage.OriginalLabel;
        }

        function formatAssociatedVoltageLabel(state) {
            const parts = state.text.split("~");
            const label = parts[0];
            const orgLabel = parts.length > 1 ? parts[1] : undefined;

            if (isEmpty(orgLabel) || label === orgLabel) {
                const $state = $("<span>" + state.text + "</span>");
                return $state;
            }

            const $state = $("<span>" + label + " <span class='sub-text'>(" + orgLabel + ")</span></span>");
            return $state;
        }

        function saveDeviceConfiguration(acronym, configuration) {
            return $.ajax({
                url: "/api/PhasorConfig/SaveDeviceConfiguration/" + acronym,
                method: "POST",
                contentType: "application/json; charset=utf-8",
                data: configuration,
                dataType: "json"
            });
        }

        function loadDeviceConfiguration(acronym) {
            return $.ajax({
                url: "/api/PhasorConfig/LoadDeviceConfiguration/" + acronym,
                method: "GET",
                contentType: "application/json; charset=utf-8"
            });
        }

        function DeviceViewModel() {
            const self = this;
            const defaultDeviceAcronym = "DEVICEACRONYM";

            // Observable fields
            self.voltages = ko.observableArray();
            self.currents = ko.observableArray();
            self.configFrame = ko.observable({ConnectionString: "", Cells: []});
            self.configFrameDetails = ko.observable("Calculating...");
            self.configExported = ko.observable(false);
            self.addAnalogs = ko.observable(false);
            self.addDigitals = ko.observable(false);
            self.readOnly = ko.observable(false);
            self.errors = ko.validation.group(self);
            self.working = ko.observable(false);

            // Internal fields
            self._connectionString = ko.observable("");
            self._addTagsAsVirtualPoints = ko.observable(undefined);
            self._deviceAcronym = ko.observable(defaultDeviceAcronym);
            self._deviceName = ko.observable("Device Name");
            self._longitude = ko.observable(0.0);
            self._latitude = ko.observable(0.0);
            self._instanceName = ko.observable("");
            self._templateType = ko.observable("");
            self._historianID = ko.observable(-1);
            self._phasorHubIsConnected = ko.observable(false);
            self._forwardOnly = ko.observable(false);
            self._isDirty = ko.observable(false);

            // Properties
            self.connectionString = ko.pureComputed({
                read: self._connectionString,
                write: function (value) {
                    const settings = value.parseKeyValuePairs();
                    settings.set("forwardOnly", self.forwardOnly());
                    self._connectionString(settings.joinKeyValuePairs());
                    self.configFrame().ConnectionString = self._connectionString();
                },
                owner: self
            });

            self.addTagsAsVirtualPoints = ko.pureComputed({
                read: function () {
                    if (self._addTagsAsVirtualPoints() === undefined)
                        self._addTagsAsVirtualPoints(Cookies.get("addTagsAsVirtualPoints") === "true");

                    return self._addTagsAsVirtualPoints();
                },
                write: function (value) {
                    if (value === self._addTagsAsVirtualPoints())
                        return;

                    self._addTagsAsVirtualPoints(value);
                    Cookies.set("addTagsAsVirtualPoints", value.toString(), { expires: 365 });
                },
                owner: self
            });

            self.deviceAcronym = ko.pureComputed({
                read: self._deviceAcronym,
                write: function (value) {
                    if (value === self._deviceAcronym())
                        return;

                    if (value) {
                        value = value.trim();
                        self._deviceAcronym(value);
                    }
                    else {
                        self._deviceAcronym(value);
                    }
                },
                owner: self
            });

            self.deviceName = ko.pureComputed({
                read: self._deviceName,
                write: function (value) {
                    if (value === self._deviceName())
                        return;

                    if (value) {
                        value = value.trim();
                        self._deviceName(value);
                    }
                    else {
                        self._deviceName(value);
                    }
                },
                owner: self
            });

            self.longitude = ko.pureComputed({
                read: self._longitude,
                write: function (value) {
                    if (value === self._longitude())
                        return;

                    if (isNumber(value))
                        self._longitude(parseFloat(value));
                    else
                        self._longitude(0.0);
                },
                owner: self
            });

            self.latitude = ko.pureComputed({
                read: self._latitude,
                write: function (value) {
                    if (value === self._latitude())
                        return;

                    if (isNumber(value))
                        self._latitude(parseFloat(value));
                    else
                        self._latitude(0.0);
                },
                owner: self
            });

            self.instanceName = ko.pureComputed({
                read: self._instanceName,
                write: function (value) {
                    if (value === self._instanceName())
                        return;

                    if (value) {
                        self._instanceName(value);
                        Cookies.set("instanceName", value.toString(), { expires: 365 });
                    } else {
                        self._instanceName("");
                    }

                    if (self.phasorHubIsConnected()) {
                        if (isEmpty(self._instanceName())) {
                            self._historianID(-1);
                        }
                        else {
                            dataHub.queryHistorian(self.instanceName()).done(function (historian) {
                                if (historian)
                                    self._historianID(historian.ID);
                                else
                                    self._historianID(-1);
                            });
                        }
                    }
                },
                owner: self
            });

            self.templateType = ko.pureComputed({
                read: self._templateType,
                write: function (value) {
                    if (value === self._templateType())
                        return;

                    if (value) {
                        self._templateType(value);
                        Cookies.set("templateType", value.toString(), { expires: 365 });
                    } else {
                        self._templateType("");
                    }
                },
                owner: self
            });

            self.historianID = ko.pureComputed({
                read: function () {
                    const historianID = self._historianID();

                    if (historianID === -1)
                        return null;

                    return historianID;
                },
                owner: self
            });

            self.phasorHubIsConnected = ko.pureComputed({
                read: self._phasorHubIsConnected,
                write: function (value) {
                    if (value === undefined)
                        value = false;

                    self._phasorHubIsConnected(value);

                    if (value)
                        self.refreshValidationErrors();
                },
                owner: self
            });

            self.forwardOnly = ko.pureComputed({
                read: self._forwardOnly,
                write: function (value) {
                    if (value === undefined)
                        value = false;

                    if (value !== self._forwardOnly()) {
                        self._forwardOnly(value);

                        self.voltages().forEach(function (voltage) {
                            voltage.Enabled(!value);
                        });

                        self.currents().forEach(function (current) {
                            current.Enabled(!value);
                        });

                        if (value) {
                            self.addAnalogs(false);
                            self.addDigitals(false);
                        }
                        else {
                            var analogCount = 0;
                            var digitalCount = 0;

                            self.configFrame().Cells.forEach(function (cell) {
                                analogCount += cell.AnalogDefinitions.length;
                                digitalCount += cell.DigitalDefinitions.length;
                            });

                            self.addAnalogs(analogCount > 0);
                            self.addDigitals(digitalCount > 0);
                        }

                        // Force update of connection string to reflect new setting
                        self.connectionString(self.connectionString());
                    }
                },
                owner: self
            });

            self.isDirty = ko.pureComputed({
                read: self._isDirty,
                write: function (value) {
                    if (value === undefined)
                        value = true;

                    self._isDirty(value);

                    if (value)
                        self.configExported(false);
                },
                owner: self
            });

            // Methods

            self.updateConfigFrameDetails = function () {
                var voltageCount = 0;
                var currentCount = 0;
                var analogCount = 0;
                var digitalCount = 0;

                const cells = self.configFrame().Cells;
                const cellCount = cells.length;

                for (let i = 0; i < cellCount; i++) {
                    const cell = cells[i];

                    for (let j = 0; j < cell.PhasorDefinitions.length; j++) {
                        const phasorDefinition = cell.PhasorDefinitions[j];

                        if (phasorDefinition.PhasorType.toLowerCase() === "voltage")
                            voltageCount++;
                        else
                            currentCount++;
                    }

                    analogCount += cell.AnalogDefinitions.length;
                    digitalCount += cell.DigitalDefinitions.length;
                }

                self.configFrameDetails(String.format("Device Count {0} &ndash; {1} Voltage Phasors, {2} Current Phasors, {3} Analogs, {4} Digitals",
                    cellCount,
                    voltageCount,
                    currentCount,
                    analogCount,
                    digitalCount));

                self.addAnalogs(analogCount > 0 && !self.forwardOnly());
                self.addDigitals(digitalCount > 0 && !self.forwardOnly());
            };

            self.loadConfigFrame = function (configFrame, skipGuessing) {
                if (skipGuessing === undefined)
                    skipGuessing = false;

                if ((configFrame.ConnectionString + "").length > 0)
                    self.connectionString(configFrame.ConnectionString + "");

                const currentConnectionString = self.connectionString();
                self.configFrame(configFrame);
                self.connectionString(currentConnectionString);

                self.voltageCount = 0;

                if (configFrame.ProtocolID > 0) {
                    phasorHub.getProtocolCategory(configFrame.ProtocolID).done(function (category) {
                        self.readOnly(category.toLowerCase() === "gateway");
                    });
                }

                // Sort devices
                self.configFrame().Cells.sort(function (left, right) {
                    const leftLabel = String(left.IDLabel).trim().toUpperCase();
                    const rightLabel = String(right.IDLabel).trim().toUpperCase();

                    if (leftLabel < rightLabel)
                        return -1;

                    if (leftLabel > rightLabel)
                        return 1;

                    return 0;
                });

                if (isEmpty(self.deviceAcronym()) || self.deviceAcronym() === defaultDeviceAcronym) {
                    let deviceAcronym = configFrame.IDLabel;

                    if (isEmpty(deviceAcronym) && !isEmpty(configFrame.StationName))
                        deviceAcronym = getCleanAcronym(configFrame.StationName.toUpperCase().replaceAll(" ", "_"));
                    else
                        deviceAcronym = defaultDeviceAcronym;

                    self.deviceAcronym(deviceAcronym);
                }

                if (!isEmpty(configFrame.StationName))
                    self.deviceName(configFrame.StationName);
                else
                    self.deviceName("Device Name");

                const deviceCount = self.configFrame().Cells.length;

                // Sort device phasor definitions by voltage, current then label
                for (let i = 0; i < deviceCount; i++) {
                    const cell = self.configFrame().Cells[i];

                    cell.PhasorDefinitions.sort(function (left, right) {
                        const leftIsVoltage = left.PhasorType.toLowerCase() === "voltage";
                        const rightIsVoltage = right.PhasorType.toLowerCase() === "voltage";

                        if (leftIsVoltage && !rightIsVoltage)
                            return -1;

                        if (!leftIsVoltage && rightIsVoltage)
                            return 1;

                        const leftLabel = String(left.Label).trim().toUpperCase();
                        const rightLabel = String(right.Label).trim().toUpperCase();

                        if (leftLabel < rightLabel)
                            return -1;

                        if (leftLabel > rightLabel)
                            return 1;

                        return 0;
                    });
                }

                for (let i = 0; i < deviceCount; i++) {
                    const cell = self.configFrame().Cells[i];

                    // TODO: Update screen to accommodate lat/long at the device level
                    if (!isEmpty(cell.Latitude))
                        self.latitude(cell.Latitude);

                    if (!isEmpty(cell.Longitude))
                        self.longitude(cell.Longitude);

                    let cellAcronym = cell.IDLabel;

                    if (isEmpty(cellAcronym))
                        cellAcronym = getCleanAcronym(cell.StationName.toUpperCase().replaceAll(" ", "_"));

                    if (deviceCount === 1) {
                        self.deviceAcronym(cellAcronym);
                        self.deviceName(cell.StationName);
                        cell.IDLabel = self.deviceAcronym;
                    } else {
                        cell.IDLabel = ko.observable(cellAcronym);
                    }

                    cell.IDLabel.extend({
                        required: true,
                        pattern: {
                            message: "@Raw(AcronymValidationAttribute.DefaultErrorMessage)",
                            params: "@Raw(AcronymValidationAttribute.ValidationPattern.JavaScriptEncode())"
                        },
                        deviceUniqueInDatabase: cell.ID
                    });

                    cell.Acronym = cellAcronym;

                    cell.OriginalAcronym = ko.pureComputed({
                        read: function () {
                            return deviceID > 0 ? cell.Acronym : cell.IDLabel();
                        },
                        owner: cell
                    });

                    let firstVoltage = true;
                    let firstCurrent = true;

                    for (let j = 0; j < cell.PhasorDefinitions.length; j++) {
                        const phasorDefinition = cell.PhasorDefinitions[j];

                        phasorDefinition.Label = String(phasorDefinition.Label).toUpperCase();

                        if (phasorDefinition.PhasorType.toLowerCase() === "voltage") {
                            self.voltages.push(self.createObservableVoltage(cell, phasorDefinition, firstVoltage, skipGuessing));
                            firstVoltage = false;
                        } else {
                            self.currents.push(self.createObservableCurrent(cell, phasorDefinition, firstCurrent, skipGuessing));
                            firstCurrent = false;
                        }
                    }

                    cell.serializeCell = function () {
                        var phasorDefinitions = [];

                        cell.PhasorDefinitions.forEach(function (phasorDefinition) {
                            const isVoltage = phasorDefinition.PhasorType.toLowerCase() === "voltage";

                            phasorDefinitions.push({
                                ID: phasorDefinition.ID,
                                Label: phasorDefinition.Label(),
                                PhasorType: phasorDefinition.PhasorType,
                                Phase: phasorDefinition.Phase(),
                                DestinationPhasorID: isVoltage ? phasorDefinition.DestinationPhasorID : phasorDefinition.Current.AssociatedVoltage(),
                                NominalVoltage: isVoltage ? phasorDefinition.Voltage.NominalVoltage() : phasorDefinition.Current.AssociatedNominalVoltage(),
                                SourceIndex: phasorDefinition.SourceIndex,
                                TaggedForDelete: phasorDefinition.TaggedForDelete()
                            });
                        });

                        return {
                            ID: cell.ID,
                            ParentID: cell.ParentID,
                            UniqueID: cell.UniqueID,
                            Longitude: cell.Longitude,
                            Latitude: cell.Latitude,
                            IDCode: cell.IDCode,
                            StationName: self.configFrame().Cells.length === 1 ? self.deviceName() : cell.IDLabel(),
                            IDLabel: cell.IDLabel(),
                            FrequencyDefinition: cell.FrequencyDefinition,
                            PhasorDefinitions: phasorDefinitions,
                            AnalogDefinitions: cell.AnalogDefinitions,
                            DigitalDefinitions: cell.DigitalDefinitions
                        };
                    };
                }

                self.resortPhasors();

                // Make sure table is refreshed
                if (ko.options.deferUpdates)
                    ko.tasks.runEarly();

                self.errors = ko.validation.group([
                    self.deviceAcronym,
                    self.voltages,
                    self.currents
                ]);

                self.refreshValidationErrors();

                $("[id=voltageRow]").css("visibility", "visible");
                $("[id=currentRow]").css("visibility", "visible");

                self.updateConfigFrameDetails();
                self.isDirty(false);

                if (deviceCount === 1) {
                    $("#voltagesSection").addClass("col-md-6");
                    $("#currentsSection").addClass("col-md-6");
                } else {
                    $("#voltagesSection").removeClass("col-md-6");
                    $("#currentsSection").removeClass("col-md-6");
                }

                $("#connectionSettings").collapse("hide");
                hideLoadingLabel();
            };

            self.loadExisting = function () {
                if (!self.phasorHubIsConnected())
                    return;

                self.voltages.removeAll();
                self.currents.removeAll();

                $("#responsiveTableDiv").show();
                $("[id=voltageRow]").css("visibility", "hidden");
                $("[id=currentRow]").css("visibility", "hidden");
                $("#bulkSelectionButtons").hide();
                showLoadingLabel();

                self.configFrameDetails("Analyzing...");

                phasorHub.extractConfigurationFrame(deviceID).done(self.loadConfigFrame).fail(function (error) {
                    showErrorMessage(String.format("Failed to extract config file from existing device: {0}", error), null, true);

                    self.configFrameDetails("Unavailable");
                    $("[id=voltageRow]").css("visibility", "visible");
                    $("[id=currentRow]").css("visibility", "visible");
                    hideLoadingLabel();
                });
            };

            self.analyzeConfig = function (sourceData) {
                if (!self.phasorHubIsConnected())
                    return;

                self.voltages.removeAll();
                self.currents.removeAll();

                $("#responsiveTableDiv").show();
                $("[id=voltageRow]").css("visibility", "hidden");
                $("[id=currentRow]").css("visibility", "hidden");
                $("#bulkSelectionButtons").hide();
                showLoadingLabel();

                self.configFrameDetails("Analyzing...");

                // If device is currently active, disconnect it before requesting a configuration
                // frame in case device doesn't support multiple connections
                if (deviceID > 0)
                    serviceHub.sendCommand("disconnect " + deviceID);

                phasorHub.loadConfigurationFrame(sourceData).done(self.loadConfigFrame).then(function () {
                    // Reconnect device
                    if (deviceID > 0)
                        serviceHub.sendCommand("connect " + deviceID);
                })
                .fail(function (error) {
                    showErrorMessage(String.format("Failed to analyze config file: {0}", error), null, true);

                    self.configFrameDetails("Unavailable");
                    $("[id=voltageRow]").css("visibility", "visible");
                    $("[id=currentRow]").css("visibility", "visible");
                    hideLoadingLabel();
                });
            };

            self.refreshValidationErrors = function () {
                // Make sure any initial validation error messages are visible
                self.errors.showAllMessages();
            };

            self.resortPhasors = function () {
                const voltages = self.voltages();
                const currents = self.currents();

                function sortPhasors(phasors) {
                    phasors.sort(function (left, right) {
                        // Sort by IDLabel first - in case there are multiple devices
                        const leftIDLabel = String(left.Device.IDLabel()).trim().toUpperCase();
                        const rightIDLabel = String(right.Device.IDLabel()).trim().toUpperCase();

                        if (leftIDLabel < rightIDLabel)
                            return -1;

                        if (leftIDLabel > rightIDLabel)
                            return 1;

                        // Sort next by enabled flag such that disabled devices drop to bottom
                        if (left.Enabled() && !right.Enabled())
                            return -1;

                        if (!left.Enabled() && right.Enabled())
                            return 1;

                        // Finally sort by phasor label
                        const leftLabel = String(left.Label()).trim().toUpperCase();
                        const rightLabel = String(right.Label()).trim().toUpperCase();

                        if (leftLabel < rightLabel)
                            return -1;

                        if (leftLabel > rightLabel)
                            return 1;

                        return 0;
                    });
                }

                sortPhasors(voltages);
                sortPhasors(currents);

                self.voltages.valueHasMutated();
                self.currents.valueHasMutated();
            };

            self.createObservableVoltage = function (cell, phasorDefinition, firstVoltage, skipGuessing) {
                if (skipGuessing === undefined)
                    skipGuessing = false;

                const voltage = {};
                const phasorLabel = notNull(phasorDefinition.Label).replaceAll(" ", "_").toUpperCase();
                const nominalVoltage = skipGuessing ? phasorDefinition.NominalVoltage : guessNominalVoltage(phasorDefinition.NominalVoltage, phasorLabel, cell.IDLabel());
                const phase = skipGuessing ? phasorDefinition.Phase : guessPhase(phasorDefinition, phasorLabel);
                const vphmSignalType = getPhasorSignalType("VPHM");

                voltage._enabled = ko.observable(!self.forwardOnly() && nominalVoltage >= 0);
                voltage._taggedForDelete = ko.observable(Boolean(phasorDefinition.TaggedForDelete));

                voltage.ID = phasorDefinition.ID;
                voltage.Device = cell;
                voltage.Label = ko.observable(phasorLabel);
                voltage.OriginalLabel = phasorLabel;
                voltage.Phase = ko.observable(phase);
                voltage.NominalVoltage = ko.observable(nominalVoltage);
                voltage.FirstVoltage = firstVoltage;

                voltage.Enabled = ko.pureComputed({
                    read: voltage._enabled,
                    write: function (value) {
                        voltage._enabled(value);

                        if (value) {
                            // Un-tag for delete when enabled
                            voltage.TaggedForDelete(false);
                            voltage.NominalVoltage(Math.abs(voltage.NominalVoltage()));

                            if (voltage.NominalVoltage() === 1)
                                voltage.NominalVoltage(guessNominalVoltage(0, voltage.OriginalLabel, voltage.Device.IDLabel()));
                        }
                        else {
                            if (voltage.NominalVoltage() === 0)
                                voltage.NominalVoltage(-1);
                            else
                                voltage.NominalVoltage(Math.abs(voltage.NominalVoltage()) * -1);
                        }

                        self.resortPhasors();
                    },
                    owner: voltage
                });

                voltage.TaggedForDelete = ko.pureComputed({
                    read: voltage._taggedForDelete,
                    write: function (value) {
                        voltage._taggedForDelete(value);

                        // Uncheck enabled when tagging for deletion
                        if (value)
                            voltage.Enabled(false);
                    },
                    owner: voltage
                });

                voltage.TagName = updateTagName(function () {
                    return phasorHub.createPhasorPointTag(voltage.Device.IDLabel(), vphmSignalType.Acronym, voltage.Label(), voltage.Phase(), phasorDefinition.SourceIndex, voltage.NominalVoltage());
                }, voltage);

                voltage.Label.extend({ required: true });

                voltage.Phase.extend({
                    required: true,
                    pattern: {
                        message: "Must be one of: A, B, C, 0, +, -, N or L",
                        params: "^[A-C0+\\-NL]$"
                    }
                });

                voltage.NominalVoltage.extend({ required: true });

                phasorDefinition.Voltage = voltage;
                phasorDefinition.Label = voltage.Label;
                phasorDefinition.Phase = voltage.Phase;
                phasorDefinition.Enabled = voltage.Enabled;
                phasorDefinition.TaggedForDelete = voltage.TaggedForDelete;

                return voltage;
            };

            self.createObservableCurrent = function (cell, phasorDefinition, firstCurrent, skipGuessing) {
                if (skipGuessing === undefined)
                    skipGuessing = false;

                const current = {};
                const phasorLabel = notNull(phasorDefinition.Label).replaceAll(" ", "_").toUpperCase();
                const iphmSignalType = getPhasorSignalType("IPHM");

                current.ID = phasorDefinition.ID;
                current.Device = cell;
                current.Label = ko.observable(phasorLabel);
                current.OriginalLabel = phasorLabel;
                current.FirstCurrent = firstCurrent;

                current._associatedVoltage = ko.observable(-1);
                current._phase = ko.observable("");
                current._enabled = ko.observable(!self.forwardOnly() && phasorDefinition.NominalVoltage >= 0);
                current._taggedForDelete = ko.observable(Boolean(phasorDefinition.TaggedForDelete));

                current.AssociatedVoltage = ko.pureComputed({
                    read: function () {
                        if (current._associatedVoltage() === undefined) // Unselected KO option
                            current._associatedVoltage(-1);

                        return current._associatedVoltage();
                    },
                    write: function (value) {
                        if (value === null) // Undefined DB value
                            value = -1;

                        current._associatedVoltage(value);
                    },
                    owner: current
                });

                current.Phase = ko.pureComputed({
                    read: current._phase,
                    write: function (value) {
                        current._phase(value);

                        // Validate any pre-defined association
                        const associatedVoltage = current.AssociatedVoltage();

                        if (associatedVoltage > 0) {
                            const voltages = current.DeviceVoltages();
                            let found = false;

                            for (let j = 0; j < voltages.length; j++) {
                                const voltage = voltages[j];

                                if (voltage.ID === associatedVoltage && voltage.Phase() === current.Phase() && voltage.Enabled()) {
                                    found = true;
                                    break;
                                }
                            }

                            if (!found)
                                current.AssociatedVoltage(-1);
                        }

                        // Guess associated voltage
                        if (current.AssociatedVoltage() === -1 && !skipGuessing)
                            current.AssociatedVoltage(guessAssociatedVoltage(current));
                    },
                    owner: current
                });

                current.DeviceVoltages = ko.pureComputed({
                    read: function () {
                        const allVoltages = self.voltages();
                        const deviceVoltages = [];

                        // Match by phase first
                        for (let i = 0; i < allVoltages.length; i++) {
                            const voltage = allVoltages[i];

                            if (voltage.Device === current.Device && voltage.Phase() === current.Phase() && voltage.Enabled())
                                deviceVoltages.push(voltage);
                        }

                        if (deviceVoltages.length === 0) {
                            // If no phases match, select all for device second
                            for (let i = 0; i < allVoltages.length; i++) {
                                const voltage = allVoltages[i];

                                if (voltage.Device === current.Device && voltage.Enabled())
                                    deviceVoltages.push(voltage);
                            }
                        }

                        return deviceVoltages;
                    },
                    owner: current
                });

                current.AssociatedNominalVoltage = ko.pureComputed({
                    read: function () {
                        const voltage = lookupAssociatedVoltage(current.Device, current.AssociatedVoltage());

                        if (voltage)
                            return voltage.Voltage.NominalVoltage();

                        return 0;
                    },
                    owner: current
                });

                current.Enabled = ko.pureComputed({
                    read: current._enabled,
                    write: function (value) {
                        current._enabled(value);

                        if (value) {
                            // Re-select associated voltage when enabled
                            current.Phase(current.Phase());

                            // Un-tag for delete when enabled
                            current.TaggedForDelete(false);
                        }

                        self.resortPhasors();
                    },
                    owner: current
                });

                current.TaggedForDelete = ko.pureComputed({
                    read: current._taggedForDelete,
                    write: function (value) {
                        current._taggedForDelete(value);

                        // Uncheck enabled when tagging for deletion
                        if (value)
                            current.Enabled(false);
                    },
                    owner: current
                });

                current.TagName = updateTagName(function () {
                    return phasorHub.createPhasorPointTag(current.Device.IDLabel(), iphmSignalType.Acronym, current.Label(), current.Phase(), phasorDefinition.SourceIndex, current.AssociatedNominalVoltage());
                }, current);

                current.Label.extend({ required: true });

                current.Phase.extend({
                    required: true,
                    pattern: {
                        message: "Must be one of: A, B, C, 0, +, - or N",
                        params: "^[A-C0+\\-N]$"
                    }
                });

                // Assign any existing associated voltage
                current.AssociatedVoltage(phasorDefinition.DestinationPhasorID);

                // Guess phase, which will subsequently guess any unassociated voltage
                current.Phase(skipGuessing ? phasorDefinition.Phase : guessPhase(phasorDefinition, phasorLabel));

                phasorDefinition.Current = current;
                phasorDefinition.Label = current.Label;
                phasorDefinition.Phase = current.Phase;
                phasorDefinition.Enabled = current.Enabled;
                phasorDefinition.TaggedForDelete = current.TaggedForDelete;

                return current;
            };

            self.serializeConfiguration = function () {
                const configFrame = self.configFrame();
                const cells = configFrame.Cells;
                var serializedCells = [];

                if (cells) {
                    cells.forEach(function (cell) {
                        serializedCells.push(cell.serializeCell());
                    });
                }

                return {
                    IDCode: configFrame.IDCode,
                    StationName: self.deviceName(),
                    IDLabel: self.deviceAcronym(),
                    FrameRate: configFrame.FrameRate,
                    ConnectionString: "", //configFrame.ConnectionString,
                    ProtocolID: configFrame.ProtocolID,
                    Cells: serializedCells
                };
            };

            self.saveConfiguration = function (fileName) {
                const data = JSON.stringify(self.serializeConfiguration(), null, 2);
                const anchor = $("#saveConfigurationFileLink");

                if (typeof anchor[0].download != "undefined") {
                    anchor.attr("href", "data:text/json;charset=utf-8," + encodeURIComponent(data));
                    anchor.attr("download", fileName);
                    anchor[0].click();
                } else {
                    if (isIE)
                        window.navigator.msSaveBlob(new Blob([data]), fileName);
                    else
                        window.open("data:text/json;charset=utf-8," + encodeURIComponent(data), "_blank", "");
                }

                self.configExported(true);
            };

            self.loadConfiguration = function (fileBlob) {
                var reader = new FileReader();

                reader.onload = function () {
                    if (!self.phasorHubIsConnected())
                        return;

                    const configFrame = JSON.parse(reader.result);

                    self.voltages.removeAll();
                    self.currents.removeAll();

                    $("#responsiveTableDiv").show();
                    $("[id=voltageRow]").css("visibility", "hidden");
                    $("[id=currentRow]").css("visibility", "hidden");
                    $("#bulkSelectionButtons").hide();
                    showLoadingLabel();

                    self.configFrameDetails("Loading...");

                    self.forwardOnly(false);

                    // Do not guess any values for a directly loaded JSON configuration
                    self.loadConfigFrame(configFrame, true);
                    self.configExported(true);
                };

                reader.onloadend = function () {
                    if (reader.error && reader.error.message)
                        showErrorMessage("Failed to load configuration: " + reader.error.message, null, true);
                };

                reader.readAsText(fileBlob);
            };

            // Validations
            self.deviceAcronym.extend({
                required: true,
                pattern: {
                    message: "@Raw(AcronymValidationAttribute.DefaultErrorMessage)",
                    params: "@Raw(AcronymValidationAttribute.ValidationPattern.JavaScriptEncode())"
                },
                deviceUniqueInDatabase: deviceID
            });

            self.deviceName.extend({
                required: true
            });

            self.longitude.extend({
                required: false,
                number: true
            });

            self.latitude.extend({
                required: false,
                number: true
            });

            self.validationErrors = ko.pureComputed(function () {
                return self.errors().length;
            }).extend({
                notify: "always"
            });
        }

        function getCleanAcronym(acronym) {
            // Remove any invalid characters from acronym - @@ is Razor escaped single "at" symbol:
            return acronym.replace(/[^A-Z0-9\-!_\.@@#\$]/gi, "");
        }

        function getCleanPointTag(pointTag) {
            // Remove any invalid characters from point tag - @@ is Razor escaped single "at" symbol:
            return pointTag.replace(/[^A-Z0-9\-\+!\:_\.@@#\$]/gi, "");
        }

        function getDeviceSignalType(acronym) {
            acronym = acronym.toUpperCase();

            for (let i = 0; i < deviceSignalTypes.length; i++) {
                const deviceSignalType = deviceSignalTypes[i];

                if (deviceSignalType.Acronym.toUpperCase() === acronym)
                    return deviceSignalType;
            }

            return null;
        }

        function getPhasorSignalType(acronym) {
            acronym = acronym.toUpperCase();

            for (let i = 0; i < phasorSignalTypes.length; i++) {
                const phasorSignalType = phasorSignalTypes[i];

                if (phasorSignalType.Acronym.toUpperCase() === acronym)
                    return phasorSignalType;
            }

            return null;
        }

        function lookupAssociatedVoltage(cell, voltageID) {
            for (let i = 0; i < cell.PhasorDefinitions.length; i++) {
                const phasorDefinition = cell.PhasorDefinitions[i];

                if (phasorDefinition.PhasorType.toLowerCase() === "voltage" && phasorDefinition.Voltage.ID === voltageID)
                    return phasorDefinition;
            }

            return null;
        }

        function savePhasorMeasurement(cell, signalType, phasorDefinition, index) {
            const orgSignalReference = String.format("{0}-{1}{2}", cell.OriginalAcronym(), signalType.Suffix, index);
            const signalReference = String.format("{0}-{1}{2}", cell.IDLabel(), signalType.Suffix, index);

            // Query existing measurement record for specified signal reference - function will create a new blank measurement record if one does not exist
            return phasorHub.queryMeasurement(orgSignalReference).then(function (measurement) {
                // Determine defined nominal voltage kV level of phasor
                let baseKV = 0;

                if (phasorDefinition.Voltage) {
                    baseKV = phasorDefinition.Voltage.NominalVoltage();
                }
                else if (phasorDefinition.Current) {
                    baseKV = phasorDefinition.Current.AssociatedNominalVoltage();
                }

                // Create point tag using system defined naming convention
                return phasorHub.createPhasorPointTag(cell.IDLabel(), signalType.Acronym, phasorDefinition.Label(), phasorDefinition.Phase(), index, baseKV).then(function (pointTag) {
                    measurement.DeviceID = cell.ID;
                    measurement.HistorianID = viewModel.historianID();
                    measurement.PointTag = pointTag;
                    measurement.Description = String.format("{0} {1} {2} {3}", cell.IDLabel(), phasorDefinition.Label(), phasorDefinition.Phase(), signalType.Name);
                    measurement.PhasorSourceIndex = index;
                    measurement.SignalReference = signalReference;
                    measurement.SignalTypeID = signalType.ID;
                    measurement.Internal = true;
                    measurement.Enabled = phasorDefinition.Enabled();

                    return phasorHub.addNewOrUpdateMeasurement(measurement).fail(function (error) {
                        showErrorMessage("Save failed for new measurement " + signalReference + ": " + error, null, true);
                    });
                })
                .fail(function (error) {
                    showErrorMessage("Failed to create point tag for measurement " + signalReference + ": " + error, null, true);
                });
            })
            .fail(function (error) {
                showErrorMessage("Failed to lookup measurement " + signalReference + ": " + error, null, true);
            });
        }

        function saveDevicePhasors(cell) {
            // Get phasor signal types
            const iphmSignalType = getPhasorSignalType("IPHM");
            const iphaSignalType = getPhasorSignalType("IPHA");
            const vphmSignalType = getPhasorSignalType("VPHM");
            const vphaSignalType = getPhasorSignalType("VPHA");

            if (iphmSignalType == null || iphaSignalType == null || vphmSignalType == null || vphaSignalType == null) {
                showErrorMessage("Failed to find one or more phasor signal type records.", null, true);
                return $.Deferred().resolve().promise();
            }

            return phasorHub.queryPhasorsForDevice(cell.ID).then(function (phasors) {
                let dropAndAdd = phasors.length !== cell.PhasorDefinitions.length;

                if (!dropAndAdd) {
                    // Also do add operation if these are new records, e.g., from new config
                    for (let i = 0; i < cell.PhasorDefinitions.length; i++) {
                        const phasorID = cell.PhasorDefinitions[i].ID;

                        if (phasorID === null || phasorID === 0) {
                            dropAndAdd = true;
                            break;
                        }
                    }
                }

                if (!dropAndAdd) {
                    // Also do add operation if phasor source index records are not sequential
                    for (let i = 0; i < phasors.length; i++) {
                        if (phasors[i].SourceIndex !== i + 1) {
                            dropAndAdd = true;
                            break;
                        }
                    }
                }

                // Separate voltage and current phasor definitions
                const saveDevicePromises = [];
                const voltages = [];
                const currents = [];

                for (let i = 0; i < cell.PhasorDefinitions.length; i++) {
                    const phasorDefinition = cell.PhasorDefinitions[i];

                    if (phasorDefinition.TaggedForDelete()) {
                        saveDevicePromises.push(phasorHub.queryDeviceMeasurements(cell.ID).then(function (measurements) {
                            const promises = [];

                            // Remove measurements associated with phasor
                            for (let j = 0; j < measurements.length; j++) {
                                const measurement = measurements[j];

                                if (measurement.PhasorSourceIndex === phasorDefinition.SourceIndex) {
                                    promises.push(phasorHub.deleteMeasurement(measurement.PointID).fail(function (error) {
                                        showErrorMessage("Failed to delete phasor measurement: " + error, null, true);
                                    }));
                                }
                            }

                            // Remove phasor
                            for (let j = 0; j < phasors.length; j++) {
                                const phasor = phasors[j];

                                if (phasor.SourceIndex === phasorDefinition.SourceIndex) {
                                    promises.push(phasorHub.deletePhasor(phasor.ID).fail(function (error) {
                                        showErrorMessage("Failed to delete phasor: " + error, null, true);
                                    }));
                                    break;
                                }
                            }

                            return $(promises).whenAll();
                        })
                        .fail(function (error) {
                            showErrorMessage("Failed to query device measurements: " + error, null, true);
                        }));
                    }
                    else {
                        if (phasorDefinition.PhasorType.toLowerCase() === "voltage")
                            voltages.push(phasorDefinition);
                        else
                            currents.push(phasorDefinition);
                    }
                }

                if (dropAndAdd) {
                    // Handle drop and (re)add phasors operation
                    const promise = cell.PhasorDefinitions.length > 0 ? phasorHub.deletePhasorsForDevice(cell.ID) : $.Deferred().resolve().promise();

                    saveDevicePromises.push(promise.then(function () {
                        const voltagePromises = [];
                        const voltageIDMap = [];

                        for (let i = 0; i < voltages.length; i++) {
                            const voltage = voltages[i];

                            voltagePromises.push(phasorHub.newPhasorWithTimestamps(voltage.UpdatedOn, voltage.CreatedOn).then(function (phasor) {
                                phasor.DeviceID = cell.ID;
                                phasor.Label = voltage.Label();
                                phasor.Type = "V";
                                phasor.Phase = voltage.Phase();
                                phasor.BaseKV = voltage.Voltage.NominalVoltage();
                                phasor.DestinationPhasorID = null;
                                phasor.SourceIndex = voltage.SourceIndex;

                                return phasorHub.addNewPhasor(phasor).then(function () {
                                    return savePhasorMeasurement(cell, vphmSignalType, voltage, phasor.SourceIndex).then(function () {
                                        return savePhasorMeasurement(cell, vphaSignalType, voltage, phasor.SourceIndex);
                                    })
                                    .then(function () {
                                        const vphmSignalReference = String.format("{0}-{1}{2}", cell.IDLabel(), vphmSignalType.Suffix, phasor.SourceIndex);

                                        return phasorHub.queryMeasurement(vphmSignalReference).done(function (measurement) {
                                            voltage.vphmMeasurement = measurement;
                                        });
                                    })
                                    .then(function () {
                                        const vphaSignalReference = String.format("{0}-{1}{2}", cell.IDLabel(), vphaSignalType.Suffix, phasor.SourceIndex);

                                        return phasorHub.queryMeasurement(vphaSignalReference).done(function (measurement) {
                                            voltage.vphaMeasurement = measurement;
                                        });
                                    })
                                    .then(function () {
                                        return phasorHub.queryPhasorForDevice(cell.ID, phasor.SourceIndex).then(function (newPhasor) {
                                            voltageIDMap[voltage.ID] = newPhasor.ID;
                                        })
                                        .fail(function (error) {
                                            showErrorMessage("Failed to query voltage phasor: " + error, null, true);
                                        });
                                    })
                                    .then(function () {
                                        // Update phasor after add so UpdatedOn date is greater than CreatedOn
                                        return phasorHub.updatePhasor(phasor).fail(function (error) {
                                            showErrorMessage("Failed to update voltage phasor: " + error, null, true);
                                        });
                                    });
                                })
                                .fail(function (error) {
                                    showErrorMessage("Failed to save new voltage phasor: " + error, null, true);
                                });
                            })
                            .fail(function (error) {
                                showErrorMessage("Failed to create new voltage phasor: " + error, null, true);
                            }));
                        }

                        // In the case of drop and add we make sure to complete all voltage phasor operations
                        // before beginning current phasor operations so that voltageIDMap will be populated
                        // with new voltage phasor IDs needed for destination phasor IDs
                        return $(voltagePromises).whenAll().then(function () {
                            const currentPromises = [];

                            for (let i = 0; i < currents.length; i++) {
                                const current = currents[i];

                                currentPromises.push(phasorHub.newPhasorWithTimestamps(current.UpdatedOn, current.CreatedOn).then(function (phasor) {
                                    const associatedVoltage = current.Current.AssociatedVoltage();
                                    const voltage = lookupAssociatedVoltage(cell, associatedVoltage);
                                    let baseKV = 0;

                                    if (voltage)
                                        baseKV = voltage.Voltage.NominalVoltage();

                                    if (!current.Enabled()) {
                                        if (baseKV === 0)
                                            baseKV = -1;
                                        else
                                            baseKV = Math.abs(baseKV) * -1;
                                    }

                                    phasor.DeviceID = cell.ID;
                                    phasor.Label = current.Label();
                                    phasor.Type = "I";
                                    phasor.Phase = current.Phase();
                                    phasor.BaseKV = baseKV;
                                    phasor.DestinationPhasorID = voltageIDMap[associatedVoltage];
                                    phasor.SourceIndex = current.SourceIndex;

                                    if (phasor.DestinationPhasorID === undefined)
                                        phasor.DestinationPhasorID = null;

                                    return phasorHub.addNewPhasor(phasor).then(function () {
                                        return savePhasorMeasurement(cell, iphmSignalType, current, phasor.SourceIndex).then(function () {
                                            return savePhasorMeasurement(cell, iphaSignalType, current, phasor.SourceIndex);
                                        })
                                        .then(function () {
                                            const iphmSignalReference = String.format("{0}-{1}{2}", cell.IDLabel(), iphmSignalType.Suffix, phasor.SourceIndex);

                                            return phasorHub.queryMeasurement(iphmSignalReference).done(function (measurement) {
                                                current.iphmMeasurement = measurement;
                                            });
                                        })
                                        .then(function () {
                                            const iphaSignalReference = String.format("{0}-{1}{2}", cell.IDLabel(), iphaSignalType.Suffix, phasor.SourceIndex);

                                            return phasorHub.queryMeasurement(iphaSignalReference).done(function (measurement) {
                                                current.iphaMeasurement = measurement;
                                            });
                                        })
                                        .then(function () {
                                            // Update phasor after add so UpdatedOn date is greater than CreatedOn
                                            return phasorHub.updatePhasor(phasor).fail(function (error) {
                                                showErrorMessage("Failed to update current phasor: " + error, null, true);
                                            });
                                        });
                                    })
                                    .fail(function (error) {
                                        showErrorMessage("Failed to save new current phasor: " + error, null, true);
                                    });
                                })
                                .fail(function (error) {
                                    showErrorMessage("Failed to create current new phasor: " + error, null, true);
                                }));
                            }

                            return $(currentPromises).whenAll();
                        });
                    })
                    .fail(function (error) {
                        showErrorMessage("Failed to delete old phasors: " + error, null, true);
                    }));
                }
                else {
                    // Handle update phasors operation
                    const voltageIDMap = [];

                    for (let i = 0; i < voltages.length; i++) {
                        const voltage = voltages[i];

                        saveDevicePromises.push(phasorHub.queryPhasorForDevice(cell.ID, voltage.SourceIndex).then(function (phasor) {
                            phasor.DeviceID = cell.ID;
                            phasor.Label = voltage.Label();
                            phasor.Type = "V";
                            phasor.Phase = voltage.Phase();
                            phasor.BaseKV = voltage.Voltage.NominalVoltage();
                            phasor.DestinationPhasorID = null;
                            phasor.SourceIndex = voltage.SourceIndex;

                            voltageIDMap[voltage.ID] = phasor.ID;

                            return phasorHub.updatePhasor(phasor).then(function () {
                                return savePhasorMeasurement(cell, vphmSignalType, voltage, phasor.SourceIndex).then(function () {
                                    return savePhasorMeasurement(cell, vphaSignalType, voltage, phasor.SourceIndex);
                                })
                                .then(function () {
                                    const vphmSignalReference = String.format("{0}-{1}{2}", cell.IDLabel(), vphmSignalType.Suffix, phasor.SourceIndex);

                                    return phasorHub.queryMeasurement(vphmSignalReference).done(function (measurement) {
                                        voltage.vphmMeasurement = measurement;
                                    });
                                })
                                .then(function () {
                                    const vphaSignalReference = String.format("{0}-{1}{2}", cell.IDLabel(), vphaSignalType.Suffix, phasor.SourceIndex);

                                    return phasorHub.queryMeasurement(vphaSignalReference).done(function (measurement) {
                                        voltage.vphaMeasurement = measurement;
                                    });
                                });
                            })
                            .fail(function (error) {
                                showErrorMessage("Failed to save voltage phasor: " + error, null, true);
                            });
                        })
                        .fail(function (error) {
                            showErrorMessage("Failed to query voltage phasor: " + error, null, true);
                        }));
                    }

                    for (let i = 0; i < currents.length; i++) {
                        const current = currents[i];

                        saveDevicePromises.push(phasorHub.queryPhasorForDevice(cell.ID, current.SourceIndex).then(function (phasor) {
                            phasor.DeviceID = cell.ID;
                            phasor.Label = current.Label();
                            phasor.Type = "I";
                            phasor.Phase = current.Phase();
                            phasor.BaseKV = current.Current.AssociatedNominalVoltage();
                            phasor.DestinationPhasorID = voltageIDMap[current.Current.AssociatedVoltage()];
                            phasor.SourceIndex = current.SourceIndex;

                            if (!current.Enabled()) {
                                if (phasor.BaseKV === 0)
                                    phasor.BaseKV = -1;
                                else
                                    phasor.BaseKV = Math.abs(phasor.BaseKV) * -1;
                            }

                            if (phasor.DestinationPhasorID === undefined)
                                phasor.DestinationPhasorID = null;

                            return phasorHub.updatePhasor(phasor).then(function () {
                                return savePhasorMeasurement(cell, iphmSignalType, current, phasor.SourceIndex).then(function () {
                                    return savePhasorMeasurement(cell, iphaSignalType, current, phasor.SourceIndex);
                                })
                                .then(function () {
                                    const iphmSignalReference = String.format("{0}-{1}{2}", cell.IDLabel(), iphmSignalType.Suffix, phasor.SourceIndex);

                                    return phasorHub.queryMeasurement(iphmSignalReference).done(function (measurement) {
                                        current.iphmMeasurement = measurement;
                                    });
                                })
                                .then(function () {
                                    const iphaSignalReference = String.format("{0}-{1}{2}", cell.IDLabel(), iphaSignalType.Suffix, phasor.SourceIndex);

                                    return phasorHub.queryMeasurement(iphaSignalReference).done(function (measurement) {
                                        current.iphaMeasurement = measurement;
                                    });
                                });
                            })
                            .fail(function (error) {
                                showErrorMessage("Failed to save current phasor: " + error, null, true);
                            });
                        })
                        .fail(function (error) {
                            showErrorMessage("Failed to query current phasor: " + error, null, true);
                        }));
                    }
                }

                return $(saveDevicePromises).whenAll();
            })
            .fail(function (error) {
                showErrorMessage("Failed to query phasor count: " + error, null, true);
            });
        }

        function saveFixedMeasurement(cell, signalType, label) {
            const orgSignalReference = String.format("{0}-{1}", cell.OriginalAcronym(), signalType.Suffix);
            const signalReference = String.format("{0}-{1}", cell.IDLabel(), signalType.Suffix);

            // Query existing measurement record for specified signal reference - function will create a new blank measurement record if one does not exist
            return phasorHub.queryMeasurement(orgSignalReference).then(function (measurement) {
                return phasorHub.createPointTag(cell.IDLabel(), signalType.Acronym).then(function (pointTag) {
                    measurement.DeviceID = cell.ID;
                    measurement.HistorianID = viewModel.historianID();
                    measurement.PointTag = pointTag;
                    measurement.Description = String.format("{0} {1}", cell.IDLabel(), signalType.Name, isEmpty(label) ? "" : " - " + label);
                    measurement.SignalReference = signalReference;
                    measurement.SignalTypeID = signalType.ID;
                    measurement.Internal = true;
                    measurement.Enabled = true;

                    return phasorHub.addNewOrUpdateMeasurement(measurement).fail(function (error) {
                        showErrorMessage("Save failed for new measurement " + signalReference + ": " + error, null, true);
                    });
                })
                .fail(function (error) {
                    showErrorMessage("Failed to create point tag for measurement " + signalReference + ": " + error, null, true);
                });
            })
            .fail(function (error) {
                showErrorMessage("Failed to lookup measurement " + signalReference + ": " + error, null, true);
            });
        }

        function saveDeviceMeasurements(cell) {
            // No measurements to save if only forwarding data
            if (viewModel.forwardOnly())
                return $.Deferred().resolve().promise();

            const freqSignalType = getDeviceSignalType("FREQ");
            const dfdtSignalType = getDeviceSignalType("DFDT");
            const flagSignalType = getDeviceSignalType("FLAG");

            if (freqSignalType == null || dfdtSignalType == null || flagSignalType == null) {
                showErrorMessage("Failed to find one or more signal type records.", null, true);
                return $.Deferred().resolve().promise();
            }

            // Add frequency
            return saveFixedMeasurement(cell, freqSignalType, cell.FrequencyDefinition.Label).then(function () {
                // Add dF/dt
                return saveFixedMeasurement(cell, dfdtSignalType);
            })
            .then(function () {
                // Add status flags
                return saveFixedMeasurement(cell, flagSignalType);
            })
            .then(function () {
                // Add analogs
                if (viewModel.addAnalogs()) {
                    const analogSignalType = getDeviceSignalType("ALOG");

                    if (analogSignalType != null) {
                        const promises = [];

                        for (let i = 0; i < cell.AnalogDefinitions.length; i++) {
                            const index = i + 1;
                            const analogDefinition = cell.AnalogDefinitions[i];
                            const orgSignalReference = String.format("{0}-{1}{2}", cell.OriginalAcronym(), analogSignalType.Suffix, index);
                            const signalReference = String.format("{0}-{1}{2}", cell.IDLabel(), analogSignalType.Suffix, index);

                            // Query existing measurement record for specified signal reference - function will create a new blank measurement record if one does not exist
                            promises.push(phasorHub.queryMeasurement(orgSignalReference).then(function (measurement) {
                                return phasorHub.createIndexedPointTag(cell.IDLabel(), analogSignalType.Acronym, index, analogDefinition.Label).then(function (pointTag) {
                                    measurement.DeviceID = cell.ID;
                                    measurement.HistorianID = viewModel.historianID();
                                    measurement.PointTag = pointTag;
                                    measurement.AlternateTag = analogDefinition.Label;
                                    measurement.Description = String.format("{0} Analog Value {1}:{2}: {3}", cell.IDLabel(), index, analogDefinition.AnalogType, analogDefinition.Label);
                                    measurement.SignalReference = signalReference;
                                    measurement.SignalTypeID = analogSignalType.ID;
                                    measurement.Internal = true;
                                    measurement.Enabled = true;

                                    return phasorHub.addNewOrUpdateMeasurement(measurement).fail(function (error) {
                                        showErrorMessage("Save failed for new measurement " + signalReference + ": " + error, null, true);
                                    });
                                })
                                .fail(function (error) {
                                    showErrorMessage("Failed to create point tag for measurement " + signalReference + ": " + error, null, true);
                                });
                            })
                            .fail(function (error) {
                                showErrorMessage("Failed to lookup measurement " + signalReference + ": " + error, null, true);
                            }));
                        }

                        return $(promises).whenAll();
                    }
                    else {
                        showErrorMessage("Failed to find analog signal type record.", null, true);
                        return $.Deferred().resolve().promise();
                    }
                }
                else {
                    return $.Deferred().resolve().promise();
                }
            })
            .then(function () {
                // Add digitals
                if (viewModel.addDigitals()) {
                    const digitalSignalType = getDeviceSignalType("DIGI");

                    if (digitalSignalType != null) {
                        const promises = [];

                        for (let i = 0; i < cell.DigitalDefinitions.length; i++) {
                            const index = i + 1;
                            const digitalDefinition = cell.DigitalDefinitions[i];
                            const orgSignalReference = String.format("{0}-{1}{2}", cell.OriginalAcronym(), digitalSignalType.Suffix, index);
                            const signalReference = String.format("{0}-{1}{2}", cell.IDLabel(), digitalSignalType.Suffix, index);

                            // Query existing measurement record for specified signal reference - function will create a new blank measurement record if one does not exist
                            promises.push(phasorHub.queryMeasurement(orgSignalReference).then(function (measurement) {
                                return phasorHub.createIndexedPointTag(cell.IDLabel(), digitalSignalType.Acronym, index, digitalDefinition.Label).then(function (pointTag) {
                                    measurement.DeviceID = cell.ID;
                                    measurement.HistorianID = viewModel.historianID();
                                    measurement.PointTag = pointTag;
                                    measurement.AlternateTag = digitalDefinition.Label;
                                    measurement.Description = String.format("{0} Digital Value {1}: {2}", cell.IDLabel(), index, digitalDefinition.Label);
                                    measurement.SignalReference = signalReference;
                                    measurement.SignalTypeID = digitalSignalType.ID;
                                    measurement.Internal = true;
                                    measurement.Enabled = true;

                                    return phasorHub.addNewOrUpdateMeasurement(measurement).fail(function (error) {
                                        showErrorMessage("Save failed for new measurement " + signalReference + ": " + error, null, true);
                                    });
                                })
                                .fail(function (error) {
                                    showErrorMessage("Failed to create point tag for measurement " + signalReference + ": " + error, null, true);
                                });
                            })
                            .fail(function (error) {
                                showErrorMessage("Failed to lookup measurement " + signalReference + ": " + error, null, true);
                            }));
                        }

                        return $(promises).whenAll();
                    }
                    else {
                        showErrorMessage("Failed to find digital signal type record.", null, true);
                        return $.Deferred().resolve().promise();
                    }
                }
                else {
                    return $.Deferred().resolve().promise();
                }
            })
            .then(function () {
                return saveDevicePhasors(cell);
            });
        }

        function savePowerCalculations(cell, tagTemplate) {
            const promises = [];
            const phase = tagTemplate.Inputs[0].toUpperCase()[0];

            for (let i = 0; i < cell.PhasorDefinitions.length; i++) {
                const phasorDefinition = cell.PhasorDefinitions[i];

                // Power calculations can be applied to currents with an associated voltage
                if (phasorDefinition.PhasorType.toLowerCase() === "current" && phasorDefinition.Phase().toUpperCase() === phase && phasorDefinition.Current.AssociatedVoltage() > 0) {
                    const current = phasorDefinition;
                    const voltage = lookupAssociatedVoltage(cell, phasorDefinition.Current.AssociatedVoltage());

                    if (voltage) {
                        if (voltage.hasOwnProperty("vphaMeasurement") && voltage.hasOwnProperty("vphmMeasurement") && current.hasOwnProperty("iphaMeasurement") && current.hasOwnProperty("iphmMeasurement")) {
                            const circuitDescription = String.format("{0}-{1}-{2}", cell.IDLabel(), tagTemplate.TagName, current.Label());
                            const vphaID = voltage.vphaMeasurement.SignalID;
                            const vphmID = voltage.vphmMeasurement.SignalID;
                            const iphaID = current.iphaMeasurement.SignalID;
                            const iphmID = current.iphmMeasurement.SignalID;

                            // Query for existing power calculation, this will create a new record if not found
                            promises.push(phasorHub.queryPowerCalculationForDescriptionOrInputs(circuitDescription, vphaID, vphmID, iphaID, iphmID).then(function (powerCalculation) {
                                powerCalculation.VoltageAngleSignalID = vphaID;
                                powerCalculation.VoltageMagSignalID = vphmID;
                                powerCalculation.CurrentAngleSignalID = iphaID;
                                powerCalculation.CurrentMagSignalID = iphmID;
                                powerCalculation.Enabled = true;

                                // For all phase power calculations, do not apply any voltage adjustment strategy
                                powerCalculation.CircuitDescription = circuitDescription + "; AdjustmentStrategy = None";

                                if (powerCalculation.ID === 0) {
                                    return phasorHub.addNewPowerCalculation(powerCalculation).fail(function (error) {
                                        showErrorMessage("Failed to add new power calculation record: " + error, null, true);
                                    });
                                }
                                else {
                                    return phasorHub.updatePowerCalculation(powerCalculation).fail(function (error) {
                                        showErrorMessage("Failed to update power calculation record: " + error, null, true);
                                    });
                                }
                            })
                            .fail(function (error) {
                                showErrorMessage("Failed to query power calculation record: " + error, null, true);
                            }));
                        }
                    }
                }
            }

            return $(promises).whenAll();
        }

        function lineCurrentExists(lines, current) {
            for (let i = 0; i < lines.length; i++) {
                const line = lines[i];

                if (line.A.current === current || line.B.current === current || line.C.current === current)
                    return true;
            }

            return false;
        }

        // Find lines that have phasors for each phase, i.e., A, B and C
        function findMatchingLines(cell) {
            const lines = [];

            // Scan all phasor definitions
            for (let i = 0; i < cell.PhasorDefinitions.length; i++) {
                const phasorDefinition = cell.PhasorDefinitions[i];
                const phase = phasorDefinition.Phase().toUpperCase();

                if ((phase !== "A" && phase !== "B" && phase !== "C") || phasorDefinition.PhasorType.toLowerCase() !== "current")
                    continue;

                const current = phasorDefinition;
                const voltage = lookupAssociatedVoltage(cell, phasorDefinition.Current.AssociatedVoltage());

                // No matching voltage means no power calculation, so can skip this as a match potential
                if (!voltage)
                    continue;

                // See if this line current has already been matched
                if (lineCurrentExists(lines, current))
                    continue;

                // Strategy for finding matching line phases is to remove any A, B or C phase designations from label
                const match = current.Label().trim().toUpperCase().replace(/[ABC]/gi, "");

                if (isEmpty(match))
                    continue;

                const line = [];

                line[phase] = {
                    current: current,
                    voltage: voltage
                };

                // Look for matching line currents - this creates a quadratic search time, but total phasors are expected to be small
                for (let j = 0; j < cell.PhasorDefinitions.length; j++) {
                    if (j === i)
                        continue;

                    const nextPhasorDefinition = cell.PhasorDefinitions[j];
                    const nextPhase = nextPhasorDefinition.Phase().toUpperCase();

                    if ((nextPhase !== "A" && nextPhase !== "B" && nextPhase !== "C") || nextPhasorDefinition.PhasorType.toLowerCase() !== "current" || nextPhase === phase || line.hasOwnProperty(nextPhase))
                        continue;

                    const nextCurrent = nextPhasorDefinition;
                    const nextVoltage = lookupAssociatedVoltage(cell, nextPhasorDefinition.Current.AssociatedVoltage());

                    // No matching voltage means no power calculation, so can skip this as a match potential
                    if (!nextVoltage)
                        continue;

                    // See if this next current is for matching line based on label minus phase designations
                    if (match === nextCurrent.Label().trim().toUpperCase().replace(/[ABC]/gi, "")) {
                        line[nextPhase] = {
                            current: nextCurrent,
                            voltage: nextVoltage
                        };

                        if (line.hasOwnProperty("A") && line.hasOwnProperty("B") && line.hasOwnProperty("C")) {
                            lines.push(line);
                            break;
                        }
                    }
                }
            }

            return lines;
        }

        function queryPowerOutput(type, linePhase, attempt) {
            if (attempt === undefined)
                attempt = 1;

            if (attempt > 4) {
                return $.Deferred().reject("Failed to find \"" + type +"\" power output measurement after waiting 12 seconds - skipping 3-phase power calculations.").promise();
            }

            if (!linePhase.voltage.hasOwnProperty("vphaMeasurement") || !linePhase.voltage.hasOwnProperty("vphmMeasurement") || !linePhase.current.hasOwnProperty("iphaMeasurement") || !linePhase.current.hasOwnProperty("iphmMeasurement"))
                return $.Deferred().resolve(null).promise();

            const vphaID = linePhase.voltage.vphaMeasurement.SignalID;
            const vphmID = linePhase.voltage.vphmMeasurement.SignalID;
            const iphaID = linePhase.current.iphaMeasurement.SignalID;
            const iphmID = linePhase.current.iphmMeasurement.SignalID;

            return phasorHub.queryPowerCalculationForInputs(vphaID, vphmID, iphaID, iphmID).then(function (powerCalculation) {
                if (powerCalculation.ID > 0) {
                    switch (type) {
                        case "MW":
                            if (powerCalculation.ActivePowerOutputSignalID == null || powerCalculation.ActivePowerOutputSignalID === 0)
                                return delayedPromise(3000).then(function () { return queryPowerOutput(type, linePhase, ++attempt); });

                            return $.Deferred().resolve(powerCalculation.ActivePowerOutputSignalID).promise();
                        case "MVAR":
                            if (powerCalculation.ReactivePowerOutputSignalID == null || powerCalculation.ReactivePowerOutputSignalID === 0)
                                return delayedPromise(3000).then(function () { return queryPowerOutput(type, linePhase, ++attempt); });

                            return $.Deferred().resolve(powerCalculation.ReactivePowerOutputSignalID).promise();
                        case "MVA":
                            if (powerCalculation.ApparentPowerOutputSignalID == null || powerCalculation.ApparentPowerOutputSignalID === 0)
                                return delayedPromise(3000).then(function () { return queryPowerOutput(type, linePhase, ++attempt); });

                            return $.Deferred().resolve(powerCalculation.ApparentPowerOutputSignalID).promise();
                    }
                }

                return $.Deferred().resolve(null).promise();
            })
            .fail(function (error) {
                showErrorMessage("Failed to query power calculation record: " + error, null, true);
            });
        }

        var matchingLines = [];

        function saveSumPhase(cell, tagTemplate, calcSignalType) {
            const deviceLabel = cell.IDLabel();
            var lines;

            if (matchingLines.hasOwnProperty(deviceLabel)) {
                lines = matchingLines[deviceLabel];
            }
            else {
                lines = findMatchingLines(cell);
                matchingLines[deviceLabel] = lines;
            }

            const type = tagTemplate.Inputs[0].trim().toUpperCase(); // MW, MVAR, MVA
            const linePromises = [];

            for (let i = 0; i < lines.length; i++) {
                const line = lines[i];
                const queryPromises = [];

                let phaseASignalID = null;
                let phaseBSignalID = null;
                let phaseCSignalID = null;

                // These queries will keep looping while power calculations are initializing until power output measurements exist or timeout after 12 seconds:
                queryPromises.push(queryPowerOutput(type, line.A, 1).then(function (signalID) {
                    phaseASignalID = signalID;
                }));

                queryPromises.push(queryPowerOutput(type, line.B, 1).then(function (signalID) {
                    phaseBSignalID = signalID;
                }));

                queryPromises.push(queryPowerOutput(type, line.C, 1).then(function (signalID) {
                    phaseCSignalID = signalID;
                }));

                linePromises.push($(queryPromises).whenAll().then(function () {
                    // Signal IDs should not be null at this point
                    if (!phaseASignalID && !phaseBSignalID && !phaseCSignalID)
                        return $.Deferred().resolve().promise();

                    const lineName = line.A.current.Label();
                    const orgSignalReference = String.format("{0}-{1}-{2}-{3}", cell.OriginalAcronym(), tagTemplate.TagName, lineName, calcSignalType.Suffix);
                    const signalReference = String.format("{0}-{1}-{2}-{3}", cell.IDLabel(), tagTemplate.TagName, lineName, calcSignalType.Suffix);

                    // Query existing measurement record for specified signal reference - function will create a new blank measurement record if one does not exist
                    return phasorHub.queryMeasurement(orgSignalReference).then(function (measurement) {
                        measurement.DeviceID = cell.ID;
                        measurement.HistorianID = viewModel.historianID();
                        measurement.PointTag = getCleanPointTag(String.format("{0}-{1}:CALC-{2}", cell.IDLabel(), lineName, tagTemplate.TagName));
                        measurement.Description = String.format("{0} {1} Calculated Value: {2}", cell.IDLabel(), lineName, tagTemplate.Description);
                        measurement.SignalReference = signalReference;
                        measurement.SignalTypeID = calcSignalType.ID;
                        measurement.Internal = true;
                        measurement.Enabled = true;

                        return phasorHub.addNewOrUpdateMeasurement(measurement).then(function () {
                            return phasorHub.queryMeasurement(signalReference).then(function (measurement) {
                                const connectionString = new Dictionary();
                                const variableList = new Dictionary();
                                const equation = "APW+BPW+CPW";

                                variableList.set("APW", phaseASignalID);
                                variableList.set("BPW", phaseBSignalID);
                                variableList.set("CPW", phaseCSignalID);

                                connectionString.set("variableList", variableList.joinKeyValuePairs());
                                connectionString.set("expressionText", equation);
                                connectionString.set("framesPerSecond", viewModel.configFrame().FrameRate);

                                // Adding one second to lag and lead time to ensure that the calculation does not time out
                                // too fast since this calculation is dependent on power calculation measurements as inputs
                                connectionString.set("lagTime", "@(DefaultCalculationLagTime + 1.0D)");
                                connectionString.set("leadTime", "@(DefaultCalculationLeadTime + 1.0D)");

                                connectionString.set("outputMeasurements", measurement.SignalID);
                                connectionString.set("useLatestValues", "false");

                                return phasorHub.newCustomActionAdapter().then(function (adapter) {
                                    adapter.NodeID = nodeID;
                                    adapter.AdapterName = getCleanAcronym(measurement.PointTag);
                                    adapter.AssemblyName = "DynamicCalculator.dll";
                                    adapter.TypeName = "DynamicCalculator.DynamicCalculator";
                                    adapter.ConnectionString = connectionString.joinKeyValuePairs();
                                    adapter.LoadOrder = 100;
                                    adapter.Enabled = true;

                                    return phasorHub.addNewOrUpdateCustomActionAdapter(adapter).then(function () {
                                        return serviceHub.sendCommand("initialize " + adapter.AdapterName);
                                    })
                                    .fail(function (error) {
                                        showErrorMessage("Save failed for new custom action adapter: " + error, null, true);
                                    });
                                })
                                .fail(function (error) {
                                    showErrorMessage("Failed to create new custom action adapter record: " + error, null, true);
                                });
                            })
                            .fail(function (error) {
                                showErrorMessage("Failed to lookup measurement " + signalReference + ": " + error, null, true);
                            });
                        })
                        .fail(function (error) {
                            showErrorMessage("Save failed for new measurement " + signalReference + ": " + error, null, true);
                        });
                    })
                    .fail(function (error) {
                        showErrorMessage("Failed to lookup or create measurement " + signalReference + ": " + error, null, true);
                    });
                }));
            }

            return $(linePromises).whenAll();
        }

        var dynamicCalculation = {
            initialized: false,
            deviceVariables: new Dictionary(),
            FAVG: "",
            FNOM: 60
        };

        function initializeDynamicCalculation() {
            if (dynamicCalculation.initialized)
                return $.Deferred().resolve().promise();

            // Input variables - expanded per device:
            //   VNOM: Nominal Voltage = viewModel.configFrame().phasorDefinitions[voltage].Voltage.NominalVoltage()
            //    VAM: Voltage A-Phase Magnitude also VBM, VCM, VNM for B, C & N phases and VPOSM, VNEGM, VZM for +, -, 0 sequence
            //    VAA: Voltage A-Phase Angle     also VBA, VCA, VNA            ↑            VPOSA, VNEGA, VZA
            //    IAM: Current A-Phase Magnitude also IBM, ICM, INM         Neutral         IPOSM, INEGM, IZM
            //    IAA: Current A-Phase Angle     also IBA, ICA, INA                         IPOSA, INEGA, IZA
            //   FREQ: Frequency
            //   FNOM: Model.Global.NominalFrequency
            //   FAVG: Frequency Average = system singleton where signal reference is "SYSTEM!FREQ-FQ"
            //  FLAGS: Status Flags
            //   ALOG: Analog value array
            //   DIGI: Digital value array

            const promises = [];
            const configFrame = viewModel.configFrame();
            const cells = configFrame.Cells;
            const cellCount = cells.length;

            for (let i = 0; i < cellCount; i++) {
                const cell = cells[i];
                const label = cell.IDLabel();
                const vars = {
                      VAM: [],   VBM: [],   VCM: [],   VNM: [],   VPOSM: [],   VNEGM: [],   VZM: [],
                      VAA: [],   VBA: [],   VCA: [],   VNA: [],   VPOSA: [],   VNEGA: [],   VZA: [],
                    VANOM: [], VBNOM: [], VCNOM: [], VNNOM: [], VPOSNOM: [], VNEGNOM: [], VZNOM: [],
                      IAM: [],   IBM: [],   ICM: [],   INM: [],   IPOSM: [],   INEGM: [],   IZM: [],
                      IAA: [],   IBA: [],   ICA: [],   INA: [],   IPOSA: [],   INEGA: [],   IZA: [],
                     FREQ: "", FLAGS: "",
                     ALOG: [],  DIGI: []
                };

                dynamicCalculation.deviceVariables.set(label, vars);

                for (let j = 0; j < cell.PhasorDefinitions.length; j++) {
                    const phasorDefinition = cell.PhasorDefinitions[j];
                    const phase = phasorDefinition.Phase().toUpperCase();

                    if (!phasorDefinition.Enabled())
                        continue;

                    if (phasorDefinition.PhasorType.toLowerCase() === "voltage") {
                        const nominalVoltage = phasorDefinition.Voltage.NominalVoltage() * 1000; // Convert from kV
                        const nominalVoltage3 = nominalVoltage / 1.7320508075688772;

                        if (!phasorDefinition.hasOwnProperty("vphmMeasurement") || !phasorDefinition.hasOwnProperty("vphaMeasurement"))
                            continue;

                        switch (phase) {
                            case "A":
                                vars.VAM.push(phasorDefinition.vphmMeasurement.SignalID);
                                vars.VAA.push(phasorDefinition.vphaMeasurement.SignalID);
                                vars.VANOM.push(nominalVoltage3);
                                break;
                            case "B":
                                vars.VBM.push(phasorDefinition.vphmMeasurement.SignalID);
                                vars.VBA.push(phasorDefinition.vphaMeasurement.SignalID);
                                vars.VBNOM.push(nominalVoltage3);
                                break;
                            case "C":
                                vars.VCM.push(phasorDefinition.vphmMeasurement.SignalID);
                                vars.VCA.push(phasorDefinition.vphaMeasurement.SignalID);
                                vars.VCNOM.push(nominalVoltage3);
                                break;
                            case "N": // Neutral
                                vars.VNM.push(phasorDefinition.vphmMeasurement.SignalID);
                                vars.VNA.push(phasorDefinition.vphaMeasurement.SignalID);
                                vars.VNNOM.push(nominalVoltage);
                                break;
                            case "+": // Positive Sequence
                                vars.VPOSM.push(phasorDefinition.vphmMeasurement.SignalID);
                                vars.VPOSA.push(phasorDefinition.vphaMeasurement.SignalID);
                                vars.VPOSNOM.push(nominalVoltage);
                                break;
                            case "-": // Negative Sequence
                                vars.VNEGM.push(phasorDefinition.vphmMeasurement.SignalID);
                                vars.VNEGA.push(phasorDefinition.vphaMeasurement.SignalID);
                                vars.VNEGNOM.push(nominalVoltage);
                                break;
                            case "0": // Zero Sequence
                                vars.VZM.push(phasorDefinition.vphmMeasurement.SignalID);
                                vars.VZA.push(phasorDefinition.vphaMeasurement.SignalID);
                                vars.VZNOM.push(nominalVoltage);
                                break;
                            default:
                                continue;
                        }
                    } else {
                        if (!phasorDefinition.hasOwnProperty("iphmMeasurement") || !phasorDefinition.hasOwnProperty("iphaMeasurement"))
                            continue;

                        switch (phase) {
                            case "A":
                                vars.IAM.push(phasorDefinition.iphmMeasurement.SignalID);
                                vars.IAA.push(phasorDefinition.iphaMeasurement.SignalID);
                                break;
                            case "B":
                                vars.IBM.push(phasorDefinition.iphmMeasurement.SignalID);
                                vars.IBA.push(phasorDefinition.iphaMeasurement.SignalID);
                                break;
                            case "C":
                                vars.ICM.push(phasorDefinition.iphmMeasurement.SignalID);
                                vars.ICA.push(phasorDefinition.iphaMeasurement.SignalID);
                                break;
                            case "N": // Neutral
                                vars.INM.push(phasorDefinition.iphmMeasurement.SignalID);
                                vars.INA.push(phasorDefinition.iphaMeasurement.SignalID);
                                break;
                            case "+": // Positive Sequence
                                vars.IPOSM.push(phasorDefinition.iphmMeasurement.SignalID);
                                vars.IPOSA.push(phasorDefinition.iphaMeasurement.SignalID);
                                break;
                            case "-": // Negative Sequence
                                vars.INEGM.push(phasorDefinition.iphmMeasurement.SignalID);
                                vars.INEGA.push(phasorDefinition.iphaMeasurement.SignalID);
                                break;
                            case "0": // Zero Sequence
                                vars.IZM.push(phasorDefinition.iphmMeasurement.SignalID);
                                vars.IZA.push(phasorDefinition.iphaMeasurement.SignalID);
                                break;
                            default:
                                continue;
                        }
                    }
                }

                promises.push(phasorHub.queryMeasurement(label + "-FQ").then(function (measurement) {
                    vars.FREQ = measurement.SignalID;
                    return phasorHub.queryMeasurement(label + "-SF");
                })
                .then(function (measurement) {
                    vars.FLAGS = measurement.SignalID;
                })
                .fail(function (error) {
                    showErrorMessage("Failed to find device '" + label + "' frequency or flags measurement: " + error);
                }));

                // Add analogs array
                for (let j = 0; j < cell.AnalogDefinitions.length; j++) {
                    const index = j + 1;

                    promises.push(phasorHub.queryMeasurement(String.format("{0}-AV{1}", label, index)).then(function (measurement) {
                        vars.ALOG.push(measurement.SignalID);
                    })
                    .fail(function (error) {
                        showErrorMessage("Failed to find device '" + label + "' analog value " + String(index) + " measurement: " + error);
                    }));
                }

                // Add digitals array
                for (let j = 0; j < cell.DigitalDefinitions.length; j++) {
                    const index = j + 1;

                    promises.push(phasorHub.queryMeasurement(String.format("{0}-DV{1}", label, index)).then(function (measurement) {
                        vars.DIGI.push(measurement.SignalID);
                    })
                    .fail(function (error) {
                        showErrorMessage("Failed to find device '" + label + "' digital value " + String(index) + " measurement: " + error);
                    }));
                }
            }

            return $(promises).whenAll().then(function () {
                return phasorHub.queryMeasurement(freqDeviceName + "-FQ");
            })
            .then(function (measurement) {
                if (measurement && measurement.SignalID)
                    dynamicCalculation.FAVG = measurement.SignalID;

                dynamicCalculation.FNOM = @NominalFrequency;
                dynamicCalculation.initialized = true;
            })
            .fail(function (error) {
                showErrorMessage("Failed to find average system frequency with SignalReference = '" + freqDeviceName + "-FQ': " + error);
            });
        }

        function lookupAssociatedPhasorDefinition(cell, signalID) {
            for (let i = 0; i < cell.PhasorDefinitions.length; i++) {
                const phasorDefinition = cell.PhasorDefinitions[i];

                if (phasorDefinition.PhasorType.toLowerCase() === "voltage") {
                    if (phasorDefinition.hasOwnProperty("vphmMeasurement") && phasorDefinition.hasOwnProperty("vphaMeasurement"))
                        if (phasorDefinition.vphmMeasurement.SignalID === signalID || phasorDefinition.vphaMeasurement.SignalID === signalID)
                            return phasorDefinition;
                }
                else if (phasorDefinition.hasOwnProperty("iphmMeasurement") && phasorDefinition.hasOwnProperty("iphaMeasurement")) {
                    if (phasorDefinition.iphmMeasurement.SignalID === signalID || phasorDefinition.iphaMeasurement.SignalID === signalID)
                        return phasorDefinition;
                }
            }

            return null;
        }

        function saveDynamicCalculation(cell, tagTemplate, templateIndex, subType, calcSignalType, attempt) {
            if (attempt === undefined)
                attempt = 1;

            if (attempt > 4) {
                return $.Deferred().reject("Failed to create \"" + tagTemplate.TagName + "\" aggregate tag template: input \"" + property + "\" source array could not be resolved after waiting 12 seconds.").promise();
            }

            return initializeDynamicCalculation().then(function () {
                var vars = dynamicCalculation.deviceVariables.get(cell.IDLabel());
                var inputSet = {};
                let arrayInputs = 0;

                for (let i = 0; i < tagTemplate.Inputs.length; i++) {
                    let inputName = tagTemplate.Inputs[i].toUpperCase();
                    let varName = inputName;

                    if (inputName === "FAVG") {
                        inputSet.FAVG = dynamicCalculation.FAVG;
                        continue;
                    }

                    if (inputName === "FNOM") {
                        inputSet.FNOM = dynamicCalculation.FNOM;
                        continue;
                    }

                    // Map VNOM since it's entered as per-phasor nominal voltage
                    if (inputName === "VNOM") {
                        for (let j = 0; j < tagTemplate.Inputs.length; j++) {
                            if (i === j)
                                continue;

                            switch (tagTemplate.Inputs[j].toUpperCase()) {
                                case "VAM":
                                case "VAA":
                                    varName = "VANOM";
                                    break;
                                case "VBM":
                                case "VBA":
                                    varName = "VBNOM";
                                    break;
                                case "VCM":
                                case "VCA":
                                    varName = "VCNOM";
                                    break;
                                case "VNM":
                                case "VNA":
                                    varName = "VNNOM";
                                    break;
                                case "VPOSM":
                                case "VPOSA":
                                    varName = "VPOSNOM";
                                    break;
                                case "VNEGM":
                                case "VNEGA":
                                    varName = "VNEGNOM";
                                    break;
                                case "VZM":
                                case "VZA":
                                    varName = "VZNOM";
                                    break;
                            }

                            if (varName !== inputName)
                                break;
                        }

                        if (varName === "VNOM")
                            varName = "VANOM";
                    }

                    if (inputName.endsWith("[]")) {
                        arrayInputs++;
                        varName = inputName = inputName.substring(0, inputName.length - 2);
                    }

                    inputSet[inputName] = vars[varName];
                }

                if (arrayInputs > 0 && arrayInputs !== Object.keys(inputSet).length)
                    return $.Deferred().reject("Error in \"" + tagTemplate.TagName + "\" [" + String(templateIndex) + "] tag template input definitions. When array inputs are used, arrays must be the only input types specified using array indicator suffix \"[]\".").promise();

                if (arrayInputs === 0 && subType !== "Calc")
                    return $.Deferred().reject("Error in \"" + tagTemplate.TagName + "\" [" + String(templateIndex) + "] tag template input definitions. For ValueAdjuster and ValueFilter types, arrays must be the only input types specified using array indicator suffix \"[]\".").promise();

                var maxInputLength = 0;
                var inputsAvailable = true;
                var singletonCalculation = false;
                var aggregateCalculation = arrayInputs > 0;

                if (aggregateCalculation) {
                    // Aggregate calculations operate over a single set of input arrays
                    maxInputLength = 1;
                    singletonCalculation = true;

                    // Validate all inputs are arrays
                    for (let property in inputSet) {
                        if (inputSet.hasOwnProperty(property)) {
                            if (!Array.isArray(inputSet[property]))
                                return $.Deferred().reject("Error in \"" + tagTemplate.TagName + "\" [" + String(templateIndex) + "] tag template: input \"" + property + "\" source is not an array. When array inputs are used, arrays must be the only input types specified.").promise();

                            // Inputs can be outputs of other calculations, so will wait for a moment for these to get created if needed
                            if (Object.keys(inputSet[property]).length === 0)
                                return delayedPromise(3000).then(function () { return saveDynamicCalculation(cell, tagTemplate, templateIndex, subType, calcSignalType, ++attempt); });
                        }
                    }
                }
                else {
                    // TODO: Handle case where there may be an odd number of positive sequence values to phase values - may need to match by line??

                    // Get max channel count
                    for (let property in inputSet) {
                        if (inputSet.hasOwnProperty(property)) {
                            // Ignore non-array elements
                            if (!Array.isArray(inputSet[property]))
                                continue;

                            const channelCount = inputSet[property].length;

                            if (channelCount > maxInputLength)
                                maxInputLength = channelCount;
                        }
                    }

                    // Validate inputs
                    if (maxInputLength > 0) {
                        for (let property in inputSet) {
                            if (inputSet.hasOwnProperty(property)) {
                                // Ignore non-array elements
                                if (!Array.isArray(inputSet[property]))
                                    continue;

                                // All array-based inputs, e.g., phasors, must have consistent lengths
                                if (maxInputLength !== inputSet[property].length) {
                                    inputsAvailable = false;
                                    break;
                                }
                            }
                        }
                    } else {
                        // Check for singleton calculation inputs
                        inputsAvailable = inputSet.hasOwnProperty("FREQ") || inputSet.hasOwnProperty("FAVG") || inputSet.hasOwnProperty("FNOM") || inputSet.hasOwnProperty("FLAGS");

                        if (inputsAvailable) {
                            maxInputLength = 1;
                            singletonCalculation = true;
                        }
                    }
                }

                function addDynamicCalculatorAdapter(index, measurement) {
                    let phasorDefinition = null;
                    const connectionString = new Dictionary();
                    const variableList = new Dictionary();
                    let equation = tagTemplate.Equation;

                    if (!singletonCalculation && !aggregateCalculation && measurement !== undefined) {
                        vars[tagTemplate.TagName].push(measurement.SignalID);
                        dynamicCalculation.deviceVariables.set(cell.IDLabel(), vars);
                    }

                    for (let property in inputSet) {
                        if (inputSet.hasOwnProperty(property)) {
                            const input = inputSet[property];

                            if (aggregateCalculation) {
                                // Get all array input signal IDs
                                const signalIDs = [];

                                for (let inputProperty in input) {
                                    if (input.hasOwnProperty(inputProperty)) {
                                        signalIDs.push(input[inputProperty] + "");
                                    }
                                }

                                // Define array variable input for dynamic calculation
                                const arrayName = subType !== "Calc" && property === tagTemplate.TagName ? "value" : property;
                                variableList.set(arrayName + "[]", signalIDs.join(","));
                            }
                            else {
                                if (Array.isArray(input)) {
                                    if (property === "VNOM") {
                                        // Replace VNOM constant
                                        equation = equation.replaceAll("VNOM", String(inputSet.VNOM[index]), true);
                                    }
                                    else {
                                        // Assign variable to signal ID
                                        const signalID = input[index] + "";
                                        variableList.set(property, signalID);

                                        if (phasorDefinition == null) {
                                            const matchedPhasorDefinition = lookupAssociatedPhasorDefinition(cell, signalID);

                                            if (matchedPhasorDefinition != null)
                                                phasorDefinition = matchedPhasorDefinition;
                                        }
                                    }
                                }
                                else {
                                    if (property === "FNOM") {
                                        // Replace FNOM constant
                                        equation = equation.replaceAll("FNOM", String(inputSet.FNOM), true);
                                    } else {
                                        // Assign variable to signal ID
                                        const signalID = input + "";
                                        variableList.set(property, signalID);
                                    }
                                }
                            }
                        }
                    }

                    let adapterName;
                    let pointTagPromise;

                    if (measurement === undefined) {
                        // ValueAdjuster and ValueFilter types produce no output measurement, only need an adapter name
                        adapterName = getCleanAcronym(String.format("{0}-{1}!{2}{3}", cell.IDLabel(), tagTemplate.TagName, subType.toUpperCase(), templateIndex));
                        pointTagPromise = $.Deferred().resolve().promise();
                    }
                    else {
                        // Inject phasor definition label into output measurement point tag and description
                        if (phasorDefinition != null && !isEmpty(phasorDefinition.Label())) {
                            const label = phasorDefinition.Label().replaceAll(" ", "_").toUpperCase();
                            measurement.PointTag = getCleanPointTag(String.format(measurement.PointTag.replace("<0>", "{0}"), label));
                            adapterName = getCleanAcronym(measurement.PointTag);
                            measurement.Description = String.format(measurement.Description.replace("<0>", " {0}"), phasorDefinition.Label());
                            pointTagPromise = phasorHub.updateMeasurement(measurement);
                        }
                        else {
                            measurement.PointTag = getCleanPointTag(measurement.PointTag.replace("-<0>", ""));
                            adapterName = getCleanAcronym(measurement.PointTag);
                            measurement.Description = measurement.Description.replace("<0>", "");
                            pointTagPromise = phasorHub.updateMeasurement(measurement);
                        }
                    }

                    function newDynamicCalculatorAdapter() {
                        return subType === "Calc" ?
                            phasorHub.newCustomActionAdapter() :
                            phasorHub.newCustomFilterAdapter();
                    }

                    function addNewOrUpdateDynamicCalculatorAdapter(adapter) {
                        return subType === "Calc" ?
                            phasorHub.addNewOrUpdateCustomActionAdapter(adapter) :
                            phasorHub.addNewOrUpdateCustomFilterAdapter(adapter);
                    }

                    connectionString.set("variableList", variableList.joinKeyValuePairs());
                    connectionString.set("expressionText", equation);

                    return pointTagPromise.then(function () {
                        return newDynamicCalculatorAdapter().then(function (adapter) {
                            adapter.NodeID = nodeID;
                            adapter.AdapterName = adapterName + (aggregateCalculation ? "-CALC" : "");
                            adapter.AssemblyName = "DynamicCalculator.dll";

                            switch (subType) {
                                case "Calc":  // DynamicCalculator type
                                    adapter.TypeName = "DynamicCalculator.DynamicCalculator";
                                    connectionString.set("framesPerSecond", viewModel.configFrame().FrameRate);
                                    connectionString.set("lagTime", "@DefaultCalculationLagTime");
                                    connectionString.set("leadTime", "@DefaultCalculationLeadTime");
                                    connectionString.set("outputMeasurements", measurement.SignalID);
                                    connectionString.set("useLatestValues", "false");
                                    break;
                                case "Adjust": // ValueAdjuster type
                                    adapter.TypeName = "DynamicCalculator.DynamicFilter";
                                    connectionString.set("filterOperation", "ValueAugmentation");
                                    break;
                                case "Filter": // ValueFilter type
                                    adapter.TypeName = "DynamicCalculator.DynamicFilter";
                                    connectionString.set("filterOperation", "RemoveWhenTrue");
                                    break;
                            }

                            adapter.ConnectionString = connectionString.joinKeyValuePairs();
                            adapter.LoadOrder = 100 + templateIndex;
                            adapter.Enabled = true;

                            return addNewOrUpdateDynamicCalculatorAdapter(adapter).then(function () {
                                return serviceHub.sendCommand("initialize " + adapter.AdapterName);
                            })
                            .fail(function (error) {
                                showErrorMessage("Save failed for new custom " + (subType === "Calc" ? "action" : "filter") + " adapter: " + error, null, true);
                            });
                        })
                        .fail(function (error) {
                            showErrorMessage("Failed to create new custom " + (subType === "Calc" ? "action" : "filter") + " adapter record: " + error, null, true);
                        });
                    })
                    .fail(function (error) {
                        showErrorMessage("Failed to update output measurement tag \"" + adapterName + "\" for new custom " + (subType === "Calc" ? "action" : "filter") + " adapter record: " + error, null, true);
                    });
                }

                const promises = [];

                if (inputsAvailable) {
                    for (let i = 0; i < maxInputLength; i++) {
                        const index = i;

                        if (subType === "Calc") {
                            const orgSignalReference = String.format("{0}-{1}-{2}{3}", cell.OriginalAcronym(), tagTemplate.TagName, calcSignalType.Suffix, singletonCalculation ? "" : String(index));
                            const signalReference = String.format("{0}-{1}-{2}{3}", cell.IDLabel(), tagTemplate.TagName, calcSignalType.Suffix, singletonCalculation ? "" : String(index));

                            // Track all dynamic calculation output SignalIDs by tag name so they can be used as inputs to aggregate calculations
                            if (!singletonCalculation && !aggregateCalculation)
                                vars[tagTemplate.TagName] = [];

                            // Query existing measurement record for specified signal reference - function will create a new blank measurement record if one does not exist
                            promises.push(phasorHub.queryMeasurement(orgSignalReference).then(function (measurement) {
                                measurement.DeviceID = cell.ID;
                                measurement.HistorianID = viewModel.historianID();
                                measurement.PointTag = String.format("{0}-<0>{1}{2}", cell.IDLabel(), aggregateCalculation ? "-" : ":CALC-", tagTemplate.TagName);
                                measurement.Description = String.format("{0}<0>{1} Value{2}: {3}", cell.IDLabel(), aggregateCalculation ? "" : " Calculated", singletonCalculation ? "" : " " + String(index), tagTemplate.Description);
                                measurement.SignalReference = signalReference;
                                measurement.SignalTypeID = calcSignalType.ID;
                                measurement.Internal = true;
                                measurement.Enabled = true;

                                return phasorHub.addNewOrUpdateMeasurement(measurement).then(function () {
                                    return phasorHub.queryMeasurement(signalReference).then(function (updatedMeasurement) {
                                        return addDynamicCalculatorAdapter(index, updatedMeasurement);
                                    })
                                    .fail(function (error) {
                                        showErrorMessage("Failed to lookup measurement " + signalReference + ": " + error, null, true);
                                    });
                                })
                                .fail(function (error) {
                                    showErrorMessage("Save failed for new measurement " + signalReference + ": " + error, null, true);
                                });
                            })
                            .fail(function (error) {
                                showErrorMessage("Failed to lookup or create measurement " + signalReference + ": " + error, null, true);
                            }));
                        }
                        else {
                            promises.push(addDynamicCalculatorAdapter(index));
                        }
                    }
                }

                return $(promises).whenAll();
            });
        }

        function saveCustomActionAdapter(tagTemplate) {
            return phasorHub.newCustomActionAdapter().then(function (adapter) {
                adapter.NodeID = nodeID;
                adapter.AdapterName = getCleanAcronym(tagTemplate.TagName);
                adapter.AssemblyName = tagTemplate.Equation;
                adapter.TypeName = tagTemplate.Type;
                adapter.ConnectionString = tagTemplate.Inputs.join(";");
                adapter.LoadOrder = 1;
                adapter.Enabled = true;

                return phasorHub.addNewOrUpdateCustomActionAdapter(adapter).then(function () {
                    return serviceHub.sendCommand("initialize " + adapter.AdapterName);
                })
                .fail(function (error) {
                    showErrorMessage("Save failed for new custom action adapter: " + error, null, true);
                });
            })
            .fail(function (error) {
                showErrorMessage("Failed to create new custom action adapter record: " + error, null, true);
            });
        }

        function saveTemplateCalculations(cell, index) {
            // Do not create calculations if only forwarding data
            if (viewModel.forwardOnly())
                return $.Deferred().resolve().promise();

            const templateType = viewModel.templateType();

            if (templateType.toUpperCase().startsWith("NONE:"))
                return $.Deferred().resolve().promise();

            const calcSignalType = getDeviceSignalType("CALC");

            if (calcSignalType == null && !errorDisplayed) {
                showErrorMessage("Cannot save tag template calculations: no signal type record found for 'CALC'", null, true);
                return $.Deferred().resolve().promise();
            }

            return phasorHub.loadTemplate(templateType).then(function (tagTemplates) {
                return phasorHub.validateCalculatorConfigurations(viewModel.historianID(), "@SystemName").then(function () {
                    return serviceHub.sendCommand("initialize PHASOR!AVERAGEFREQ").then(function () {
                        const promises = [];

                        let calculatePowerCount = 0;
                        let sumPhaseCount = 0;

                        for (let i = 0; i < tagTemplates.length; i++) {
                            const tagTemplate = tagTemplates[i];

                            switch (tagTemplate.Type.toUpperCase()) {
                                case "CALCULATEPOWER":
                                    calculatePowerCount++;
                                    break;
                                case "SUMPHASE":
                                    sumPhaseCount++;
                                    break;
                            }

                            if (calculatePowerCount > 0 && sumPhaseCount > 0)
                                break;
                        }

                        if (sumPhaseCount > 0 && calculatePowerCount === 0)
                            showErrorMessage("3-phase power calculations will be skipped because selected template \"" + templateType + "\" defines no power calculations...");

                        const sumPhaseTagTemplates = [];

                        for (let i = 0; i < tagTemplates.length; i++) {
                            const tagTemplate = tagTemplates[i];

                            switch (tagTemplate.Type.toUpperCase()) {
                                case "CALCULATEPOWER":
                                    promises.push(savePowerCalculations(cell, tagTemplate).then(function () {
                                        return serviceHub.sendCommand("initialize PHASOR!POWERCALC");
                                    }));
                                    break;
                                case "SUMPHASE":
                                    // Hold on to sum phase tag templates for later execution
                                    if (calculatePowerCount > 0)
                                        sumPhaseTagTemplates.push(tagTemplate);
                                    break;
                                case "DYNAMICCALCULATOR":
                                    promises.push(saveDynamicCalculation(cell, tagTemplate, i, "Calc", calcSignalType));
                                    break;
                                case "VALUEADJUSTER":
                                    promises.push(saveDynamicCalculation(cell, tagTemplate, i, "Adjust", calcSignalType));
                                    break;
                                case "VALUEFILTER":
                                    promises.push(saveDynamicCalculation(cell, tagTemplate, i, "Filter", calcSignalType));
                                    break;
                                default:
                                    // All other template types are assumed to be custom action adapter definitions. Since
                                    // these adpater definitions are singletons, only execute save for first device:
                                    if (index === 0)
                                        promises.push(saveCustomActionAdapter(tagTemplate));
                                    break;
                            }
                        }

                        return $(promises).whenAll().then(function () {
                            const sumPhasePromises = [];

                            // Sum phase templates are saved after power calculations have completed as they are dependent calculations
                            for (let i = 0; i < sumPhaseTagTemplates.length; i++) {
                                sumPhasePromises.push(saveSumPhase(cell, sumPhaseTagTemplates[i], calcSignalType));
                            }

                            return $(sumPhasePromises).whenAll();
                        });
                    })
                    .fail(function (error) {
                        showErrorMessage("Failed to validate calculator configurations: " + error, null, true);
                    });
                });
            })
            .fail(function (error) {
                showErrorMessage("Failed to load " + templateType + " tag template: " + error, null, true);
            });
        }

        function saveDeviceRecords(id) {
            const configFrame = viewModel.configFrame();
            const cells = configFrame.Cells;
            const cellCount = cells.length;

            if (cellCount === 0) {
                showErrorMessage("Cannot save device records: no devices were defined in loaded configuration.", null, true);
                return $.Deferred().resolve().promise();
            }

            if (configFrame.IsConcentrator || cellCount > 1) {
                let deviceSaveChain = $.Deferred().resolve();

                for (let i = 0; i < cellCount; i++) {
                    const index = i;
                    const cell = cells[index];

                    // Chain multiple devices saves behind one another...
                    deviceSaveChain = deviceSaveChain.then(function () {
                        showInfoMessage(String.format("Saving \"{0}\" device {1} / {2} please wait...", cell.IDLabel(), index + 1, cellCount), -1, true);

                        // Query existing child device record - function will create a new blank device record if one does not exist
                        return phasorHub.queryDeviceByID(cell.ID).then(function (device) {
                            // Check if this is a direct update to child device
                            if (cellCount === 1 && device.ID === id) {
                                cell.ID = id;

                                return phasorHub.updateDevice(device).then(function () {
                                    // Save measurements and calculations associated with a directly edited child device
                                    return saveDeviceMeasurements(cell).then(function () {
                                        return saveTemplateCalculations(cell, index);
                                    });
                                });
                            }
                            else {
                                // Set device properties
                                device.ParentID = cell.ParentID == null ? id : cell.ParentID;
                                device.HistorianID = viewModel.historianID();
                                device.ProtocolID = configFrame.ProtocolID;
                                device.FrameRate = configFrame.FrameRate;
                                device.AccessID = cell.IDCode;
                                device.Acronym = cell.IDLabel();

                                if (isEmpty(device.Name))
                                    device.Name = device.Acronym;

                                device.Enabled = true;

                                // Check if this is a new device or an edit to an existing one
                                if (device.ID === 0) {
                                    if (!isEmpty(cell.UniqueID))
                                        device.UniqueID = cell.UniqueID;

                                    // Add new device record
                                    return phasorHub.addNewDevice(device).then(function () {
                                        // Get newly added device with auto-incremented ID
                                        return phasorHub.queryDevice(device.Acronym).then(function (newDevice) {
                                            // Save associated device records...
                                            cell.ID = newDevice.ID;

                                            return saveDeviceMeasurements(cell).then(function () {
                                                return saveTemplateCalculations(cell, index);
                                            });
                                        })
                                        .fail(function (error) {
                                            showErrorMessage("Failed while querying new device " + device.Acronym + " - no measurements saved: " + error, null, true);
                                        });
                                    })
                                    .fail(function (error) {
                                        showErrorMessage("Save failed for new device " + device.Acronym + ": " + error, null, true);
                                    });
                                }
                                else {
                                    // Update existing device record
                                    return phasorHub.updateDevice(device).then(function () {
                                        // Save associated device records...
                                        cell.ID = device.ID;

                                        return saveDeviceMeasurements(cell).then(function () {
                                            return saveTemplateCalculations(cell, index);
                                        });
                                    })
                                    .fail(function (error) {
                                        showErrorMessage("Update failed for existing device " + device.Acronym + " - no measurements updated: " + error, null, true);
                                    });
                                }
                            }
                        })
                        .fail(function (error) {
                            showErrorMessage("Save failed for new device " + device.Acronym + " - could not create new or lookup existing device: " + error, null, true);
                        });
                    });
                }

                return deviceSaveChain.promise();
            }
            else {
                const cell = cells[0];
                cell.ID = id;

                // Save measurements and calculations  associated with a directly connected device
                return saveDeviceMeasurements(cell).then(function () {
                    return saveTemplateCalculations(cell, 0);
                });
            }
        }

        function saveDeviceConnection() {
            const configFrame = viewModel.configFrame();

            // Warn user to export config when phasors are tagged for deletion before save removes them permanently
            if (!viewModel.configExported()) {
                let anyTaggedForDelete = false;

                const cells = configFrame.Cells;
                const cellCount = cells.length;

                for (let i = 0; i < cellCount && !anyTaggedForDelete; i++) {
                    const cell = cells[i];

                    for (let j = 0; j < cell.PhasorDefinitions.length; j++) {
                        const phasorDefinition = cell.PhasorDefinitions[j];

                        if (phasorDefinition.TaggedForDelete()) {
                            anyTaggedForDelete = true;
                            break;
                        }
                    }
                }

                if (anyTaggedForDelete) {
                    if (confirm("Phasors are tagged for deletion: to preserve definitions, configuration should be exported before saving device record.\n\nDo you want to export config now?")) {
                        setTimeout(() => { $("#saveConfigurationFileNameDialogButton").click(); }, 100);
                        return $.Deferred().resolve().promise();
                    }
                    else if (!confirm("Skipping configuration export.\n\nDo you want to continue with saving device record?")) {
                        return $.Deferred().resolve().promise();
                    }
                }
            }

            if (!hubIsConnected) {
                showErrorMessage("Cannot save device connection, cannot connect to server.");
                return $.Deferred().resolve().promise();
            }

            showInfoMessage("Saving device connection, please wait...", -1, true);
            disableUIButtons();

            // Query existing device record - function will create a new blank device record if one does not exist
            return phasorHub.queryDeviceByID(deviceID).then(function (device) {
                // Set device properties
                let connectionString = configFrame.ConnectionString + "";
                const connectionStringMap = new Dictionary(connectionString.parseKeyValuePairs());
                let autoStartDataParsingSequence = true;
                let skipDisableRealTimeData = false;

                // Handle connection string parameters that are fields in the device table
                if (connectionStringMap.containsKey("autoStartDataParsingSequence")) {
                    autoStartDataParsingSequence = connectionStringMap.get("autoStartDataParsingSequence");
                    connectionStringMap.remove("autoStartDataParsingSequence");
                    connectionString = connectionStringMap.joinKeyValuePairs();
                }

                if (connectionStringMap.containsKey("skipDisableRealTimeData")) {
                    skipDisableRealTimeData = connectionStringMap.get("skipDisableRealTimeData");
                    connectionStringMap.remove("skipDisableRealTimeData");
                    connectionString = connectionStringMap.joinKeyValuePairs();
                }

                if (connectionString === "null")
                    connectionString = "";

                device.Acronym = viewModel.deviceAcronym();
                device.Name = viewModel.deviceName();
                device.Longitude = viewModel.longitude();
                device.Latitude = viewModel.latitude();
                device.HistorianID = viewModel.historianID();
                device.ProtocolID = configFrame.ProtocolID;
                device.FrameRate = configFrame.FrameRate;
                device.AccessID = configFrame.IDCode;
                device.IsConcentrator = !isEmpty(connectionString) && (configFrame.IsConcentrator || configFrame.Cells.length > 1);

                if (isEmpty(device.Name))
                    device.Name = device.Acronym;

                // Only update connection string if one has been defined, prevents changing any existing one to blank
                if (connectionString.length > 0)
                    device.ConnectionString = connectionString;

                device.AutoStartDataParsingSequence = autoStartDataParsingSequence;
                device.SkipDisableRealTimeData = skipDisableRealTimeData;
                device.Enabled = true;

                // Save serialized config JSON to server to it can be retrieved later restoring
                // records that were marked for deletion for possible re-association
                return saveDeviceConfiguration(device.Acronym, JSON.stringify(viewModel.serializeConfiguration(), null, 2)).done(function () {
                    // Check if this is a new device or an edit to an existing one
                    if (device.ID === 0) {
                        // Add new device record
                        return phasorHub.addNewDevice(device).then(function () {
                            // Get newly added device with auto-incremented ID
                            return phasorHub.queryDevice(device.Acronym).then(function (newDevice) {
                                // Save associated device records...
                                deviceID = newDevice.ID;

                                return saveDeviceRecords(deviceID).then(function () {
                                    enableUIButtons("Save complete.");

                                    serviceHub.sendCommand("initialize " + deviceID).done(function () {
                                        window.location = "GraphMeasurements.cshtml";
                                    });
                                });
                            })
                            .fail(function (error) {
                                showErrorMessage("Failed while querying new device " + device.Acronym + " - no measurements saved: " + error, null, true);
                                enableUIButtons();
                            });
                        })
                        .fail(function (error) {
                            showErrorMessage("Save failed for new device " + device.Acronym + ": " + error, null, true);
                            enableUIButtons();
                        });
                    }
                    else {
                        // Update existing device record
                        return phasorHub.updateDevice(device).then(function () {
                            // Save associated device records...
                            return saveDeviceRecords(device.ID).then(function () {
                                enableUIButtons("Save complete.");

                                const connectionID = device.ParentID ? device.ParentID : device.ID;

                                serviceHub.sendCommand("initialize " + connectionID).done(function () {
                                    window.location = "GraphMeasurements.cshtml";
                                });
                            });
                        })
                        .fail(function (error) {
                            showErrorMessage("Update failed for existing device " + device.Acronym + " - no measurements updated: " + error, null, true);
                            enableUIButtons();
                        });
                    }
                })
                .fail(function (error) {
                    showErrorMessage("Save failed for new device " + device.Acronym + " - could not create new or lookup existing device: " + error, null, true);
                    enableUIButtons();
                });
            })
            .fail(function (error) {
                showErrorMessage("Failed to save JSON config for new device " + device.Acronym + ": " + error, null, true);
                enableUIButtons();
            });
        }

        // Load existing device data
        function loadDeviceConnection(id) {
            if (!hubIsConnected)
                return;

            phasorHub.queryDeviceByID(id).done(function (device) {
                $("#editDeviceName").html("Editing&nbsp;" + device.Acronym);
                viewModel.deviceAcronym(device.Acronym);
                viewModel.longitude(device.Longitude);
                viewModel.latitude(device.Latitude);

                setTimeout(function () {
                    showInfoMessage("Loading existing configuration...");
                    loadDeviceConfiguration(device.Acronym).done(function (mapping) {
                        if (mapping && mapping.length > 0)
                            viewModel.loadConfiguration(new Blob([mapping], { type: "application/json" }), false);
                    });
                }, 100);
            })
            .fail(function (error) {
                showErrorMessage(String.format("Failed to load existing device \"{0}\": {1}", id, error), null, true);
            });
        }

        function getActiveTab() {
            return $("#tabs").tabs("option", "active");
        }

        function resizePageElements() {
            //if (deviceID === 0) {
            //    let width = $("#connectionSettings").hasClass("in") ?
            //        (getActiveTab() === 0 ? $("#inputConfigFile").width() : $("#inputConnectionString").width()) :
            //        $("#connectionSettingsPanel").width() * 0.60;

            //    $("#inputDeviceAcronym").width(width);
            //    $("#inputDeviceName").width(width);
            //}

            $("#contentWell").height(calculateRemainingBodyHeight() - $("#headerArea").outerHeight(true));
        }

        function disableUIButtons() {
            $("#inputConfigFile").disable();
            $("#saveData").disable();
            showLoadingLabel();
        }

        function enableUIButtons(message) {
            $("#inputConfigFile").enable();
            $("#saveData").enable();
            hideLoadingLabel();

            if (message === undefined)
                hideInfoMessage();
            else
                showInfoMessage(message);
        }

        function showConnectionBuilderDialog() {
            switch ($("#selectTransport").val()) {
                case "TCP":
                    $("#tcpBuilderDialog").show();
                    $("#inputTcpHostName").focus();
                    break;
                case "UDP":
                    $("#udpBuilderDialog").show();
                    $("#inputUdpPort").focus();
                    break;
                case "SERIAL":
                    $("#serialBuilderDialog").show();
                    $("#inputSerialPort").focus();
                    break;
                // TODO: case "FILE:"
            }
        }

        function applyTcpConnectionSettings() {
            viewModel.connectionString(String.format("hostName = {0}; port = {1}",
                $("#inputTcpHostName").val(),
                $("#inputTcpPort").val()));

            $("#tcpBuilderDialog").hide();
        }

        function applyUdpConnectionSettings() {
            viewModel.connectionString(String.format("port = {0}; interface = {1}",
                $("#inputUdpPort").val(),
                $("#inputUdpInterface").val()));

            $("#udpBuilderDialog").hide();
        }

        function applySerialConnectionSettings() {
            viewModel.connectionString(String.format("portName = COM{0}; baudRate = {1}; dataBits = {2}; parity = {3}; stopBits = {4}",
                $("#inputSerialPort").val(),
                $("#selectSerialBaudRate").val(),
                $("#inputSerialDataBits").val(),
                $("#selectSerialParity").val(),
                $("#selectSerialStopBits").val()));

            $("#serialBuilderDialog").hide();
        }

        function applyDeviceNameParameters() {
            // TODO: Build device name
            $("#deviceNameBuilderDialog").hide();
        }

        function connectToDevice() {
            $("#connectionStatus").collapse("hide");

            if (hubIsConnected) {
                //if (deviceConnected)
                //    dataHub.modbusDisconnect();
                //else
                //    dataHub.modbusConnect($("#inputConnectionString").val());
            } else {
                showErrorMessage("Device is inaccessible, cannot connect to server.", -1);
            }
        }

        function scrollConnectionStatusWindowToBottom() {
            const connectionStatusWindow = $("#connectionStatusWindow");
            connectionStatusWindow.scrollTop(connectionStatusWindow[0].scrollHeight);
        }

        function showSaveConfigurationFileNameDialog() {
            $("#saveConfigurationFileNameDialog").toggle();

            if ($("#saveConfigurationFileNameDialog").is(":visible")) {
                $("#inputConfigurationFileName").val(viewModel.deviceAcronym() + ".json");
                $("#inputConfigurationFileName").focus();
            }
        }

        function showLoadConfigurationFileNameDialog() {
            $("#loadConfigurationFileName").trigger("click");
        }

        function loadConfigurationFile(event) {
            viewModel.loadConfiguration(event.target.files[0]);
            $("#loadConfigurationFileName").val("");
        }

        function requestDeviceConfiguration() {
            if (!hubIsConnected)
                return;

            showInfoMessage("Requesting latest device configuration...", -1, true);

            phasorHub.queryDeviceByID(deviceID).done(function (device) {
                showInfoMessage("Device configuration request complete, analyzing...", null, true);
                viewModel.analyzeConfig(device.ConnectionString);
            })
            .fail(function (error) {
                hideInfoMessage();
                showErrorMessage(String.format("Failed to load record for existing device \"{0}\": {1}", deviceID, error), null, true);
            });
        }

        // Page initialization function
        $(function () {
            $("#tabs").tabs({
                active: 0,
                activate: function (event, ui) {
                    switch (ui.newPanel.attr("id")) {
                        case "tab1":
                            break;
                        case "tab2":
                            break;
                    }

                    resizePageElements();
                }
            });

            // Connect to phasor hub
            phasorHub = $.connection.phasorHub.server;
            phasorHubClient = $.connection.phasorHub.client;

            // Create hub client functions for message control
            function encodeInfoMessage(message, timeout) {
                // Html encode message
                const encodedMessage = $("<div />").text(message).html();
                showInfoMessage(encodedMessage, timeout, true);
            }

            function encodeErrorMessage(message, timeout) {
                // Html encode message
                const encodedMessage = $("<div />").text(message).html();
                showErrorMessage(encodedMessage, timeout, true);
            }

            // Register info and error message handlers for each hub client
            phasorHubClient.sendInfoMessage = encodeInfoMessage;
            phasorHubClient.sendErrorMessage = encodeErrorMessage;

            $("#bodyContainer").addClass("fill-height");

            // Define local rule that will check that device acronym is unique in the database
            ko.validation.rules["deviceUniqueInDatabase"] = {
                async: true,
                validator: function (newVal, options, callback) {
                    if (viewModel.phasorHubIsConnected()) {
                        // Lookup Device record by Acronym - this will return an empty record if not found
                        phasorHub.queryDevice(newVal).done(function (device) {
                            // Valid if device doesn't exist or is itself
                            callback(device.ID === 0 || device.ID === options);
                        })
                        .fail(function (error) {
                            showErrorMessage(error);

                            // Do not display validation failure message for connection issues
                            callback(true);
                        });
                    }
                    else {
                        callback(true);
                    }
                },
                message: "This device acronym already exists in the database. Acronyms must be unique."
            };

            ko.bindingHandlers.selectOnError = {
                init: function (element, valueAccessor) {
                    $(element).on("input", function(event) {
                        setTimeout(function () {
                            if (!valueAccessor().isValid())
                                element.select();
                        }, 1);
                    });
                }
            };

            // Enable knockout validation
            ko.validation.init({
                registerExtenders: true,
                messagesOnModified: true,
                insertMessages: true,
                parseInputAttributes: true,
                allowHtmlMessages: true,
                messageTemplate: null,
                decorateElement: true,
                errorElementClass: "has-error",
                errorMessageClass: "help-block",
                grouping: { deep: true, observable: true, live: true }
            }, true);

            // Enable deferred updates for better performance
            ko.options.deferUpdates = true;

            // Create the primary view model
            viewModel = new DeviceViewModel();

            // Initialize primary view model
            ko.applyBindings(viewModel, document.body);

            // Monitor for view model changes
            ko.watch(viewModel.devices, { depth: -1 }, function (parents, child, item) {
                viewModel.isDirty(true);
            });

            $("#connectionSettings").on("shown.bs.collapse", function() {
                resizePageElements();
            });

            $("#connectionSettings").on("hidden.bs.collapse", function() {
                resizePageElements();
            });

            $("#connectionStatus").on("shown.bs.collapse", function() {
                scrollConnectionStatusWindowToBottom();
            });

            $("#tcpBuilderDialog").modal({
                show: false,
                backdrop: "static",
                keyboard: false
            });

            $("#udpBuilderDialog").modal({
                show: false,
                backdrop: "static",
                keyboard: false
            });

            $("#serialBuilderDialog").modal({
                show: false,
                backdrop: "static",
                keyboard: false
            });

            $("#saveDeviceConnectionDialog").modal({
                show: false,
                backdrop: "static",
                keyboard: false
            });

            $("#deviceNameBuilderDialog").modal({
                show: false,
                backdrop: "static",
                keyboard: false
            });

            $("#inputTcpHostName").focus(function() {
                $(this).select();
            });

            $("#inputTcpPort").focus(function() {
                $(this).select();
            });

            $("#inputUdpPort").focus(function() {
                $(this).select();
            });

            $("#inputUdpInterface").focus(function() {
                $(this).select();
            });

            $("#inputSerialPort").focus(function() {
                $(this).select();
            });

            $("#inputSerialDataBits").focus(function() {
                $(this).select();
            });

            $("#inputDeviceAcronym").focus(function() {
                $(this).select();
            });

            $("#inputDeviceName").focus(function() {
                $(this).select();
            });

            $("#inputESPMarker").focus(function() {
                $(this).select();
            });

            $("#inputNonESPMarker").focus(function() {
                $(this).select();
            });

            $("#latitude").focus(function() {
                $(this).select();
            });

            $("#longitude").focus(function() {
                $(this).select();
            });

            // Let view model know about hub connectivity changes
            $(window).on("hubConnected", function () {
                viewModel.phasorHubIsConnected(true);

                if (!firstConnect)
                    return;

                firstConnect = false;

                if (deviceID > 0)
                    loadDeviceConnection(deviceID);

                const instanceNameSelect = $("#instanceName");

                // Load available historian instance names, if not already loaded
                if (instanceNameSelect.children("option").length === 0) {
                    dataHub.getInstanceNames().done(function (names) {
                        instanceNameSelect.append($("<option>", { value: null, text: 'Do Not Archive' }));

                        for (let i = 0; i < names.length; i++) {
                            const value = names[i];
                            instanceNameSelect.append($("<option>", { value: value, text: value }));
                        }

                        // Select last value
                        var lastInstanceName = Cookies.get("instanceName");

                        if (lastInstanceName === undefined) {
                            // Assume name of PPA as default, if defined
                            if (names.indexOf("PPA") !== -1)
                                lastInstanceName = "PPA";
                            // Otherwise select first available historian
                            else if (names.length > 1)
                                lastInstanceName = instanceNameSelect.eq(1).val();
                        }

                        if (!isEmpty(lastInstanceName))
                            instanceNameSelect.val(lastInstanceName);

                        setTimeout(function () {
                            viewModel.instanceName(lastInstanceName);
                        }, 200);
                    });
                }

                const protocolSelect = $("#selectProtocol");

                // Load available synchrophasor protocols, if not already loaded
                if (protocolSelect.children("option").length === 0) {
                    phasorHub.getSynchrophasorProtocols().done(function (protocols) {
                        for (let i = 0; i < protocols.length; i++) {
                            const protocol = protocols[i];
                            protocolSelect.append($("<option>", { value: protocol.Acronym, text: protocol.Name }));
                        }

                        protocolSelect.autoSizeSelect();
                    });
                }

                const templateTypeSelect = $("#templateType");

                // Load available calculation templates, if not already loaded
                if (templateTypeSelect.children("option").length === 0) {
                    phasorHub.getTemplateTypes().done(function (names) {
                        for (let i = 0; i < names.length; i++) {
                            const value = names[i];
                            templateTypeSelect.append($("<option>", { value: value, text: value }));
                        }

                        // Select last value
                        var lastTemplateType = Cookies.get("templateType");

                        if (lastTemplateType === undefined)
                            lastTemplateType = templateTypeSelect.eq(0).val();

                        if (!isEmpty(lastTemplateType))
                            instanceNameSelect.val(lastTemplateType);

                        setTimeout(function () {
                            viewModel.templateType(lastTemplateType);
                        }, 200);
                    });
                }

                phasorHub.loadSignalTypes("PMU").then(function (result) {
                    deviceSignalTypes = result;

                    return phasorHub.loadSignalTypes("Phasor").then(function (result) {
                        phasorSignalTypes = result;

                        if (deviceID > 0)
                            viewModel.loadExisting();
                    });
                });
            });

            $(window).on("hubDisconnected", function () {
                viewModel.phasorHubIsConnected(false);
            });

            $(window).on("messageVisibiltyChanged", function () {
                resizePageElements();
            });

            $(window).resize(function () {
                resizePageElements();
            });

            // Define button handlers
            $("#saveData").click(function() {
                saveDeviceConnection();
            });

            $("#inputConfigFile").change(function(event){
                const uploadedFile = event.target.files[0];

                if (uploadedFile) {
                    const readFile = new FileReader();

                    readFile.onload = function(event) {
                        viewModel.analyzeConfig(event.target.result);
                    };

                    readFile.readAsText(uploadedFile);
                }

                $("#inputConfigFile").tooltip("hide");
            });

            // Setup save configuration file name dialog functionality
            $("#saveConfigurationFile").click(function() {
                $("#saveConfigurationFileNameDialog").hide();

                var fileName = notNull($("#inputConfigurationFileName").val());

                if (fileName.length === 0)
                    fileName = viewModel.deviceAcronym() + ".json";

                if (!fileName.endsWith(".json"))
                    fileName += ".json";

                viewModel.saveConfiguration(fileName);
            });

            // Make enter key auto-click save
            $("#inputConfigurationFileName").keyup(function(event) {
                if (event.keyCode === 13)
                    $("#saveConfigurationFile").click();
            });

            // Auto-select all text on focus
            $("#inputConifgurationFileName").focus(function() {
                $(this).select();
            });

            // Prevent default form submission when user presses enter
            $("#saveConfigurationFileNameDialog").submit(function() {
                return false;
            });

            // Auto-hide pop-up form when user clicks outside form area
            $("#saveConfigurationFileNameDialog").focusout(function() {
                if (!$("#saveConfigurationFileNameDialog").is(":hover") && !$("#saveConfigurationFileNameDialogButton").is(":hover"))
                    $("#saveConfigurationFileNameDialog").hide();
            });

            resizePageElements();

            if (deviceID === 0)
                hideLoadingLabel();
        });
    </script>
}
<div id="headerArea">
    <h3 style="margin-top: -10px;">
        @ViewBag.Title <span class="label label-info" id="editDeviceName"></span> <!--img class="page-logo pull-right" src="Images/AddDevice.png" /-->
        <span class="form-inline pull-right clearfix">
            <small>
                Instance:&nbsp;<select class="form-control" id="instanceName" data-bind="value: instanceName; valueAllowUnset: true" style="border: 0; width: 140px"></select>
            </small>
        </span>
    </h3>
    <div>
        <table style="width: 100%">
            <tr>
                <td colspan="2">
                    @* Connection Settings and Status Panel *@
                    <div class="panel panel-primary" id="connectionSettingsPanel" style="margin: 2px">
                        <div class="panel-heading panel-heading-condensed clearfix" onclick="$('#connectionSettings').collapse('toggle')">
                            <label>
                                Connection&nbsp;Settings
                            </label>
                            <div class="pull-right">
                                <span id="notConnected" style="display: none">Not&nbsp;Connected&nbsp;&nbsp;<span class="glyphicon glyphicon-ban-circle" style="color: #FF003B;"></span></span>&nbsp;&nbsp;
                                <span id="attemptingConnection" style="display: none">Attempting&nbsp;Connection&nbsp;&nbsp;<span class="glyphicon glyphicon-refresh glyphicon-spin" style="color: yellow"></span></span>&nbsp;&nbsp;
                                <span id="connected" style="display: none">Connected&nbsp;&nbsp;<span class="glyphicon glyphicon-check" style="color: chartreuse"></span></span>
                                <button type="button" class="btn btn-xs btn-collapsable" data-toggle="collapse" data-target="#connectionSettings"></button>
                            </div>
                            <span class="pull-right clearfix" id="loadingDataLabel" style="display: inline; color: white; margin-right: -10px">
                                Loading&nbsp;&nbsp;<span class="glyphicon glyphicon-refresh glyphicon-spin"></span>
                            </span>
                        </div>
                        <div class="panel-body collapse" data-bind="css: {'in': deviceID === 0}" id="connectionSettings" style="padding: 2px 6px">
                            <div id="tabs">
                                <ul>
                                    <li>
                                        <a href="#tab1">Use Connection File</a>
                                    </li>
                                    <li style="display: none">
                                        @* TODO: Complete Build Connection Tab *@
                                        <a href="#tab2">Build Connection</a>
                                    </li>
                                </ul>
                                <hr style="margin: 0; border-top-color: lightgray" />
                                <div class="input-group pull-right" style="margin-top: -35px">
                                    <div class="checkbox" style="display: none">
                                        <label><input type="checkbox" data-bind="checked: forwardOnly"> Forward&nbsp;Only</label>
                                    </div>
                                </div>
                                <div id="tab1" class="ui-tabs-active">
                                    <table style="width: 100%">
                                        <tr>
                                            <td class="input-label" style="width: 150px">
                                                <label for="inputConfigFile" style="white-space: nowrap">Connection File:</label>
                                            </td>
                                            <td>
                                                <div class="input-group input-area">
                                                    <input id="inputConfigFile" type="file" placeholder="Connection file name..." title="Select&nbsp;PMUConnection&nbsp;file..." accept=".PmuConnection,.xml" data-toggle="tooltip" data-placement="right" class="form-control" style="width: 100%">
                                                </div>
                                            </td>
                                        </tr>
                                    </table>
                                </div>
                                <div id="tab2" style="display: none">
                                    <form class="form-hortizontal" role="form">
                                        <div class="row">
                                            <div class="form-group">
                                                <label class="col-md-2 control-label top-padding text-right text-nowrap col-input offset-width" for="selectProtocol">Protocol:</label>
                                                <div class="col-md-3">
                                                    <select class="form-control" id="selectProtocol" @*data-bind="value: frameFormat"*@>
                                                    </select>
                                                </div>
                                                <label class="col-md-2 control-label top-padding text-right text-nowrap col-input" for="selectTransport">Transport:</label>
                                                <div class="col-md-1">
                                                    <select class="form-control" id="selectTransport" style="width: 85px" @*data-bind="value: transport"*@>
                                                        <option value="TCP">TCP</option>
                                                        <option value="UDP">UDP</option>
                                                        <option value="SERIAL">Serial</option>
                                                        <option value="FILE">File</option>
                                                    </select>
                                                </div>
                                            </div>
                                            <div class="form-group" style="padding-top: 0; margin-top: -15px;" @*data-bind="validationElement: unitID"*@>
                                                <label class="col-md-2 control-label top-padding text-right text-nowrap col-input" for="inputUnitID">Access ID:</label>
                                                <div class="col-md-2">
                                                    <input type="number" class="form-control" id="inputUnitID" @*data-bind="integer, textInput: unitID"*@>
                                                </div>
                                            </div>
                                        </div>
                                        <div class="row">
                                            <div class="form-group">
                                                <label class="col-md-2 control-label top-padding text-right text-nowrap col-input offset-width" for="inputConnectionString">Connection String:</label>
                                                <div class="col-md-10">
                                                    <div class="input-group">
                                                        <input type="text" class="form-control" id="inputConnectionString" data-bind="textInput: connectionString">
                                                        <span class="input-group-btn">
                                                            <button type="button" class="btn btn-default" onclick="showConnectionBuilderDialog()"><span class="glyphicon glyphicon-edit glyphicon-action-button"></span> Build...</button>
                                                            <button type="button" class="btn btn-primary" style="margin-left: 5px" onclick="connectToDevice()" title="Connect to Device" hub-dependent><span class="glyphicon glyphicon-transfer" style="vertical-align: text-top"></span> <strong id="connectButtonLabel">Connect</strong>&nbsp;</button>
                                                        </span>
                                                    </div>
                                                </div>
                                            </div>
                                        </div>
                                        <div class="panel panel-default" style="margin: 5px 1px">
                                            <div class="panel-heading panel-heading-condensed" onclick="$('#connectionStatus').collapse('toggle')">
                                                <label>Connection&nbsp;Status</label>
                                                <button type="button" class="btn btn-xs btn-collapsable collapsed" data-toggle="collapse" data-target="#connectionStatus"></button>
                                            </div>
                                            <div class="panel-body collapse" style="padding: 2px" id="connectionStatus">
                                                <pre id="connectionStatusWindow" class="small connection-status" style="height: 150px"></pre>
                                            </div>
                                        </div>
                                    </form>
                                </div>
                            </div>
                        </div>
                    </div>
                </td>
            </tr>
            <tr>
                <td class="input-label">
                    <label for="inputDeviceAcronym"><span data-bind="text: configFrame().Cells.length == 1 ? 'Device' : 'Connection'">Connection</span> Acronym:</label>
                </td>
                <td>
                    <div class="input-group" data-bind="css: { 'has-error': !fieldIsValid(deviceAcronym, true), 'has-feedback': !fieldIsValid(deviceAcronym, true) }">
                        <input id="inputDeviceAcronym" type="text" class="form-control" style="width: 260px" data-bind="acronym: deviceAcronym, textInput: deviceAcronym, disable: readOnly" required>
                        <span class="glyphicon glyphicon-remove form-control-feedback" data-bind="visible: !fieldIsValid(deviceAcronym, true)"></span>
                    </div>
                    @if (userIsEditor)
                    {
                        <div class="input-group save-button pull-right">
                            <button type="button" class="btn btn-primary save-button pull-right" id="saveData" data-bind="disable: !isDirty() && (working() || validationErrors() > 0 || !phasorHubIsConnected())">
                                <span class="glyphicon glyphicon-plus"></span>&nbsp;&nbsp;Save&nbsp;Device&nbsp;
                            </button>
                        </div>
                    }
                    else
                    {
                        <div class="label label-danger label-md no-access pull-right" style="">
                            User "@GetCurrentUserID()" does not have rights to add or modify device data.
                        </div>
                    }
                </td>
            </tr>
            <tr>
                <td class="input-label">
                    <label for="inputDeviceName"><span data-bind="text: configFrame().Cells.length == 1 ? 'Device' : 'Connection'">Connection</span> Name:</label>
                </td>
                <td>
                    <div class="input-group" data-bind="css: { 'has-error': !fieldHasValue(deviceName, true), 'has-feedback': !fieldHasValue(deviceName, true) }">
                        <input id="inputDeviceName" type="text" class="form-control" style="width: 260px" data-bind="textInput: deviceName, disable: readOnly" required>
                        @*<button type="button" class="input-group-addon" onclick="$('#deviceNameBuilderDialog').show()" data-bind="hidden: readOnly" style="line-height: inherit; width: 55px; margin-left: -1px; border-radius: 4px; border-top-left-radius: 0; border-bottom-left-radius: 0">Build</button>*@
                        <span class="glyphicon glyphicon-remove form-control-feedback" data-bind="visible: !fieldHasValue(deviceName, true), style: { 'margin-right': readOnly() ? undefined: '54px' }"></span>
                    </div>
                    <div class="input-group save-button pull-right">
                        <button type="button" class="btn btn-default save-button pull-right" onclick="showSaveConfigurationFileNameDialog()" id="saveConfigurationFileNameDialogButton" data-bind="enable: configFrame().Cells.length > 0">
                            <span class="glyphicon glyphicon-floppy-save glyphicon-action-button"></span>&nbsp;Export&nbsp;Config
                        </button>
                    </div>
                    <div class="well well-sm floating-form" id="saveConfigurationFileNameDialog" style="z-index: 1000">
                        <form class="form-inline" role="form">
                            <div class="form-group form-group-sm">
                                <button type="button" class="close" onclick="$('#saveConfigurationFileNameDialog').hide()" style="margin-top: -13px; margin-left: 8px">&times;</button>
                                <div class="input-group">
                                    <input type="text" class="form-control" id="inputConfigurationFileName" placeholder="File name..."/>
                                    <span class="input-group-btn">
                                        <button type="button" class="btn btn-default btn-sm" id="saveConfigurationFile" style="margin-right: -3px; font-weight: bold">Save</button>
                                    </span>
                                </div>
                            </div>
                        </form>
                    </div>
                    <a href="#" id="saveConfigurationFileLink" target="_blank" style="display: none"></a>
                </td>
            </tr>
            <tr>
                <td class="input-label">
                    <label for="latitude">Latitude:</label>
                </td>
                <td>
                    <table>
                        <tr>
                            <td>
                                <div class="input-group">
                                    <input class="form-control" id="latitude" type="number" data-bind="textInput: latitude" style="width: 89px; border-radius: 4px; border-top-right-radius: 0; border-bottom-right-radius: 0">
                                </div>
                            </td>
                            <td class="input-label" style="width: 10px; padding-right: 4px">
                                <label for="longitude">Longitude:</label>
                            </td>
                            <td>
                                <div class="input-group">
                                    <input class="form-control" id="longitude" type="number" data-bind="textInput: longitude" style="width: 89px; border-radius: 4px; border-top-right-radius: 0; border-bottom-right-radius: 0">
                                </div>
                            </td>
                        </tr>
                    </table>
                    @if (userIsEditor)
                    {
                        <div class="input-group save-button pull-right">
                            <button type="button" class="btn btn-default save-button pull-right" onclick="showLoadConfigurationFileNameDialog()">
                                <span class="glyphicon glyphicon-import glyphicon-action-button"></span>&nbsp;Import&nbsp;Config&nbsp;
                            </button>
                        </div>
                        <input id="loadConfigurationFileName" type="file" accept="text/json" style="position: fixed; top: -100em" onchange="loadConfigurationFile(event)">
                    }
                </td>
            </tr>
            <tr>
                <td class="input-label">
                    <label for="templateType" data-bind="css: { 'disabled': forwardOnly }">Tag Template:</label>
                </td>
                <td>
                    <div class="input-group">
                        <select class="form-control" id="templateType" data-bind="value: templateType, valueAllowUnset: false, disable: forwardOnly" style="border: 1px solid #ccc; width: 260px"></select>
                        <div class="checkbox" style="display:inline; margin-left: 15px">
                            <label class="disabled" style="margin-top: 6px; display: none"><input type="checkbox" data-bind="checked: addTagsAsVirtualPoints" disabled> Generate virtual tags (otherwise tags will be archived)</label>
                        </div>
                    </div>
                    <div class="input-group save-button pull-right" style="margin-top: -29px; margin-bottom: 4px">
                        <button type="button" class="btn btn-default save-button pull-right" onclick="requestDeviceConfiguration()">
                            <span class="glyphicon glyphicon-refresh glyphicon-action-button"></span>&nbsp;Request&nbsp;Config
                        </button>
                    </div>
                </td>
            </tr>
        </table>
    </div>
</div>
<div id="contentWell" class="well well-dynamic-content">
    <div id="responsiveTableDiv" class="table-responsive" style="display: none; border: none">
        <span id="configFrameDetails">Config Frame: <span data-bind="html: configFrameDetails"></span></span>
        <div class="pull-right" style="text-align: right">
            <div class="input-group pull-right" style="margin-top: -4px">
                <form class="form-inline" style="padding-bottom: 4px">
                    <div class="checkbox">
                        <label><input type="checkbox" data-bind="checked: addAnalogs"> Add Analogs</label>
                    </div>
                    <div class="checkbox" style="padding-left: 5px;">
                        <label><input type="checkbox" data-bind="checked: addDigitals"> Add Digitals</label>
                    </div>
                </form>
            </div>
        </div>
        <span><br />Connection String: <span data-bind="text: connectionString"></span></span>
        <em data-bind="visible: validationErrors() > 0">
            <br />
            <span data-bind="text: validationErrors()"></span> validation error<span data-bind="visible: validationErrors() > 1">s</span>...
        </em>
        <hr class="quarter-break" />
        <div id="configInfo"></div>

        <!-- Voltages Section -->
        <div id="voltagesSection" class="col-md-6">
            <h3>Voltages</h3>
            <table class="table table-condensed table-striped table-hover">
                <thead>
                <tr>
                    <!-- ko if: configFrame().Cells.length > 1 -->
                    <th class="text-left">Device&nbsp;Acronym</th>
                    <!-- /ko -->
                    <th class="text-left">Phasor&nbsp;Label</th>
                    <th class="text-center">Phase</th>
                    <th class="text-left">Nominal&nbsp;Voltage</th>
                </tr>
                </thead>
                <tbody data-bind="foreach: { data: voltages }">
                <!-- ko if: $index() > 0 && FirstVoltage && $parent.configFrame().Cells.length > 1 -->
                <tr id="voltageRow" class="separator-top">
                    <td colspan="4" style="padding: 2px"></td>
                </tr>
                <tr id="voltageRow" class="separator-bottom">
                    <td colspan="4" style="padding: 2px"></td>
                </tr>
                <!-- /ko -->
                <tr id="voltageRow" style="visibility: hidden" data-bind="style: { 'background-color': TaggedForDelete() ? 'red' : '' }">
                    <!-- ko if: !FirstVoltage && $parent.configFrame().Cells.length > 1 -->
                    <td width="190px" class="text-left" style="padding-right: 20px">
                        <div class="input-group"></div>
                    </td>
                    <!-- /ko -->
                    <!-- ko if: FirstVoltage && $parent.configFrame().Cells.length > 1 -->
                    <td width="190px" class="text-left" style="padding-right: 20px">
                        <span class="org-label" data-bind="visible: OriginalLabel != Label()">&nbsp;</span>
                        <div class="input-group" data-bind="css: { 'has-error': !fieldIsValid(Device.IDLabel, true), 'has-feedback': !fieldIsValid(Device.IDLabel, true) }">
                            <input type="text" class="form-control" style="width: 180px" data-bind="acronym: Device.IDLabel, textInput: Device.IDLabel, disable: $parent.readOnly() || !$data.Enabled()" required>
                            <span class="glyphicon glyphicon-remove form-control-feedback" data-bind="visible: !fieldIsValid(Device.IDLabel, true)"></span>
                        </div>
                    </td>
                    <!-- /ko -->
                    <td width="210px" class="text-left" style="position: sticky">
                        <span class="org-label" data-bind="text: OriginalLabel, visible: OriginalLabel != Label()"></span>
                        <div class="checkbox include-phasor" title="Include phasor when saving">
                            <input type="checkbox" class="include-phasor" data-bind="checked: Enabled">
                        </div>
                        <div class="delete-phasor" title="Mark phasor for deletion" data-bind="click: TaggedForDelete.bind($data, true)"><span class="glyphicon glyphicon-remove glyphicon-action-button delete-phasor"></span></div>
                        <div class="input-group" data-bind="css: { 'has-error': !fieldIsValid(Label, true), 'has-feedback': !fieldIsValid(Label, true), 'error-margin': !fieldIsValid(Label, true) }">
                            <input type="text" class="form-control" style="width: 240px" data-bind="acronym: Label, textInput: Label, disable: $parent.readOnly() || !$data.Enabled()" required>
                            <span class="glyphicon glyphicon-remove form-control-feedback" style="z-index: 5" data-bind="visible: !fieldIsValid(Label, true)"></span>
                        </div>
                        <span class="tag-name-label">Tag name:&nbsp;</span><span class="tag-name" data-bind="text: TaggedForDelete() ? '*** MARKED FOR DELETION ***' : Enabled() ? TagName() : '*** REMOVED FROM UPDATE ***'"></span>
                    </td>
                    <td width="55px" class="text-center">
                        <span class="org-label" data-bind="visible: OriginalLabel != Label()">&nbsp;</span>
                        <div class="input-group" data-bind="css: { 'has-error': !fieldIsValid(Phase, true), 'has-feedback': !fieldIsValid(Phase, true), 'error-margin': !fieldIsValid(Phase, true) }">
                            <input type="text" class="form-control" maxlength="1" style="width: 37px; margin-left: 3px" onclick="this.select()" data-bind="upperCase: Phase, textInput: Phase, style: { width: Phase.isValid() ? '37px' : '75px' }, selectOnError: Phase, enable: Enabled" placeholder="Ø" required>
                            <span class="glyphicon glyphicon-remove form-control-feedback" style="z-index: 5" data-bind="visible: !fieldIsValid(Phase, true)"></span>
                        </div>
                    </td>
                    <td class="text-left">
                        <span class="org-label" data-bind="visible: OriginalLabel != Label()">&nbsp;</span>
                        <div class="input-group" data-bind="css: { 'has-error': !fieldIsValid(NominalVoltage, true), 'has-feedback': !fieldIsValid(NominalVoltage, true), 'error-margin':! fieldIsValid(NominalVoltage, true) }">
                            <input type="text" class="form-control" style="width: 70px; margin-left: 10px" data-bind="integer: NominalVoltage, textInput: NominalVoltage, enable: Enabled" required>&nbsp;<span class="table-cell-text">kV</span>
                            <span class="glyphicon glyphicon-remove form-control-feedback" style="z-index: 5; width: 65px" data-bind="visible: !fieldIsValid(NominalVoltage, true)"></span>
                        </div>
                    </td>
                </tr>
                </tbody>
            </table>
        </div>

        <!-- Currents Section -->
        <div id="currentsSection" class="col-md-6">
            <h3>Currents</h3>
            <table class="table table-condensed table-striped table-hover">
                <thead>
                <tr>
                    <!-- ko if: configFrame().Cells.length > 1 -->
                    <th class="text-left">Device&nbsp;Acronym</th>
                    <!-- /ko -->
                    <th class="text-left">Phasor&nbsp;Label</th>
                    <th class="text-center">Phase</th>
                    <th class="text-left">Associated&nbsp;Voltage</th>
                </tr>
                </thead>
                <tbody data-bind="foreach: { data: currents }">
                <!-- ko if: $index() > 0 && FirstCurrent && $parent.configFrame().Cells.length > 1 -->
                <tr id="currentRow" class="separator-top">
                    <td colspan="4" style="padding: 2px"></td>
                </tr>
                <tr id="currentRow" class="separator-bottom">
                    <td colspan="4" style="padding: 2px"></td>
                </tr>
                <!-- /ko -->
                <tr id="currentRow" style="visibility: hidden" data-bind="style: { 'background-color': TaggedForDelete() ? 'red' : '' }">
                    <!-- ko if: !FirstCurrent && $parent.configFrame().Cells.length > 1 -->
                    <td width="190px" class="text-left" style="padding-right: 20px">
                        <div class="input-group"></div>
                    </td>
                    <!-- /ko -->
                    <!-- ko if: FirstCurrent && $parent.configFrame().Cells.length > 1 -->
                    <td width="190px" class="text-left" style="padding-right: 20px">
                        <span class="org-label" data-bind="visible: OriginalLabel != Label()">&nbsp;</span>
                        <div class="input-group" data-bind="css: { 'has-error': !fieldIsValid(Device.IDLabel, true), 'has-feedback': !fieldIsValid(Device.IDLabel, true) }">
                            <input type="text" class="form-control" style="width: 180px" data-bind="acronym: Device.IDLabel, textInput: Device.IDLabel, disable: $parent.readOnly() || !$data.Enabled()" required>
                            <span class="glyphicon glyphicon-remove form-control-feedback" data-bind="visible: !fieldIsValid(Device.IDLabel, true)"></span>
                        </div>
                    </td>
                    <!-- /ko -->
                    <td width="210px" class="text-left" style="position: sticky">
                        <span class="org-label" data-bind="text: OriginalLabel, visible: OriginalLabel != Label()"></span>
                        <div class="checkbox include-phasor" title="Include phasor when saving">
                            <input type="checkbox" class="include-phasor" data-bind="checked: Enabled">
                        </div>
                        <div class="delete-phasor" title="Mark phasor for deletion" data-bind="click: TaggedForDelete.bind($data, true)"><span class="glyphicon glyphicon-remove glyphicon-action-button delete-phasor"></span></div>
                        <div class="input-group" data-bind="css: { 'has-error': !fieldIsValid(Label, true), 'has-feedback': !fieldIsValid(Label, true), 'error-margin': !fieldIsValid(Label, true) }">
                            <input type="text" class="form-control" style="width: 200px" data-bind="acronym: Label, textInput: Label, disable: $parent.readOnly() || !$data.Enabled()" required>
                            <span class="glyphicon glyphicon-remove form-control-feedback" style="z-index: 5" data-bind="visible: !fieldIsValid(Label, true)"></span>
                        </div>
                        <span class="tag-name-label">Tag name:&nbsp;</span><span class="tag-name" data-bind="text: TaggedForDelete() ? '*** MARKED FOR DELETION ***' : Enabled() ? TagName() : '*** REMOVED FROM UPDATE ***'"></span>
                    </td>
                    <td width="55px" class="text-center">
                        <span class="org-label" data-bind="visible: OriginalLabel != Label()">&nbsp;</span>
                        <div class="input-group" data-bind="css: { 'has-error': !fieldIsValid(Phase, true), 'has-feedback': !fieldIsValid(Phase, true), 'error-margin': !fieldIsValid(Phase, true)}">
                            <input type="text" class="form-control" maxlength="1" style="width: 37px; margin-left: 3px" onclick="this.select()" data-bind="upperCase: Phase, textInput: Phase, style: { width: Phase.isValid() ? '37px' : '75px' }, selectOnError: Phase, enable: Enabled" placeholder="Ø" required>
                            <span class="glyphicon glyphicon-remove form-control-feedback" style="z-index: 5" data-bind="visible: !fieldIsValid(Phase, true)"></span>
                        </div>
                    </td>
                    <td class="text-left">
                        <span class="org-label" data-bind="visible: OriginalLabel != Label()">&nbsp;</span>
                        <select class="form-control" style="width: 85%" data-bind="options: DeviceVoltages, optionsCaption: 'None', value: AssociatedVoltage, optionsText: associatedVoltageLabel, optionsValue: 'ID', valueAllowUnset: true, enable: Enabled, select2: { templateSelection: formatAssociatedVoltageLabel, templateResult: formatAssociatedVoltageLabel, minimumResultsForSearch: -1, theme: 'bootstrap' }"></select>
                    </td>
                </tr>
                </tbody>
            </table>
        </div>
    </div>
</div>
@* JSON Serialized Configuration Display Panel *@
<hr class="thick-spacer" />
<div class="panel panel-default">
    <div class="panel-heading panel-heading-condensed" onclick="$('#serializedConfiguration').collapse('toggle')">
        <label>Serialized&nbsp;Configuration</label>
        <button type="button" class="btn btn-xs btn-collapsable collapsed" style="top: 0; right: -10px" data-toggle="collapse" data-target="#serializedConfiguration"></button>
    </div>
    <div class="panel-body collapse" style="padding: 2px; margin-bottom: -10px" id="serializedConfiguration">
        <pre data-bind="text: JSON.stringify(serializeConfiguration(), null, 2)"></pre>
    </div>
</div>
@* TCP Connection String Builder *@
<div id="tcpBuilderDialog" class="modal" role="dialog">
    <div class="modal-dialog modal-md">
        <div class="modal-content">
            <div class="modal-header">
                <button type="button" class="close" onclick="$('#tcpBuilderDialog').hide()">&times;</button>
                <h4 class="modal-title">Define TCP Connection Parameters</h4>
            </div>
            <div class="modal-body">
                <form role="form">
                    <div class="form-group" @*data-bind="validationElement: hostName"*@>
                        <label for="inputTcpHostName">Host Name or IP:</label>
                        <input type="text" class="form-control" id="inputTcpHostName" maxlength="200" size="200" placeholder="localhost">
                    </div>
                    <div class="form-group" @*data-bind="validationElement: ipPort"*@>
                        <label for="inputTcpPort">Port:</label>
                        <input type="number" class="form-control" id="inputTcpPort" maxlength="5" size="5" placeholder="4712">
                    </div>
                </form>
            </div>
            <div class="modal-footer">
                <button type="submit" class="btn btn-primary" onclick="applyTcpConnectionSettings()">Save</button>
                <button type="button" class="btn btn-default" onclick="$('#tcpBuilderDialog').hide()">Cancel</button>
            </div>
        </div>
    </div>
</div>
@* UDP Connection String Builder *@
<div id="udpBuilderDialog" class="modal" role="dialog">
    <div class="modal-dialog modal-md">
        <div class="modal-content">
            <div class="modal-header">
                <button type="button" class="close" onclick="$('#udpBuilderDialog').hide()">&times;</button>
                <h4 class="modal-title">Define UDP Connection Parameters</h4>
            </div>
            <div class="modal-body">
                <form role="form">
                    <div class="form-group" @*data-bind="validationElement: ipPort"*@>
                        <label for="inputUdpPort">Port:</label>
                        <input type="number" class="form-control" id="inputUdpPort" maxlength="5" size="5" placeholder="4713">
                    </div>
                    <div class="form-group" @*data-bind="validationElement: interface"*@>
                        <label for="inputUdpInterface">Interface IP:</label>
                        <input type="text" class="form-control" id="inputUdpInterface" maxlength="200" size="200">
                    </div>
                </form>
            </div>
            <div class="modal-footer">
                <button type="submit" class="btn btn-primary" onclick="applyUdpConnectionSettings()">Save</button>
                <button type="button" class="btn btn-default" onclick="$('#udpBuilderDialog').hide()">Cancel</button>
            </div>
        </div>
    </div>
</div>
@* Serial Connection String Builder *@
<div id="serialBuilderDialog" class="modal" role="dialog">
    <div class="modal-dialog modal-md">
        <div class="modal-content">
            <div class="modal-header">
                <button type="button" class="close" onclick="$('#serialBuilderDialog').hide()">&times;</button>
                <h4 class="modal-title">Define Serial Connection Parameters</h4>
            </div>
            <div class="modal-body">
                <form role="form">
                    <div class="form-group" @*data-bind="validationElement: comPort"*@>
                        <label for="inputSerialPort">Port:</label>
                        <div class="input-group">
                            <span class="input-group-addon">COM</span>
                            <input type="number" class="form-control" id="inputSerialPort" maxlength="5" size="5">
                        </div>
                    </div>
                    <div class="form-group">
                        <label for="selectSerialBaudRate">Baud Rate:</label>
                        <select class="form-control" id="selectSerialBaudRate">
                            <option value="115200">115200</option>
                            <option value="57600" selected>57600</option>
                            <option value="38400">38400</option>
                            <option value="19200">19200</option>
                            <option value="9600">9600</option>
                            <option value="4800">4800</option>
                            <option value="2400">2400</option>
                            <option value="1200">1200</option>
                        </select>
                    </div>
                    <div class="form-group">
                        <label for="selectSerialParity">Parity:</label>
                        <select class="form-control" id="selectSerialParity">
                            <option value="None" selected>None</option>
                            <option value="Odd">Odd</option>
                            <option value="Even">Even</option>
                            <option value="Mark">Mark</option>
                            <option value="Space">Space</option>
                        </select>
                    </div>
                    <div class="form-group">
                        <label for="selectSerialStopBits">Stop Bits:</label>
                        <select class="form-control" id="selectSerialStopBits">
                            <option value="One" selected>One</option>
                            <option value="Two">Two</option>
                            <option value="OnePointFive">OnePointFive</option>
                        </select>
                    </div>
                    <div class="form-group" @*data-bind="validationElement: dataBits"*@>
                        <label for="inputSerialDataBits">Data Bits:</label>
                        <input type="number" class="form-control" id="inputSerialDataBits" maxlength="200" size="200" @*data-bind="integer, textInput: dataBits"*@>
                    </div>
                </form>
            </div>
            <div class="modal-footer">
                <button type="submit" class="btn btn-primary" onclick="applySerialConnectionSettings()">Save</button>
                <button type="button" class="btn btn-default" onclick="$('#serialBuilderDialog').hide()">Cancel</button>
            </div>
        </div>
    </div>
</div>
@* Device Name String Builder *@
<div id="deviceNameBuilderDialog" class="modal" role="dialog">
    <div class="modal-dialog modal-md">
        <div class="modal-content">
            <div class="modal-header">
                <button type="button" class="close" onclick="$('#deviceNameBuilderDialog').hide()">&times;</button>
                <h4 class="modal-title">Define Device Name Parameters</h4>
            </div>
            <div class="modal-body">
                <form role="form">
                    <div class="form-group form-inline">
                        <label for="kv765">Voltage Levels:</label><br/>
                        &nbsp;
                        <div class="checkbox">
                            <label><input type="checkbox" id="kv765"> 765kV</label>
                        </div>
                        &nbsp;
                        <div class="checkbox">
                            <label><input type="checkbox" id="kv500"> 500kV</label>
                        </div>
                        &nbsp;
                        <div class="checkbox">
                            <label><input type="checkbox" id="kv345"> 345kV</label>
                        </div>
                        &nbsp;
                        <div class="checkbox">
                            <label><input type="checkbox" id="kv230"> 230kV</label>
                        </div>
                        &nbsp;
                        <div class="checkbox">
                            <label><input type="checkbox" id="kv138"> 138kV</label>
                        </div>
                        &nbsp;
                        <div class="checkbox">
                            <label><input type="checkbox" id="kv115"> 115kV</label>
                        </div>
                        &nbsp;
                        <div class="checkbox">
                            <label><input type="checkbox" id="kv69"> 69kV</label>
                        </div>
                    </div>
                    <div class="form-group">
                        <label for="selectDeviceType">Device Type:</label>
                        <select class="form-control" id="selectDeviceType">
                            <option value="PMU" selected>Phasor Measurement Unit</option>
                            <option value="DFR">Digital Fault Recorder</option>
                            <option value="PQMETER">Power Quality Meter</option>
                            <option value="IED">Other Intelligent Electronic Device</option>
                        </select>
                    </div>
                    <div class="form-group form-inline">
                        <label for="esp">Security Zone:</label><br/>
                        <label class="radio-inline" for="esp">
                            <input type="radio" value="ESP" name="esp" id="esp" checked> ESP
                        </label>
                        <input type="text" class="form-control" size="2" id="inputESPMarker" value="#">
                        &nbsp;&nbsp;
                        <label class="radio-inline" for="nonesp">
                            <input type="radio" value="NONESP" name="esp" id="nonesp"> Non-ESP
                        </label>
                        <input type="text" class="form-control" size="2" id="inputNonESPMarker" value="!">
                    </div>
                    <div class="form-group">
                        <div class="checkbox">
                            <label><input type="checkbox" id="includeCompanyAcronym"> Include Company Acronym "@CompanyAcronym"</label>
                        </div>
                    </div>
                </form>
            </div>
            <div class="modal-footer">
                <button type="submit" class="btn btn-primary" onclick="applyDeviceNameParameters()">Save</button>
                <button type="button" class="btn btn-default" onclick="$('#deviceNameBuilderDialog').hide()">Cancel</button>
            </div>
        </div>
    </div>
</div>